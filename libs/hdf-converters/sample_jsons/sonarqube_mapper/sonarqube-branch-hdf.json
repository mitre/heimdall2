{
  "platform": {
    "name": "Heimdall Tools",
    "release": "2.11.5"
  },
  "version": "2.11.5",
  "statistics": {},
  "profiles": [
    {
      "name": "SonarQube Scan",
      "version": "SonarQube v9.9.8.100196",
      "title": "SonarQube Scan of project libc_unix on http://127.0.0.1:3001 at 2025-06-18T06:34:37.491Z using branch release",
      "supports": [],
      "attributes": [],
      "groups": [],
      "status": "loaded",
      "controls": [
        {
          "desc": "<p>Time Of Check to Time Of Use (TOCTOU) vulnerabilities occur when an application:</p>\n<ul>\n  <li> First, checks permissions or attributes of a file: for instance, is a file a symbolic link? </li>\n  <li> Next, performs some operations such as writing data to this file. </li>\n</ul>\n<p>The application cannot assume the state of the file is unchanged between these two steps, there is a race condition (ie: two different processes\ncan access and modify the same shared object/file at the same time, which can lead to privilege escalation, denial of service and other unexpected\nresults).</p>\n<p>For instance, attackers can benefit from this situation by creating a symbolic link to a sensitive file directly after the first step (eg in Unix:\n<code>/etc/passwd</code>) and try to elevate their privileges (eg: if the written data has the correct <code>/etc/passwd</code> file format).</p>\n<p>To avoid TOCTOU vulnerabilities, one possible solution is to do a single atomic operation for the check and use actions, therefore removing the\nrace condition window. Another possibility is to use file descriptors. This way the binding of the file descriptor to the file cannot be changed by a\nconcurrent process.</p>\n<h2>Noncompliant Code Example</h2>\n<p>A check function (for instance <code>access</code>, <code>stat</code> …​ in this case <code>access</code> to verify the existence of a file) is\nused, followed by a use function (<code>open</code>, <code>fopen</code> …​) to write data inside a non existing file. These two consecutive calls\ncreate a TOCTOU race condition:</p>\n<pre>\n#include &lt;stdio.h&gt;\n\nvoid fopen_with_toctou(const char *file) {\n  if (access(file, F_OK) == -1 &amp;&amp; errno == ENOENT) {\n    // the file doesn't exist\n    // it is now created in order to write some data inside\n    FILE *f = fopen(file, w); // Noncompliant: a race condition window exist from access() call to fopen() call calls\n    if (NULL == f) {\n      /* Handle error */\n    }\n\n    if (fclose(f) == EOF) {\n      /* Handle error */\n    }\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<p>If the file already exists on the disk, <code>fopen</code> with <code>x</code> mode will fail:</p>\n<pre>\n#include &lt;stdio.h&gt;\n\nvoid open_without_toctou(const char *file) {\n  FILE *f = fopen(file, wx); // Compliant\n  if (NULL == f) {\n    /* Handle error */\n  }\n  /* Write to file */\n  if (fclose(f) == EOF) {\n    /* Handle error */\n  }\n}\n</pre>\n<p>A more generic solution is to use file descriptors:</p>\n<pre>\nvoid open_without_toctou(const char *file) {\n  int fd = open(file, O_CREAT | O_EXCL | O_WRONLY);\n  if (-1 != fd) {\n    FILE *f = fdopen(fd, w);  // Compliant\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=https://owasp.org/Top10/A01_2021-Broken_Access_Control/>OWASP Top 10 2021 Category A1</a> - Broken Access Control </li>\n  <li> <a href=https://www.owasp.org/index.php/Top_10-2017_A5-Broken_Access_Control>OWASP Top 10 2017 Category A5</a> - Boken Access Control </li>\n  <li> <a href=https://cwe.mitre.org/data/definitions/367.html>MITRE, CWE-367</a> - Time-of-check Time-of-use (TOCTOU) Race Condition </li>\n  <li> <a href=https://wiki.sei.cmu.edu/confluence/display/c/FIO45-C.+Avoid+TOCTOU+race+conditions+while+accessing+files>CERT, FIO45-C.</a> - Avoid\n  TOCTOU race conditions while accessing files </li>\n</ul>",
          "refs": [],
          "source_location": {},
          "id": "c:S5847",
          "title": "Accessing files should not introduce TOCTOU vulnerabilities",
          "impact": 0.7,
          "tags": {
            "cci": [
              "CCI-000213"
            ],
            "nist": [
              "AC-3"
            ],
            "cweid": [
              "CWE-367"
            ],
            "owasp": [
              "Top 10 2021 Category A1",
              "Top 10 2017 Category A5",
              "A5"
            ]
          },
          "results": [
            {
              "status": "failed",
              "code_desc": "libc_unix:dev/src/libc_unix/sumapss7.c:65-65\nFile checked here\n<pre>\n63 \n64    /* ! If Key String is invalid */\n65    if ( stat(Key_String, &buf) )\n66    {\n67       FILE *fd;\n68       /* !! If this is a physical device, error is fatal */\n</pre>\nlibc_unix:dev/src/libc_unix/sumapss7.c:79-79\nFile used here\n<pre>\n77       }\n78       /* !! Try to create the file */\n79       fd = fopen(Key_String, \"w\");\n80       /* !! If NOT sucessfull */\n81       if (! fd )\n82       {\n</pre>",
              "start_time": "2021-10-05T07:48:39-0400"
            }
          ],
          "descriptions": null
        }
      ],
      "sha256": "d902e97c0fe52366e9a4c15fb37f0b3ab5ae33d9d64748f71f6eb12d2994733c"
    }
  ],
  "passthrough": {}
}