{
  "/api/server/version": "9.9.8.100196",
  "/api/issues/search?componentKeys=xss&types=VULNERABILITY&statuses=OPEN,REOPENED,CONFIRMED,RESOLVED&p=1": {
    "total": 1,
    "p": 1,
    "ps": 100,
    "paging": {
      "pageIndex": 1,
      "pageSize": 100,
      "total": 1
    },
    "effortTotal": 10,
    "issues": [
      {
        "key": "AX2RcGnrl-KH7KTFNgLl",
        "rule": "javascript:S2819",
        "severity": "CRITICAL",
        "component": "xss:packages/docs/src/service-worker.js",
        "project": "xss",
        "line": 29,
        "hash": "8be50716e6366451fef374e82fb66aca",
        "textRange": {
          "startLine": 29,
          "endLine": 29,
          "startOffset": 0,
          "endOffset": 21
        },
        "flows": [],
        "status": "OPEN",
        "message": "Verify the message's origin in this cross-origin communication.",
        "effort": "10min",
        "debt": "10min",
        "author": "example@example.com",
        "tags": [
          "cwe",
          "html5",
          "owasp-a3"
        ],
        "creationDate": "2020-09-01T17:04:31+0000",
        "updateDate": "2021-12-06T20:27:51+0000",
        "type": "VULNERABILITY",
        "scope": "MAIN",
        "quickFixAvailable": false
      }
    ],
    "components": [
      {
        "key": "xss:packages/docs/src/service-worker.js",
        "enabled": true,
        "qualifier": "FIL",
        "name": "service-worker.js",
        "longName": "packages/docs/src/service-worker.js",
        "path": "packages/docs/src/service-worker.js"
      },
      {
        "key": "xss",
        "enabled": true,
        "qualifier": "TRK",
        "name": "xss",
        "longName": "xss"
      }
    ],
    "facets": []
  },
  "/api/issues/search?componentKeys=libc_unix&types=VULNERABILITY&statuses=OPEN,REOPENED,CONFIRMED,RESOLVED&p=1&branch=release": {
    "total": 2,
    "p": 1,
    "ps": 100,
    "paging": {
      "pageIndex": 1,
      "pageSize": 100,
      "total": 2
    },
    "effortTotal": 20,
    "issues": [
      {
        "key": "AXzck64vC85-0Ss6yFbS",
        "rule": "c:S5847",
        "severity": "CRITICAL",
        "component": "libc_unix:dev/src/libc_unix/sumapss7.c",
        "project": "libc_unix",
        "line": 136,
        "hash": "8430f2c6db3e4549755fbd9e481817c7",
        "textRange": {
          "startLine": 136,
          "endLine": 136,
          "startOffset": 11,
          "endOffset": 33
        },
        "flows": [
          {
            "locations": [
              {
                "component": "libc_unix:dev/src/libc_unix/sumapss7.c",
                "textRange": {
                  "startLine": 122,
                  "endLine": 122,
                  "startOffset": 8,
                  "endOffset": 30
                },
                "msg": "File checked here"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "libc_unix:dev/src/libc_unix/sumapss7.c",
                "textRange": {
                  "startLine": 136,
                  "endLine": 136,
                  "startOffset": 11,
                  "endOffset": 33
                },
                "msg": "File used here"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Remove this TOCTOU race condition window when accessing files",
        "effort": "10min",
        "debt": "10min",
        "author": "",
        "tags": [
          "cert",
          "cwe",
          "owasp-a5"
        ],
        "creationDate": "2021-10-05T07:48:39-0400",
        "updateDate": "2021-10-05T07:48:39-0400",
        "type": "VULNERABILITY",
        "branch": "release",
        "scope": "MAIN",
        "quickFixAvailable": false
      }
    ],
    "components": [
      {
        "key": "libc_unix:dev/src/libc_unix/sumapss7.c",
        "enabled": true,
        "qualifier": "FIL",
        "name": "sumapss7.c",
        "longName": "dev/src/libc_unix/sumapss7.c",
        "path": "dev/src/libc_unix/sumapss7.c",
        "branch": "release"
      },
      {
        "key": "libc_unix",
        "enabled": true,
        "qualifier": "TRK",
        "name": "libc_unix",
        "longName": "libc_unix",
        "branch": "release"
      }
    ],
    "facets": []
  },
  "/api/issues/search?componentKeys=libc_unix&types=VULNERABILITY&statuses=OPEN,REOPENED,CONFIRMED,RESOLVED&p=1&pullRequest=123": {
    "total": 2,
    "p": 1,
    "ps": 100,
    "paging": {
      "pageIndex": 1,
      "pageSize": 100,
      "total": 2
    },
    "effortTotal": 20,
    "issues": [
      {
        "key": "AXzck64vC85-0Ss6yFbS",
        "rule": "c:S5847",
        "severity": "CRITICAL",
        "component": "libc_unix:dev/src/libc_unix/sumapss7.c",
        "project": "libc_unix",
        "line": 136,
        "hash": "8430f2c6db3e4549755fbd9e481817c7",
        "textRange": {
          "startLine": 136,
          "endLine": 136,
          "startOffset": 11,
          "endOffset": 33
        },
        "flows": [
          {
            "locations": [
              {
                "component": "libc_unix:dev/src/libc_unix/sumapss7.c",
                "textRange": {
                  "startLine": 122,
                  "endLine": 122,
                  "startOffset": 8,
                  "endOffset": 30
                },
                "msg": "File checked here"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "libc_unix:dev/src/libc_unix/sumapss7.c",
                "textRange": {
                  "startLine": 136,
                  "endLine": 136,
                  "startOffset": 11,
                  "endOffset": 33
                },
                "msg": "File used here"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Remove this TOCTOU race condition window when accessing files",
        "effort": "10min",
        "debt": "10min",
        "author": "",
        "tags": [
          "cert",
          "cwe",
          "owasp-a5"
        ],
        "creationDate": "2021-10-05T07:48:39-0400",
        "updateDate": "2021-10-05T07:48:39-0400",
        "type": "VULNERABILITY",
        "scope": "MAIN",
        "quickFixAvailable": false
      }
    ],
    "components": [
      {
        "key": "libc_unix:dev/src/libc_unix/sumapss7.c",
        "enabled": true,
        "qualifier": "FIL",
        "name": "sumapss7.c",
        "longName": "dev/src/libc_unix/sumapss7.c",
        "path": "dev/src/libc_unix/sumapss7.c"
      },
      {
        "key": "libc_unix",
        "enabled": true,
        "qualifier": "TRK",
        "name": "libc_unix",
        "longName": "libc_unix"
      }
    ],
    "facets": []
  },
  "/api/sources/show?key=xss:packages%2Fdocs%2Fsrc%2Fservice-worker.js": {
  "sources": [
    [ 1, "// Imports" ],
    [
      2,
      "import { precacheAndRoute, matchPrecache } from 'workbox-precaching'"
    ],
    [
      3,
      "import { registerRoute, setDefaultHandler, setCatchHandler } from 'workbox-routing'"
    ],
    [
      4,
      "import { NetworkOnly, CacheFirst } from 'workbox-strategies'"
    ],
    [ 5, "" ],
    [ 6, "precacheAndRoute(self.__WB_MANIFEST)" ],
    [ 7, "" ],
    [ 8, "const cacheFirst = new CacheFirst()" ],
    [ 9, "const networkOnly = new NetworkOnly()" ],
    [ 10, "" ],
    [ 11, "registerRoute(" ],
    [
      12,
      "  ({ url, request }) => url.origin === self.location.origin && request.destination !== 'document',"
    ],
    [ 13, "  cacheFirst" ],
    [ 14, ")" ],
    [ 15, "" ],
    [ 16, "setDefaultHandler(networkOnly)" ],
    [ 17, "" ],
    [ 18, "setCatchHandler(async ({ url, request }) => {" ],
    [ 19, "  if (" ],
    [ 20, "    url.origin === self.location.origin &&" ],
    [ 21, "    request.destination === 'document'" ],
    [ 22, "  ) {" ],
    [
      23,
      "    return matchPrecache(url.pathname.startsWith('/eo-UY/') ? '_crowdin.html' : '/_fallback.html')"
    ],
    [ 24, "  }" ],
    [ 25, "" ],
    [ 26, "  return Response.error()" ],
    [ 27, "})" ],
    [ 28, "" ],
    [ 29, "self.addEventListener('message', event => {" ],
    [ 30, "  if (event.data === 'sw:update') self.skipWaiting()" ],
    [ 31, "})" ],
    [ 32, "" ],
    [ 33, "" ]
  ]
},
  "api/sources/show?key=c130j_libc_unix:dev%2Fsrc%2Flibc_unix%2Fsumapss7.c": {
  "sources": [
    [
      1,
      "\\\\sanitized"
    ],
    [
      2,
      "#include <stdio.h>endif"
    ],
    [
      3,
      ""
    ],
    [
      4,
      "#include <sys/types.h>"
    ],
    [
      5,
      "#include <sys/stat.h>"
    ],
    [
      6,
      "#ifdef __linux"
    ],
    [
      7,
      "#include <sys/ipc.h>"
    ],
    [
      8,
      "#include <sys/shm.h>"
    ],
    [
      9,
      "#endif"
    ],
    [
      10,
      "#include <errno.h>"
    ],
    [
      11,
      "#include <string.h>"
    ],
    [
      12,
      "#include <fcntl.h>"
    ],
    [
      13,
      ""
    ],
    [
      14,
      "#ifndef PAGE_SIZE"
    ],
    [
      15,
      "#define PAGE_SIZE 4096"
    ],
    [
      16,
      "#endif"
    ],
    [
      17,
      ""
    ],
    [
      18,
      "void map_segment_rmnet( char *physDevName,"
    ],
    [
      19,
      "                        void **Mapped_Address, char *Result );"
    ],
    [
      20,
      "void map_segment_rfm2g( char *physDevName,"
    ],
    [
      21,
      "                        void **Mapped_Address, char *Result );"
    ],
    [
      22,
      ""
    ],
    [
      23,
      ""
    ],
    [
      24,
      "/************************************************************************"
    ],
    [
      25,
      " ** ! void c_map_segment( char *Key_String,"
    ],
    [
      26,
      " ** !                     long Size_Of_Area,"
    ],
    [
      27,
      " ** !                     char Map_Local,"
    ],
    [
      28,
      " ** !                     void **Mapped_Address,"
    ],
    [
      29,
      " ** !                     char *Error );"
    ],
    [
      30,
      " ** !"
    ],
    [
      31,
      " ** ! INPUTS :"
    ],
    [
      32,
      " ** ! char *Key_String      : Key identifying segment to be mapped."
    ],
    [
      33,
      " ** ! long Size_Of_Area     : Number of bytes to map."
    ],
    [
      34,
      " ** ! char Map_Local        : If this flag is set and the machine supports"
    ],
    [
      35,
      " ** !                       : local memory then map the segment into \"hard\""
    ],
    [
      36,
      " ** !                       : local memory."
    ],
    [
      37,
      " ** !"
    ],
    [
      38,
      " ** ! OUTPUTS :"
    ],
    [
      39,
      " ** ! void **Mapped_Address : Logical address mapped."
    ],
    [
      40,
      " ** ! char *Error           : Succes of mapping. 0 = Ok, 1 = Fail."
    ],
    [
      41,
      " ** !"
    ],
    [
      42,
      " ************************************************************************/"
    ],
    [
      43,
      ""
    ],
    [
      44,
      "#define RETURN_ERROR \\n         *Mapped_Address = NULL; \\n         *Error = 1; \\n         return;"
    ],
    [
      45,
      "void c_map_segment( char *Key_String, long Size_Of_Area, char Map_Local,"
    ],
    [
      46,
      "                    void **Mapped_Address, char *Error )"
    ],
    [
      47,
      ""
    ],
    [
      48,
      "{"
    ],
    [
      49,
      "#ifndef WIN32"
    ],
    [
      50,
      ""
    ],
    [
      51,
      "   /*** NOTE : Map_Local is not yet implemented ***/"
    ],
    [
      52,
      ""
    ],
    [
      53,
      "   struct stat buf;            /* Used to check validity of key */"
    ],
    [
      54,
      "   key_t       key;"
    ],
    [
      55,
      "   int         shmid;"
    ],
    [
      56,
      "   int         shmctrl;"
    ],
    [
      57,
      "   struct shmid_ds shmid_buf;      /* struct shmid_ds from shm.h */"
    ],
    [
      58,
      "   char       *Address_Mapped = NULL;"
    ],
    [
      59,
      "   char       Key_Is_Physical_Device = ! strncmp(\"/dev/\", Key_String, 5);"
    ],
    [
      60,
      ""
    ],
    [
      61,
      "   /* ! If Key String is invalid */"
    ],
    [
      62,
      "   if ( stat(Key_String, &buf) )"
    ],
    [
      63,
      "   {"
    ],
    [
      64,
      "      FILE *fd;"
    ],
    [
      65,
      "      /* !! If this is a physical device, error is fatal */"
    ],
    [
      66,
      "      if ( Key_Is_Physical_Device )"
    ],
    [
      67,
      "      {"
    ],
    [
      68,
      "         /* !!! Exit with error. */"
    ],
    [
      69,
      "         (void)fprintf(stderr,"
    ],
    [
      70,
      "            \">>> %s:%d:ERROR : c_map_segment : during open of %s"
    ],
    [
      71,
      "\","
    ],
    [
      72,
      "           __FILE__, __LINE__, Key_String);"
    ],
    [
      73,
      "         perror(\"--> \");"
    ],
    [
      74,
      "         RETURN_ERROR"
    ],
    [
      75,
      "      }"
    ],
    [
      76,
      "      /* !! Try to create the file */"
    ],
    [
      77,
      "      fd = fopen(Key_String, \"w\");"
    ],
    [
      78,
      "      /* !! If NOT sucessfull */"
    ],
    [
      79,
      "      if (! fd )"
    ],
    [
      80,
      "      {"
    ],
    [
      81,
      "         /* !! Exit with error. */"
    ],
    [
      82,
      "         (void)fprintf(stderr,"
    ],
    [
      83,
      "            \">>> ERROR : c_map_segment : during open of %s"
    ],
    [
      84,
      "\", Key_String);"
    ],
    [
      85,
      "         perror(\"--> \");"
    ],
    [
      86,
      "         RETURN_ERROR"
    ],
    [
      87,
      "      }"
    ],
    [
      88,
      ""
    ],
    [
      89,
      "      /* !! File open Ok, Write to File. */"
    ],
    [
      90,
      "      fprintf(fd, \"Key"
    ],
    [
      91,
      "\");"
    ],
    [
      92,
      "      /* !! Close File. */"
    ],
    [
      93,
      "      fclose(fd);"
    ],
    [
      94,
      ""
    ],
    [
      95,
      "      /* !! Try Key String again */"
    ],
    [
      96,
      "      if ( stat(Key_String, &buf) )"
    ],
    [
      97,
      "      {"
    ],
    [
      98,
      "         /* !!! Exit with error. */"
    ],
    [
      99,
      "         (void)fprintf(stderr,"
    ],
    [
      100,
      "            \">>> ERROR : c_map_segment : during stat of %s"
    ],
    [
      101,
      "\", Key_String);"
    ],
    [
      102,
      "         perror(\"--> \");"
    ],
    [
      103,
      "         RETURN_ERROR"
    ],
    [
      104,
      "      }"
    ],
    [
      105,
      "   }"
    ],
    [
      106,
      "   /* ! End If */"
    ],
    [
      107,
      ""
    ],
    [
      108,
      ""
    ]
  ]
},
  "/api/rules/show?key=javascript:S2819": {
    "rule": {
      "key": "javascript:S2819",
      "repo": "javascript",
      "name": "Origins should be verified during cross-origin communications",
      "createdAt": "2021-12-06T19:35:19+0000",
      "htmlDesc": "<p>Browsers <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage\">allow message exchanges</a> between Window objects of\ndifferent origins.</p>\n<p>Because any window can send / receive messages from other window it is important to verify the sender’s / receiver’s identity:</p>\n<ul>\n  <li> When sending message with postMessage method, the identity’s receiver should be defined (the wildcard keyword (<code>*</code>) should not be\n  used). </li>\n  <li> When receiving message with message event, the sender’s identity should be verified using the origin and possibly source properties. </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<p>When sending message:</p>\n<pre>\nvar iframe = document.getElementById(\"testiframe\");\niframe.contentWindow.postMessage(\"secret\", \"*\"); // Noncompliant: * is used\n</pre>\n<p>When receiving message:</p>\n<pre>\nwindow.addEventListener(\"message\", function(event) { // Noncompliant: no checks are done on the origin property.\n      console.log(event.data);\n });\n</pre>\n<h2>Compliant Solution</h2>\n<p>When sending message:</p>\n<pre>\nvar iframe = document.getElementById(\"testsecureiframe\");\niframe.contentWindow.postMessage(\"hello\", \"https://secure.example.com\"); // Compliant\n</pre>\n<p>When receiving message:</p>\n<pre>\nwindow.addEventListener(\"message\", function(event) {\n\n  if (event.origin !== \"http://example.org\") // Compliant\n    return;\n\n  console.log(event.data)\n});\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\">OWASP Top 10 2021 Category A1</a> - Broken Access Control </li>\n  <li> <a href=\"https://www.owasp.org/index.php/Top_10_2010-A3-Broken_Authentication_and_Session_Management\">OWASP Top 10 2017 Category A3</a> -\n  Broken Authentication and Session Management </li>\n  <li> <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage\">developer.mozilla.org</a> - postMessage API </li>\n</ul>",
      "mdDesc": "<p>Browsers <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage\">allow message exchanges</a> between Window objects of\ndifferent origins.</p>\n<p>Because any window can send / receive messages from other window it is important to verify the sender’s / receiver’s identity:</p>\n<ul>\n  <li> When sending message with postMessage method, the identity’s receiver should be defined (the wildcard keyword (<code>*</code>) should not be\n  used). </li>\n  <li> When receiving message with message event, the sender’s identity should be verified using the origin and possibly source properties. </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<p>When sending message:</p>\n<pre>\nvar iframe = document.getElementById(\"testiframe\");\niframe.contentWindow.postMessage(\"secret\", \"*\"); // Noncompliant: * is used\n</pre>\n<p>When receiving message:</p>\n<pre>\nwindow.addEventListener(\"message\", function(event) { // Noncompliant: no checks are done on the origin property.\n      console.log(event.data);\n });\n</pre>\n<h2>Compliant Solution</h2>\n<p>When sending message:</p>\n<pre>\nvar iframe = document.getElementById(\"testsecureiframe\");\niframe.contentWindow.postMessage(\"hello\", \"https://secure.example.com\"); // Compliant\n</pre>\n<p>When receiving message:</p>\n<pre>\nwindow.addEventListener(\"message\", function(event) {\n\n  if (event.origin !== \"http://example.org\") // Compliant\n    return;\n\n  console.log(event.data)\n});\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\">OWASP Top 10 2021 Category A1</a> - Broken Access Control </li>\n  <li> <a href=\"https://www.owasp.org/index.php/Top_10_2010-A3-Broken_Authentication_and_Session_Management\">OWASP Top 10 2017 Category A3</a> -\n  Broken Authentication and Session Management </li>\n  <li> <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage\">developer.mozilla.org</a> - postMessage API </li>\n</ul>",
      "severity": "CRITICAL",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "cwe",
        "html5",
        "owasp-a3"
      ],
      "lang": "js",
      "langName": "JavaScript",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "10min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "10min",
      "type": "VULNERABILITY",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "10min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "10min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    "actives": []
  },
  "/api/rules/show?key=c:S5847": {
    "rule": {
      "key": "c:S5847",
      "repo": "c",
      "name": "Accessing files should not introduce TOCTOU vulnerabilities",
      "createdAt": "2021-01-21T16:26:38-0500",
      "htmlDesc": "<p>Time Of Check to Time Of Use (TOCTOU) vulnerabilities occur when an application:</p>\n<ul>\n  <li> First, checks permissions or attributes of a file: for instance, is a file a symbolic link? </li>\n  <li> Next, performs some operations such as writing data to this file. </li>\n</ul>\n<p>The application cannot assume the state of the file is unchanged between these two steps, there is a race condition (ie: two different processes\ncan access and modify the same shared object/file at the same time, which can lead to privilege escalation, denial of service and other unexpected\nresults).</p>\n<p>For instance, attackers can benefit from this situation by creating a symbolic link to a sensitive file directly after the first step (eg in Unix:\n<code>/etc/passwd</code>) and try to elevate their privileges (eg: if the written data has the correct <code>/etc/passwd</code> file format).</p>\n<p>To avoid TOCTOU vulnerabilities, one possible solution is to do a single atomic operation for the check and use actions, therefore removing the\nrace condition window. Another possibility is to use file descriptors. This way the binding of the file descriptor to the file cannot be changed by a\nconcurrent process.</p>\n<h2>Noncompliant Code Example</h2>\n<p>A check function (for instance <code>access</code>, <code>stat</code> …​ in this case <code>access</code> to verify the existence of a file) is\nused, followed by a use function (<code>open</code>, <code>fopen</code> …​) to write data inside a non existing file. These two consecutive calls\ncreate a TOCTOU race condition:</p>\n<pre>\n#include &lt;stdio.h&gt;\n\nvoid fopen_with_toctou(const char *file) {\n  if (access(file, F_OK) == -1 &amp;&amp; errno == ENOENT) {\n    // the file doesn\u0027t exist\n    // it is now created in order to write some data inside\n    FILE *f = fopen(file, w); // Noncompliant: a race condition window exist from access() call to fopen() call calls\n    if (NULL == f) {\n      /* Handle error */\n    }\n\n    if (fclose(f) == EOF) {\n      /* Handle error */\n    }\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<p>If the file already exists on the disk, <code>fopen</code> with <code>x</code> mode will fail:</p>\n<pre>\n#include &lt;stdio.h&gt;\n\nvoid open_without_toctou(const char *file) {\n  FILE *f = fopen(file, wx); // Compliant\n  if (NULL == f) {\n    /* Handle error */\n  }\n  /* Write to file */\n  if (fclose(f) == EOF) {\n    /* Handle error */\n  }\n}\n</pre>\n<p>A more generic solution is to use file descriptors:</p>\n<pre>\nvoid open_without_toctou(const char *file) {\n  int fd = open(file, O_CREAT | O_EXCL | O_WRONLY);\n  if (-1 != fd) {\n    FILE *f = fdopen(fd, w);  // Compliant\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=https://owasp.org/Top10/A01_2021-Broken_Access_Control/>OWASP Top 10 2021 Category A1</a> - Broken Access Control </li>\n  <li> <a href=https://www.owasp.org/index.php/Top_10-2017_A5-Broken_Access_Control>OWASP Top 10 2017 Category A5</a> - Boken Access Control </li>\n  <li> <a href=https://cwe.mitre.org/data/definitions/367.html>MITRE, CWE-367</a> - Time-of-check Time-of-use (TOCTOU) Race Condition </li>\n  <li> <a href=https://wiki.sei.cmu.edu/confluence/display/c/FIO45-C.+Avoid+TOCTOU+race+conditions+while+accessing+files>CERT, FIO45-C.</a> - Avoid\n  TOCTOU race conditions while accessing files </li>\n</ul>",
      "mdDesc": "<p>Time Of Check to Time Of Use (TOCTOU) vulnerabilities occur when an application:</p>\n<ul>\n  <li> First, checks permissions or attributes of a file: for instance, is a file a symbolic link? </li>\n  <li> Next, performs some operations such as writing data to this file. </li>\n</ul>\n<p>The application cannot assume the state of the file is unchanged between these two steps, there is a race condition (ie: two different processes\ncan access and modify the same shared object/file at the same time, which can lead to privilege escalation, denial of service and other unexpected\nresults).</p>\n<p>For instance, attackers can benefit from this situation by creating a symbolic link to a sensitive file directly after the first step (eg in Unix:\n<code>/etc/passwd</code>) and try to elevate their privileges (eg: if the written data has the correct <code>/etc/passwd</code> file format).</p>\n<p>To avoid TOCTOU vulnerabilities, one possible solution is to do a single atomic operation for the check and use actions, therefore removing the\nrace condition window. Another possibility is to use file descriptors. This way the binding of the file descriptor to the file cannot be changed by a\nconcurrent process.</p>\n<h2>Noncompliant Code Example</h2>\n<p>A check function (for instance <code>access</code>, <code>stat</code> …​ in this case <code>access</code> to verify the existence of a file) is\nused, followed by a use function (<code>open</code>, <code>fopen</code> …​) to write data inside a non existing file. These two consecutive calls\ncreate a TOCTOU race condition:</p>\n<pre>\n#include &lt;stdio.h&gt;\n\nvoid fopen_with_toctou(const char *file) {\n  if (access(file, F_OK) == -1 &amp;&amp; errno == ENOENT) {\n    // the file doesn\u0027t exist\n    // it is now created in order to write some data inside\n    FILE *f = fopen(file, w); // Noncompliant: a race condition window exist from access() call to fopen() call calls\n    if (NULL == f) {\n      /* Handle error */\n    }\n\n    if (fclose(f) == EOF) {\n      /* Handle error */\n    }\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<p>If the file already exists on the disk, <code>fopen</code> with <code>x</code> mode will fail:</p>\n<pre>\n#include &lt;stdio.h&gt;\n\nvoid open_without_toctou(const char *file) {\n  FILE *f = fopen(file, wx); // Compliant\n  if (NULL == f) {\n    /* Handle error */\n  }\n  /* Write to file */\n  if (fclose(f) == EOF) {\n    /* Handle error */\n  }\n}\n</pre>\n<p>A more generic solution is to use file descriptors:</p>\n<pre>\nvoid open_without_toctou(const char *file) {\n  int fd = open(file, O_CREAT | O_EXCL | O_WRONLY);\n  if (-1 != fd) {\n    FILE *f = fdopen(fd, w);  // Compliant\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=https://owasp.org/Top10/A01_2021-Broken_Access_Control/>OWASP Top 10 2021 Category A1</a> - Broken Access Control </li>\n  <li> <a href=https://www.owasp.org/index.php/Top_10-2017_A5-Broken_Access_Control>OWASP Top 10 2017 Category A5</a> - Boken Access Control </li>\n  <li> <a href=https://cwe.mitre.org/data/definitions/367.html>MITRE, CWE-367</a> - Time-of-check Time-of-use (TOCTOU) Race Condition </li>\n  <li> <a href=https://wiki.sei.cmu.edu/confluence/display/c/FIO45-C.+Avoid+TOCTOU+race+conditions+while+accessing+files>CERT, FIO45-C.</a> - Avoid\n  TOCTOU race conditions while accessing files </li>\n</ul>",
      "severity": "CRITICAL",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "cert",
        "cwe",
        "owasp-a5"
      ],
      "lang": "c",
      "langName": "C",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "10min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "10min",
      "type": "VULNERABILITY",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "10min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "10min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    "actives": []
  }
}
