{
  "/api/issues/search?componentKeys=test&types=CODE_SMELL,BUG,VULNERABILITY&p=1": {
    "total": 68,
    "p": 1,
    "ps": 100,
    "paging": {
      "pageIndex": 1,
      "pageSize": 100,
      "total": 68
    },
    "effortTotal": 475,
    "issues": [
      {
        "key": "AXtAUPqUi8r-LMdMzpgJ",
        "rule": "typescript:S3776",
        "severity": "CRITICAL",
        "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
        "project": "test",
        "line": 353,
        "hash": "c8784c25364adaf775f446d53048aaad",
        "textRange": {
          "startLine": 353,
          "endLine": 353,
          "startOffset": 6,
          "endOffset": 11
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 363,
                  "endLine": 363,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 363,
                  "endLine": 363,
                  "startOffset": 36,
                  "endOffset": 38
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 366,
                  "endLine": 366,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 369,
                  "endLine": 369,
                  "startOffset": 11,
                  "endOffset": 13
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 370,
                  "endLine": 370,
                  "startOffset": 38,
                  "endOffset": 40
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 374,
                  "endLine": 374,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 377,
                  "endLine": 377,
                  "startOffset": 11,
                  "endOffset": 13
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 378,
                  "endLine": 378,
                  "startOffset": 40,
                  "endOffset": 42
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 382,
                  "endLine": 382,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 385,
                  "endLine": 385,
                  "startOffset": 11,
                  "endOffset": 13
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 385,
                  "endLine": 385,
                  "startOffset": 44,
                  "endOffset": 46
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 387,
                  "endLine": 387,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 390,
                  "endLine": 390,
                  "startOffset": 11,
                  "endOffset": 13
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 399,
                  "endLine": 399,
                  "startOffset": 6,
                  "endOffset": 10
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 391,
                  "endLine": 391,
                  "startOffset": 39,
                  "endOffset": 41
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 396,
                  "endLine": 396,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 404,
                  "endLine": 404,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 410,
                  "endLine": 410,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Refactor this function to reduce its Cognitive Complexity from 23 to the 15 allowed.",
        "effort": "13min",
        "debt": "13min",
        "author": "rbclark@mitre.org",
        "tags": [
          "brain-overload"
        ],
        "creationDate": "2021-08-05T18:34:07+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "\n  /** Return items sorted and filters out viewed controls */\n  get items(): ListElt[] {\n    // Controls ascending/descending\n    let factor = 1;\n    // Whether or not we need to sort",
        "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
      },
      {
        "key": "AXtAUPhHi8r-LMdMzpf2",
        "rule": "typescript:S3317",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/components/global/upload_tabs/aws/AuthStepBasic.vue",
        "project": "test",
        "flows": [],
        "status": "OPEN",
        "message": "Rename this file to \"S3Reader\"",
        "effort": "5min",
        "debt": "5min",
        "author": "rbclark@mitre.org",
        "tags": [
          "confusing",
          "convention",
          "es2015"
        ],
        "creationDate": "2021-08-05T18:34:07+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "",
        "summary": "<p>By convention, a file that exports only one class, function, or constant should be named for that class, function or constant. Anything else may\nconfuse maintainers.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n// file path: myclass.js  -- Noncompliant\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n// file path: MyClass.js\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Exceptions</h2>\n<p>Case, underscores ( <code>_</code> ) and dashes (<code>-</code>) are ignored from the name comparison.</p>"
      },
      {
        "key": "AXtAUPnEi8r-LMdMzpf3",
        "rule": "typescript:S3317",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/components/global/upload_tabs/aws/AuthStepMFA.vue",
        "project": "test",
        "flows": [],
        "status": "OPEN",
        "message": "Rename this file to \"S3Reader\"",
        "effort": "5min",
        "debt": "5min",
        "author": "rbclark@mitre.org",
        "tags": [
          "confusing",
          "convention",
          "es2015"
        ],
        "creationDate": "2021-08-05T18:34:07+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "",
        "summary": "<p>By convention, a file that exports only one class, function, or constant should be named for that class, function or constant. Anything else may\nconfuse maintainers.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n// file path: myclass.js  -- Noncompliant\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n// file path: MyClass.js\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Exceptions</h2>\n<p>Case, underscores ( <code>_</code> ) and dashes (<code>-</code>) are ignored from the name comparison.</p>"
      },
      {
        "key": "AXtAUPy-i8r-LMdMzphZ",
        "rule": "typescript:S3776",
        "severity": "CRITICAL",
        "component": "test:libs/hdf-converters/src/base-converter.ts",
        "project": "test",
        "line": 195,
        "hash": "e3a2905493498652453fa20fca99f9b9",
        "textRange": {
          "startLine": 195,
          "endLine": 195,
          "startOffset": 2,
          "endOffset": 13
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 199,
                  "endLine": 199,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 202,
                  "endLine": 202,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 215,
                  "endLine": 215,
                  "startOffset": 6,
                  "endOffset": 10
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 211,
                  "endLine": 211,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 220,
                  "endLine": 220,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 245,
                  "endLine": 245,
                  "startOffset": 8,
                  "endOffset": 12
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 222,
                  "endLine": 222,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 238,
                  "endLine": 238,
                  "startOffset": 10,
                  "endOffset": 14
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 231,
                  "endLine": 231,
                  "startOffset": 10,
                  "endOffset": 12
                },
                "msg": "+4 (incl. 3 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 234,
                  "endLine": 234,
                  "startOffset": 10,
                  "endOffset": 12
                },
                "msg": "+4 (incl. 3 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 239,
                  "endLine": 239,
                  "startOffset": 10,
                  "endOffset": 12
                },
                "msg": "+4 (incl. 3 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 241,
                  "endLine": 241,
                  "startOffset": 12,
                  "endOffset": 16
                },
                "msg": "+1"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Refactor this function to reduce its Cognitive Complexity from 25 to the 15 allowed.",
        "effort": "15min",
        "debt": "15min",
        "author": "rbclark@mitre.org",
        "tags": [
          "brain-overload"
        ],
        "creationDate": "2021-08-05T16:58:31+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "  }\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  handleArray<T extends object>(\n    file: Record<string, unknown>,\n    v: Array<T & ILookupPath>\n  ): Array<T> {",
        "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzph5",
        "rule": "typescript:S3776",
        "severity": "CRITICAL",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 228,
        "hash": "5fd6dcc3adfc524cd3dd083080299a0c",
        "textRange": {
          "startLine": 228,
          "endLine": 228,
          "startOffset": 9,
          "endOffset": 18
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 286,
                  "endLine": 286,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 287,
                  "endLine": 287,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 288,
                  "endLine": 288,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 291,
                  "endLine": 291,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 292,
                  "endLine": 292,
                  "startOffset": 4,
                  "endOffset": 9
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 292,
                  "endLine": 292,
                  "startOffset": 35,
                  "endOffset": 37
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 295,
                  "endLine": 295,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 296,
                  "endLine": 296,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 297,
                  "endLine": 297,
                  "startOffset": 50,
                  "endOffset": 51
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 298,
                  "endLine": 298,
                  "startOffset": 50,
                  "endOffset": 51
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 299,
                  "endLine": 299,
                  "startOffset": 50,
                  "endOffset": 51
                },
                "msg": "+4 (incl. 3 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 303,
                  "endLine": 303,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 303,
                  "endLine": 303,
                  "startOffset": 21,
                  "endOffset": 23
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 230,
                  "endLine": 230,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 237,
                  "endLine": 237,
                  "startOffset": 8,
                  "endOffset": 11
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 241,
                  "endLine": 241,
                  "startOffset": 14,
                  "endOffset": 19
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 247,
                  "endLine": 247,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 253,
                  "endLine": 253,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 258,
                  "endLine": 258,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 262,
                  "endLine": 262,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 269,
                  "endLine": 269,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 269,
                  "endLine": 269,
                  "startOffset": 52,
                  "endOffset": 54
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 275,
                  "endLine": 275,
                  "startOffset": 69,
                  "endOffset": 70
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 279,
                  "endLine": 279,
                  "startOffset": 12,
                  "endOffset": 14
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Refactor this function to reduce its Cognitive Complexity from 44 to the 15 allowed.",
        "effort": "34min",
        "debt": "34min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "brain-overload"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "}\n\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);",
        "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzph9",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 238,
        "hash": "c18b29c89a7108ee069bbe31d8a88c35",
        "textRange": {
          "startLine": 238,
          "endLine": 238,
          "startOffset": 18,
          "endOffset": 21
        },
        "flows": [],
        "status": "OPEN",
        "message": "'typ' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        const l = typs.length;\n        for (let i = 0; i < l; i++) {\n            const typ = typs[i];\n            try {\n                return transform(val, typ, getProps);\n            } catch (_) {}",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzpiC",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 268,
        "hash": "00fba73079d5d65a34ef9c6a86abaae5",
        "textRange": {
          "startLine": 268,
          "endLine": 268,
          "startOffset": 75,
          "endOffset": 83
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {\n        if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n            return invalidValue(\"object\", val);\n        }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzpiD",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 273,
        "hash": "f55f8faca787b16a5de85276cda27696",
        "textRange": {
          "startLine": 273,
          "endLine": 273,
          "startOffset": 50,
          "endOffset": 53
        },
        "flows": [],
        "status": "OPEN",
        "message": "'key' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        }\n        const result: any = {};\n        Object.getOwnPropertyNames(props).forEach(key => {\n            const prop = props[key];\n            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;\n            result[prop.key] = transform(v, prop.typ, getProps, prop.key);",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzpiE",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 278,
        "hash": "85cdf91827cdae6313afff45d00a55bf",
        "textRange": {
          "startLine": 278,
          "endLine": 278,
          "startOffset": 48,
          "endOffset": 51
        },
        "flows": [],
        "status": "OPEN",
        "message": "'key' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "            result[prop.key] = transform(v, prop.typ, getProps, prop.key);\n        });\n        Object.getOwnPropertyNames(val).forEach(key => {\n            if (!Object.prototype.hasOwnProperty.call(props, key)) {\n                result[key] = transform(val[key], additional, getProps, key);\n            }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzpiF",
        "rule": "typescript:S3358",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 298,
        "hash": "312531a9243571ab2555c04a21adee70",
        "textRange": {
          "startLine": 298,
          "endLine": 300,
          "startOffset": 14,
          "endOffset": 36
        },
        "flows": [],
        "status": "OPEN",
        "message": "Extract this nested ternary operation into an independent statement.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "confusing"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    if (typeof typ === \"object\") {\n        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);",
        "summary": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>"
      },
      {
        "key": "AXtAUP0Ii8r-LMdMzpiG",
        "rule": "typescript:S3358",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 299,
        "hash": "8a63580931669d2f7b7d79bda6f68a08",
        "textRange": {
          "startLine": 299,
          "endLine": 300,
          "startOffset": 14,
          "endOffset": 36
        },
        "flows": [],
        "status": "OPEN",
        "message": "Extract this nested ternary operation into an independent statement.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "confusing"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);",
        "summary": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzphr",
        "rule": "typescript:S3776",
        "severity": "CRITICAL",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 90,
        "hash": "5fd6dcc3adfc524cd3dd083080299a0c",
        "textRange": {
          "startLine": 90,
          "endLine": 90,
          "startOffset": 9,
          "endOffset": 18
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 148,
                  "endLine": 148,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 149,
                  "endLine": 149,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 150,
                  "endLine": 150,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 153,
                  "endLine": 153,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 154,
                  "endLine": 154,
                  "startOffset": 4,
                  "endOffset": 9
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 154,
                  "endLine": 154,
                  "startOffset": 35,
                  "endOffset": 37
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 157,
                  "endLine": 157,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 158,
                  "endLine": 158,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 159,
                  "endLine": 159,
                  "startOffset": 50,
                  "endOffset": 51
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 160,
                  "endLine": 160,
                  "startOffset": 50,
                  "endOffset": 51
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 161,
                  "endLine": 161,
                  "startOffset": 50,
                  "endOffset": 51
                },
                "msg": "+4 (incl. 3 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 165,
                  "endLine": 165,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 165,
                  "endLine": 165,
                  "startOffset": 21,
                  "endOffset": 23
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 92,
                  "endLine": 92,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 99,
                  "endLine": 99,
                  "startOffset": 8,
                  "endOffset": 11
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 103,
                  "endLine": 103,
                  "startOffset": 14,
                  "endOffset": 19
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 109,
                  "endLine": 109,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 115,
                  "endLine": 115,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 120,
                  "endLine": 120,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 124,
                  "endLine": 124,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 131,
                  "endLine": 131,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 131,
                  "endLine": 131,
                  "startOffset": 52,
                  "endOffset": 54
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 137,
                  "endLine": 137,
                  "startOffset": 69,
                  "endOffset": 70
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 141,
                  "endLine": 141,
                  "startOffset": 12,
                  "endOffset": 14
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Refactor this function to reduce its Cognitive Complexity from 44 to the 15 allowed.",
        "effort": "34min",
        "debt": "34min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "brain-overload"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "}\n\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);",
        "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzph0",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 130,
        "hash": "00fba73079d5d65a34ef9c6a86abaae5",
        "textRange": {
          "startLine": 130,
          "endLine": 130,
          "startOffset": 75,
          "endOffset": 83
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {\n        if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n            return invalidValue(\"object\", val);\n        }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzph1",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 135,
        "hash": "f55f8faca787b16a5de85276cda27696",
        "textRange": {
          "startLine": 135,
          "endLine": 135,
          "startOffset": 50,
          "endOffset": 53
        },
        "flows": [],
        "status": "OPEN",
        "message": "'key' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        }\n        const result: any = {};\n        Object.getOwnPropertyNames(props).forEach(key => {\n            const prop = props[key];\n            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;\n            result[prop.key] = transform(v, prop.typ, getProps, prop.key);",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzph2",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 140,
        "hash": "85cdf91827cdae6313afff45d00a55bf",
        "textRange": {
          "startLine": 140,
          "endLine": 140,
          "startOffset": 48,
          "endOffset": 51
        },
        "flows": [],
        "status": "OPEN",
        "message": "'key' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "            result[prop.key] = transform(v, prop.typ, getProps, prop.key);\n        });\n        Object.getOwnPropertyNames(val).forEach(key => {\n            if (!Object.prototype.hasOwnProperty.call(props, key)) {\n                result[key] = transform(val[key], additional, getProps, key);\n            }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzph3",
        "rule": "typescript:S3358",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 160,
        "hash": "312531a9243571ab2555c04a21adee70",
        "textRange": {
          "startLine": 160,
          "endLine": 162,
          "startOffset": 14,
          "endOffset": 36
        },
        "flows": [],
        "status": "OPEN",
        "message": "Extract this nested ternary operation into an independent statement.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "confusing"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    if (typeof typ === \"object\") {\n        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);",
        "summary": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzph4",
        "rule": "typescript:S3358",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 161,
        "hash": "8a63580931669d2f7b7d79bda6f68a08",
        "textRange": {
          "startLine": 161,
          "endLine": 162,
          "startOffset": 14,
          "endOffset": 36
        },
        "flows": [],
        "status": "OPEN",
        "message": "Extract this nested ternary operation into an independent statement.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "confusing"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);",
        "summary": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphd",
        "rule": "typescript:S3776",
        "severity": "CRITICAL",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 147,
        "hash": "5fd6dcc3adfc524cd3dd083080299a0c",
        "textRange": {
          "startLine": 147,
          "endLine": 147,
          "startOffset": 9,
          "endOffset": 18
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 205,
                  "endLine": 205,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 206,
                  "endLine": 206,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 207,
                  "endLine": 207,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 210,
                  "endLine": 210,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 211,
                  "endLine": 211,
                  "startOffset": 4,
                  "endOffset": 9
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 211,
                  "endLine": 211,
                  "startOffset": 35,
                  "endOffset": 37
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 214,
                  "endLine": 214,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 215,
                  "endLine": 215,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 216,
                  "endLine": 216,
                  "startOffset": 50,
                  "endOffset": 51
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 217,
                  "endLine": 217,
                  "startOffset": 50,
                  "endOffset": 51
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 218,
                  "endLine": 218,
                  "startOffset": 50,
                  "endOffset": 51
                },
                "msg": "+4 (incl. 3 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 222,
                  "endLine": 222,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 222,
                  "endLine": 222,
                  "startOffset": 21,
                  "endOffset": 23
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 149,
                  "endLine": 149,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 156,
                  "endLine": 156,
                  "startOffset": 8,
                  "endOffset": 11
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 160,
                  "endLine": 160,
                  "startOffset": 14,
                  "endOffset": 19
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 166,
                  "endLine": 166,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 172,
                  "endLine": 172,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 177,
                  "endLine": 177,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 181,
                  "endLine": 181,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 188,
                  "endLine": 188,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 188,
                  "endLine": 188,
                  "startOffset": 52,
                  "endOffset": 54
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 194,
                  "endLine": 194,
                  "startOffset": 69,
                  "endOffset": 70
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 198,
                  "endLine": 198,
                  "startOffset": 12,
                  "endOffset": 14
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Refactor this function to reduce its Cognitive Complexity from 44 to the 15 allowed.",
        "effort": "34min",
        "debt": "34min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "brain-overload"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "}\n\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);",
        "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphh",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 157,
        "hash": "c18b29c89a7108ee069bbe31d8a88c35",
        "textRange": {
          "startLine": 157,
          "endLine": 157,
          "startOffset": 18,
          "endOffset": 21
        },
        "flows": [],
        "status": "OPEN",
        "message": "'typ' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        const l = typs.length;\n        for (let i = 0; i < l; i++) {\n            const typ = typs[i];\n            try {\n                return transform(val, typ, getProps);\n            } catch (_) {}",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphm",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 187,
        "hash": "00fba73079d5d65a34ef9c6a86abaae5",
        "textRange": {
          "startLine": 187,
          "endLine": 187,
          "startOffset": 75,
          "endOffset": 83
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {\n        if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n            return invalidValue(\"object\", val);\n        }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphn",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 192,
        "hash": "f55f8faca787b16a5de85276cda27696",
        "textRange": {
          "startLine": 192,
          "endLine": 192,
          "startOffset": 50,
          "endOffset": 53
        },
        "flows": [],
        "status": "OPEN",
        "message": "'key' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        }\n        const result: any = {};\n        Object.getOwnPropertyNames(props).forEach(key => {\n            const prop = props[key];\n            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;\n            result[prop.key] = transform(v, prop.typ, getProps, prop.key);",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzpho",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 197,
        "hash": "85cdf91827cdae6313afff45d00a55bf",
        "textRange": {
          "startLine": 197,
          "endLine": 197,
          "startOffset": 48,
          "endOffset": 51
        },
        "flows": [],
        "status": "OPEN",
        "message": "'key' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "            result[prop.key] = transform(v, prop.typ, getProps, prop.key);\n        });\n        Object.getOwnPropertyNames(val).forEach(key => {\n            if (!Object.prototype.hasOwnProperty.call(props, key)) {\n                result[key] = transform(val[key], additional, getProps, key);\n            }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphp",
        "rule": "typescript:S3358",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 217,
        "hash": "312531a9243571ab2555c04a21adee70",
        "textRange": {
          "startLine": 217,
          "endLine": 219,
          "startOffset": 14,
          "endOffset": 36
        },
        "flows": [],
        "status": "OPEN",
        "message": "Extract this nested ternary operation into an independent statement.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "confusing"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    if (typeof typ === \"object\") {\n        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);",
        "summary": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphq",
        "rule": "typescript:S3358",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 218,
        "hash": "8a63580931669d2f7b7d79bda6f68a08",
        "textRange": {
          "startLine": 218,
          "endLine": 219,
          "startOffset": 14,
          "endOffset": 36
        },
        "flows": [],
        "status": "OPEN",
        "message": "Extract this nested ternary operation into an independent statement.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "confusing"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);",
        "summary": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPqri8r-LMdMzpgL",
        "rule": "typescript:S3776",
        "severity": "CRITICAL",
        "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
        "project": "test",
        "line": 71,
        "hash": "033d83583fb5666efff076b608fc30c3",
        "textRange": {
          "startLine": 71,
          "endLine": 71,
          "startOffset": 6,
          "endOffset": 19
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                "textRange": {
                  "startLine": 78,
                  "endLine": 78,
                  "startOffset": 6,
                  "endOffset": 9
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                "textRange": {
                  "startLine": 80,
                  "endLine": 80,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                "textRange": {
                  "startLine": 99,
                  "endLine": 99,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                "textRange": {
                  "startLine": 105,
                  "endLine": 105,
                  "startOffset": 10,
                  "endOffset": 14
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                "textRange": {
                  "startLine": 100,
                  "endLine": 100,
                  "startOffset": 10,
                  "endOffset": 12
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                "textRange": {
                  "startLine": 102,
                  "endLine": 102,
                  "startOffset": 12,
                  "endOffset": 16
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                "textRange": {
                  "startLine": 100,
                  "endLine": 100,
                  "startOffset": 31,
                  "endOffset": 33
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                "textRange": {
                  "startLine": 109,
                  "endLine": 109,
                  "startOffset": 6,
                  "endOffset": 11
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                "textRange": {
                  "startLine": 88,
                  "endLine": 88,
                  "startOffset": 10,
                  "endOffset": 12
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                "textRange": {
                  "startLine": 95,
                  "endLine": 95,
                  "startOffset": 12,
                  "endOffset": 16
                },
                "msg": "+1"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Refactor this function to reduce its Cognitive Complexity from 16 to the 15 allowed.",
        "effort": "6min",
        "debt": "6min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "brain-overload"
        ],
        "creationDate": "2021-06-30T16:09:04+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "\n  /** The currently selected treemap node. Wrapped to avoid initialization woes */\n  get selected_node(): d3.HierarchyRectangularNode<TreemapNode> {\n    // Get typed versions of the curr state\n    // Set curr to root\n    let curr = this.treemap_layout;",
        "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
      },
      {
        "key": "AXtAUPnSi8r-LMdMzpf4",
        "rule": "typescript:S4325",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/components/global/upload_tabs/aws/FileList.vue",
        "project": "test",
        "line": 79,
        "hash": "8a88aeebc2f9b4b0ecc10da38885032e",
        "textRange": {
          "startLine": 79,
          "endLine": 79,
          "startOffset": 41,
          "endOffset": 50
        },
        "flows": [],
        "status": "OPEN",
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "effort": "1min",
        "debt": "1min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "redundant"
        ],
        "creationDate": "2021-06-30T16:09:04+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "\n    // Fetch it from s3, and promise to submit it to be loaded afterwards\n    await fetch_s3_file(this.auth.creds, file.Key!, this.formBucketName).then(\n      (content) => {\n        InspecIntakeModule.loadText({\n          text: content,",
        "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPnsi8r-LMdMzpf6",
        "rule": "typescript:S4325",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/components/global/upload_tabs/aws/S3Reader.vue",
        "project": "test",
        "line": 184,
        "hash": "9a4009784ecd065c4fe9baa831240022",
        "textRange": {
          "startLine": 184,
          "endLine": 184,
          "startOffset": 22,
          "endOffset": 39
        },
        "flows": [],
        "status": "OPEN",
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "effort": "1min",
        "debt": "1min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "redundant"
        ],
        "creationDate": "2021-06-30T16:09:04+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "   */\n  async load_bucket(name: string) {\n    const s3 = new S3(this.assumedRole!.creds);\n    await s3\n      .listObjectsV2({\n        Bucket: name,",
        "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPr3i8r-LMdMzpgO",
        "rule": "typescript:S4325",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/store/data_filters.ts",
        "project": "test",
        "line": 96,
        "hash": "13967f9141b7884039ec8d6481313af7",
        "textRange": {
          "startLine": 96,
          "endLine": 103,
          "startOffset": 32,
          "endOffset": 41
        },
        "flows": [],
        "status": "OPEN",
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "effort": "1min",
        "debt": "1min",
        "author": "sheikholeslam@mitre.org",
        "tags": [
          "redundant"
        ],
        "creationDate": "2021-06-23T16:08:32+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "  const asHDF = contextControl.root.hdf;\n  // Get our (non-null) searchable data\n  const searchables: string[] = [\n    asHDF.wraps.id,\n    asHDF.wraps.title,\n    asHDF.wraps.code,\n    asHDF.severity,\n    asHDF.status,\n    asHDF.finding_details\n  ].filter((s) => s !== null) as string[];\n\n  // See if any contain term\n  return searchables.some((s) => s.toLowerCase().includes(term));",
        "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPs3i8r-LMdMzpgS",
        "rule": "typescript:S4325",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/utilities/format_util.ts",
        "project": "test",
        "line": 29,
        "hash": "0c2f340c5bacde239d24920b8a453c6b",
        "textRange": {
          "startLine": 29,
          "endLine": 29,
          "startOffset": 6,
          "endOffset": 60
        },
        "flows": [],
        "status": "OPEN",
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "effort": "1min",
        "debt": "1min",
        "author": "sheikholeslam@mitre.org",
        "tags": [
          "redundant"
        ],
        "creationDate": "2021-06-23T14:32:15+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "  } else {\n    return `${execution_unique_key(\n      profile.sourcedFrom as SourcedContextualizedEvaluation\n    )}-${profile.data.name}`;\n  }\n}",
        "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
      },
      {
        "key": "AXtAUP0Vi8r-LMdMzpiH",
        "rule": "typescript:S3776",
        "severity": "CRITICAL",
        "component": "test:libs/inspecjs/src/context.ts",
        "project": "test",
        "line": 153,
        "hash": "bd47be4985f547192f96954033d9e458",
        "textRange": {
          "startLine": 153,
          "endLine": 153,
          "startOffset": 16,
          "endOffset": 39
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 162,
                  "endLine": 162,
                  "startOffset": 2,
                  "endOffset": 5
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 176,
                  "endLine": 176,
                  "startOffset": 2,
                  "endOffset": 5
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 181,
                  "endLine": 181,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 188,
                  "endLine": 188,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 199,
                  "endLine": 199,
                  "startOffset": 2,
                  "endOffset": 5
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 208,
                  "endLine": 208,
                  "startOffset": 2,
                  "endOffset": 5
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 210,
                  "endLine": 210,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 233,
                  "endLine": 233,
                  "startOffset": 6,
                  "endOffset": 10
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 210,
                  "endLine": 210,
                  "startOffset": 42,
                  "endOffset": 44
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 213,
                  "endLine": 213,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 220,
                  "endLine": 220,
                  "startOffset": 6,
                  "endOffset": 9
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 226,
                  "endLine": 226,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+4 (incl. 3 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 245,
                  "endLine": 245,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 250,
                  "endLine": 250,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 252,
                  "endLine": 252,
                  "startOffset": 8,
                  "endOffset": 12
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 241,
                  "endLine": 241,
                  "startOffset": 30,
                  "endOffset": 32
                },
                "msg": "+1"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Refactor this function to reduce its Cognitive Complexity from 31 to the 15 allowed.",
        "effort": "21min",
        "debt": "21min",
        "author": "sheikholeslam@mitre.org",
        "tags": [
          "brain-overload"
        ],
        "creationDate": "2021-06-23T14:32:15+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "}\n\nexport function contextualizeEvaluation(\n  evaluation: AnyEval\n): ContextualizedEvaluation {\n  // To begin, create basic context for profiles and evaluation",
        "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzpiB",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 257,
        "hash": "ec0d349e10fedfa2b54a27dd6cf235ca",
        "textRange": {
          "startLine": 257,
          "endLine": 257,
          "startOffset": 27,
          "endOffset": 35
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "sheikholeslam@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-06-23T14:32:15+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformDate(val: any): any {\n        if (val === null) {\n            return null;\n        }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzphz",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 119,
        "hash": "ec0d349e10fedfa2b54a27dd6cf235ca",
        "textRange": {
          "startLine": 119,
          "endLine": 119,
          "startOffset": 27,
          "endOffset": 35
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "sheikholeslam@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-06-23T14:32:15+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformDate(val: any): any {\n        if (val === null) {\n            return null;\n        }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphl",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 176,
        "hash": "ec0d349e10fedfa2b54a27dd6cf235ca",
        "textRange": {
          "startLine": 176,
          "endLine": 176,
          "startOffset": 27,
          "endOffset": 35
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "sheikholeslam@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-06-23T14:32:15+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformDate(val: any): any {\n        if (val === null) {\n            return null;\n        }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzphv",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 100,
        "hash": "c18b29c89a7108ee069bbe31d8a88c35",
        "textRange": {
          "startLine": 100,
          "endLine": 100,
          "startOffset": 18,
          "endOffset": 21
        },
        "flows": [],
        "status": "OPEN",
        "message": "'typ' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "sheikholeslam@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-06-22T15:34:30+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        const l = typs.length;\n        for (let i = 0; i < l; i++) {\n            const typ = typs[i];\n            try {\n                return transform(val, typ, getProps);\n            } catch (_) {}",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzdi8r-LMdMzphc",
        "rule": "typescript:S3776",
        "severity": "CRITICAL",
        "component": "test:libs/inspecjs/src/nist.ts",
        "project": "test",
        "line": 126,
        "hash": "99d4f34dee5a16b69df60f274112f848",
        "textRange": {
          "startLine": 126,
          "endLine": 126,
          "startOffset": 2,
          "endOffset": 10
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 131,
                  "endLine": 131,
                  "startOffset": 24,
                  "endOffset": 26
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 132,
                  "endLine": 132,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 136,
                  "endLine": 136,
                  "startOffset": 4,
                  "endOffset": 7
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 136,
                  "endLine": 136,
                  "startOffset": 34,
                  "endOffset": 36
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 140,
                  "endLine": 140,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 142,
                  "endLine": 142,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 142,
                  "endLine": 142,
                  "startOffset": 29,
                  "endOffset": 31
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 147,
                  "endLine": 147,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 148,
                  "endLine": 148,
                  "startOffset": 10,
                  "endOffset": 12
                },
                "msg": "+4 (incl. 3 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 153,
                  "endLine": 153,
                  "startOffset": 10,
                  "endOffset": 12
                },
                "msg": "+4 (incl. 3 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 160,
                  "endLine": 160,
                  "startOffset": 13,
                  "endOffset": 15
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 162,
                  "endLine": 162,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 166,
                  "endLine": 166,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Refactor this function to reduce its Cognitive Complexity from 28 to the 15 allowed.",
        "effort": "18min",
        "debt": "18min",
        "author": "sheikholeslam@mitre.org",
        "tags": [
          "brain-overload"
        ],
        "creationDate": "2021-06-22T15:34:30+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "   * Avoid repeating this if possible.\n   */\n  canonize(config: CanonizationConfig): string {\n    config = default_partial_config(config);\n    const ss = this.subSpecifiers;\n",
        "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
      },
      {
        "key": "AXtAUPrqi8r-LMdMzpgN",
        "rule": "typescript:S4325",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/store/data_store.ts",
        "project": "test",
        "line": 81,
        "hash": "3899fef5cfc73d590869dd79cb4cc7e9",
        "textRange": {
          "startLine": 81,
          "endLine": 83,
          "startOffset": 11,
          "endOffset": 39
        },
        "flows": [],
        "status": "OPEN",
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "effort": "1min",
        "debt": "1min",
        "author": "66680985+camdenmoors@users.noreply.github.com",
        "tags": [
          "redundant"
        ],
        "creationDate": "2021-04-06T20:31:54+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "   */\n  get contextualExecutionProfiles(): readonly SourcedContextualizedProfile[] {\n    return this.contextualExecutions.flatMap(\n      (evaluation) => evaluation.contains\n    ) as SourcedContextualizedProfile[];\n  }\n\n  /**",
        "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPqii8r-LMdMzpgK",
        "rule": "typescript:S4325",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/components/cards/treemap/Cell.vue",
        "project": "test",
        "line": 84,
        "hash": "132666a69b184b8b50ac1bf8e461a4d6",
        "textRange": {
          "startLine": 84,
          "endLine": 84,
          "startOffset": 7,
          "endOffset": 40
        },
        "flows": [],
        "status": "OPEN",
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "effort": "1min",
        "debt": "1min",
        "author": "rbclark@mitre.org",
        "tags": [
          "redundant"
        ],
        "creationDate": "2020-10-14T22:38:18+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    return (\n      this.is_control && // We are a control\n      (this.node.data as TreemapNodeLeaf).control.data.id ===\n        this.selectedControlId // Our control id matches\n    );\n  }",
        "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPnSi8r-LMdMzpf5",
        "rule": "typescript:S4325",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/components/global/upload_tabs/aws/FileList.vue",
        "project": "test",
        "line": 83,
        "hash": "74f2f0146720ebd242fef2ef1727b1cd",
        "textRange": {
          "startLine": 83,
          "endLine": 83,
          "startOffset": 20,
          "endOffset": 29
        },
        "flows": [],
        "status": "OPEN",
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "effort": "1min",
        "debt": "1min",
        "author": "rbclark@mitre.org",
        "tags": [
          "redundant"
        ],
        "creationDate": "2020-09-22T22:33:07+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        InspecIntakeModule.loadText({\n          text: content,\n          filename: file.Key!\n        }).then((uniqueId) => this.$emit('got-files', [uniqueId]));\n      }\n    );",
        "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPrPi8r-LMdMzpgM",
        "rule": "typescript:S4138",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/components/generic/ApexLineChart.vue",
        "project": "test",
        "line": 46,
        "hash": "9acd2d681bf613b90597cfd8bcf316e8",
        "textRange": {
          "startLine": 46,
          "endLine": 48,
          "startOffset": 4,
          "endOffset": 5
        },
        "flows": [],
        "status": "OPEN",
        "message": "Expected a `for-of` loop instead of a `for` loop with this simple iteration.",
        "effort": "5min",
        "debt": "5min",
        "author": "51336847+cjdoherty@users.noreply.github.com",
        "tags": [
          "clumsy"
        ],
        "creationDate": "2020-08-26T14:02:11+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "  get label_colors(): string[] {\n    const colors = [];\n    for (let i = 0; i < this.categories.length; i++) {\n      colors.push('#FFFFFF');\n    }\n    return colors;\n  }\n",
        "summary": "<p>If you have an iterable, such as an array, set, or list, your best option for looping through its values is the <code>for of</code> syntax. Use a\ncounter, and …​ well you’ll get the right behavior, but your code just isn’t as clean or clear.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nconst arr = [4, 3, 2, 1];\n\nfor (let i = 0; i &lt; arr.length; i++) {  // Noncompliant\n  console.log(arr[i]);\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nconst arr = [4, 3, 2, 1];\n\nfor (let value of arr) {\n  console.log(value);\n}\n</pre>"
      },
      {
        "key": "AXtAUPsri8r-LMdMzpgQ",
        "rule": "typescript:S4325",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/utilities/delta_util.ts",
        "project": "test",
        "line": 158,
        "hash": "1ff214edad50c0e11919635e4a4da1fe",
        "textRange": {
          "startLine": 158,
          "endLine": 158,
          "startOffset": 10,
          "endOffset": 28
        },
        "flows": [],
        "status": "OPEN",
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "effort": "1min",
        "debt": "1min",
        "author": "51336847+cjdoherty@users.noreply.github.com",
        "tags": [
          "redundant"
        ],
        "creationDate": "2020-08-26T14:02:11+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "  for (const prof of ev.contains) {\n    for (const ctrl of prof.contains) {\n      if (ctrl.hdf.segments!.length) {\n        return ctrl.hdf.segments![0].start_time;\n      }\n    }",
        "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPssi8r-LMdMzpgR",
        "rule": "typescript:S4325",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/utilities/delta_util.ts",
        "project": "test",
        "line": 159,
        "hash": "a35b4c61d3b8c13f7961feca7a6ec00c",
        "textRange": {
          "startLine": 159,
          "endLine": 159,
          "startOffset": 15,
          "endOffset": 33
        },
        "flows": [],
        "status": "OPEN",
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "effort": "1min",
        "debt": "1min",
        "author": "51336847+cjdoherty@users.noreply.github.com",
        "tags": [
          "redundant"
        ],
        "creationDate": "2020-08-26T14:02:11+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    for (const ctrl of prof.contains) {\n      if (ctrl.hdf.segments!.length) {\n        return ctrl.hdf.segments![0].start_time;\n      }\n    }\n  }",
        "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPt6i8r-LMdMzpgU",
        "rule": "typescript:S4144",
        "severity": "MAJOR",
        "component": "test:apps/frontend/tests/unit/Compare.spec.ts",
        "project": "test",
        "line": 46,
        "hash": "a68d822d383917a99ac357fd376a830d",
        "textRange": {
          "startLine": 46,
          "endLine": 46,
          "startOffset": 55,
          "endOffset": 57
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:apps/frontend/tests/unit/Compare.spec.ts",
                "textRange": {
                  "startLine": 38,
                  "endLine": 38,
                  "startOffset": 55,
                  "endOffset": 57
                },
                "msg": "Original implementation"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Update this function so that its implementation is not identical to the one on line 38.",
        "effort": "15min",
        "debt": "15min",
        "author": "51336847+cjdoherty@users.noreply.github.com",
        "tags": [
          "confusing",
          "duplicate",
          "suspicious"
        ],
        "creationDate": "2020-08-26T14:02:11+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "  });\n\n  it('does not recount same controls with 3 files', () => {\n    loadSample('NGINX With Failing Tests');\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets",
        "summary": "<p>When two functions have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but\nmay be confusing to maintainers. In the latter case, the code should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {  // Noncompliant\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {\n  return calculateCode();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Functions with fewer than 3 lines are ignored.</p>"
      },
      {
        "key": "AXtAUPtAi8r-LMdMzpgT",
        "rule": "typescript:S1135",
        "severity": "INFO",
        "component": "test:apps/frontend/src/utilities/splunk_util.ts",
        "project": "test",
        "line": 341,
        "hash": "4ad01e433047b4d0b74d3a3bd46ae007",
        "textRange": {
          "startLine": 341,
          "endLine": 341,
          "startOffset": 3,
          "endOffset": 7
        },
        "flows": [],
        "status": "OPEN",
        "message": "Complete the task associated to this \"TODO\" comment.",
        "effort": "0min",
        "debt": "0min",
        "author": "51966679+mitriol@users.noreply.github.com",
        "tags": [
          "cwe"
        ],
        "creationDate": "2020-08-26T14:01:58+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": " * HDF heirarchy.\n *\n * TODO: Provide a mechanism for also returning orphaned items\n */\nexport function consolidate_payloads(\n  payloads: UnknownPayload[]",
        "summary": "<p><code>TODO</code> tags are commonly used to mark places where some more code is required, but which the developer wants to implement later.</p>\n<p>Sometimes the developer will not have the time or will simply forget to get back to that tag.</p>\n<p>This rule is meant to track those tags and to ensure that they do not go unnoticed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction doSomething() {\n  // TODO\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/546.html\">MITRE, CWE-546</a> - Suspicious Comment </li>\n</ul>"
      },
      {
        "key": "AXtAUPsYi8r-LMdMzpgP",
        "rule": "typescript:S4325",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/utilities/treemap_util.ts",
        "project": "test",
        "line": 222,
        "hash": "9a78ca4b58afc6956625e79056466a00",
        "textRange": {
          "startLine": 222,
          "endLine": 222,
          "startOffset": 21,
          "endOffset": 33
        },
        "flows": [],
        "status": "OPEN",
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "effort": "1min",
        "debt": "1min",
        "author": "51966679+mitriol@users.noreply.github.com",
        "tags": [
          "redundant"
        ],
        "creationDate": "2020-08-26T14:01:23+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        }\n      } else if (root.parent !== null) {\n        return 1.0 / root.parent!.children.length;\n      }\n      return 0;\n    });",
        "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPp3i8r-LMdMzpgG",
        "rule": "typescript:S1135",
        "severity": "INFO",
        "component": "test:apps/frontend/src/components/cards/controltable/ControlRowDetails.vue",
        "project": "test",
        "line": 67,
        "hash": "b3b8610f2f997ad05a0cc9fcc8d5aa17",
        "textRange": {
          "startLine": 67,
          "endLine": 67,
          "startOffset": 2,
          "endOffset": 6
        },
        "flows": [],
        "status": "OPEN",
        "message": "Complete the task associated to this \"TODO\" comment.",
        "effort": "0min",
        "debt": "0min",
        "author": "lippold@gmail.com",
        "tags": [
          "cwe"
        ],
        "creationDate": "2020-08-26T14:01:02+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "import {ContextualizedControl} from 'inspecjs';\nimport _ from 'lodash';\n//TODO: add line numbers\nimport 'prismjs';\nimport 'prismjs/components/prism-makefile.js';\nimport 'prismjs/components/prism-ruby.js';",
        "summary": "<p><code>TODO</code> tags are commonly used to mark places where some more code is required, but which the developer wants to implement later.</p>\n<p>Sometimes the developer will not have the time or will simply forget to get back to that tag.</p>\n<p>This rule is meant to track those tags and to ensure that they do not go unnoticed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction doSomething() {\n  // TODO\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/546.html\">MITRE, CWE-546</a> - Suspicious Comment </li>\n</ul>"
      },
      {
        "key": "AXtAUPuhi8r-LMdMzpgV",
        "rule": "typescript:S4144",
        "severity": "MAJOR",
        "component": "test:apps/backend/src/evaluations/evaluations.service.spec.ts",
        "project": "test",
        "line": 293,
        "hash": "4fb693e4f6656b1e3dbad68b47593776",
        "textRange": {
          "startLine": 293,
          "endLine": 293,
          "startOffset": 76,
          "endOffset": 78
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:apps/backend/src/evaluations/evaluations.service.spec.ts",
                "textRange": {
                  "startLine": 141,
                  "endLine": 141,
                  "startOffset": 73,
                  "endOffset": 75
                },
                "msg": "Original implementation"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Update this function so that its implementation is not identical to the one on line 141.",
        "effort": "15min",
        "debt": "15min",
        "author": "kfagan@mitre.org",
        "tags": [
          "confusing",
          "duplicate",
          "suspicious"
        ],
        "creationDate": "2020-08-19T20:43:00+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    });\n\n    it('should throw an error when the evaluation does not exist', async () => {\n      expect.assertions(1);\n      await expect(evaluationsService.findById('-1')).rejects.toThrow(\n        NotFoundException",
        "summary": "<p>When two functions have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but\nmay be confusing to maintainers. In the latter case, the code should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {  // Noncompliant\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {\n  return calculateCode();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Functions with fewer than 3 lines are ignored.</p>"
      },
      {
        "key": "AXtAUPwji8r-LMdMzpga",
        "rule": "typescript:S1848",
        "severity": "MAJOR",
        "component": "test:apps/backend/src/config/config.service.spec.ts",
        "project": "test",
        "line": 33,
        "hash": "3cf63da6002c83ff5e01af3ea9a377fe",
        "textRange": {
          "startLine": 33,
          "endLine": 33,
          "startOffset": 6,
          "endOffset": 23
        },
        "flows": [],
        "status": "OPEN",
        "message": "Either remove this useless object instantiation of \"ConfigService\" or use it.",
        "effort": "5min",
        "debt": "5min",
        "author": "60075714+samuelsunvold@users.noreply.github.com",
        "tags": [],
        "creationDate": "2020-07-01T16:16:10+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "BUG",
        "scope": "MAIN",
        "snip": "      const consoleSpy = jest.spyOn(console, 'log');\n      // Used to make sure logs are outputted\n      new ConfigService();\n      expect(consoleSpy).toHaveBeenCalledWith(\n        'Unable to read configuration file `.env`!'\n      );",
        "summary": "<p>There is no good reason to create a new object to not do anything with it. Most of the time, this is due to a missing piece of code and so could\nlead to an unexpected behavior in production.</p>\n<p>If it was done on purpose because the constructor has side-effects, then that side-effect code should be moved into a separate method and called\ndirectly.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nnew MyConstructor(); // Non-Compliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar something = new MyConstructor();  // Compliant\n</pre>\n<h2>Exceptions</h2>\n<p>Immediately dropped new objects inside <code>try</code>-statements are ignored.</p>\n<pre>\ntry {\n  new MyConstructor();\n} catch (e) {\n  /* ... */\n}\n</pre>"
      },
      {
        "key": "AXtAUPwFi8r-LMdMzpgY",
        "rule": "typescript:S4144",
        "severity": "MAJOR",
        "component": "test:apps/backend/src/pipes/password-complexity.pipe.spec.ts",
        "project": "test",
        "line": 141,
        "hash": "7bdcb56ce070e980805d0246390b76f1",
        "textRange": {
          "startLine": 141,
          "endLine": 141,
          "startOffset": 16,
          "endOffset": 18
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:apps/backend/src/pipes/password-complexity.pipe.spec.ts",
                "textRange": {
                  "startLine": 135,
                  "endLine": 135,
                  "startOffset": 16,
                  "endOffset": 18
                },
                "msg": "Original implementation"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Update this function so that its implementation is not identical to the one on line 135.",
        "effort": "15min",
        "debt": "15min",
        "author": "kfagan@mitre.org",
        "tags": [
          "confusing",
          "duplicate",
          "suspicious"
        ],
        "creationDate": "2020-07-01T13:38:16+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        )\n      ).toThrowError(BadRequestException);\n      expect(() =>\n        passwordComplexityPipe.transform(\n          CREATE_USER_DTO_TEST_OBJ_WITH_MISSING_PASSWORD_FIELD,\n          metaData",
        "summary": "<p>When two functions have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but\nmay be confusing to maintainers. In the latter case, the code should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {  // Noncompliant\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {\n  return calculateCode();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Functions with fewer than 3 lines are ignored.</p>"
      },
      {
        "key": "AXtAUPwFi8r-LMdMzpgZ",
        "rule": "typescript:S4144",
        "severity": "MAJOR",
        "component": "test:apps/backend/src/pipes/password-complexity.pipe.spec.ts",
        "project": "test",
        "line": 161,
        "hash": "7bdcb56ce070e980805d0246390b76f1",
        "textRange": {
          "startLine": 161,
          "endLine": 161,
          "startOffset": 16,
          "endOffset": 18
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:apps/backend/src/pipes/password-complexity.pipe.spec.ts",
                "textRange": {
                  "startLine": 155,
                  "endLine": 155,
                  "startOffset": 16,
                  "endOffset": 18
                },
                "msg": "Original implementation"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Update this function so that its implementation is not identical to the one on line 155.",
        "effort": "15min",
        "debt": "15min",
        "author": "kfagan@mitre.org",
        "tags": [
          "confusing",
          "duplicate",
          "suspicious"
        ],
        "creationDate": "2020-07-01T13:38:16+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        )\n      ).toThrowError(BadRequestException);\n      expect(() =>\n        passwordComplexityPipe.transform(\n          UPDATE_USER_DTO_TEST_WITHOUT_PASSWORD,\n          metaData",
        "summary": "<p>When two functions have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but\nmay be confusing to maintainers. In the latter case, the code should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {  // Noncompliant\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {\n  return calculateCode();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Functions with fewer than 3 lines are ignored.</p>"
      },
      {
        "key": "AXtAUPv_i8r-LMdMzpgX",
        "rule": "typescript:S4144",
        "severity": "MAJOR",
        "component": "test:apps/backend/src/pipes/passwords-match.pipe.spec.ts",
        "project": "test",
        "line": 57,
        "hash": "7bdcb56ce070e980805d0246390b76f1",
        "textRange": {
          "startLine": 57,
          "endLine": 57,
          "startOffset": 16,
          "endOffset": 18
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:apps/backend/src/pipes/passwords-match.pipe.spec.ts",
                "textRange": {
                  "startLine": 51,
                  "endLine": 51,
                  "startOffset": 16,
                  "endOffset": 18
                },
                "msg": "Original implementation"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Update this function so that its implementation is not identical to the one on line 51.",
        "effort": "15min",
        "debt": "15min",
        "author": "kfagan@mitre.org",
        "tags": [
          "confusing",
          "duplicate",
          "suspicious"
        ],
        "creationDate": "2020-07-01T13:38:16+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        )\n      ).toThrowError(BadRequestException);\n      expect(() =>\n        passwordsMatchPipe.transform(\n          CREATE_USER_DTO_TEST_OBJ_WITH_UNMATCHING_PASSWORDS,\n          metaData",
        "summary": "<p>When two functions have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but\nmay be confusing to maintainers. In the latter case, the code should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {  // Noncompliant\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {\n  return calculateCode();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Functions with fewer than 3 lines are ignored.</p>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzph6",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 229,
        "hash": "b981ea8d10d148243a1b3b9ee8a0c3a4",
        "textRange": {
          "startLine": 229,
          "endLine": 229,
          "startOffset": 32,
          "endOffset": 43
        },
        "flows": [],
        "status": "OPEN",
        "message": "'typ' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzph7",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 229,
        "hash": "b981ea8d10d148243a1b3b9ee8a0c3a4",
        "textRange": {
          "startLine": 229,
          "endLine": 229,
          "startOffset": 45,
          "endOffset": 53
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzph8",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 234,
        "hash": "c0531a3bd0eb2b95bf1124e7638d6e3d",
        "textRange": {
          "startLine": 234,
          "endLine": 234,
          "startOffset": 41,
          "endOffset": 49
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformUnion(typs: any[], val: any): any {\n        // val must validate against one typ in typs\n        const l = typs.length;\n        for (let i = 0; i < l; i++) {",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzph-",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 246,
        "hash": "f326b05dbcd91d3c9c8640bc74bcce26",
        "textRange": {
          "startLine": 246,
          "endLine": 246,
          "startOffset": 44,
          "endOffset": 52
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformEnum(cases: string[], val: any): any {\n        if (cases.indexOf(val) !== -1) return val;\n        return invalidValue(cases, val);\n    }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzph_",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 251,
        "hash": "1c3e797b8d85c13b868b149ec110baa3",
        "textRange": {
          "startLine": 251,
          "endLine": 251,
          "startOffset": 28,
          "endOffset": 36
        },
        "flows": [],
        "status": "OPEN",
        "message": "'typ' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzpiA",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 251,
        "hash": "1c3e797b8d85c13b868b149ec110baa3",
        "textRange": {
          "startLine": 251,
          "endLine": 251,
          "startOffset": 38,
          "endOffset": 46
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzphs",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 91,
        "hash": "b981ea8d10d148243a1b3b9ee8a0c3a4",
        "textRange": {
          "startLine": 91,
          "endLine": 91,
          "startOffset": 32,
          "endOffset": 43
        },
        "flows": [],
        "status": "OPEN",
        "message": "'typ' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzpht",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 91,
        "hash": "b981ea8d10d148243a1b3b9ee8a0c3a4",
        "textRange": {
          "startLine": 91,
          "endLine": 91,
          "startOffset": 45,
          "endOffset": 53
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzphu",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 96,
        "hash": "c0531a3bd0eb2b95bf1124e7638d6e3d",
        "textRange": {
          "startLine": 96,
          "endLine": 96,
          "startOffset": 41,
          "endOffset": 49
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformUnion(typs: any[], val: any): any {\n        // val must validate against one typ in typs\n        const l = typs.length;\n        for (let i = 0; i < l; i++) {",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzphw",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 108,
        "hash": "f326b05dbcd91d3c9c8640bc74bcce26",
        "textRange": {
          "startLine": 108,
          "endLine": 108,
          "startOffset": 44,
          "endOffset": 52
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformEnum(cases: string[], val: any): any {\n        if (cases.indexOf(val) !== -1) return val;\n        return invalidValue(cases, val);\n    }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzphx",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 113,
        "hash": "1c3e797b8d85c13b868b149ec110baa3",
        "textRange": {
          "startLine": 113,
          "endLine": 113,
          "startOffset": 28,
          "endOffset": 36
        },
        "flows": [],
        "status": "OPEN",
        "message": "'typ' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzphy",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 113,
        "hash": "1c3e797b8d85c13b868b149ec110baa3",
        "textRange": {
          "startLine": 113,
          "endLine": 113,
          "startOffset": 38,
          "endOffset": 46
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphe",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 148,
        "hash": "b981ea8d10d148243a1b3b9ee8a0c3a4",
        "textRange": {
          "startLine": 148,
          "endLine": 148,
          "startOffset": 32,
          "endOffset": 43
        },
        "flows": [],
        "status": "OPEN",
        "message": "'typ' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphf",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 148,
        "hash": "b981ea8d10d148243a1b3b9ee8a0c3a4",
        "textRange": {
          "startLine": 148,
          "endLine": 148,
          "startOffset": 45,
          "endOffset": 53
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphg",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 153,
        "hash": "c0531a3bd0eb2b95bf1124e7638d6e3d",
        "textRange": {
          "startLine": 153,
          "endLine": 153,
          "startOffset": 41,
          "endOffset": 49
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformUnion(typs: any[], val: any): any {\n        // val must validate against one typ in typs\n        const l = typs.length;\n        for (let i = 0; i < l; i++) {",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphi",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 165,
        "hash": "f326b05dbcd91d3c9c8640bc74bcce26",
        "textRange": {
          "startLine": 165,
          "endLine": 165,
          "startOffset": 44,
          "endOffset": 52
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformEnum(cases: string[], val: any): any {\n        if (cases.indexOf(val) !== -1) return val;\n        return invalidValue(cases, val);\n    }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphj",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 170,
        "hash": "1c3e797b8d85c13b868b149ec110baa3",
        "textRange": {
          "startLine": 170,
          "endLine": 170,
          "startOffset": 28,
          "endOffset": 36
        },
        "flows": [],
        "status": "OPEN",
        "message": "'typ' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphk",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 170,
        "hash": "1c3e797b8d85c13b868b149ec110baa3",
        "textRange": {
          "startLine": 170,
          "endLine": 170,
          "startOffset": 38,
          "endOffset": 46
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      }
    ],
    "components": [
      {
        "key": "test:apps/frontend/src/components/cards/controltable/ControlRowDetails.vue",
        "enabled": true,
        "qualifier": "FIL",
        "name": "ControlRowDetails.vue",
        "longName": "apps/frontend/src/components/cards/controltable/ControlRowDetails.vue",
        "path": "apps/frontend/src/components/cards/controltable/ControlRowDetails.vue"
      },
      {
        "key": "test:apps/backend/src/pipes/passwords-match.pipe.spec.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "passwords-match.pipe.spec.ts",
        "longName": "apps/backend/src/pipes/passwords-match.pipe.spec.ts",
        "path": "apps/backend/src/pipes/passwords-match.pipe.spec.ts"
      },
      {
        "key": "test:apps/backend/src/pipes/password-complexity.pipe.spec.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "password-complexity.pipe.spec.ts",
        "longName": "apps/backend/src/pipes/password-complexity.pipe.spec.ts",
        "path": "apps/backend/src/pipes/password-complexity.pipe.spec.ts"
      },
      {
        "key": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
        "enabled": true,
        "qualifier": "FIL",
        "name": "ControlTable.vue",
        "longName": "apps/frontend/src/components/cards/controltable/ControlTable.vue",
        "path": "apps/frontend/src/components/cards/controltable/ControlTable.vue"
      },
      {
        "key": "test:libs/hdf-converters/src/base-converter.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "base-converter.ts",
        "longName": "libs/hdf-converters/src/base-converter.ts",
        "path": "libs/hdf-converters/src/base-converter.ts"
      },
      {
        "key": "test:apps/frontend/src/utilities/treemap_util.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "treemap_util.ts",
        "longName": "apps/frontend/src/utilities/treemap_util.ts",
        "path": "apps/frontend/src/utilities/treemap_util.ts"
      },
      {
        "key": "test:apps/frontend/src/store/data_store.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "data_store.ts",
        "longName": "apps/frontend/src/store/data_store.ts",
        "path": "apps/frontend/src/store/data_store.ts"
      },
      {
        "key": "test:apps/frontend/src/store/data_filters.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "data_filters.ts",
        "longName": "apps/frontend/src/store/data_filters.ts",
        "path": "apps/frontend/src/store/data_filters.ts"
      },
      {
        "key": "test:apps/backend/src/evaluations/evaluations.service.spec.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "evaluations.service.spec.ts",
        "longName": "apps/backend/src/evaluations/evaluations.service.spec.ts",
        "path": "apps/backend/src/evaluations/evaluations.service.spec.ts"
      },
      {
        "key": "test:apps/frontend/src/components/global/upload_tabs/aws/S3Reader.vue",
        "enabled": true,
        "qualifier": "FIL",
        "name": "S3Reader.vue",
        "longName": "apps/frontend/src/components/global/upload_tabs/aws/S3Reader.vue",
        "path": "apps/frontend/src/components/global/upload_tabs/aws/S3Reader.vue"
      },
      {
        "key": "test:apps/frontend/src/components/global/upload_tabs/aws/FileList.vue",
        "enabled": true,
        "qualifier": "FIL",
        "name": "FileList.vue",
        "longName": "apps/frontend/src/components/global/upload_tabs/aws/FileList.vue",
        "path": "apps/frontend/src/components/global/upload_tabs/aws/FileList.vue"
      },
      {
        "key": "test:apps/frontend/src/components/global/upload_tabs/aws/AuthStepMFA.vue",
        "enabled": true,
        "qualifier": "FIL",
        "name": "AuthStepMFA.vue",
        "longName": "apps/frontend/src/components/global/upload_tabs/aws/AuthStepMFA.vue",
        "path": "apps/frontend/src/components/global/upload_tabs/aws/AuthStepMFA.vue"
      },
      {
        "key": "test:apps/frontend/src/components/global/upload_tabs/aws/AuthStepBasic.vue",
        "enabled": true,
        "qualifier": "FIL",
        "name": "AuthStepBasic.vue",
        "longName": "apps/frontend/src/components/global/upload_tabs/aws/AuthStepBasic.vue",
        "path": "apps/frontend/src/components/global/upload_tabs/aws/AuthStepBasic.vue"
      },
      {
        "key": "test:apps/frontend/src/utilities/delta_util.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "delta_util.ts",
        "longName": "apps/frontend/src/utilities/delta_util.ts",
        "path": "apps/frontend/src/utilities/delta_util.ts"
      },
      {
        "key": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
        "enabled": true,
        "qualifier": "FIL",
        "name": "Treemap.vue",
        "longName": "apps/frontend/src/components/cards/treemap/Treemap.vue",
        "path": "apps/frontend/src/components/cards/treemap/Treemap.vue"
      },
      {
        "key": "test:apps/frontend/tests/unit/Compare.spec.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "Compare.spec.ts",
        "longName": "apps/frontend/tests/unit/Compare.spec.ts",
        "path": "apps/frontend/tests/unit/Compare.spec.ts"
      },
      {
        "key": "test:apps/frontend/src/utilities/format_util.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "format_util.ts",
        "longName": "apps/frontend/src/utilities/format_util.ts",
        "path": "apps/frontend/src/utilities/format_util.ts"
      },
      {
        "key": "test:apps/frontend/src/utilities/splunk_util.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "splunk_util.ts",
        "longName": "apps/frontend/src/utilities/splunk_util.ts",
        "path": "apps/frontend/src/utilities/splunk_util.ts"
      },
      {
        "key": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "exec-jsonmin.ts",
        "longName": "libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "path": "libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts"
      },
      {
        "key": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "exec-json.ts",
        "longName": "libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "path": "libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts"
      },
      {
        "key": "test:apps/frontend/src/components/cards/treemap/Cell.vue",
        "enabled": true,
        "qualifier": "FIL",
        "name": "Cell.vue",
        "longName": "apps/frontend/src/components/cards/treemap/Cell.vue",
        "path": "apps/frontend/src/components/cards/treemap/Cell.vue"
      },
      {
        "key": "test:libs/inspecjs/src/context.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "context.ts",
        "longName": "libs/inspecjs/src/context.ts",
        "path": "libs/inspecjs/src/context.ts"
      },
      {
        "key": "test:apps/frontend/src/components/generic/ApexLineChart.vue",
        "enabled": true,
        "qualifier": "FIL",
        "name": "ApexLineChart.vue",
        "longName": "apps/frontend/src/components/generic/ApexLineChart.vue",
        "path": "apps/frontend/src/components/generic/ApexLineChart.vue"
      },
      {
        "key": "test:libs/inspecjs/src/nist.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "nist.ts",
        "longName": "libs/inspecjs/src/nist.ts",
        "path": "libs/inspecjs/src/nist.ts"
      },
      {
        "key": "test",
        "enabled": true,
        "qualifier": "TRK",
        "name": "test",
        "longName": "test"
      },
      {
        "key": "test:apps/backend/src/config/config.service.spec.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "config.service.spec.ts",
        "longName": "apps/backend/src/config/config.service.spec.ts",
        "path": "apps/backend/src/config/config.service.spec.ts"
      },
      {
        "key": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "profile-json.ts",
        "longName": "libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "path": "libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts"
      }
    ],
    "facets": []
  },
  "/api/sources/raw?key=test:apps/frontend/src/components/cards/controltable/ControlTable.vue": "<template>\n  <v-container fluid class=\"font-weight-bold\">\n    <div\n      ref=\"controlTableTitle\"\n      :class=\"\n        $vuetify.breakpoint.smAndDown\n          ? 'control-table-title'\n          : 'pinned-header control-table-title'\n      \"\n      :style=\"controlTableTitleStyle\"\n    >\n      <!-- Toolbar -->\n      <v-row v-resize=\"onResize\">\n        <v-row>\n          <v-col cols=\"12\" md=\"3\" class=\"pb-0\">\n            <v-card-title class=\"pb-0\">Results View Data</v-card-title>\n          </v-col>\n          <v-spacer />\n          <v-col cols=\"3\" md=\"auto\" class=\"text-right pl-6 pb-0\">\n            <v-switch\n              v-model=\"displayUnviewedControls\"\n              label=\"Show Only Unviewed\"\n            />\n          </v-col>\n          <v-col cols=\"3\" md=\"auto\" class=\"text-right pb-0\">\n            <v-switch v-model=\"syncTabs\" label=\"Sync Tabs\" />\n          </v-col>\n          <v-col cols=\"3\" md=\"auto\" class=\"text-right pb-0\">\n            <v-switch\n              v-model=\"singleExpand\"\n              label=\"Single Expand\"\n              @change=\"handleToggleSingleExpand\"\n            />\n          </v-col>\n          <v-col cols=\"3\" md=\"auto\" class=\"text-right pb-0\">\n            <v-switch v-model=\"expandAll\" label=\"Expand All\" class=\"mr-5\" />\n          </v-col>\n        </v-row>\n      </v-row>\n\n      <!-- Header. This should mirror the structure of ControlRowHeader -->\n      <ResponsiveRowSwitch>\n        <template #status>\n          <ColumnHeader\n            text=\"Status\"\n            :sort=\"sortStatus\"\n            @input=\"set_sort('status', $event)\"\n          />\n        </template>\n\n        <template #set>\n          <ColumnHeader\n            text=\"Result Set\"\n            :sort=\"sortSet\"\n            @input=\"set_sort('set', $event)\"\n          />\n        </template>\n\n        <template #id>\n          <ColumnHeader\n            text=\"ID\"\n            :sort=\"sortId\"\n            @input=\"set_sort('id', $event)\"\n          />\n        </template>\n\n        <template #severity>\n          <ColumnHeader\n            :text=\"showImpact ? 'Impact' : 'Severity'\"\n            :sort=\"sortSeverity\"\n            @input=\"set_sort('severity', $event)\"\n          />\n        </template>\n\n        <template #title>\n          <ColumnHeader text=\"Title\" sort=\"disabled\" />\n        </template>\n\n        <template #tags>\n          <ColumnHeader text=\"800-53 Controls & CCIs\" sort=\"disabled\" />\n        </template>\n\n        <template #runTime>\n          <ColumnHeader\n            text=\"Run Time\"\n            :sort=\"sortRunTime\"\n            @input=\"set_sort('runTime', $event)\"\n          />\n        </template>\n\n        <template #viewed class=\"my-2 px-1\">\n          <ColumnHeader\n            text=\"Controls Viewed\"\n            sort=\"disabled\"\n            :viewed-header=\"true\"\n            :number-of-viewed-controls=\"viewedControlIds.length\"\n            :number-of-all-controls=\"raw_items.length\"\n          />\n        </template>\n      </ResponsiveRowSwitch>\n    </div>\n\n    <!-- Body -->\n    <v-lazy\n      v-for=\"item in items\"\n      :key=\"item.key\"\n      min-height=\"50\"\n      transition=\"fade-transition\"\n    >\n      <div :id=\"striptoChars(item.key)\">\n        <ControlRowHeader\n          :class=\"$vuetify.breakpoint.smAndDown ? '' : 'pinned-header'\"\n          :style=\"controlRowPinOffset\"\n          :control=\"item.control\"\n          :expanded=\"expanded.includes(item.key)\"\n          :show-impact=\"showImpact\"\n          :viewed-controls=\"viewedControlIds\"\n          @toggle=\"toggle(item.key)\"\n          @control-viewed=\"toggleControlViewed\"\n        />\n        <ControlRowDetails\n          v-if=\"expanded.includes(item.key)\"\n          :control=\"item.control\"\n          :tab=\"syncTabs ? syncTab : undefined\"\n          @update:tab=\"updateTab\"\n        />\n      </div>\n    </v-lazy>\n  </v-container>\n</template>\n\n<script lang=\"ts\">\nimport ControlRowDetails from '@/components/cards/controltable/ControlRowDetails.vue';\nimport ControlRowHeader, {\n  getControlRunTime\n} from '@/components/cards/controltable/ControlRowHeader.vue';\nimport ResponsiveRowSwitch from '@/components/cards/controltable/ResponsiveRowSwitch.vue';\nimport ColumnHeader, {Sort} from '@/components/generic/ColumnHeader.vue';\nimport {Filter, FilteredDataModule} from '@/store/data_filters';\nimport {HeightsModule} from '@/store/heights';\nimport {control_unique_key} from '@/utilities/format_util';\nimport {ContextualizedControl} from 'inspecjs';\nimport _ from 'lodash';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\nimport {Prop, Ref} from 'vue-property-decorator';\n\n// Tracks the visibility of an HDF control\ninterface ListElt {\n  // A unique id to be used as a key.\n  key: string;\n\n  filename: string;\n\n  // Computed values for status and severity \"value\", for sorting\n  status_val: number;\n  severity_val: number;\n\n  control: ContextualizedControl;\n}\n\n@Component({\n  components: {\n    ControlRowHeader,\n    ControlRowDetails,\n    ColumnHeader,\n    ResponsiveRowSwitch\n  }\n})\nexport default class ControlTable extends Vue {\n  @Ref('controlTableTitle') readonly controlTableTitle!: Element;\n  @Prop({type: Object, required: true}) readonly filter!: Filter;\n  @Prop({type: Boolean, required: true}) readonly showImpact!: boolean;\n\n  // Whether to allow multiple expansions\n  singleExpand = true;\n\n  // If the currently selected tab should sync\n  syncTabs = false;\n  syncTab = 'tab-test';\n\n  // List of currently expanded options. If unique id is in here, it is expanded\n  expanded: Array<string> = [];\n\n  // Sorts\n  sortId: Sort = 'none';\n  sortStatus: Sort = 'none';\n  sortSet: Sort = 'none';\n  sortSeverity: Sort = 'none';\n  sortRunTime: Sort = 'none';\n\n  // Used for viewed/unviewed controls.\n  viewedControlIds: string[] = [];\n  displayUnviewedControls = true;\n\n  toggleControlViewed(control: ContextualizedControl) {\n    const alreadyViewed = this.viewedControlIds.indexOf(control.data.id);\n    // If the control hasn't been marked as viewed yet, mark it as viewed.\n    if (alreadyViewed === -1) {\n      this.viewedControlIds.push(control.data.id);\n    }\n    // Else, remove it from the view controls array.\n    else {\n      this.viewedControlIds.splice(alreadyViewed, 1);\n    }\n  }\n\n  mounted() {\n    this.onResize();\n  }\n\n  onResize() {\n    // Allow the page to settle before checking the controlTableHeader height\n    // (this is what $nextTick is supposed to do but it's firing too quickly)\n    setTimeout(() => {\n      HeightsModule.setControlTableHeaderHeight(\n        this.controlTableTitle?.clientHeight\n      );\n    }, 2000);\n  }\n\n  /** Callback to handle setting a new sort */\n  set_sort(column: string, newSort: Sort) {\n    this.sortId = 'none';\n    this.sortSet = 'none';\n    this.sortStatus = 'none';\n    this.sortSeverity = 'none';\n    this.sortRunTime = 'none';\n    switch (column) {\n      case 'id':\n        this.sortId = newSort;\n        break;\n      case 'status':\n        this.sortStatus = newSort;\n        break;\n      case 'set':\n        this.sortSet = newSort;\n        break;\n      case 'severity':\n        this.sortSeverity = newSort;\n        break;\n      case 'runTime':\n        this.sortRunTime = newSort;\n        break;\n    }\n  }\n\n  get expandAll() {\n    return this.expanded.length === this.items.length;\n  }\n\n  set expandAll(value: boolean) {\n    if (value) {\n      this.singleExpand = false;\n      this.expanded = this.items.map((items) => items.key);\n    } else {\n      this.expanded = [];\n    }\n  }\n\n  get controlTableTitleStyle() {\n    return {top: `${HeightsModule.topbarHeight}px`};\n  }\n\n  get controlRowPinOffset() {\n    // There is ~10px of padding being added which makes the ControlRowHeader look out of place\n    return {top: `${this.topOfPage - 10}px`};\n  }\n\n  // The top of the page, relative to the topbar and the title bar\n  get topOfPage() {\n    return HeightsModule.topbarHeight + HeightsModule.controlTableHeaderHeight;\n  }\n\n  /** Closes all open controls when single-expand is re-enabled */\n  async handleToggleSingleExpand(singleExpand: boolean): Promise<void> {\n    if (singleExpand) {\n      this.expandAll = false;\n    }\n  }\n\n  async updateTab(tab: string) {\n    this.syncTab = tab;\n  }\n\n  /** Toggles the given expansion of a control details panel */\n  toggle(key: string) {\n    if (this.singleExpand) {\n      // Check if key already there\n      const had = this.expanded.includes(key);\n\n      // Clear\n      this.expanded = [];\n\n      // If key is new, add it\n      if (!had) {\n        this.expanded.push(key);\n        this.jump_to_key(key);\n      }\n    } else {\n      // Add or remove it from the set, as appropriate. Shortcut this by only adding if delete fails\n      const i = this.expanded.indexOf(key);\n      if (i < 0) {\n        this.expanded.push(key);\n        this.jump_to_key(key);\n      } else {\n        this.expanded.splice(i, 1);\n      }\n    }\n  }\n\n  jump_to_key(key: string) {\n    if (!this.$vuetify.breakpoint.smAndDown) {\n      this.$nextTick(() => {\n        this.$vuetify.goTo(`#${this.striptoChars(key)}`, {\n          offset: this.topOfPage,\n          duration: 300\n        });\n      });\n    }\n  }\n\n  striptoChars(key: string) {\n    return key.replace(/[^a-z0-9]/gi, '');\n  }\n\n  /** Return items as key, value pairs */\n  get raw_items(): ListElt[] {\n    return FilteredDataModule.controls(this.filter).map((d) => {\n      const key = control_unique_key(d);\n\n      // File, hdf wrapper\n      return {\n        key,\n        control: d,\n        status_val: [\n          'Passed',\n          'Not Applicable',\n          'No Data',\n          'Not Reviewed',\n          'Profile Error',\n          'Failed'\n        ].indexOf(d.root.hdf.status),\n        severity_val: ['none', 'low', 'medium', 'high', 'critical'].indexOf(\n          d.root.hdf.severity\n        ),\n        filename: _.get(d, 'sourcedFrom.sourcedFrom.from_file.filename')\n      };\n    });\n  }\n\n  /** Return items sorted and filters out viewed controls */\n  get items(): ListElt[] {\n    // Controls ascending/descending\n    let factor = 1;\n    // Whether or not we need to sort\n    let sort = true;\n    // Our comparator function\n    let cmp: (a: ListElt, b: ListElt) => number;\n\n    let items = this.raw_items;\n\n    if (this.sortId === 'ascending' || this.sortId === 'descending') {\n      cmp = (a: ListElt, b: ListElt) =>\n        a.control.data.id.localeCompare(b.control.data.id);\n      if (this.sortId === 'ascending') {\n        factor = -1;\n      }\n    } else if (\n      this.sortStatus === 'ascending' ||\n      this.sortStatus === 'descending'\n    ) {\n      cmp = (a: ListElt, b: ListElt) => a.status_val - b.status_val;\n      if (this.sortStatus === 'ascending') {\n        factor = -1;\n      }\n    } else if (\n      this.sortSeverity === 'ascending' ||\n      this.sortSeverity === 'descending'\n    ) {\n      cmp = (a: ListElt, b: ListElt) => a.severity_val - b.severity_val;\n      if (this.sortSeverity === 'ascending') {\n        factor = -1;\n      }\n    } else if (this.sortSet === 'ascending' || this.sortSet === 'descending') {\n      cmp = (a: ListElt, b: ListElt) => a.filename.localeCompare(b.filename);\n      if (this.sortSet === 'ascending') {\n        factor = -1;\n      }\n    } else if (\n      this.sortRunTime === 'ascending' ||\n      this.sortRunTime === 'descending'\n    ) {\n      cmp = (a: ListElt, b: ListElt) =>\n        getControlRunTime(b.control) - getControlRunTime(a.control);\n      if (this.sortRunTime === 'ascending') {\n        factor = -1;\n      }\n    } else {\n      sort = false;\n    }\n\n    // Displays only unviewed controls.\n    if (this.displayUnviewedControls) {\n      items = items.filter(\n        (val) => !this.viewedControlIds.includes(val.control.data.id)\n      );\n    }\n\n    if (sort === true) {\n      items = items.sort((a, b) => cmp(a, b) * factor);\n    }\n\n    return items;\n  }\n}\n</script>\n\n<style scoped>\n.pinned-header {\n  position: sticky;\n  z-index: 2;\n  padding-top: 2px;\n  padding-bottom: 2px;\n}\n\n.control-table-title {\n  background-color: var(--v-secondary-lighten1);\n  z-index: 10;\n}\n</style>\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/components/global/upload_tabs/aws/AuthStepBasic.vue": "<template>\n  <v-stepper-content step=\"1\">\n    <v-form v-model=\"valid\">\n      <v-text-field\n        :value=\"accessToken\"\n        label=\"User Account Access Token\"\n        lazy-validation=\"lazy\"\n        :rules=\"[reqRule]\"\n        @input=\"change_access_token\"\n      />\n      <v-text-field\n        :value=\"secretToken\"\n        label=\"User Account Secret Token\"\n        type=\"password\"\n        :rules=\"[reqRule]\"\n        @input=\"change_secret_token\"\n      />\n    </v-form>\n    <v-btn\n      color=\"primary\"\n      :disabled=\"!valid\"\n      class=\"my-2 mr-3\"\n      @click=\"$emit('auth-basic')\"\n    >\n      Basic Login\n    </v-btn>\n    <v-btn\n      color=\"green\"\n      :disabled=\"!valid\"\n      class=\"my-2 mr-3\"\n      @click=\"$emit('goto-mfa')\"\n    >\n      MFA Login\n    </v-btn>\n  </v-stepper-content>\n</template>\n\n<script lang=\"ts\">\nimport FileList from '@/components/global/upload_tabs/aws/FileList.vue';\nimport {LocalStorageVal} from '@/utilities/helper_util';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\nimport {Prop} from 'vue-property-decorator';\n\n/** Localstorage keys */\nconst localAccessToken = new LocalStorageVal<string>('aws_s3_access_token');\nconst localSecretToken = new LocalStorageVal<string>('aws_s3_secret_token');\n\n/**\n * File reader component for taking in inspec JSON data.\n * Uploads data to the store with unique IDs asynchronously as soon as data is entered.\n * Emits \"got-files\" with a list of the unique_ids of the loaded files.\n */\n@Component({\n  components: {\n    FileList\n  }\n})\nexport default class S3Reader extends Vue {\n  @Prop({type: String}) readonly accessToken!: string;\n  @Prop({type: String}) readonly secretToken!: string;\n\n  /** Models if currently displayed form is valid.\n   * Shouldn't be used to interpret literally anything else as valid - just checks fields filled\n   */\n  valid = false;\n\n  /** Form required field rules. Maybe eventually expand to other stuff */\n  reqRule = (v: string | null | undefined) =>\n    (v || '').trim().length > 0 || 'Field is Required';\n\n  // Callback for change in access token\n  change_access_token(token: string) {\n    localAccessToken.set(token);\n    this.$emit('update:accessToken', token);\n  }\n\n  // Callback for change in secret token\n  change_secret_token(token: string) {\n    localSecretToken.set(token);\n    this.$emit('update:secretToken', token);\n  }\n\n  /** On mount, try to look up stored auth info */\n  mounted() {\n    // Load our credentials\n    this.change_access_token(localAccessToken.get_default(''));\n    this.change_secret_token(localSecretToken.get_default(''));\n  }\n}\n</script>\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/components/global/upload_tabs/aws/AuthStepMFA.vue": "<template>\n  <v-stepper-content step=\"2\">\n    <v-form v-model=\"valid\">\n      <v-text-field\n        :value=\"mfaToken\"\n        label=\"MFA Token\"\n        :rules=\"[reqRule, mfaRule]\"\n        @input=\"change_mfa_token\"\n        @keyup.enter=\"proceed\"\n      />\n      <v-text-field\n        :value=\"mfaSerial\"\n        label=\"MFA Device ARN (Optional)\"\n        hint=\"Defaults to virtual IAM device\"\n        @input=\"changeMFASerial\"\n        @keyup.enter=\"proceed\"\n      />\n      <v-btn\n        color=\"primary\"\n        :disabled=\"!valid\"\n        class=\"my-2 mr-2\"\n        @click=\"$emit('auth-mfa')\"\n      >\n        Login\n      </v-btn>\n      <v-btn color=\"red\" class=\"my-2 ml-2\" @click=\"proceed\"> Cancel </v-btn>\n    </v-form>\n  </v-stepper-content>\n</template>\n\n<script lang=\"ts\">\nimport {LocalStorageVal} from '@/utilities/helper_util';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\nimport {PropSync} from 'vue-property-decorator';\n\n/** Localstorage keys */\nconst localMFASerial = new LocalStorageVal<string>('aws_s3_mfa_serial');\n\n/**\n * File reader component for taking in inspec JSON data.\n * Uploads data to the store with unique IDs asynchronously as soon as data is entered.\n * Emits \"got-files\" with a list of the unique_ids of the loaded files.\n */\n@Component\nexport default class S3Reader extends Vue {\n  @PropSync('mfaToken', {type: String}) token!: string;\n  @PropSync('mfaSerial', {type: String}) serial!: string;\n  /** Models if currently displayed form is valid.\n   * Shouldn't be used to interpret literally anything else as valid - just checks fields filled\n   */\n  valid = false;\n\n  /** Form required field rules. Maybe eventually expand to other stuff */\n  reqRule = (v: string | null | undefined) =>\n    (v || '').trim().length > 0 || 'Field is Required';\n\n  mfaRule = (v: string | null | undefined) =>\n    (v || '').trim().match('^\\\\d{6}$') !== null ||\n    'Field must be the 6 number code from a valid authenticator device';\n\n  /** On mount, try to look up stored auth info */\n  mounted() {\n    this.changeMFASerial(localMFASerial.get_default(''));\n  }\n\n  /** Handles changes to mfa serial */\n  change_mfa_token(newValue: string) {\n    this.token = newValue;\n  }\n\n  /** Handles changes to mfa token */\n  changeMFASerial(newValue: string) {\n    localMFASerial.set(newValue);\n    this.serial = newValue;\n  }\n\n  /** When button is pressed or enter is pressed */\n  proceed() {\n    this.$emit('exit-mfa');\n  }\n}\n</script>\n\n",
  "/api/sources/raw?key=test:libs/hdf-converters/src/base-converter.ts": "import {createHash} from 'crypto';\nimport * as htmlparser from 'htmlparser2';\nimport {ExecJSON} from 'inspecjs';\nimport _ from 'lodash';\n\nexport interface ILookupPath {\n  path?: string;\n  transformer?: (value: unknown) => unknown;\n  arrayTransformer?: (value: unknown[], file: unknown) => unknown[];\n  key?: string;\n}\n\nexport type ObjectEntries<T> = {[K in keyof T]: readonly [K, T[K]]}[keyof T];\n/* eslint-disable @typescript-eslint/ban-types */\nexport type MappedTransform<T, U extends ILookupPath> = {\n  [K in keyof T]: Exclude<T[K], undefined | null> extends Array<any>\n    ? MappedTransform<T[K], U>\n    : T[K] extends Function\n    ? T[K]\n    : T[K] extends object\n    ? MappedTransform<\n        T[K] &\n          (U & {\n            arrayTransformer?: (\n              value: unknown[],\n              file: Record<string, unknown>\n            ) => T[K][];\n          }),\n        U\n      >\n    : T[K] | (U & {transformer?: (value: unknown) => T[K]});\n};\nexport type MappedReform<T, U> = {\n  [K in keyof T]: Exclude<T[K], undefined | null> extends Array<any>\n    ? MappedReform<T[K], U>\n    : T[K] extends object\n    ? MappedReform<T[K] & U, U>\n    : Exclude<T[K], U>;\n};\n/* eslint-enable @typescript-eslint/ban-types */\n\n// Hashing Function\nexport function generateHash(data: string, algorithm = 'sha256'): string {\n  const hash = createHash(algorithm);\n  return hash.update(data).digest('hex');\n}\n\nexport function parseHtml(input: unknown): string {\n  const textData: string[] = [];\n  const myParser = new htmlparser.Parser({\n    ontext(text: string) {\n      textData.push(text);\n    }\n  });\n  if (typeof input === 'string') {\n    myParser.write(input);\n  }\n  return textData.join('');\n}\nexport function impactMapping(\n  mapping: Map<string, number>\n): (severity: unknown) => number {\n  return (severity: unknown): number => {\n    if (typeof severity === 'string' || typeof severity === 'number') {\n      return mapping.get(severity.toString().toLowerCase()) || 0;\n    } else {\n      return 0;\n    }\n  };\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction collapseDuplicates<T extends object>(\n  array: Array<T>,\n  key: string,\n  collapseResults: boolean\n): Array<T> {\n  const seen = new Map<string, number>();\n  const newArray: T[] = [];\n  let counter = 0;\n  array.forEach((item: T) => {\n    const propertyValue = _.get(item, key);\n    if (typeof propertyValue === 'string') {\n      const index = seen.get(propertyValue) || 0;\n      if (!seen.has(propertyValue)) {\n        newArray.push(item);\n        seen.set(propertyValue, counter);\n        counter++;\n      } else {\n        const oldResult = _.get(\n          newArray[index],\n          'results'\n        ) as ExecJSON.ControlResult[];\n        const descriptions = oldResult.map((element) =>\n          _.get(element, 'code_desc')\n        );\n        if (collapseResults) {\n          if (\n            descriptions.indexOf(\n              _.get(item, 'results[0].code_desc') as string\n            ) === -1\n          ) {\n            _.set(\n              newArray[index],\n              'results',\n              oldResult.concat(\n                _.get(item, 'results') as ExecJSON.ControlResult[]\n              )\n            );\n          }\n        } else {\n          _.set(\n            newArray[index],\n            'results',\n            oldResult.concat(_.get(item, 'results') as ExecJSON.ControlResult[])\n          );\n        }\n      }\n    }\n  });\n  return newArray;\n}\nexport class BaseConverter {\n  data: Record<string, unknown>;\n  mappings?: MappedTransform<ExecJSON.Execution, ILookupPath>;\n  collapseResults: boolean;\n\n  constructor(data: Record<string, unknown>, collapseResults = false) {\n    this.data = data;\n    this.collapseResults = collapseResults;\n  }\n  setMappings(\n    mappings: MappedTransform<ExecJSON.Execution, ILookupPath>\n  ): void {\n    this.mappings = mappings;\n  }\n  toHdf(): ExecJSON.Execution {\n    if (this.mappings === undefined) {\n      throw new Error('Mappings must be provided');\n    } else {\n      const v = this.convertInternal(this.data, this.mappings);\n      v.profiles.forEach((element) => {\n        element.sha256 = generateHash(JSON.stringify(element));\n      });\n      return v;\n    }\n  }\n\n  objectMap<T, V>(obj: T, fn: (v: ObjectEntries<T>) => V): {[K in keyof T]: V} {\n    return Object.fromEntries(\n      Object.entries(obj).map(([k, v]) => [k, fn(v)])\n    ) as Record<keyof T, V>;\n  }\n  convertInternal<T>(\n    file: Record<string, unknown>,\n    fields: T\n  ): MappedReform<T, ILookupPath> {\n    const result = this.objectMap(fields, (v: ObjectEntries<T>) =>\n      this.evaluate(file, v)\n    );\n    return result as MappedReform<T, ILookupPath>;\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  evaluate<T extends object>(\n    file: Record<string, unknown>,\n    v: Array<T> | T\n  ): T | Array<T> | MappedReform<T, ILookupPath> {\n    const transformer = _.get(v, 'transformer');\n    if (Array.isArray(v)) {\n      return this.handleArray(file, v);\n    } else if (\n      typeof v === 'string' ||\n      typeof v === 'number' ||\n      typeof v === 'boolean' ||\n      v === null\n    ) {\n      return v;\n    } else if (_.has(v, 'path')) {\n      if (typeof transformer === 'function') {\n        return transformer(this.handlePath(file, _.get(v, 'path') as string));\n      }\n      const pathVal = this.handlePath(file, _.get(v, 'path') as string);\n      if (Array.isArray(pathVal)) {\n        return pathVal as T[];\n      }\n      return pathVal as T;\n    }\n    if (typeof transformer === 'function') {\n      return transformer(file);\n    } else {\n      return this.convertInternal(file, v);\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  handleArray<T extends object>(\n    file: Record<string, unknown>,\n    v: Array<T & ILookupPath>\n  ): Array<T> {\n    if (v.length === 0) {\n      return [];\n    }\n    if (v[0].path === undefined) {\n      const arrayTransformer = v[0].arrayTransformer;\n      v = v.map((element) => {\n        return _.omit(element, ['arrayTransformer']) as T & ILookupPath;\n      });\n      let output: Array<T> = [];\n      v.forEach((element) => {\n        output.push(this.evaluate(file, element) as T);\n      });\n      if (arrayTransformer !== undefined) {\n        output = arrayTransformer(output, this.data) as T[];\n      }\n      return output;\n    } else {\n      const path = v[0].path;\n      const key = v[0].key;\n      const arrayTransformer = v[0].arrayTransformer;\n      const transformer = v[0].transformer;\n      if (this.hasPath(file, path)) {\n        const pathVal = this.handlePath(file, path);\n        if (Array.isArray(pathVal)) {\n          v = pathVal.map((element: Record<string, unknown>) => {\n            return _.omit(this.convertInternal(element, v[0]), [\n              'path',\n              'transformer',\n              'arrayTransformer',\n              'key'\n            ]) as T;\n          });\n          if (key !== undefined) {\n            v = collapseDuplicates(v, key, this.collapseResults);\n          }\n          if (arrayTransformer !== undefined) {\n            v = arrayTransformer(v, this.data) as T[];\n          }\n          return v;\n        } else {\n          if (transformer !== undefined) {\n            return [transformer(this.handlePath(file, path)) as T];\n          } else {\n            return [this.handlePath(file, path) as T];\n          }\n        }\n      } else {\n        return [];\n      }\n    }\n  }\n  handlePath(file: Record<string, unknown>, path: string): unknown {\n    if (path.startsWith('$.')) {\n      return _.get(this.data, path.slice(2)) || '';\n    } else {\n      return _.get(file, path) || '';\n    }\n  }\n  hasPath(file: Record<string, unknown>, path: string): boolean {\n    if (path.startsWith('$.')) {\n      return _.has(this.data, path.slice(2));\n    } else {\n      return _.has(file, path);\n    }\n  }\n}\n\n",
  "/api/sources/raw?key=test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts": "// To parse this data:\n//\n//   import { Convert, ExecJSON } from \"./file\";\n//\n//   const execJSON = Convert.toExecJSON(json);\n//\n// These functions will throw an error if the JSON doesn't\n// match the expected interface, even if the JSON is valid.\n\nexport interface ExecJSON {\n    platform:   Platform;\n    profiles:   ExecJSONProfile[];\n    statistics: Statistics;\n    version:    string;\n}\n\nexport interface Platform {\n    /**\n     * The name of the platform this was run on.\n     */\n    name: string;\n    /**\n     * The version of the platform this was run on.\n     */\n    release:    string;\n    target_id?: null | string;\n}\n\nexport interface ExecJSONProfile {\n    attributes:       { [key: string]: any }[];\n    controls:         ExecJSONControl[];\n    copyright?:       null | string;\n    copyright_email?: null | string;\n    depends?:         Dependency[] | null;\n    description?:     null | string;\n    groups:           ControlGroup[];\n    inspec_version?:  null | string;\n    license?:         null | string;\n    maintainer?:      null | string;\n    name:             string;\n    parent_profile?:  null | string;\n    sha256:           string;\n    skip_message?:    null | string;\n    status?:          null | string;\n    status_message?:  null | string;\n    summary?:         null | string;\n    supports:         SupportedPlatform[];\n    title?:           null | string;\n    version?:         null | string;\n}\n\nexport interface ExecJSONControl {\n    /**\n     * The raw source code of the control. Note that if this is an overlay control, it does not\n     * include the underlying source code\n     */\n    code?:         null | string;\n    desc?:         null | string;\n    descriptions?: ControlDescription[] | null;\n    /**\n     * The ID of this control\n     */\n    id:     string;\n    impact: number;\n    refs:   Reference[];\n    /**\n     * A list of all results of the controls describe blocks.\n     *\n     * For instance, if in the controls code we had the following:\n     * describe sshd_config do\n     * its('Port') { should cmp 22 }\n     * end\n     * The result of this block as a ControlResult would be appended to the results list.\n     */\n    results:         ControlResult[];\n    source_location: SourceLocation;\n    tags:            { [key: string]: any };\n    title?:          null | string;\n    waiver_data?:    null | WaiverData;\n}\n\nexport interface ControlDescription {\n    data:  string;\n    label: string;\n}\n\nexport interface Reference {\n    ref?: { [key: string]: any }[] | string;\n    url?: string;\n    uri?: string;\n}\n\nexport interface ControlResult {\n    backtrace?:    string[] | null;\n    code_desc:     string;\n    exception?:    null | string;\n    message?:      null | string;\n    resource?:     null | string;\n    run_time?:     number | null;\n    skip_message?: null | string;\n    start_time:    string;\n    status?:       ControlResultStatus | null;\n}\n\nexport enum ControlResultStatus {\n    Error = \"error\",\n    Failed = \"failed\",\n    Passed = \"passed\",\n    Skipped = \"skipped\",\n}\n\nexport interface SourceLocation {\n    /**\n     * The line at which this statement is located in the file\n     */\n    line?: number | null;\n    /**\n     * Path to the file that this statement originates from\n     */\n    ref?: null | string;\n}\n\nexport interface WaiverData {\n    expiration_date?:       null | string;\n    justification?:         null | string;\n    message?:               null | string;\n    run?:                   boolean | null;\n    skipped_due_to_waiver?: boolean | null | string;\n}\n\nexport interface Dependency {\n    branch?:         null | string;\n    compliance?:     null | string;\n    git?:            null | string;\n    name?:           null | string;\n    path?:           null | string;\n    status?:         null | string;\n    status_message?: null | string;\n    supermarket?:    null | string;\n    url?:            null | string;\n}\n\nexport interface ControlGroup {\n    /**\n     * The control IDs in this group\n     */\n    controls: string[];\n    /**\n     * The unique identifier of the group\n     */\n    id: string;\n    /**\n     * The name of the group\n     */\n    title?: null | string;\n}\n\nexport interface SupportedPlatform {\n    \"os-family\"?:       null | string;\n    \"os-name\"?:         null | string;\n    platform?:          null | string;\n    \"platform-family\"?: null | string;\n    \"platform-name\"?:   null | string;\n    release?:           null | string;\n}\n\nexport interface Statistics {\n    controls?: null | StatisticHash;\n    /**\n     * How long (in seconds) this inspec exec ran for.\n     */\n    duration?: number | null;\n}\n\n/**\n * Breakdowns of control statistics by result\n */\nexport interface StatisticHash {\n    failed?:  null | StatisticBlock;\n    passed?:  null | StatisticBlock;\n    skipped?: null | StatisticBlock;\n}\n\nexport interface StatisticBlock {\n    /**\n     * Total number of controls (in this category) for this inspec execution.\n     */\n    total: number;\n}\n\n// Converts JSON strings to/from your types\n// and asserts the results of JSON.parse at runtime\nexport class Convert {\n    public static toExecJSON(json: string): ExecJSON {\n        return cast(JSON.parse(json), r(\"ExecJSON\"));\n    }\n\n    public static execJSONToJson(value: ExecJSON): string {\n        return JSON.stringify(uncast(value, r(\"ExecJSON\")), null, 2);\n    }\n}\n\nfunction invalidValue(typ: any, val: any, key: any = ''): never {\n    if (key) {\n        throw Error(`Invalid value for key \"${key}\". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);\n    }\n    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );\n}\n\nfunction jsonToJSProps(typ: any): any {\n    if (typ.jsonToJS === undefined) {\n        const map: any = {};\n        typ.props.forEach((p: any) => map[p.json] = { key: p.js, typ: p.typ });\n        typ.jsonToJS = map;\n    }\n    return typ.jsonToJS;\n}\n\nfunction jsToJSONProps(typ: any): any {\n    if (typ.jsToJSON === undefined) {\n        const map: any = {};\n        typ.props.forEach((p: any) => map[p.js] = { key: p.json, typ: p.typ });\n        typ.jsToJSON = map;\n    }\n    return typ.jsToJSON;\n}\n\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }\n\n    function transformUnion(typs: any[], val: any): any {\n        // val must validate against one typ in typs\n        const l = typs.length;\n        for (let i = 0; i < l; i++) {\n            const typ = typs[i];\n            try {\n                return transform(val, typ, getProps);\n            } catch (_) {}\n        }\n        return invalidValue(typs, val);\n    }\n\n    function transformEnum(cases: string[], val: any): any {\n        if (cases.indexOf(val) !== -1) return val;\n        return invalidValue(cases, val);\n    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));\n    }\n\n    function transformDate(val: any): any {\n        if (val === null) {\n            return null;\n        }\n        const d = new Date(val);\n        if (isNaN(d.valueOf())) {\n            return invalidValue(\"Date\", val);\n        }\n        return d;\n    }\n\n    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {\n        if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n            return invalidValue(\"object\", val);\n        }\n        const result: any = {};\n        Object.getOwnPropertyNames(props).forEach(key => {\n            const prop = props[key];\n            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;\n            result[prop.key] = transform(v, prop.typ, getProps, prop.key);\n        });\n        Object.getOwnPropertyNames(val).forEach(key => {\n            if (!Object.prototype.hasOwnProperty.call(props, key)) {\n                result[key] = transform(val[key], additional, getProps, key);\n            }\n        });\n        return result;\n    }\n\n    if (typ === \"any\") return val;\n    if (typ === null) {\n        if (val === null) return val;\n        return invalidValue(typ, val);\n    }\n    if (typ === false) return invalidValue(typ, val);\n    while (typeof typ === \"object\" && typ.ref !== undefined) {\n        typ = typeMap[typ.ref];\n    }\n    if (Array.isArray(typ)) return transformEnum(typ, val);\n    if (typeof typ === \"object\") {\n        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);\n    return transformPrimitive(typ, val);\n}\n\nfunction cast<T>(val: any, typ: any): T {\n    return transform(val, typ, jsonToJSProps);\n}\n\nfunction uncast<T>(val: T, typ: any): any {\n    return transform(val, typ, jsToJSONProps);\n}\n\nfunction a(typ: any) {\n    return { arrayItems: typ };\n}\n\nfunction u(...typs: any[]) {\n    return { unionMembers: typs };\n}\n\nfunction o(props: any[], additional: any) {\n    return { props, additional };\n}\n\nfunction m(additional: any) {\n    return { props: [], additional };\n}\n\nfunction r(name: string) {\n    return { ref: name };\n}\n\nconst typeMap: any = {\n    \"ExecJSON\": o([\n        { json: \"platform\", js: \"platform\", typ: r(\"Platform\") },\n        { json: \"profiles\", js: \"profiles\", typ: a(r(\"ExecJSONProfile\")) },\n        { json: \"statistics\", js: \"statistics\", typ: r(\"Statistics\") },\n        { json: \"version\", js: \"version\", typ: \"\" },\n    ], \"any\"),\n    \"Platform\": o([\n        { json: \"name\", js: \"name\", typ: \"\" },\n        { json: \"release\", js: \"release\", typ: \"\" },\n        { json: \"target_id\", js: \"target_id\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"ExecJSONProfile\": o([\n        { json: \"attributes\", js: \"attributes\", typ: a(m(\"any\")) },\n        { json: \"controls\", js: \"controls\", typ: a(r(\"ExecJSONControl\")) },\n        { json: \"copyright\", js: \"copyright\", typ: u(undefined, u(null, \"\")) },\n        { json: \"copyright_email\", js: \"copyright_email\", typ: u(undefined, u(null, \"\")) },\n        { json: \"depends\", js: \"depends\", typ: u(undefined, u(a(r(\"Dependency\")), null)) },\n        { json: \"description\", js: \"description\", typ: u(undefined, u(null, \"\")) },\n        { json: \"groups\", js: \"groups\", typ: a(r(\"ControlGroup\")) },\n        { json: \"inspec_version\", js: \"inspec_version\", typ: u(undefined, u(null, \"\")) },\n        { json: \"license\", js: \"license\", typ: u(undefined, u(null, \"\")) },\n        { json: \"maintainer\", js: \"maintainer\", typ: u(undefined, u(null, \"\")) },\n        { json: \"name\", js: \"name\", typ: \"\" },\n        { json: \"parent_profile\", js: \"parent_profile\", typ: u(undefined, u(null, \"\")) },\n        { json: \"sha256\", js: \"sha256\", typ: \"\" },\n        { json: \"skip_message\", js: \"skip_message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"status\", js: \"status\", typ: u(undefined, u(null, \"\")) },\n        { json: \"status_message\", js: \"status_message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"summary\", js: \"summary\", typ: u(undefined, u(null, \"\")) },\n        { json: \"supports\", js: \"supports\", typ: a(r(\"SupportedPlatform\")) },\n        { json: \"title\", js: \"title\", typ: u(undefined, u(null, \"\")) },\n        { json: \"version\", js: \"version\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"ExecJSONControl\": o([\n        { json: \"code\", js: \"code\", typ: u(undefined, u(null, \"\")) },\n        { json: \"desc\", js: \"desc\", typ: u(undefined, u(null, \"\")) },\n        { json: \"descriptions\", js: \"descriptions\", typ: u(undefined, u(a(r(\"ControlDescription\")), null)) },\n        { json: \"id\", js: \"id\", typ: \"\" },\n        { json: \"impact\", js: \"impact\", typ: 3.14 },\n        { json: \"refs\", js: \"refs\", typ: a(r(\"Reference\")) },\n        { json: \"results\", js: \"results\", typ: a(r(\"ControlResult\")) },\n        { json: \"source_location\", js: \"source_location\", typ: r(\"SourceLocation\") },\n        { json: \"tags\", js: \"tags\", typ: m(\"any\") },\n        { json: \"title\", js: \"title\", typ: u(undefined, u(null, \"\")) },\n        { json: \"waiver_data\", js: \"waiver_data\", typ: u(undefined, u(null, r(\"WaiverData\"))) },\n    ], \"any\"),\n    \"ControlDescription\": o([\n        { json: \"data\", js: \"data\", typ: \"\" },\n        { json: \"label\", js: \"label\", typ: \"\" },\n    ], \"any\"),\n    \"Reference\": o([\n        { json: \"ref\", js: \"ref\", typ: u(undefined, u(a(m(\"any\")), \"\")) },\n        { json: \"url\", js: \"url\", typ: u(undefined, \"\") },\n        { json: \"uri\", js: \"uri\", typ: u(undefined, \"\") },\n    ], \"any\"),\n    \"ControlResult\": o([\n        { json: \"backtrace\", js: \"backtrace\", typ: u(undefined, u(a(\"\"), null)) },\n        { json: \"code_desc\", js: \"code_desc\", typ: \"\" },\n        { json: \"exception\", js: \"exception\", typ: u(undefined, u(null, \"\")) },\n        { json: \"message\", js: \"message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"resource\", js: \"resource\", typ: u(undefined, u(null, \"\")) },\n        { json: \"run_time\", js: \"run_time\", typ: u(undefined, u(3.14, null)) },\n        { json: \"skip_message\", js: \"skip_message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"start_time\", js: \"start_time\", typ: \"\" },\n        { json: \"status\", js: \"status\", typ: u(undefined, u(r(\"ControlResultStatus\"), null)) },\n    ], \"any\"),\n    \"SourceLocation\": o([\n        { json: \"line\", js: \"line\", typ: u(undefined, u(3.14, null)) },\n        { json: \"ref\", js: \"ref\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"WaiverData\": o([\n        { json: \"expiration_date\", js: \"expiration_date\", typ: u(undefined, u(null, \"\")) },\n        { json: \"justification\", js: \"justification\", typ: u(undefined, u(null, \"\")) },\n        { json: \"message\", js: \"message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"run\", js: \"run\", typ: u(undefined, u(true, null)) },\n        { json: \"skipped_due_to_waiver\", js: \"skipped_due_to_waiver\", typ: u(undefined, u(true, null, \"\")) },\n    ], \"any\"),\n    \"Dependency\": o([\n        { json: \"branch\", js: \"branch\", typ: u(undefined, u(null, \"\")) },\n        { json: \"compliance\", js: \"compliance\", typ: u(undefined, u(null, \"\")) },\n        { json: \"git\", js: \"git\", typ: u(undefined, u(null, \"\")) },\n        { json: \"name\", js: \"name\", typ: u(undefined, u(null, \"\")) },\n        { json: \"path\", js: \"path\", typ: u(undefined, u(null, \"\")) },\n        { json: \"status\", js: \"status\", typ: u(undefined, u(null, \"\")) },\n        { json: \"status_message\", js: \"status_message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"supermarket\", js: \"supermarket\", typ: u(undefined, u(null, \"\")) },\n        { json: \"url\", js: \"url\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"ControlGroup\": o([\n        { json: \"controls\", js: \"controls\", typ: a(\"\") },\n        { json: \"id\", js: \"id\", typ: \"\" },\n        { json: \"title\", js: \"title\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"SupportedPlatform\": o([\n        { json: \"os-family\", js: \"os-family\", typ: u(undefined, u(null, \"\")) },\n        { json: \"os-name\", js: \"os-name\", typ: u(undefined, u(null, \"\")) },\n        { json: \"platform\", js: \"platform\", typ: u(undefined, u(null, \"\")) },\n        { json: \"platform-family\", js: \"platform-family\", typ: u(undefined, u(null, \"\")) },\n        { json: \"platform-name\", js: \"platform-name\", typ: u(undefined, u(null, \"\")) },\n        { json: \"release\", js: \"release\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"Statistics\": o([\n        { json: \"controls\", js: \"controls\", typ: u(undefined, u(null, r(\"StatisticHash\"))) },\n        { json: \"duration\", js: \"duration\", typ: u(undefined, u(3.14, null)) },\n    ], \"any\"),\n    \"StatisticHash\": o([\n        { json: \"failed\", js: \"failed\", typ: u(undefined, u(null, r(\"StatisticBlock\"))) },\n        { json: \"passed\", js: \"passed\", typ: u(undefined, u(null, r(\"StatisticBlock\"))) },\n        { json: \"skipped\", js: \"skipped\", typ: u(undefined, u(null, r(\"StatisticBlock\"))) },\n    ], \"any\"),\n    \"StatisticBlock\": o([\n        { json: \"total\", js: \"total\", typ: 3.14 },\n    ], \"any\"),\n    \"ControlResultStatus\": [\n        \"error\",\n        \"failed\",\n        \"passed\",\n        \"skipped\",\n    ],\n};\n\n",
  "/api/sources/raw?key=test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts": "// To parse this data:\n//\n//   import { Convert, ExecJsonmin } from \"./file\";\n//\n//   const execJsonmin = Convert.toExecJsonmin(json);\n//\n// These functions will throw an error if the JSON doesn't\n// match the expected interface, even if the JSON is valid.\n\nexport interface ExecJsonmin {\n    controls:   ExecJSONMINControl[];\n    statistics: Statistics;\n    version:    string;\n}\n\nexport interface ExecJSONMINControl {\n    backtrace?:     string[] | null;\n    code_desc:      string;\n    exception?:     null | string;\n    id:             string;\n    message?:       null | string;\n    profile_id?:    null | string;\n    profile_sha256: string;\n    resource?:      null | string;\n    skip_message?:  null | string;\n    status:         string;\n}\n\nexport interface Statistics {\n    controls?: null | StatisticHash;\n    /**\n     * How long (in seconds) this inspec exec ran for.\n     */\n    duration: number;\n}\n\n/**\n * Breakdowns of control statistics by result\n */\nexport interface StatisticHash {\n    failed?:  null | StatisticBlock;\n    passed?:  null | StatisticBlock;\n    skipped?: null | StatisticBlock;\n}\n\nexport interface StatisticBlock {\n    /**\n     * Total number of controls (in this category) for this inspec execution.\n     */\n    total: number;\n}\n\n// Converts JSON strings to/from your types\n// and asserts the results of JSON.parse at runtime\nexport class Convert {\n    public static toExecJsonmin(json: string): ExecJsonmin {\n        return cast(JSON.parse(json), r(\"ExecJsonmin\"));\n    }\n\n    public static execJsonminToJson(value: ExecJsonmin): string {\n        return JSON.stringify(uncast(value, r(\"ExecJsonmin\")), null, 2);\n    }\n}\n\nfunction invalidValue(typ: any, val: any, key: any = ''): never {\n    if (key) {\n        throw Error(`Invalid value for key \"${key}\". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);\n    }\n    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );\n}\n\nfunction jsonToJSProps(typ: any): any {\n    if (typ.jsonToJS === undefined) {\n        const map: any = {};\n        typ.props.forEach((p: any) => map[p.json] = { key: p.js, typ: p.typ });\n        typ.jsonToJS = map;\n    }\n    return typ.jsonToJS;\n}\n\nfunction jsToJSONProps(typ: any): any {\n    if (typ.jsToJSON === undefined) {\n        const map: any = {};\n        typ.props.forEach((p: any) => map[p.js] = { key: p.json, typ: p.typ });\n        typ.jsToJSON = map;\n    }\n    return typ.jsToJSON;\n}\n\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }\n\n    function transformUnion(typs: any[], val: any): any {\n        // val must validate against one typ in typs\n        const l = typs.length;\n        for (let i = 0; i < l; i++) {\n            const typ = typs[i];\n            try {\n                return transform(val, typ, getProps);\n            } catch (_) {}\n        }\n        return invalidValue(typs, val);\n    }\n\n    function transformEnum(cases: string[], val: any): any {\n        if (cases.indexOf(val) !== -1) return val;\n        return invalidValue(cases, val);\n    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));\n    }\n\n    function transformDate(val: any): any {\n        if (val === null) {\n            return null;\n        }\n        const d = new Date(val);\n        if (isNaN(d.valueOf())) {\n            return invalidValue(\"Date\", val);\n        }\n        return d;\n    }\n\n    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {\n        if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n            return invalidValue(\"object\", val);\n        }\n        const result: any = {};\n        Object.getOwnPropertyNames(props).forEach(key => {\n            const prop = props[key];\n            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;\n            result[prop.key] = transform(v, prop.typ, getProps, prop.key);\n        });\n        Object.getOwnPropertyNames(val).forEach(key => {\n            if (!Object.prototype.hasOwnProperty.call(props, key)) {\n                result[key] = transform(val[key], additional, getProps, key);\n            }\n        });\n        return result;\n    }\n\n    if (typ === \"any\") return val;\n    if (typ === null) {\n        if (val === null) return val;\n        return invalidValue(typ, val);\n    }\n    if (typ === false) return invalidValue(typ, val);\n    while (typeof typ === \"object\" && typ.ref !== undefined) {\n        typ = typeMap[typ.ref];\n    }\n    if (Array.isArray(typ)) return transformEnum(typ, val);\n    if (typeof typ === \"object\") {\n        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);\n    return transformPrimitive(typ, val);\n}\n\nfunction cast<T>(val: any, typ: any): T {\n    return transform(val, typ, jsonToJSProps);\n}\n\nfunction uncast<T>(val: T, typ: any): any {\n    return transform(val, typ, jsToJSONProps);\n}\n\nfunction a(typ: any) {\n    return { arrayItems: typ };\n}\n\nfunction u(...typs: any[]) {\n    return { unionMembers: typs };\n}\n\nfunction o(props: any[], additional: any) {\n    return { props, additional };\n}\n\nfunction m(additional: any) {\n    return { props: [], additional };\n}\n\nfunction r(name: string) {\n    return { ref: name };\n}\n\nconst typeMap: any = {\n    \"ExecJsonmin\": o([\n        { json: \"controls\", js: \"controls\", typ: a(r(\"ExecJSONMINControl\")) },\n        { json: \"statistics\", js: \"statistics\", typ: r(\"Statistics\") },\n        { json: \"version\", js: \"version\", typ: \"\" },\n    ], \"any\"),\n    \"ExecJSONMINControl\": o([\n        { json: \"backtrace\", js: \"backtrace\", typ: u(undefined, u(a(\"\"), null)) },\n        { json: \"code_desc\", js: \"code_desc\", typ: \"\" },\n        { json: \"exception\", js: \"exception\", typ: u(undefined, u(null, \"\")) },\n        { json: \"id\", js: \"id\", typ: \"\" },\n        { json: \"message\", js: \"message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"profile_id\", js: \"profile_id\", typ: u(undefined, u(null, \"\")) },\n        { json: \"profile_sha256\", js: \"profile_sha256\", typ: \"\" },\n        { json: \"resource\", js: \"resource\", typ: u(undefined, u(null, \"\")) },\n        { json: \"skip_message\", js: \"skip_message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"status\", js: \"status\", typ: \"\" },\n    ], \"any\"),\n    \"Statistics\": o([\n        { json: \"controls\", js: \"controls\", typ: u(undefined, u(null, r(\"StatisticHash\"))) },\n        { json: \"duration\", js: \"duration\", typ: 3.14 },\n    ], \"any\"),\n    \"StatisticHash\": o([\n        { json: \"failed\", js: \"failed\", typ: u(undefined, u(null, r(\"StatisticBlock\"))) },\n        { json: \"passed\", js: \"passed\", typ: u(undefined, u(null, r(\"StatisticBlock\"))) },\n        { json: \"skipped\", js: \"skipped\", typ: u(undefined, u(null, r(\"StatisticBlock\"))) },\n    ], \"any\"),\n    \"StatisticBlock\": o([\n        { json: \"total\", js: \"total\", typ: 3.14 },\n    ], \"any\"),\n};\n\n",
  "/api/sources/raw?key=test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts": "// To parse this data:\n//\n//   import { Convert, ProfileJSON } from \"./file\";\n//\n//   const profileJSON = Convert.toProfileJSON(json);\n//\n// These functions will throw an error if the JSON doesn't\n// match the expected interface, even if the JSON is valid.\n\nexport interface ProfileJSON {\n    controls:         ProfileJSONControl[];\n    copyright?:       null | string;\n    copyright_email?: null | string;\n    depends?:         Dependency[] | null;\n    generator?:       null | Generator;\n    groups:           ControlGroup[];\n    inputs?:          { [key: string]: any }[] | null;\n    maintainer?:      null | string;\n    name:             string;\n    sha256:           string;\n    status?:          null | string;\n    supports:         SupportedPlatform[];\n    title?:           null | string;\n    version?:         null | string;\n}\n\nexport interface ProfileJSONControl {\n    /**\n     * The raw source code of the control. Note that if this is an overlay control, it does not\n     * include the underlying source code\n     */\n    code:          string;\n    desc?:         null | string;\n    descriptions?: { [key: string]: any } | null;\n    /**\n     * The ID of this control\n     */\n    id:               string;\n    impact:           number;\n    refs?:            Reference[] | null;\n    source_location?: null | SourceLocation;\n    tags:             { [key: string]: any };\n    title?:           null | string;\n}\n\nexport interface Reference {\n    ref?: { [key: string]: any }[] | string;\n    url?: string;\n    uri?: string;\n}\n\nexport interface SourceLocation {\n    /**\n     * The line at which this statement is located in the file\n     */\n    line?: number | null;\n    /**\n     * Path to the file that this statement originates from\n     */\n    ref?: null | string;\n}\n\nexport interface Dependency {\n    branch?:         null | string;\n    compliance?:     null | string;\n    git?:            null | string;\n    name?:           null | string;\n    path?:           null | string;\n    status?:         null | string;\n    status_message?: null | string;\n    supermarket?:    null | string;\n    url?:            null | string;\n}\n\nexport interface Generator {\n    /**\n     * The name of the software that generated this report.\n     */\n    name: string;\n    /**\n     * The version of the software that generated this report.\n     */\n    version: string;\n}\n\nexport interface ControlGroup {\n    /**\n     * The control IDs in this group\n     */\n    controls: string[];\n    /**\n     * The unique identifier of the group\n     */\n    id: string;\n    /**\n     * The name of the group\n     */\n    title?: null | string;\n}\n\nexport interface SupportedPlatform {\n    \"os-family\"?:       null | string;\n    \"os-name\"?:         null | string;\n    platform?:          null | string;\n    \"platform-family\"?: null | string;\n    \"platform-name\"?:   null | string;\n    release?:           null | string;\n}\n\n// Converts JSON strings to/from your types\n// and asserts the results of JSON.parse at runtime\nexport class Convert {\n    public static toProfileJSON(json: string): ProfileJSON {\n        return cast(JSON.parse(json), r(\"ProfileJSON\"));\n    }\n\n    public static profileJSONToJson(value: ProfileJSON): string {\n        return JSON.stringify(uncast(value, r(\"ProfileJSON\")), null, 2);\n    }\n}\n\nfunction invalidValue(typ: any, val: any, key: any = ''): never {\n    if (key) {\n        throw Error(`Invalid value for key \"${key}\". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);\n    }\n    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );\n}\n\nfunction jsonToJSProps(typ: any): any {\n    if (typ.jsonToJS === undefined) {\n        const map: any = {};\n        typ.props.forEach((p: any) => map[p.json] = { key: p.js, typ: p.typ });\n        typ.jsonToJS = map;\n    }\n    return typ.jsonToJS;\n}\n\nfunction jsToJSONProps(typ: any): any {\n    if (typ.jsToJSON === undefined) {\n        const map: any = {};\n        typ.props.forEach((p: any) => map[p.js] = { key: p.json, typ: p.typ });\n        typ.jsToJSON = map;\n    }\n    return typ.jsToJSON;\n}\n\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }\n\n    function transformUnion(typs: any[], val: any): any {\n        // val must validate against one typ in typs\n        const l = typs.length;\n        for (let i = 0; i < l; i++) {\n            const typ = typs[i];\n            try {\n                return transform(val, typ, getProps);\n            } catch (_) {}\n        }\n        return invalidValue(typs, val);\n    }\n\n    function transformEnum(cases: string[], val: any): any {\n        if (cases.indexOf(val) !== -1) return val;\n        return invalidValue(cases, val);\n    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));\n    }\n\n    function transformDate(val: any): any {\n        if (val === null) {\n            return null;\n        }\n        const d = new Date(val);\n        if (isNaN(d.valueOf())) {\n            return invalidValue(\"Date\", val);\n        }\n        return d;\n    }\n\n    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {\n        if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n            return invalidValue(\"object\", val);\n        }\n        const result: any = {};\n        Object.getOwnPropertyNames(props).forEach(key => {\n            const prop = props[key];\n            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;\n            result[prop.key] = transform(v, prop.typ, getProps, prop.key);\n        });\n        Object.getOwnPropertyNames(val).forEach(key => {\n            if (!Object.prototype.hasOwnProperty.call(props, key)) {\n                result[key] = transform(val[key], additional, getProps, key);\n            }\n        });\n        return result;\n    }\n\n    if (typ === \"any\") return val;\n    if (typ === null) {\n        if (val === null) return val;\n        return invalidValue(typ, val);\n    }\n    if (typ === false) return invalidValue(typ, val);\n    while (typeof typ === \"object\" && typ.ref !== undefined) {\n        typ = typeMap[typ.ref];\n    }\n    if (Array.isArray(typ)) return transformEnum(typ, val);\n    if (typeof typ === \"object\") {\n        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);\n    return transformPrimitive(typ, val);\n}\n\nfunction cast<T>(val: any, typ: any): T {\n    return transform(val, typ, jsonToJSProps);\n}\n\nfunction uncast<T>(val: T, typ: any): any {\n    return transform(val, typ, jsToJSONProps);\n}\n\nfunction a(typ: any) {\n    return { arrayItems: typ };\n}\n\nfunction u(...typs: any[]) {\n    return { unionMembers: typs };\n}\n\nfunction o(props: any[], additional: any) {\n    return { props, additional };\n}\n\nfunction m(additional: any) {\n    return { props: [], additional };\n}\n\nfunction r(name: string) {\n    return { ref: name };\n}\n\nconst typeMap: any = {\n    \"ProfileJSON\": o([\n        { json: \"controls\", js: \"controls\", typ: a(r(\"ProfileJSONControl\")) },\n        { json: \"copyright\", js: \"copyright\", typ: u(undefined, u(null, \"\")) },\n        { json: \"copyright_email\", js: \"copyright_email\", typ: u(undefined, u(null, \"\")) },\n        { json: \"depends\", js: \"depends\", typ: u(undefined, u(a(r(\"Dependency\")), null)) },\n        { json: \"generator\", js: \"generator\", typ: u(undefined, u(null, r(\"Generator\"))) },\n        { json: \"groups\", js: \"groups\", typ: a(r(\"ControlGroup\")) },\n        { json: \"inputs\", js: \"inputs\", typ: u(undefined, u(a(m(\"any\")), null)) },\n        { json: \"maintainer\", js: \"maintainer\", typ: u(undefined, u(null, \"\")) },\n        { json: \"name\", js: \"name\", typ: \"\" },\n        { json: \"sha256\", js: \"sha256\", typ: \"\" },\n        { json: \"status\", js: \"status\", typ: u(undefined, u(null, \"\")) },\n        { json: \"supports\", js: \"supports\", typ: a(r(\"SupportedPlatform\")) },\n        { json: \"title\", js: \"title\", typ: u(undefined, u(null, \"\")) },\n        { json: \"version\", js: \"version\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"ProfileJSONControl\": o([\n        { json: \"code\", js: \"code\", typ: \"\" },\n        { json: \"desc\", js: \"desc\", typ: u(undefined, u(null, \"\")) },\n        { json: \"descriptions\", js: \"descriptions\", typ: u(undefined, u(m(\"any\"), null)) },\n        { json: \"id\", js: \"id\", typ: \"\" },\n        { json: \"impact\", js: \"impact\", typ: 3.14 },\n        { json: \"refs\", js: \"refs\", typ: u(undefined, u(a(r(\"Reference\")), null)) },\n        { json: \"source_location\", js: \"source_location\", typ: u(undefined, u(null, r(\"SourceLocation\"))) },\n        { json: \"tags\", js: \"tags\", typ: m(\"any\") },\n        { json: \"title\", js: \"title\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"Reference\": o([\n        { json: \"ref\", js: \"ref\", typ: u(undefined, u(a(m(\"any\")), \"\")) },\n        { json: \"url\", js: \"url\", typ: u(undefined, \"\") },\n        { json: \"uri\", js: \"uri\", typ: u(undefined, \"\") },\n    ], \"any\"),\n    \"SourceLocation\": o([\n        { json: \"line\", js: \"line\", typ: u(undefined, u(3.14, null)) },\n        { json: \"ref\", js: \"ref\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"Dependency\": o([\n        { json: \"branch\", js: \"branch\", typ: u(undefined, u(null, \"\")) },\n        { json: \"compliance\", js: \"compliance\", typ: u(undefined, u(null, \"\")) },\n        { json: \"git\", js: \"git\", typ: u(undefined, u(null, \"\")) },\n        { json: \"name\", js: \"name\", typ: u(undefined, u(null, \"\")) },\n        { json: \"path\", js: \"path\", typ: u(undefined, u(null, \"\")) },\n        { json: \"status\", js: \"status\", typ: u(undefined, u(null, \"\")) },\n        { json: \"status_message\", js: \"status_message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"supermarket\", js: \"supermarket\", typ: u(undefined, u(null, \"\")) },\n        { json: \"url\", js: \"url\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"Generator\": o([\n        { json: \"name\", js: \"name\", typ: \"\" },\n        { json: \"version\", js: \"version\", typ: \"\" },\n    ], \"any\"),\n    \"ControlGroup\": o([\n        { json: \"controls\", js: \"controls\", typ: a(\"\") },\n        { json: \"id\", js: \"id\", typ: \"\" },\n        { json: \"title\", js: \"title\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"SupportedPlatform\": o([\n        { json: \"os-family\", js: \"os-family\", typ: u(undefined, u(null, \"\")) },\n        { json: \"os-name\", js: \"os-name\", typ: u(undefined, u(null, \"\")) },\n        { json: \"platform\", js: \"platform\", typ: u(undefined, u(null, \"\")) },\n        { json: \"platform-family\", js: \"platform-family\", typ: u(undefined, u(null, \"\")) },\n        { json: \"platform-name\", js: \"platform-name\", typ: u(undefined, u(null, \"\")) },\n        { json: \"release\", js: \"release\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n};\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/components/cards/treemap/Treemap.vue": "<template>\n  <v-container ref=\"treemapContainer\" fluid>\n    <v-row dense>\n      <v-col :cols=\"4\">\n        NIST SP 800-53 Security and Privacy Control Coverage\n      </v-col>\n      <v-col :cols=\"8\">\n        <v-btn :disabled=\"!allow_up\" block x-small @click=\"up\">\n          <v-icon v-if=\"allow_up\"> mdi-arrow-left </v-icon>\n          {{ 'NIST-SP-800-53 -> ' + value.join(' -> ') }}\n        </v-btn>\n      </v-col>\n    </v-row>\n    <v-row>\n      <v-col v-resize=\"on_resize\" :cols=\"12\">\n        <svg id=\"chartBody\" :width=\"width\" :height=\"height\">\n          <g\n            style=\"shape-rendering: crispEdges\"\n            preserveAspectRatio=\"xMidYMid meet\"\n          >\n            <!-- The body -->\n            <Cell\n              :selected_control_id=\"selected_control\"\n              :node=\"selected_node\"\n              :scales=\"scales\"\n              :depth=\"0\"\n              @select-node=\"select_node\"\n            />\n          </g>\n        </svg>\n      </v-col>\n    </v-row>\n  </v-container>\n</template>\n\n<script lang=\"ts\">\nimport Cell, {XYScale} from '@/components/cards/treemap/Cell.vue';\nimport {ColorHackModule} from '@/store/color_hack';\nimport {Filter, FilteredDataModule, TreeMapState} from '@/store/data_filters';\nimport {compare_arrays} from '@/utilities/helper_util';\nimport {\n  build_nist_tree_map,\n  is_leaf,\n  is_parent,\n  TreemapNode\n} from '@/utilities/treemap_util';\nimport * as d3 from 'd3';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\nimport {Prop, PropSync, Ref} from 'vue-property-decorator';\n\n// Respects a v-model of type TreeMapState\n@Component({\n  components: {\n    Cell\n  }\n})\nexport default class Treemap extends Vue {\n  @Ref('treemapContainer') readonly treemapContainer!: Element;\n  @Prop({type: Array, required: true}) readonly value!: TreeMapState;\n  @Prop({type: Object, required: true}) readonly filter!: Filter;\n  @PropSync('selected_control', {type: String}) syncedSelectedControl!:\n    | string\n    | null;\n\n  /** The svg internal coordinate space */\n  width = 1600;\n  height = 530;\n\n  /** The currently selected treemap node. Wrapped to avoid initialization woes */\n  get selected_node(): d3.HierarchyRectangularNode<TreemapNode> {\n    // Get typed versions of the curr state\n    // Set curr to root\n    let curr = this.treemap_layout;\n    let depth = 0;\n\n    try {\n      for (; depth < this.value.length; depth++) {\n        // If the current has no children, then just bail here\n        if (curr.children === undefined) {\n          throw Error('no children to go into');\n        }\n\n        // Fetch the next path spec\n        const nextSpecifiers = this.value.slice(0, depth + 1);\n\n        const newCurr = curr.children.find((child) => {\n          if (is_parent(child.data)) {\n            const ssA = child.data.nist_control.subSpecifiers;\n            return (\n              compare_arrays(ssA, nextSpecifiers, (a, b) =>\n                a.localeCompare(b)\n              ) === 0\n            );\n          } else {\n            return false; // We cannot go into a leaf (OR CAN WE? MUST DECIDE, AT SOME POINT)\n          }\n        });\n        if (newCurr) {\n          if (newCurr.children && newCurr.children.length) {\n            curr = newCurr;\n          } else {\n            throw Error('empty');\n          }\n        } else {\n          throw Error('truncate');\n        }\n      }\n    } catch (someTraversalError) {\n      // Slice to last successful depth. Slice is non inclusive so this works\n      this.set_path(this.value.slice(0, depth));\n    }\n\n    // Return as deep as we travelled\n    return curr;\n  }\n\n  /** Get our viewbox */\n  get view_box(): string {\n    return `0 0 ${this.width} ${this.height}`;\n  }\n\n  /** Get our scales */\n  get scales(): XYScale {\n    return {\n      scale_x: d3\n        .scaleLinear()\n        .domain([this.selected_node.x0, this.selected_node.x1])\n        .range([0, this.width]),\n      scale_y: d3\n        .scaleLinear()\n        .domain([this.selected_node.y0, this.selected_node.y1])\n        .range([0, this.height])\n    };\n  }\n\n  /** Generates a d3 heirarchy structure, with appropriate bounds to our width\n   *  detailing all of the controls in the nist hash */\n  get treemap_layout(): d3.HierarchyRectangularNode<TreemapNode> {\n    // Get the current filtered data\n    const controls = FilteredDataModule.controls(this.filter);\n\n    // Build the map\n    const hierarchy = build_nist_tree_map(controls, ColorHackModule);\n    return d3\n      .treemap<TreemapNode>()\n      .size([this.width, this.height])\n      .round(false)\n      .paddingInner(0)(hierarchy);\n  }\n\n  // Callbacks for our tree\n  select_node(n: d3.HierarchyRectangularNode<TreemapNode>): void {\n    // If it is a leaf, then select it\n    if (is_leaf(n.data)) {\n      const id = n.data.control.data.id;\n      this.syncedSelectedControl =\n        id !== this.syncedSelectedControl ? id : null;\n    } else {\n      // Otherwise, dive away. Set course for the leading title\n      const cntrl = n.data.nist_control;\n      if (cntrl) {\n        this.set_path(cntrl.subSpecifiers);\n      }\n    }\n  }\n\n  /** Submits an event to go up one node */\n  up(): void {\n    if (this.value.length) {\n      // Slice and dice, baybee\n      this.set_path(this.value.slice(0, this.value.length - 1));\n\n      // Also clear selected\n      this.syncedSelectedControl = null;\n    }\n  }\n\n  /** Typed method to wrap changes in the depth */\n  set_path(pathSpec: TreeMapState) {\n    this.$emit('input', pathSpec);\n  }\n\n  /** Controls whether we should allow up */\n  get allow_up(): boolean {\n    return this.value.length > 0;\n  }\n\n  /** Called on resize */\n  on_resize() {\n    this.width = this.treemapContainer.clientWidth;\n  }\n}\n</script>\n\n<style scoped>\ntext {\n  pointer-events: none;\n  font-weight: bold;\n  font-size: 1.1em;\n  fill: 'primary';\n}\n\nrect {\n  fill: none;\n}\n</style>\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/components/global/upload_tabs/aws/FileList.vue": "<template>\n  <v-stepper-content step=\"3\">\n    <div class=\"d-flex flex-column\">\n      <div class=\"d-flex justify-space-between\">\n        <v-text-field\n          v-model=\"formBucketName\"\n          label=\"Bucket name\"\n          @keyup.enter=\"load\"\n        />\n        <v-btn\n          title=\"Load\"\n          :disabled=\"formBucketName.length < 1\"\n          class=\"fill-height pa-0\"\n          @click=\"load\"\n        >\n          <v-icon>mdi-cloud-download</v-icon>\n        </v-btn>\n      </div>\n\n      <v-list :two-line=\"true\">\n        <v-list-item v-if=\"files.length === 0\"\n          >No items found! Try different terms?</v-list-item\n        >\n        <v-list-item v-for=\"(val, index) in files\" :key=\"val.Key\">\n          <v-list-item-content>\n            <!-- Title: The item key -->\n            <v-list-item-title>{{ val.Key }}</v-list-item-title>\n            <!-- Subtitle: Date of creation -->\n            <v-list-item-subtitle>\n              {{ val.LastModified }}\n            </v-list-item-subtitle>\n          </v-list-item-content>\n          <!-- Action: Click to add -->\n          <v-list-item-action>\n            <v-btn icon @click=\"load_file(index)\">\n              <v-icon>mdi-plus-circle</v-icon>\n            </v-btn>\n          </v-list-item-action>\n        </v-list-item>\n      </v-list>\n      <v-btn color=\"red\" class=\"my-2 mr-3\" @click=\"$emit('exit-list')\">\n        Cancel\n      </v-btn>\n    </div>\n  </v-stepper-content>\n</template>\n\n<script lang=\"ts\">\nimport {InspecIntakeModule} from '@/store/report_intake';\nimport {Auth, fetch_s3_file} from '@/utilities/aws_util';\nimport {LocalStorageVal} from '@/utilities/helper_util';\nimport S3 from 'aws-sdk/clients/s3';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\nimport {Prop} from 'vue-property-decorator';\n\n// Caches the bucket name\nconst localBucketName = new LocalStorageVal<string>('aws_bucket_name');\n\n@Component({\n  components: {}\n})\nexport default class FileList extends Vue {\n  @Prop({type: Object}) readonly auth!: Auth;\n  @Prop({type: Array}) readonly files!: S3.Object[];\n\n  /** The name written in the form */\n  formBucketName = '';\n\n  /** On mount, try to look up stored auth info */\n  /** Callback for when user selects a file.\n   * Loads it into our system.\n   */\n  async load_file(index: number): Promise<void> {\n    // Get it out of the list\n    const file = this.files[index];\n\n    // Fetch it from s3, and promise to submit it to be loaded afterwards\n    await fetch_s3_file(this.auth.creds, file.Key!, this.formBucketName).then(\n      (content) => {\n        InspecIntakeModule.loadText({\n          text: content,\n          filename: file.Key!\n        }).then((uniqueId) => this.$emit('got-files', [uniqueId]));\n      }\n    );\n  }\n\n  /** Recalls the last entered bucket name.  */\n  mounted() {\n    this.formBucketName = localBucketName.get_default('');\n  }\n\n  /** Handles when load button clicked */\n  load() {\n    localBucketName.set(this.formBucketName);\n    this.$emit('load-bucket', this.formBucketName);\n  }\n}\n</script>\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/components/global/upload_tabs/aws/S3Reader.vue": "<template>\n  <v-stepper v-model=\"step\" vertical class=\"elevation-0\">\n    <v-stepper-step :complete=\"!!assumedRole\" step=\"1\">\n      Account Credentials\n    </v-stepper-step>\n\n    <AuthStepBasic\n      :access-token.sync=\"accessToken\"\n      :secret-token.sync=\"secretToken\"\n      @auth-basic=\"handle_basic\"\n      @goto-mfa=\"handle_goto_mfa\"\n    />\n\n    <v-stepper-step :complete=\"!!assumedRole && assumedRole.from_mfa\" step=\"2\">\n      MFA Authorization\n    </v-stepper-step>\n\n    <AuthStepMFA\n      :mfa-token.sync=\"mfaToken\"\n      :mfa-serial.sync=\"mfaSerial\"\n      @auth-mfa=\"handle_proceed_mfa\"\n      @exit-mfa=\"handle_cancel_mfa\"\n    />\n\n    <v-stepper-step step=\"3\"> Browse Bucket </v-stepper-step>\n\n    <FileList\n      :auth=\"assumedRole\"\n      :files=\"files\"\n      @exit-list=\"handle_cancel_mfa\"\n      @got-files=\"got_files\"\n      @load-bucket=\"load_bucket\"\n    />\n  </v-stepper>\n</template>\n\n<script lang=\"ts\">\nimport AuthStepBasic from '@/components/global/upload_tabs/aws/AuthStepBasic.vue';\nimport AuthStepMFA from '@/components/global/upload_tabs/aws/AuthStepMFA.vue';\nimport FileList from '@/components/global/upload_tabs/aws/FileList.vue';\nimport {FileID} from '@/store/report_intake';\nimport {SnackbarModule} from '@/store/snackbar';\nimport {\n  Auth,\n  AUTH_DURATION,\n  get_session_token,\n  MFAInfo,\n  transcribe_error\n} from '@/utilities/aws_util';\nimport {LocalStorageVal} from '@/utilities/helper_util';\nimport S3 from 'aws-sdk/clients/s3';\nimport {AWSError} from 'aws-sdk/lib/error';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\n\n/** The cached session info */\nconst localSessionInformation = new LocalStorageVal<Auth | null>(\n  'aws_session_info'\n);\n\n/**\n * Uploads data to the store with unique IDs asynchronously as soon as data is entered.\n * Emits \"got-files\" with a list of the unique_ids of the loaded files.\n */\n@Component({\n  components: {\n    AuthStepBasic,\n    AuthStepMFA,\n    FileList\n  }\n})\nexport default class S3Reader extends Vue {\n  /** Form required field rules. Maybe eventually expand to other stuff */\n  reqRule = (v: string | null | undefined) =>\n    (v || '').trim().length > 0 || 'Field is Required';\n\n  /** Passed from step 1 to step 2 (MFA) if necessary */\n  /** State of all globally relevant fields */\n  accessToken = '';\n  secretToken = '';\n  mfaSerial = '';\n  mfaToken = '';\n\n  /** Our session information, generated by AWS STS */\n  assumedRole: Auth | null = null;\n\n  /** Current step */\n  step = 1;\n\n  /** Currently loaded file list from bucket */\n  files: S3.Object[] = [];\n\n  /**\n   * Handle a basic login.\n   * Gets a session token\n   */\n  handle_basic() {\n    // Attempt to assume role based on if we've determined 2fa necessary\n    get_session_token(this.accessToken, this.secretToken, AUTH_DURATION).then(\n      // Success of get session token - now need to determine if MFA necessary\n      (success) => {\n        this.assumedRole = success;\n        this.step = 3;\n      },\n\n      // Failure of initial get session token: want to set error normally\n      (failure) => {\n        this.handle_error(failure);\n      }\n    );\n  }\n\n  /** If the user tries to login by going to MFA, first check that the account is valid */\n  handle_goto_mfa() {\n    // Attempt to assume role based on if we've determined 2fa necessary\n    // Don't need the duration to be very long\n    get_session_token(this.accessToken, this.secretToken, 10).then(\n      // Success of get session token - now need to determine if MFA necessary\n      () => {\n        this.step = 2;\n      },\n\n      // Failure of initial get session token: want to set error normally\n      (failure) => {\n        this.handle_error(failure);\n      }\n    );\n  }\n\n  handle_cancel_mfa() {\n    this.step = 1;\n    this.mfaToken = '';\n    this.assumedRole = null; // Just in case\n  }\n\n  handle_exit_list() {\n    this.step = 1;\n    this.mfaToken = '';\n    this.assumedRole = null;\n    this.files = []; // Just in case\n  }\n\n  /** Handle an MFA login.\n   * Determine whether further action is necessary\n   */\n  handle_proceed_mfa() {\n    // Build our mfa params\n    const mfa: MFAInfo = {\n      SerialNumber: this.mfaSerial || null,\n      TokenCode: this.mfaToken\n    };\n\n    // Attempt to assume role based on if we've determined 2fa necessary\n    get_session_token(\n      this.accessToken,\n      this.secretToken,\n      AUTH_DURATION,\n      mfa\n    ).then(\n      (success) => {\n        // Keep them\n        this.assumedRole = success;\n        this.step = 3;\n      },\n      (failure) => {\n        this.handle_error(failure);\n      }\n    );\n  }\n\n  /** On mount, try to look up stored auth info */\n  mounted() {\n    // Load our session, if there is one\n    this.assumedRole = localSessionInformation.get_default(null);\n    if (this.assumedRole) {\n      this.step = 3;\n    }\n  }\n\n  /** Attempt to load.\n   * Basically just wraps fetch_files with error handling\n   */\n  async load_bucket(name: string) {\n    const s3 = new S3(this.assumedRole!.creds);\n    await s3\n      .listObjectsV2({\n        Bucket: name,\n        MaxKeys: 100\n      })\n      .promise()\n      .then((success) => {\n        this.files = success.Contents || [];\n      })\n      .catch((failure) => this.handle_error(failure));\n  }\n\n  /** Save the current credentials to local storage */\n  save_creds() {\n    localSessionInformation.set(this.assumedRole);\n  }\n\n  /** Callback to handle an AWS error.\n   * Sets shown error.\n   */\n  handle_error(error: AWSError): void {\n    const formattedError = transcribe_error(error);\n    // Toast whatever error we got\n    SnackbarModule.failure(formattedError);\n  }\n\n  /** Callback on got files */\n  got_files(files: Array<FileID>) {\n    this.$emit('got-files', files);\n  }\n}\n</script>\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/store/data_filters.ts": "/**\n * This module provides a cached, reusable method for filtering data from data_store.\n */\n\nimport {Trinary} from '@/enums/Trinary';\nimport {InspecDataModule} from '@/store/data_store';\nimport {\n  FileID,\n  SourcedContextualizedEvaluation,\n  SourcedContextualizedProfile\n} from '@/store/report_intake';\nimport Store from '@/store/store';\nimport {\n  ContextualizedControl,\n  ContextualizedProfile,\n  ControlStatus,\n  NistControl,\n  Severity\n} from 'inspecjs';\nimport _ from 'lodash';\nimport LRUCache from 'lru-cache';\nimport {\n  Action,\n  getModule,\n  Module,\n  Mutation,\n  VuexModule\n} from 'vuex-module-decorators';\n\nconst MAX_CACHE_ENTRIES = 20;\n\nexport declare type ExtendedControlStatus = ControlStatus | 'Waived';\n\n/** Contains common filters on data from the store. */\nexport interface Filter {\n  // General\n  /** Which file these objects came from. Undefined => any */\n  fromFile: FileID[];\n\n  // Control specific\n  /** What status the controls can have. Undefined => any */\n  status?: ExtendedControlStatus[];\n\n  /** What severity the controls can have. Undefined => any */\n  severity?: Severity[];\n\n  /** Whether or not to allow/include overlayed controls */\n  omit_overlayed_controls?: boolean;\n\n  /** Control IDs to search for */\n  ids?: string[];\n\n  /** Titles to search for */\n  titleSearchTerms?: string[];\n\n  /** Descriptions to search for */\n  descriptionSearchTerms?: string[];\n\n  /** Code to search for */\n  codeSearchTerms?: string[];\n\n  /** CCIs to search for */\n  nistIdFilter?: string[];\n\n  /** A search term string, case insensitive\n   * We look for this in\n   * - control ID\n   * - rule title\n   * - severity\n   * - status\n   * - finding details (from HDF)\n   * - code\n   */\n  searchTerm?: string;\n\n  /** The current state of the Nist Treemap. Used to further filter by nist categories etc. */\n  treeFilters?: TreeMapState;\n\n  /** A specific control id */\n  control_id?: string;\n}\n\nexport type TreeMapState = string[]; // Representing the current path spec, from root\n\n/**\n * Facillitates the search functionality\n * @param term The string to search with\n * @param contextControl The control to search for term in\n */\nfunction contains_term(\n  contextControl: ContextualizedControl,\n  term: string\n): boolean {\n  const asHDF = contextControl.root.hdf;\n  // Get our (non-null) searchable data\n  const searchables: string[] = [\n    asHDF.wraps.id,\n    asHDF.wraps.title,\n    asHDF.wraps.code,\n    asHDF.severity,\n    asHDF.status,\n    asHDF.finding_details\n  ].filter((s) => s !== null) as string[];\n\n  // See if any contain term\n  return searchables.some((s) => s.toLowerCase().includes(term));\n}\n\n@Module({\n  namespaced: true,\n  dynamic: true,\n  store: Store,\n  name: 'filteredData'\n})\nexport class FilteredData extends VuexModule {\n  selectedEvaluationIds: FileID[] = [];\n  selectedProfileIds: FileID[] = [];\n\n  @Mutation\n  SELECT_EVALUATIONS(files: FileID[]): void {\n    this.selectedEvaluationIds = [\n      ...new Set([...files, ...this.selectedEvaluationIds])\n    ];\n  }\n\n  @Mutation\n  SELECT_PROFILES(files: FileID[]): void {\n    this.selectedProfileIds = [\n      ...new Set([...files, ...this.selectedProfileIds])\n    ];\n  }\n\n  @Mutation\n  CLEAR_EVALUATION(removeId: FileID): void {\n    this.selectedEvaluationIds = this.selectedEvaluationIds.filter(\n      (ids) => ids !== removeId\n    );\n  }\n\n  @Mutation\n  CLEAR_PROFILE(removeId: FileID): void {\n    this.selectedProfileIds = this.selectedProfileIds.filter(\n      (ids) => ids !== removeId\n    );\n  }\n\n  @Mutation\n  CLEAR_ALL_EVALUATIONS(): void {\n    this.selectedEvaluationIds = [];\n  }\n\n  @Mutation\n  CLEAR_ALL_PROFILES(): void {\n    this.selectedProfileIds = [];\n  }\n\n  @Action\n  public toggle_all_evaluations(): void {\n    if (this.all_evaluations_selected === Trinary.On) {\n      this.CLEAR_ALL_EVALUATIONS();\n    } else {\n      this.SELECT_EVALUATIONS(\n        InspecDataModule.allEvaluationFiles.map((v) => v.uniqueId)\n      );\n    }\n  }\n\n  @Action\n  public toggle_all_profiles(): void {\n    if (this.all_profiles_selected === Trinary.On) {\n      this.CLEAR_ALL_PROFILES();\n    } else {\n      this.SELECT_PROFILES(\n        InspecDataModule.allProfileFiles.map((v) => v.uniqueId)\n      );\n    }\n  }\n\n  @Action\n  public select_exclusive_evaluation(fileID: FileID): void {\n    this.CLEAR_ALL_EVALUATIONS();\n    this.SELECT_EVALUATIONS([fileID]);\n  }\n\n  @Action\n  public select_exclusive_profile(fileID: FileID): void {\n    this.CLEAR_ALL_PROFILES();\n    this.SELECT_PROFILES([fileID]);\n  }\n\n  @Action\n  public toggle_evaluation(fileID: FileID): void {\n    if (this.selectedEvaluationIds.includes(fileID)) {\n      this.CLEAR_EVALUATION(fileID);\n    } else {\n      this.SELECT_EVALUATIONS([fileID]);\n    }\n  }\n\n  @Action\n  public toggle_profile(fileID: FileID): void {\n    if (this.selectedProfileIds.includes(fileID)) {\n      this.CLEAR_PROFILE(fileID);\n    } else {\n      this.SELECT_PROFILES([fileID]);\n    }\n  }\n\n  @Action\n  public clear_file(fileID: FileID): void {\n    this.CLEAR_EVALUATION(fileID);\n    this.CLEAR_PROFILE(fileID);\n  }\n\n  /**\n   * Parameterized getter.\n   * Get all evaluations from the specified file ids\n   */\n  get evaluations(): (\n    files: FileID[]\n  ) => readonly SourcedContextualizedEvaluation[] {\n    return (files: FileID[]) => {\n      return InspecDataModule.contextualExecutions.filter((e) =>\n        files.includes(e.from_file.uniqueId)\n      );\n    };\n  }\n\n  get profiles_for_evaluations(): (\n    files: FileID[]\n  ) => readonly ContextualizedProfile[] {\n    return (files: FileID[]) => {\n      // Filter to those that match our filter. In this case that just means come from the right file id\n      return this.evaluations(files).flatMap(\n        (evaluation) => evaluation.contains\n      );\n    };\n  }\n\n  /**\n   * Parameterized getter.\n   * Get all profiles from the specified file ids.\n   */\n  get profiles(): (files: FileID[]) => readonly SourcedContextualizedProfile[] {\n    return (files: FileID[]) => {\n      return InspecDataModule.contextualProfiles.filter((e) => {\n        return files.includes(e.from_file.uniqueId);\n      });\n    };\n  }\n\n  get selected_file_ids(): FileID[] {\n    return [...this.selectedEvaluationIds, ...this.selectedProfileIds];\n  }\n\n  // check to see if all profiles are selected\n  get all_profiles_selected(): Trinary {\n    switch (this.selectedProfileIds.length) {\n      case 0:\n        return Trinary.Off;\n      case InspecDataModule.allProfileFiles.length:\n        return Trinary.On;\n      default:\n        return Trinary.Mixed;\n    }\n  }\n\n  // check to see if all evaluations are selected\n  get all_evaluations_selected(): Trinary {\n    switch (this.selectedEvaluationIds.length) {\n      case 0:\n        return Trinary.Off;\n      case InspecDataModule.allEvaluationFiles.length:\n        return Trinary.On;\n      default:\n        return Trinary.Mixed;\n    }\n  }\n\n  /**\n   * Parameterized getter.\n   * Get all controls from all profiles from the specified file id.\n   * Utlizes the profiles getter to accelerate the file filter.\n   */\n  get controls(): (filter: Filter) => readonly ContextualizedControl[] {\n    /** Cache by filter */\n    const localCache: LRUCache<string, readonly ContextualizedControl[]> =\n      new LRUCache(MAX_CACHE_ENTRIES);\n\n    return (filter: Filter) => {\n      // Generate a hash for cache purposes.\n      // If the \"searchTerm\" string is not null, we don't cache - no need to pollute\n      const id: string = filter_cache_key(filter);\n\n      // Check if we have this cached:\n      const cached = localCache.get(id);\n      if (cached !== undefined) {\n        return cached;\n      }\n\n      // Get profiles from loaded Results\n      let profiles: readonly ContextualizedProfile[] =\n        this.profiles_for_evaluations(filter.fromFile);\n\n      // Get profiles from loaded Profiles\n      profiles = profiles.concat(this.profiles(filter.fromFile));\n\n      // And all the controls they contain\n      let controls: readonly ContextualizedControl[] = profiles.flatMap(\n        (profile) => profile.contains\n      );\n\n      // Filter by single control id\n      if (filter.control_id !== undefined) {\n        controls = controls.filter((c) => c.data.id === filter.control_id);\n      }\n\n      const controlFilters: Record<\n        string,\n        boolean | Array<string> | undefined\n      > = {\n        'root.hdf.severity': filter.severity,\n        'hdf.wraps.id': filter.ids,\n        'hdf.wraps.title': filter.titleSearchTerms,\n        'hdf.wraps.desc': filter.descriptionSearchTerms,\n        'hdf.raw_nist_tags': filter.nistIdFilter,\n        full_code: filter.codeSearchTerms,\n        'hdf.waived': filter.status?.includes('Waived'),\n        'root.hdf.status': _.filter(\n          filter.status,\n          (status) => status !== 'Waived'\n        )\n      };\n\n      controls = filterControlsBy(controls, controlFilters);\n\n      // Filter by overlay\n      if (filter.omit_overlayed_controls) {\n        controls = controls.filter(\n          (control) => control.extendedBy.length === 0\n        );\n      }\n\n      // Freeform search\n      if (filter.searchTerm !== undefined) {\n        const term = filter.searchTerm.toLowerCase();\n\n        // Filter controls to those that contain search term\n        controls = controls.filter((c) => contains_term(c, term));\n      }\n\n      // Filter by nist stuff\n      if (filter.treeFilters && filter.treeFilters.length > 0) {\n        // Construct a nist control to represent the filter\n        const control = new NistControl(filter.treeFilters);\n\n        controls = controls.filter((c) => {\n          // Get an hdf version so we have the fixed nist tags\n          return c.root.hdf.parsedNistTags.some((t) => control.contains(t));\n        });\n      }\n\n      // Freeze and save to cache\n      const r = Object.freeze(controls);\n      localCache.set(id, r);\n      return r;\n    };\n  }\n}\n\nexport const FilteredDataModule = getModule(FilteredData);\n\n/**\n * Generates a unique string to represent a filter.\n * Does some minor \"acceleration\" techniques such as\n * - annihilating empty search terms\n * - defaulting \"omit_overlayed_controls\"\n */\nexport function filter_cache_key(f: Filter) {\n  const newFilter: Filter = {\n    searchTerm: f.searchTerm?.trim() || '',\n    omit_overlayed_controls: f.omit_overlayed_controls || false,\n    ...f\n  };\n  return JSON.stringify(newFilter);\n}\n\nexport function filterControlsBy(\n  controls: readonly ContextualizedControl[],\n  filters: Record<string, boolean | Array<string> | undefined>\n): readonly ContextualizedControl[] {\n  const activeFilters: typeof filters = _.pickBy(\n    filters,\n    (value, _key) =>\n      (Array.isArray(value) && value.length > 0) ||\n      (typeof value === 'boolean' && value)\n  );\n  return controls.filter((control) => {\n    return Object.entries(activeFilters).every(([filter, value]) => {\n      const item: string | string[] | boolean = _.get(control, filter);\n      if (Array.isArray(value) && typeof item !== 'boolean') {\n        return value?.some((term) => {\n          return arrayOrStringIncludes(item, (compareValue) =>\n            compareValue.toLowerCase().includes(term.toLowerCase())\n          );\n        });\n      } else {\n        return item === value;\n      }\n    });\n  });\n}\n\n/** Iterate over a string or array of strings and call the string compare function provided on every element **/\nfunction arrayOrStringIncludes(\n  arrayOrString: string | string[],\n  comparator: (compareValue: string) => boolean\n) {\n  if (typeof arrayOrString === 'string') {\n    return comparator(arrayOrString);\n  } else {\n    return arrayOrString.some((value) => comparator(value));\n  }\n}\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/utilities/format_util.ts": "/**\n * Functions for formatting items to have unique keys. Principally used for vuex v-for key generation.\n */\n\nimport {isFromProfileFile} from '@/store/data_store';\nimport {\n  SourcedContextualizedEvaluation,\n  SourcedContextualizedProfile\n} from '@/store/report_intake';\nimport {ContextualizedControl} from 'inspecjs';\n\nexport function execution_unique_key(\n  exec: Readonly<SourcedContextualizedEvaluation>\n): string {\n  return `exec_${exec.from_file.uniqueId}`;\n}\n\n/**\n * Generates a unique key for the given profile\n * @param profile\n */\nexport function profile_unique_key(\n  profile: Readonly<SourcedContextualizedProfile>\n): string {\n  if (isFromProfileFile(profile)) {\n    return `profile_${profile.from_file.uniqueId}`;\n  } else {\n    return `${execution_unique_key(\n      profile.sourcedFrom as SourcedContextualizedEvaluation\n    )}-${profile.data.name}`;\n  }\n}\n\n/**\n * Generates a unique key for the given control\n * @param ctrl The control to generate the key for\n */\nexport function control_unique_key(\n  ctrl: Readonly<ContextualizedControl>\n): string {\n  return `${profile_unique_key(\n    ctrl.sourcedFrom as Readonly<SourcedContextualizedProfile>\n  )}-${ctrl.data.id}`;\n}\n\n",
  "/api/sources/raw?key=test:libs/inspecjs/src/context.ts": "/**\n * Provides general utilities for articulating associations beteen evaluations, profiles, and controls.\n * Especially useful for handling overlay/wrapper profiles.\n */\n\nimport {HDFControl, hdfWrapControl} from './compat_wrappers';\nimport {\n  AnyControl,\n  AnyEval,\n  AnyEvalControl,\n  AnyEvalProfile,\n  AnyProfile\n} from './fileparse';\n\n/**\n * Mixin type to express that this type wraps another data type to add additional fields,\n * without modifying the inner type.\n */\ninterface WrapsType<Data> {\n  data: Data;\n}\n\n/**\n * Mixin type to express that this type has some sort \"parent\".\n * Sort of an inverse to the Contains mixin.\n * E.g. A control is sourced from a profile, and an execution is from a file.\n */\ninterface Sourced<From> {\n  sourcedFrom: From;\n}\n\n/**\n * Mixin type to express that this type has some sort of directional dependency-graph with members of a (usually the same) type.\n * For instance, profiles overlay/are overlayed by profiles.\n * Controls override behavior/are overrideen by other controls\n */\ninterface Extendable<By> {\n  /**\n   * What is this data extended by?\n   * E.g. a profile that overlays this profile.\n   * Can be empty.\n   */\n  extendedBy: By[];\n\n  /**\n   * What data is this node extending?\n   * E.g. is this overlaying a profile? Another control?\n   * Can be empty.\n   */\n  extendsFrom: By[];\n}\n\n/**\n * Mixin type to express that this type is primarily a parent to some other data.\n * For instance, profiles are most directly a parent of controls .\n * What objects/resources does this item contain?\n */\ninterface Contains<Item> {\n  contains: Item;\n}\n\n// Create our three primary data types from the above mixins\n// Essentially this is just describing the parent/child relationships each type has\nexport interface ContextualizedEvaluation\n  extends WrapsType<AnyEval>,\n    Contains<ContextualizedProfile[]> {}\n\nexport interface ContextualizedProfile\n  extends WrapsType<AnyProfile>,\n    Sourced<ContextualizedEvaluation | null>,\n    Contains<ContextualizedControl[]>,\n    Extendable<ContextualizedProfile> {}\nexport interface ContextualizedControl\n  extends WrapsType<AnyControl>,\n    Sourced<ContextualizedProfile>,\n    Extendable<ContextualizedControl> {\n  /** The HDF version of this particular control */\n  hdf: HDFControl;\n\n  /** Drills down to this controls root CC. In general you should use this for all data operations */\n  root: ContextualizedControl;\n\n  /** Yields the full code of this control, by concatenating overlay code. */\n  full_code: string;\n}\n\nclass ContextualizedControlImp implements ContextualizedControl {\n  // Imp stuff\n  data: AnyControl;\n  sourcedFrom: ContextualizedProfile;\n  extendsFrom: ContextualizedControl[];\n  extendedBy: ContextualizedControl[];\n  hdf: HDFControl;\n\n  constructor(\n    data: AnyControl,\n    sourcedFrom: ContextualizedProfile,\n    extendedBy: ContextualizedControl[],\n    extendsFrom: ContextualizedControl[]\n  ) {\n    // Simple save\n    this.data = data;\n    this.sourcedFrom = sourcedFrom;\n    this.hdf = hdfWrapControl(data);\n    this.extendedBy = extendedBy;\n    this.extendsFrom = extendsFrom;\n  }\n\n  get root(): ContextualizedControl {\n    if (this.extendsFrom.length) {\n      return this.extendsFrom[0].root;\n    }\n    return this;\n  }\n\n  /** Returns whether this control is just a duplicate of base/root (but is not itself root) */\n  get is_redundant(): boolean {\n    return (\n      !this.data.code ||\n      this.data.code.trim() === '' ||\n      (this.extendsFrom.length > 0 && this.data.code === this.root.data.code)\n    );\n  }\n\n  get full_code(): string {\n    // If we extend from something, we behave slightly differently\n    if (this.extendsFrom.length) {\n      const ancestor = this.extendsFrom[0];\n      if (this.is_redundant) {\n        return ancestor.full_code;\n      } else {\n        return `\\\n=========================================================\n# Profile name: ${this.sourcedFrom.data.name}\n=========================================================\n\n${this.data.code}\n\n${this.extendsFrom[0].full_code}`.trim();\n      }\n    } else {\n      // We are the endpoint\n      return `\\\n=========================================================\n# Profile name: ${this.sourcedFrom.data.name}\n=========================================================\n\n${this.data.code}`.trim();\n    }\n  }\n}\n\nexport function contextualizeEvaluation(\n  evaluation: AnyEval\n): ContextualizedEvaluation {\n  // To begin, create basic context for profiles and evaluation\n  const evalContext: ContextualizedEvaluation = {\n    data: evaluation,\n    contains: []\n  };\n\n  for (const profile of evaluation.profiles) {\n    const evalProfileContext: ContextualizedProfile = {\n      data: profile,\n      sourcedFrom: evalContext,\n      extendedBy: [],\n      extendsFrom: [],\n      contains: []\n    };\n\n    // Add it to our parent\n    evalContext.contains.push(evalProfileContext);\n  }\n\n  // After our initial save of profiles, we go over them again to establish parentage/dependency\n  for (const profile of evalContext.contains) {\n    // We know these are from a report; label as such\n    const asExec = profile.data as AnyEvalProfile;\n\n    // If it has a parent profile then we link them by extendedby/extendsfrom\n    if (asExec.parent_profile !== undefined) {\n      // Look it up\n      const parent = evalContext.contains.find(\n        (p) => p.data.name === asExec.parent_profile\n      );\n\n      // Link it up\n      if (parent) {\n        parent.extendsFrom.push(profile);\n        profile.extendedBy.push(parent);\n      }\n    }\n  }\n\n  // Next step: Extract controls and connect them\n  // Extract the controls and set them as the \"contained\" data for each profile\n  // These ContextualizedControls are basically empty - just have data and from where they were sourced\n  const allControls: ContextualizedControl[] = [];\n  for (const profile of evalContext.contains) {\n    const pControls = profile.data.controls as AnyEvalControl[];\n    profile.contains = pControls.map((c) => {\n      return new ContextualizedControlImp(c, profile, [], []);\n    });\n    allControls.push(...profile.contains);\n  }\n\n  // Link each contextualized control\n  for (const cc of allControls) {\n    // Behaviour changes based on if we have well-formed or malformed profile dependency\n    if (cc.sourcedFrom.extendsFrom.length || cc.sourcedFrom.extendedBy.length) {\n      // Our profile is a baseline! No need to continue - children will make connections for us\n      // If we aren't extended from something we just drop. Our children will make connections for us\n      if (cc.sourcedFrom.extendsFrom.length === 0) {\n        continue;\n      }\n\n      // Get the profile(s) that this control's owning profile is extending\n      // For a wrapper profile, there might be many of these!\n      // We don't know which one it will be, so we iterate\n      for (const extendedProfile of cc.sourcedFrom.extendsFrom) {\n        // Hunt for its ancestor in the extended profile\n        const ancestor = extendedProfile.contains.find(\n          (c) => c.data.id === cc.data.id\n        );\n        // First one we find with a matching id we assume is the root (or at least, closer to root)\n        if (ancestor) {\n          ancestor.extendedBy.push(cc);\n          cc.extendsFrom.push(ancestor);\n          break; // Note that we're in a nested loop here\n        }\n      }\n      // If it's not found, then we just assume it does not exist!\n    } else {\n      // If we don't have a normal profile dependency layout, then we have to hunt ye-olde-fashioned-way\n      // Unfortunately, if theres more than 2 profiles there's ultimately no way to figure out which one was applied \"last\".\n      // This method leaves them as siblings. However, as a fallback method that is perhaps the best we can hope for\n      // First, hunt out all controls from this file that have the same id as cc\n      const sameId = allControls.filter((c) => c.data.id === cc.data.id);\n      // Find which of them, if any, is populated with results.\n      let sameIdPopulated = sameId.find(\n        (c) => c.hdf.segments && c.hdf.segments.length\n      );\n\n      // If found a populated base, use that. If not, we substitute in the first found element in sameId. This is arbitrary.\n      if (!sameIdPopulated) {\n        sameIdPopulated = sameId[0];\n      }\n\n      // If the object we end up with is \"us\", then just ignore\n      if (Object.is(cc, sameIdPopulated)) {\n        continue;\n      } else {\n        // Otherwise, bind\n        sameIdPopulated.extendedBy.push(cc);\n        cc.extendsFrom.push(sameIdPopulated);\n      }\n    }\n  }\n  return evalContext;\n}\n\n// Here we handle the independent profile (IE those in their own files, generated by inspec json).\n// These are slightly simpler because they do not actually include their overlays (even if they depend on them)\n// as a separate data structure.\n// As such, we can just do all the profile and controls from each in one fell swoop\nexport function contextualizeProfile(\n  profile: AnyProfile\n): ContextualizedProfile {\n  const profileContext: ContextualizedProfile = {\n    data: profile,\n    extendedBy: [],\n    extendsFrom: [],\n    contains: [],\n    sourcedFrom: null\n  };\n\n  // Now give it its controls\n  for (const c of profile.controls) {\n    const result = new ContextualizedControlImp(c, profileContext, [], []);\n    profileContext.contains.push(result);\n  }\n\n  return profileContext;\n}\n\n",
  "/api/sources/raw?key=test:libs/inspecjs/src/nist.ts": "import {ControlStatus} from './compat_wrappers';\nimport {ALL_NIST_CONTROL_NUMBERS, ALL_NIST_FAMILIES} from './raw_nist';\n\n// Regexes.\nconst NIST_FAMILY_RE = /^[A-Z]{2}$/;\n// Limit length of children to avoid potential DoS on malicious NIST Control strings\nconst NIST_CONTROL_RE = /^([A-Z]{2})-([0-9]+)(.{0,60})$/;\nconst SPEC_SPLITTER = /[\\s\\(\\)\\.]+/; // Includes all whitespace, periods, and parenthesis\nconst REV_RE = /^rev[\\s_.]+(\\d+)$/i; // Matches Rev_5 etc\ntype ParseNist = NistControl | NistRevision | null;\n\nexport interface CanonizationConfig {\n  max_specifiers: number;\n\n  // All are assumed false\n  pad_zeros?: boolean; // default false\n  allow_letters?: boolean; // default true\n  add_spaces?: boolean; // default true\n  add_parens?: boolean; // default true\n  add_periods?: boolean; // default true\n}\n\nfunction default_partial_config(c: CanonizationConfig): CanonizationConfig {\n  return {\n    pad_zeros: false,\n    allow_letters: true,\n    add_spaces: true,\n    add_parens: true,\n    add_periods: true,\n    ...c\n  };\n}\n\n/** Represents a single nist control, or group of controls if the sub specs are vague enoug. */\nexport class NistControl {\n  /** The sequence of sub-specifiers making up the \"parts\" of the nist tags\n   * E.g.  in \"SI-7 (14)(b)\", we would have [\"SI\", \"7\", \"14\", \"b\"]\n   *       in \"SI-4a.2.\", we would have [\"SI\", \"4\", \"a, \"2\"];\n   * First element is guaranteed to be a 2-letter family\n   * Note that we strip punctuation\n   */\n  subSpecifiers: string[]; // Guaranteed to be of length at least one on a \"real\" control\n\n  /** Holds the string from which this control was generated. */\n  rawText?: string;\n\n  /** Trivial constructor */\n  constructor(subSpecs: string[], rawRext?: string) {\n    this.subSpecifiers = subSpecs;\n    this.rawText = rawRext;\n  }\n\n  /** This function checks if the given control is contained by or equivalent to this control.\n   * It is purely a wrapper around compare_lineage\n   */\n  contains(other: NistControl): boolean {\n    return this.compare_lineage(other) !== -1;\n  }\n\n  /** This function compares this nist control to another nist control.\n   * If the other control is the same control as this one, returns 0.\n   *\n   * If the other control is a child of this control\n   * (IE it is the same base directives with further enhancements, e.g. `IA-4` -> `IA-4b.` or `AC-9a.` -> `AC-9a. (2)`)\n   * and returns how many further enhancements have been applied (IE what is the number of additional subdirectives.)\n   *\n   * If the other control is NOT a child of this control, return -1\n   */\n  compare_lineage(other: NistControl): number {\n    // Can't contain if we're more specific\n    if (this.subSpecifiers.length > other.subSpecifiers.length) {\n      return -1;\n    }\n\n    // After that we just need to iterate\n    for (let i = 0; i < this.subSpecifiers.length; i++) {\n      // If our subspec differentiate at any point, then we do not match\n      if (this.subSpecifiers[i] !== other.subSpecifiers[i]) {\n        return -1;\n      }\n    }\n\n    // We survived! The change in # sub specs is thus the # of changes to enhancements\n    return other.subSpecifiers.length - this.subSpecifiers.length;\n  }\n\n  /** Gives a numeric value indicating how these controls compare, lexicographically.\n   * See string.localCompare for the output format.\n   */\n  localCompare(other: NistControl): number {\n    // Convert into a chain of directives\n    const aChain = this.subSpecifiers;\n    const bChain = other.subSpecifiers;\n    for (let i = 0; i < aChain.length && i < bChain.length; i++) {\n      // Compare corresponding elements of the chain\n      const idA = aChain[i];\n      const idB = bChain[i];\n\n      // Return only if significant\n      const lc = idA.localeCompare(idB, 'en', {numeric: true});\n      if (lc) {\n        return lc;\n      }\n    }\n\n    // Fall back to length comparison. We want shorter first, so ascending's good\n    return aChain.length - bChain.length;\n  }\n\n  /**\n   * Quick accessor to the leading family letters for the nsit control\n   */\n  get family(): string | undefined {\n    if (this.subSpecifiers.length) {\n      return this.subSpecifiers[0];\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * Returns the \"canonical\" representation of this control, based on the provided parameters.\n   * This is, unfortunately, slightly expensive.\n   * Avoid repeating this if possible.\n   */\n  canonize(config: CanonizationConfig): string {\n    config = default_partial_config(config);\n    const ss = this.subSpecifiers;\n\n    // Build our string. Start with family\n    let s = this.family || '';\n    if (ss.length > 1) {\n      s += '-';\n    }\n\n    for (let i = 1; i < ss.length && i < config.max_specifiers; i++) {\n      let spec = ss[i];\n\n      // Handle numbers\n      if (!Number.isNaN(Number.parseInt(spec))) {\n        // If we need to, pad zeros\n        if (config.pad_zeros && spec.length < 2) {\n          spec = '0' + spec;\n        }\n\n        // If index past 1, wrap in parens\n        if (i > 1) {\n          if (config.add_parens) {\n            spec = `(${spec})`;\n          }\n\n          // If space, add space\n          if (config.add_spaces) {\n            spec = ' ' + spec;\n          }\n        }\n\n        // Append\n        s += spec;\n      } else if (config.allow_letters) {\n        // It's a letter. Add a .\n        if (config.add_spaces) {\n          s += ' ';\n        }\n        s += spec;\n        if (config.add_periods) {\n          s += '.';\n        }\n      }\n    }\n    return s;\n  }\n}\n\n/** Wrapper around a revision number. Currently has no additional functionality, but this may change. */\nexport class NistRevision {\n  revNum: number;\n  constructor(revNum: number) {\n    this.revNum = revNum;\n  }\n}\n\nexport function parse_nist(rawNist: string): ParseNist {\n  // Is it a revision? Get the match, continuing if none\n  const revMatch = rawNist.match(REV_RE);\n  if (revMatch) {\n    return new NistRevision(Number.parseInt(revMatch[1]));\n  }\n  // Is it just a family?\n  // Get the match, failing out if we can't\n  const famMatch = rawNist.match(NIST_FAMILY_RE);\n  if (famMatch) {\n    return new NistControl([famMatch[0]], famMatch[0]);\n  }\n\n  // Next try it as a full control\n  const fullMatch = rawNist.match(NIST_CONTROL_RE);\n  if (!fullMatch) {\n    return null;\n  }\n\n  // Parse sub-elements\n  const family = fullMatch[1];\n  const controlNum = fullMatch[2];\n  const subspecsRaw = (fullMatch[3] || '').trim();\n\n  // Init sub-specs\n  const subSpecs: string[] = [family, controlNum];\n\n  // Filter garbage from subspecsRaw\n  let subspecsSplit = subspecsRaw.split(SPEC_SPLITTER);\n  subspecsSplit = subspecsSplit.filter((s) => s !== '');\n  return new NistControl(subSpecs.concat(subspecsSplit), rawNist);\n}\n\n/** Simple discriminators */\nexport function is_control(\n  x: NistControl | NistRevision | null\n): x is NistControl {\n  if (x && (x as NistControl).subSpecifiers !== undefined) {\n    return true;\n  }\n  return false;\n}\n\n/** Simple discriminators */\nexport function is_revision(\n  x: NistControl | NistRevision | null\n): x is NistRevision {\n  if (x && (x as NistRevision).revNum !== undefined) {\n    return true;\n  }\n  return false;\n}\n\n/** All a control in a nist hash really needs is a status */\nexport interface CategoryItemRequirements {\n  status: ControlStatus;\n}\n\n// Represents the status of a group of controsl. Typically holds the value of the \"worst\" control amongst the group\n// Empty means no controls are in the given group\nexport type ControlGroupStatus = ControlStatus | 'Empty';\n\n/**\n * Computes the groups status having added control.\n * There's a natural precedence to statuses, at least in a list/group\n * For instance, we would not mark a group as Passed if it contained a Failed.\n * Clearly \"Empty\" is the lowest precedence, as adding any control would wipe it out.\n * Following we have \"From Profile\" since it is in some way the absence of status, but also lacks run context. We care more about literally anything else\n * Next, \"Not Applicable\" since it means that though we ran we don't care about the result\n * \"Not Reviewed\" implies that had the test run it would've mattered, but it was skipped deliberately\n * \"No Data\" is similarly a lack of result, but in this case unexpected, and thus worthy of more scrutiny\n * \"Passed\" means that a test passed! But \"Failed\" should override, since fails are really what we're looking for\n * Finally, \"Profile Errors\" mean something is broken and needs to be fixed, and thus overrides all\n *\n * Returns:\n * < 0  if a < b (by the above criteria)\n * 0    if a === b\n * > 0  if a > b\n */\nexport function compare_statuses(\n  a: ControlGroupStatus,\n  b: ControlGroupStatus\n): number {\n  const precedence: ControlGroupStatus[] = [\n    'Empty',\n    'From Profile',\n    'Not Applicable',\n    'Not Reviewed',\n    'Passed',\n    'Failed',\n    'Profile Error'\n  ];\n  const idA = precedence.indexOf(a);\n  const idB = precedence.indexOf(b);\n  return idA - idB;\n}\n\nexport function updateStatus(\n  group: ControlGroupStatus,\n  control: ControlStatus\n): ControlGroupStatus {\n  if (compare_statuses(group, control) > 0) {\n    // Our new control has shifted the status!\n    return control;\n  } else {\n    // Our existing group status was \"greater\"\n    return group;\n  }\n}\n\nexport interface NistHierarchyNode {\n  control: NistControl;\n  children: NistHierarchyNode[];\n}\nexport type NistHierarchy = NistHierarchyNode[];\n\nfunction _control_parent(c: NistControl): NistControl | null {\n  if (c.subSpecifiers.length) {\n    return new NistControl(\n      c.subSpecifiers.slice(0, c.subSpecifiers.length - 1)\n    );\n  } else {\n    return null; // Can't get any shorter\n  }\n}\n\nfunction _key_for(c: NistControl): string {\n  return c.subSpecifiers.join('-');\n}\n\nfunction _generate_full_nist_hierarchy(): NistHierarchy {\n  // Initialize our roots\n  const roots: NistHierarchy = ALL_NIST_FAMILIES.map((family) => {\n    return {\n      control: new NistControl([family], family),\n      children: []\n    };\n  });\n\n  // Init our map, which maps _key_for of controls to their corresponding hierarchy nodes\n  const map: {[key: string]: NistHierarchyNode} = {};\n\n  // Add roots to the map\n  roots.forEach((r) => {\n    map[_key_for(r.control)] = r;\n  });\n\n  // Iterate over all controls\n  ALL_NIST_CONTROL_NUMBERS.forEach((n) => {\n    const asControl = parse_nist(n) as NistControl | null; // We know there are no revs in our file\n    if (!asControl) {\n      throw new Error(`Invalid nist control constant ${n}`);\n    }\n\n    // If our node has already been created, replace the temporary control with the \"real\" one\n    const key = _key_for(asControl);\n    let asNode: NistHierarchyNode;\n    if (map[key]) {\n      asNode = map[key];\n      asNode.control = asControl;\n    } else {\n      //Make it fresh\n      asNode = {\n        control: asControl,\n        children: []\n      };\n\n      // Register in map\n      map[key] = asNode;\n    }\n\n    const parent = _control_parent(asControl);\n\n    // If parent is null, add to roots.\n    if (!parent) {\n      roots.push({\n        control: asControl,\n        children: []\n      });\n    } else {\n      // Valid parent; look it up and append us to it\n      const parentKey = _key_for(parent);\n      const parentNode = map[parentKey];\n\n      // If parent has been explored already, simply append this node to that\n      if (parentNode) {\n        parentNode.children.push(asNode);\n      } else {\n        // It's not? make a stub\n        map[parentKey] = {\n          control: parent,\n          children: [asNode] // \"Us\"\n        };\n      }\n    }\n  });\n\n  // Now roots are our final answers!\n  return roots;\n}\n\nexport const FULL_NIST_HIERARCHY: Readonly<NistHierarchy> =\n  _generate_full_nist_hierarchy();\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/store/data_store.ts": "/**\n * Tracks uploaded files, and their parsed contents\n */\n\nimport {\n  EvaluationFile,\n  FileID,\n  ProfileFile,\n  SourcedContextualizedEvaluation,\n  SourcedContextualizedProfile\n} from '@/store/report_intake';\nimport Store from '@/store/store';\nimport {\n  Action,\n  getModule,\n  Module,\n  Mutation,\n  VuexModule\n} from 'vuex-module-decorators';\nimport {FilteredDataModule} from './data_filters';\n\n/** We make some new variant types of the Contextual types, to include their files*/\nexport function isFromProfileFile(p: SourcedContextualizedProfile) {\n  return p.sourcedFrom === null;\n}\n\n@Module({\n  namespaced: true,\n  dynamic: true,\n  store: Store,\n  name: 'data'\n})\nexport class InspecData extends VuexModule {\n  /** State var containing all execution files that have been added */\n  executionFiles: EvaluationFile[] = [];\n\n  /** State var containing all profile files that have been added */\n  profileFiles: ProfileFile[] = [];\n\n  /** Return all of the files that we currently have. */\n  get allFiles(): (EvaluationFile | ProfileFile)[] {\n    const result: (EvaluationFile | ProfileFile)[] = [];\n    result.push(...this.executionFiles);\n    result.push(...this.profileFiles);\n    return result;\n  }\n\n  /* Return all evaluation files only */\n  get allEvaluationFiles(): EvaluationFile[] {\n    return this.executionFiles;\n  }\n\n  /* Return all profile files only */\n  get allProfileFiles(): ProfileFile[] {\n    return this.profileFiles;\n  }\n\n  /**\n   * Returns a readonly list of all executions currently held in the data store\n   * including associated context\n   */\n  get contextualExecutions(): readonly SourcedContextualizedEvaluation[] {\n    return this.executionFiles.map((file) => file.evaluation);\n  }\n\n  get loadedDatabaseIds(): string[] {\n    const ids: string[] = [];\n    this.allFiles.forEach((file) => {\n      if (file.database_id) {\n        ids.push(file.database_id.toString());\n      }\n    });\n    return ids;\n  }\n\n  /**\n   * Returns a readonly list of all profiles belonging to executions currently\n   * held in the data store\n   */\n  get contextualExecutionProfiles(): readonly SourcedContextualizedProfile[] {\n    return this.contextualExecutions.flatMap(\n      (evaluation) => evaluation.contains\n    ) as SourcedContextualizedProfile[];\n  }\n\n  /**\n   * Returns a readonly list of all profiles currently held in the data store\n   * including associated context\n   */\n  get contextualProfiles(): readonly SourcedContextualizedProfile[] {\n    return this.profileFiles.map((file) => file.profile);\n  }\n\n  get allProfiles(): readonly SourcedContextualizedProfile[] {\n    return this.contextualProfiles.concat(this.contextualExecutionProfiles);\n  }\n\n  /**\n   * Adds a profile file to the store.\n   * @param newProfile The profile to add\n   */\n  @Mutation\n  addProfile(newProfile: ProfileFile) {\n    this.profileFiles.push(newProfile);\n  }\n\n  /**\n   * Adds an execution file to the store.\n   * @param newExecution The execution to add\n   */\n  @Mutation\n  addExecution(newExecution: EvaluationFile) {\n    this.executionFiles.push(newExecution);\n  }\n\n  /**\n   * Unloads the file with the given id\n   */\n  @Action\n  removeFile(fileId: FileID) {\n    FilteredDataModule.clear_file(fileId);\n    this.context.commit('REMOVE_PROFILE', fileId);\n    this.context.commit('REMOVE_RESULT', fileId);\n  }\n\n  @Mutation\n  REMOVE_PROFILE(fileId: FileID) {\n    this.profileFiles = this.profileFiles.filter(\n      (pf) => pf.uniqueId !== fileId\n    );\n  }\n\n  @Mutation\n  REMOVE_RESULT(fileId: FileID) {\n    this.executionFiles = this.executionFiles.filter(\n      (ef) => ef.uniqueId !== fileId\n    );\n  }\n\n  /**\n   * Clear all stored data.\n   */\n  @Mutation\n  reset() {\n    this.profileFiles = [];\n    this.executionFiles = [];\n  }\n}\n\nexport const InspecDataModule = getModule(InspecData);\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/components/cards/treemap/Cell.vue": "<template>\n  <!-- We can use Vue transitions too! -->\n  <g>\n    <!-- Generate our children here. Only do so for parents, and if they aren't too deep -->\n    <g v-if=\"is_parent\">\n      <Cell\n        v-for=\"child in node.children\"\n        :key=\"child.data.key\"\n        :selected-control-id=\"selectedControlId\"\n        :depth=\"depth + 1\"\n        :node=\"child\"\n        :scales=\"scales\"\n        @select-node=\"select_node\"\n      />\n    </g>\n\n    <!-- The actual body of this square. Visible only if depth === 1 (ie a direct child of parent) or depth === 2 (one level deeper) -->\n    <rect\n      v-if=\"depth >= 1\"\n      :style=\"cell_style\"\n      :x=\"x\"\n      :y=\"y\"\n      :width=\"width\"\n      :height=\"height\"\n      :class=\"cell_classes\"\n      :rx=\"is_selected ? 20 : 0\"\n      @click=\"select_node(node)\"\n    />\n\n    <text\n      v-if=\"depth === 1\"\n      dominant-baseline=\"middle\"\n      text-anchor=\"middle\"\n      :x=\"x + width / 2\"\n      :y=\"y + height / 2\"\n      >{{ node.data.title }}</text\n    >\n  </g>\n</template>\n\n<script lang=\"ts\">\nimport {is_leaf, TreemapNode, TreemapNodeLeaf} from '@/utilities/treemap_util';\nimport * as d3 from 'd3';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\nimport {Prop} from 'vue-property-decorator';\n\nexport interface XYScale {\n  scale_x: d3.ScaleLinear<number, number>;\n  scale_y: d3.ScaleLinear<number, number>;\n}\n\n/**\n * Categories property must be of type Category\n * Emits \"select-node\" with payload of type d3.HierarchyRectangularNode<TreemapNode>\n */\n@Component({\n  name: 'Cell'\n})\nexport default class Cell extends Vue {\n  @Prop({type: String}) readonly selectedControlId!: string;\n  @Prop({type: Object, required: true})\n  readonly node!: d3.HierarchyRectangularNode<TreemapNode>;\n\n  @Prop({type: Number, default: 0}) readonly depth!: number;\n  @Prop({type: Object, default: 0}) readonly scales!: XYScale;\n\n  scale = 1.0;\n\n  /** Are we a control? Use treemap util type checker */\n  get is_control(): boolean {\n    return is_leaf(this.node.data);\n  }\n\n  /** Invert of above. Checks if this node has children, essentially */\n  get is_parent(): boolean {\n    return !this.is_control;\n  }\n\n  /** Are we selected? True if selectedControlId matches our id, and we are in selected hierarchy */\n  get is_selected(): boolean {\n    return (\n      this.is_control && // We are a control\n      (this.node.data as TreemapNodeLeaf).control.data.id ===\n        this.selectedControlId // Our control id matches\n    );\n  }\n\n  /** Compute the top-left x coord of this cell rect based on the provided scale_x prop */\n  get x(): number {\n    return this.scales.scale_x(this.node.x0);\n  }\n\n  /** Compute the top-left y coord of this cell rect based on the provided scale_y prop */\n  get y(): number {\n    return this.scales.scale_y(this.node.y0);\n  }\n\n  /**\n   * Compute the width of this rect based on scale, and base x position\n   */\n  get width(): number {\n    return this.scales.scale_x(this.node.x1) - this.x;\n  }\n\n  /**\n   * Compute the height of this rect based on scale, and base y position\n   */\n  get height(): number {\n    return this.scales.scale_y(this.node.y1) - this.y;\n  }\n\n  /** Returns a list of classes appropriate to this nodes Rect\n   * These are contextual based on type of data, and depth within the tree\n   */\n  get cell_classes(): string[] {\n    const s: string[] = [];\n    if (this.is_parent) {\n      s.push('parent');\n      if (!this.node.children || !this.node.children.length) {\n        s.push('empty');\n      }\n    } else {\n      s.push('leaf');\n    }\n\n    // Depth stuff\n    if (this.depth === 0) {\n      s.push('root');\n    } else if (this.depth === 1) {\n      s.push('top');\n    } else if (this.depth >= 1) {\n      s.push('nested');\n    }\n\n    return s;\n  }\n\n  get cell_style(): string {\n    if (this.node.data.color) {\n      return `fill: ${this.node.data.color.css()};`;\n    }\n    return 'fill-opacity: 0';\n  }\n\n  /**\n   * Callback fired when the user clicks a node. Passes up from cell to cell until it reaches Treemap\n   */\n  select_node(n: d3.HierarchyRectangularNode<TreemapNode>): void {\n    // Pass it up to root\n    this.$emit('select-node', n);\n  }\n}\n</script>\n\n<style scoped>\ntext {\n  pointer-events: none;\n}\n\n.theme--dark text {\n  fill: #f8f8f8;\n  font-size: large;\n}\n\n/* Basic settings for our chart. Things unclickable by default */\nrect {\n  stroke: #000000;\n  pointer-events: none;\n  fill-opacity: 0;\n}\n\n/* We want top to be clickable. */\nrect.top {\n  pointer-events: auto;\n  stroke-width: 2;\n}\n\n/* We want leaves */\nrect.leaf {\n  fill-opacity: 1;\n}\n\n/* Otherwise, don't want nested to draw strokes */\nrect.nested {\n  stroke-width: 1;\n}\n\nrect.nested.leaf {\n  stroke-width: 0;\n}\n\n/* Make tops transparent but also more thickly drawn when hovered */\nrect.top:hover {\n  stroke-width: 3;\n}\n</style>\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/components/generic/ApexLineChart.vue": "<template>\n  <div style=\"color: black\">\n    <vue-apex-charts\n      type=\"line\"\n      height=\"350\"\n      :options=\"chartOptions\"\n      :series=\"series\"\n    />\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport {ApexOptions} from 'apexcharts';\nimport Vue from 'vue';\nimport VueApexCharts from 'vue-apexcharts';\nimport Component from 'vue-class-component';\nimport {Prop} from 'vue-property-decorator';\nimport {Category} from './ApexPieChart.vue';\n\nexport interface SeriesItem {\n  name: string;\n  data: number[];\n}\n\n/**\n * Emits \"category-selected\" with payload of type Category whenever a category is selected.\n */\n@Component({\n  components: {\n    VueApexCharts\n  }\n})\nexport default class ApexLineChart extends Vue {\n  @Prop({required: true, type: Array}) readonly categories!: Category<string>[];\n  @Prop({required: true, type: Array}) readonly series!: number[];\n  @Prop({type: Number}) readonly upperRange!: number; //upper bound of y axis\n  @Prop({type: Boolean}) readonly sevChart!: boolean; //identifies chart as severity chart\n  @Prop({type: String}) readonly title!: string;\n  @Prop({type: String}) readonly yTitle!: string;\n\n  //gives apex charts the severity colors\n  sevColors: string[] = ['#FFEB3B', '#FF9800', '#FF5722', '#F44336'];\n\n  get label_colors(): string[] {\n    const colors = [];\n    for (let i = 0; i < this.categories.length; i++) {\n      colors.push('#FFFFFF');\n    }\n    return colors;\n  }\n\n  //creates differing number of ticks based on number of controls\n  get y_axis_tick(): number {\n    if (this.upperRange < 15) {\n      return this.upperRange;\n    } else if (this.upperRange < 50) {\n      return Math.floor(this.upperRange / 5);\n    } else {\n      return Math.floor(this.upperRange / 10);\n    }\n  }\n\n  get line_colors(): string[] | undefined {\n    if (this.sevChart) {\n      return this.sevColors;\n    }\n    return undefined;\n  }\n\n  // Generate the chart options based on _categories\n  get chartOptions(): ApexOptions {\n    return {\n      chart: {\n        height: 350,\n        type: 'line',\n        zoom: {\n          enabled: false\n        }\n        //background: '#000'\n      },\n      colors: this.line_colors,\n      dataLabels: {\n        enabled: false\n      },\n      stroke: {\n        width: 5,\n        curve: 'straight'\n      },\n      title: {\n        text: this.title,\n        align: 'left',\n        style: {\n          fontFamily: 'Arial Black',\n          fontSize: '14px',\n          color: '#FFFFFF'\n        }\n      },\n      legend: {\n        labels: {\n          useSeriesColors: true\n        }\n      },\n      xaxis: {\n        categories: this.categories,\n        labels: {\n          style: {\n            colors: this.label_colors\n          }\n        }\n      },\n      yaxis: {\n        min: 0,\n        max: this.upperRange,\n        tickAmount: this.y_axis_tick,\n        axisTicks: {\n          color: '#FF0000'\n        },\n        axisBorder: {\n          show: true,\n          color: '#FFFFFF',\n          offsetX: 0,\n          offsetY: 0\n        },\n        title: {\n          text: this.yTitle,\n          style: {\n            color: '#FFFFFF'\n          }\n        },\n        labels: {\n          style: {\n            colors: '#FFFFFF'\n          }\n        }\n      },\n      grid: {\n        borderColor: '#f1f1f1'\n      }\n    };\n  }\n}\n</script>\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/utilities/delta_util.ts": "/**\n * Provides utlities for comparing executions\n */\n\nimport {SourcedContextualizedEvaluation} from '@/store/report_intake';\nimport {ContextualizedControl, ContextualizedEvaluation} from 'inspecjs';\nimport {DateTime} from 'luxon';\n\nexport const NOT_SELECTED = 'not selected';\n\n// Unique ID is the unique ID of a file\n// Controls is a list of controls\ninterface ResultControls {\n  uniqueId: string;\n  controls: ContextualizedControl[];\n}\n\n/**\n * Represents a change in a property.\n * We assume that the \"old\" property is the name to use for both.\n * IE that they are the same property value.\n */\nexport class ControlChange {\n  name: string; // the key/title of these values\n  values: string[]; // values over controls sorted by time\n\n  /** Trivial constructor */\n  constructor(name: string, values: string[]) {\n    this.values = values;\n    this.name = name;\n  }\n\n  /** Checks if this actually changes anything.\n   * Returns true iff old !== new\n   */\n  get valid(): boolean {\n    let firstSelected = -1;\n    for (let i = 0; i < this.values.length; i++) {\n      if (this.values[i] !== NOT_SELECTED) {\n        firstSelected = i;\n        break;\n      }\n    }\n    if (firstSelected === -1) {\n      return false;\n    }\n    for (let i = firstSelected + 1; i < this.values.length; i++) {\n      if (\n        this.values[i] !== this.values[firstSelected] &&\n        this.values[i] !== NOT_SELECTED\n      ) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\n/**\n * Represents a group of changes all under one cnosistent named banner.\n */\nexport class ControlChangeGroup {\n  name: string;\n  changes: ControlChange[];\n\n  /** Trivial constructor */\n  constructor(name: string, changes: ControlChange[]) {\n    this.name = name;\n    this.changes = changes;\n  }\n\n  /** Checks if this has any changes at all. Simple shorthand */\n  get any(): boolean {\n    return this.changes.length > 0;\n  }\n\n  /** Removes any changes if they aren't actually changes */\n  clean() {\n    this.changes = this.changes.filter((c) => c.valid);\n  }\n}\n\n/**\n * Holds/computes the differences between two runs of the same control.\n */\nexport class ControlDelta {\n  controls: ContextualizedControl[] = [];\n  controlsandnull: (ContextualizedControl | null)[] = [];\n  numNull = 0;\n\n  constructor(controls: (ContextualizedControl | null)[]) {\n    this.controlsandnull = controls;\n    for (const value of controls) {\n      if (value !== null) {\n        this.controls.push(value);\n      } else {\n        this.numNull += 1;\n      }\n    }\n  }\n\n  /** Returns the changes in \"header\" elements of a control. E.g. name, status, etc. */\n  get headerChanges(): ControlChangeGroup {\n    // Init the list\n    const headerChanges: ControlChange[] = [];\n\n    // Change in... ID? Theoretically possible!\n    headerChanges.push(\n      new ControlChange(\n        'ID',\n        this.controlsandnull.map((c) => {\n          if (c === null) {\n            return NOT_SELECTED;\n          }\n          return c.data.id;\n        })\n      )\n    );\n\n    // And severity! Why not\n    headerChanges.push(\n      new ControlChange(\n        'Severity',\n        this.controlsandnull.map((c) => {\n          if (c === null) {\n            return NOT_SELECTED;\n          }\n          return c.hdf.severity;\n        })\n      )\n    );\n\n    // Change in nist tags!\n    headerChanges.push(\n      new ControlChange(\n        'NIST Tags',\n        this.controlsandnull.map((c) => {\n          if (c === null) {\n            return NOT_SELECTED;\n          }\n          return c.hdf.rawNistTags.join(', ');\n        })\n      )\n    );\n\n    // Make the group and clean it\n    const result = new ControlChangeGroup('Control Details', headerChanges);\n    result.clean();\n    return result;\n  }\n}\n\nexport function get_eval_start_time(\n  ev: ContextualizedEvaluation\n): string | null {\n  for (const prof of ev.contains) {\n    for (const ctrl of prof.contains) {\n      if (ctrl.hdf.segments!.length) {\n        return ctrl.hdf.segments![0].start_time;\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Grabs the \"top\" (IE non-overlayed/end of overlay chain) controls from the execution.\n *\n * @param exec The execution to grab controls from\n */\nfunction extract_top_level_controls(\n  exec: SourcedContextualizedEvaluation\n): ResultControls {\n  // Get all controls\n  const allControls = exec.contains.flatMap((p) => p.contains);\n\n  // Filter to controls that aren't overlayed further\n  const top = allControls.filter((control) => control.extendedBy.length === 0);\n  return {uniqueId: exec.from_file.uniqueId, controls: top};\n}\n\n/** An object of contextualized controls with the same V-ID */\nexport type ControlSeries = {[key: string]: ContextualizedControl};\n\n/** Matches ControlID keys to Arrays of Controls */\nexport type ControlSeriesLookup = {[key: string]: ControlSeries};\n\n/** Helps manage comparing change(s) between one or more profile executions */\nexport class ComparisonContext {\n  /** A list of old-new control pairings */\n  pairings: ControlSeriesLookup;\n\n  constructor(executions: readonly SourcedContextualizedEvaluation[]) {\n    // Get all of the \"top level\" controls from each execution, IE those that actually ran\n    // grouped by their files unique id.\n    const allControls = executions.map(extract_top_level_controls);\n    // Organize the controls by ID\n    // The structure this returns is as follows:\n    // {{\"V-XXX\": {\"unique_file_id_1\": control, \"unique_file_id_2\": control, ...}}}\n    const matched = allControls.reduce(\n      (acc: ControlSeriesLookup, evaluation: ResultControls) => {\n        evaluation.controls.forEach((control) => {\n          // Group initialization\n          if (!acc[control.data.id]) {\n            acc[control.data.id] = {};\n          }\n          // Grouping\n          acc[control.data.id][evaluation.uniqueId] = control;\n        });\n\n        return acc;\n      },\n      {}\n    );\n    // Store\n    this.pairings = matched;\n  }\n}\n\n/*\n  DateTime parsing in Chrome works very different than Safari and Firefox\n  Using luxon provides consistent timestamp information with a fallback to\n  using the native browser date parsing.\n\n  Chrome already supports parsing all of these formats natively, however it\n  is the only browser that does so.\n*/\nexport function parse_datetime(dateString: string): DateTime {\n  let result: DateTime;\n\n  result = DateTime.fromRFC2822(dateString);\n  if (result.isValid) {\n    return result;\n  }\n  result = DateTime.fromISO(dateString);\n  if (result.isValid) {\n    return result;\n  }\n  result = DateTime.fromHTTP(dateString);\n  if (result.isValid) {\n    return result;\n  }\n  result = DateTime.fromSQL(dateString);\n  if (result.isValid) {\n    return result;\n  }\n\n  return DateTime.fromJSDate(new Date(dateString));\n}\n\nexport function compare_times(\n  a: SourcedContextualizedEvaluation,\n  b: SourcedContextualizedEvaluation\n) {\n  const aDate = parse_datetime(get_eval_start_time(a) || '');\n  const bDate = parse_datetime(get_eval_start_time(b) || '');\n\n  return aDate.valueOf() - bDate.valueOf();\n}\n\n",
  "/api/sources/raw?key=test:apps/frontend/tests/unit/Compare.spec.ts": "import {FilteredDataModule} from '@/store/data_filters';\nimport {SearchModule} from '@/store/search';\nimport {StatusCountModule} from '@/store/status_counts';\nimport {ComparisonContext, ControlSeries} from '@/utilities/delta_util';\nimport Compare from '@/views/Compare.vue';\nimport {shallowMount, Wrapper} from '@vue/test-utils';\nimport 'jest';\nimport Vue from 'vue';\nimport Vuetify from 'vuetify';\nimport {fileCompliance, loadSample, removeAllFiles} from '../util/testingUtils';\n\nconst vuetify = new Vuetify();\n\nconst wrapper: Wrapper<Vue> = shallowMount(Compare, {\n  vuetify,\n  propsData: {}\n});\n\nexport interface SeriesItem {\n  name: string;\n  data: number[];\n}\n\nconst redHatControlCount = 247;\nconst nginxControlCount = 41;\nconst nginxDelta = 3;\n\ndescribe('Compare table data', () => {\n  loadSample('NGINX With Failing Tests');\n  it('correctly counts controls with 1 file', () => {\n    (wrapper.vm as Vue & {changedOnly: boolean}).changedOnly = false;\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(nginxControlCount);\n  });\n\n  it('does not recount same controls with 2 files', () => {\n    loadSample('NGINX With Failing Tests');\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(nginxControlCount);\n  });\n\n  it('does not recount same controls with 3 files', () => {\n    loadSample('NGINX With Failing Tests');\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(nginxControlCount);\n  });\n\n  it('does not show any changed between two of the same', () => {\n    (wrapper.vm as Vue & {changedOnly: boolean}).changedOnly = true;\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(0);\n  });\n\n  it('search works when nothing fits criteria', () => {\n    (wrapper.vm as Vue & {searchTerm: string}).searchTerm = 'failed';\n    SearchModule.parseSearch();\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(0);\n  });\n\n  it('search id works', () => {\n    (wrapper.vm as Vue & {changedOnly: boolean}).changedOnly = false;\n    (wrapper.vm as Vue & {searchTerm: string}).searchTerm = 'v-13613';\n    SearchModule.parseSearch();\n    setTimeout(() => {\n      expect(\n        (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n          .length\n      ).toBe(1);\n    }, 1000);\n  });\n\n  it('shows differing delta data when \"show only changed\"', () => {\n    (wrapper.vm as Vue & {searchTerm: string}).searchTerm = '';\n    (wrapper.vm as Vue & {changedOnly: boolean}).changedOnly = true;\n    loadSample('NGINX Clean Sample');\n    SearchModule.parseSearch();\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(nginxDelta);\n  });\n\n  it('search status works', () => {\n    (wrapper.vm as Vue & {changedOnly: boolean}).changedOnly = false;\n    (wrapper.vm as Vue & {searchTerm: string}).searchTerm = 'failed';\n    SearchModule.parseSearch();\n    setTimeout(() => {\n      expect(\n        (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n          .length\n      ).toBe(nginxDelta);\n    }, 1000);\n  });\n\n  it('counts every unique control', () => {\n    loadSample('Red Hat With Failing Tests');\n    (wrapper.vm as Vue & {searchTerm: string}).searchTerm = '';\n    (wrapper.vm as Vue & {changedOnly: boolean}).changedOnly = true;\n    SearchModule.parseSearch();\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(nginxControlCount + redHatControlCount);\n  });\n\n  it('shows all delta data of controls with multiple occurances when \"show only changed\"', () => {\n    loadSample('Red Hat Clean Sample');\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(nginxControlCount + redHatControlCount);\n  });\n\n  it('ComparisonContext counts status correctly', () => {\n    let failed = 0;\n    let passed = 0;\n    let na = 0;\n    let nr = 0;\n    let pe = 0;\n    const selectedData = FilteredDataModule.evaluations(\n      FilteredDataModule.selected_file_ids\n    );\n    const currDelta = new ComparisonContext(selectedData);\n    for (const pairing of Object.values(currDelta.pairings)) {\n      for (const ctrl of Object.values(pairing)) {\n        if (ctrl === null) {\n          continue;\n        } else if (ctrl.root.hdf.status === 'Passed') {\n          passed++;\n        } else if (ctrl.root.hdf.status === 'Failed') {\n          failed++;\n        } else if (ctrl.root.hdf.status === 'Not Applicable') {\n          na++;\n        } else if (ctrl.root.hdf.status === 'Not Reviewed') {\n          nr++;\n        } else if (ctrl.root.hdf.status === 'Profile Error') {\n          pe++;\n        }\n      }\n    }\n    const expected = {\n      Failed: StatusCountModule.hash({\n        omit_overlayed_controls: true,\n        fromFile: [...FilteredDataModule.selected_file_ids]\n      }).Failed,\n      Passed: StatusCountModule.hash({\n        omit_overlayed_controls: true,\n        fromFile: [...FilteredDataModule.selected_file_ids]\n      }).Passed,\n      'From Profile': 0,\n      'Profile Error': StatusCountModule.hash({\n        omit_overlayed_controls: true,\n        fromFile: [...FilteredDataModule.selected_file_ids]\n      })['Profile Error'],\n      'Not Reviewed': StatusCountModule.hash({\n        omit_overlayed_controls: true,\n        fromFile: [...FilteredDataModule.selected_file_ids]\n      })['Not Reviewed'],\n      'Not Applicable': StatusCountModule.hash({\n        omit_overlayed_controls: true,\n        fromFile: [...FilteredDataModule.selected_file_ids]\n      })['Not Applicable']\n    };\n    const actual = {\n      Failed: failed,\n      Passed: passed,\n      'From Profile': 0,\n      'Profile Error': pe,\n      'Not Reviewed': nr,\n      'Not Applicable': na\n    };\n    expect(actual).toEqual(expected);\n  });\n});\n\ndescribe('compare charts', () => {\n  it('sev chart gets correct data with 2 files', () => {\n    removeAllFiles();\n    loadSample('NGINX With Failing Tests');\n    loadSample('NGINX Clean Sample');\n    //the values in expected are the correct data\n    expect((wrapper.vm as Vue & {sev_series: number[][]}).sev_series).toEqual([\n      [0, 0],\n      [3, 0],\n      [0, 0],\n      [0, 0]\n    ]);\n  });\n\n  it('sev chart gets correct data with 2 files with differing profiles', () => {\n    removeAllFiles();\n    loadSample('NGINX With Failing Tests');\n    loadSample('Red Hat With Failing Tests');\n    //the values in expected are the correct data\n    expect((wrapper.vm as Vue & {sev_series: number[][]}).sev_series).toEqual([\n      [0, 6],\n      [3, 18],\n      [0, 3],\n      [0, 0]\n    ]);\n  });\n\n  it('sev chart gets correct data with 2 files with overlayed profiles', () => {\n    removeAllFiles();\n    loadSample('Triple Overlay Example');\n    loadSample('Acme Overlay Example');\n    //the values in expected are the correct data\n    expect((wrapper.vm as Vue & {sev_series: number[][]}).sev_series).toEqual([\n      [3, 0],\n      [51, 0],\n      [1, 0],\n      [0, 60]\n    ]);\n  });\n\n  it('compliance chart gets correct data with 2 files', () => {\n    removeAllFiles();\n    loadSample('NGINX With Failing Tests');\n    loadSample('NGINX Clean Sample');\n    expect(\n      new Set(\n        (\n          wrapper.vm as Vue & {\n            compliance_series: SeriesItem[];\n          }\n        ).compliance_series[0].data\n      )\n    ).toEqual(\n      new Set([\n        fileCompliance(FilteredDataModule.selected_file_ids[0]),\n        fileCompliance(FilteredDataModule.selected_file_ids[1])\n      ])\n    );\n  });\n\n  it('compliance chart gets correct data with 2 files with differing profiles', () => {\n    removeAllFiles();\n    loadSample('NGINX With Failing Tests');\n    loadSample('Red Hat With Failing Tests');\n    expect(\n      new Set(\n        (\n          wrapper.vm as Vue & {\n            compliance_series: SeriesItem[];\n          }\n        ).compliance_series[0].data\n      )\n    ).toEqual(\n      new Set([\n        fileCompliance(FilteredDataModule.selected_file_ids[0]),\n        fileCompliance(FilteredDataModule.selected_file_ids[1])\n      ])\n    );\n  });\n\n  it('compliance chart gets correct data with 2 files with overlayed profiles', () => {\n    removeAllFiles();\n    loadSample('Triple Overlay Example');\n    loadSample('Acme Overlay Example');\n    expect(\n      new Set(\n        (\n          wrapper.vm as Vue & {\n            compliance_series: SeriesItem[];\n          }\n        ).compliance_series[0].data\n      )\n    ).toEqual(\n      new Set([\n        fileCompliance(FilteredDataModule.selected_file_ids[0]),\n        fileCompliance(FilteredDataModule.selected_file_ids[1])\n      ])\n    );\n  });\n});\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/utilities/splunk_util.ts": "import {ConversionResult, convertFile, ExecJSON} from 'inspecjs';\nimport {ElementCompact, xml2js} from 'xml-js';\nimport {delay} from './async_util';\nimport {basic_auth, group_by, map_hash} from './helper_util';\n\nexport type JobID = string;\n\n// Interfaces\n/** The parent type to other interfaces, to save duplication */\ninterface AbsMetaInfo {\n  /** The file this came from */\n  filename: string;\n\n  /** The type of the file (NOT of this event!) */\n  filetype: 'evaluation' | 'profile';\n\n  /** The subtype of this specific event */\n  subtype: 'header' | 'profile' | 'control';\n\n  /** A randomly generated GUID capturing all of the events in this file */\n  guid: string;\n\n  /** When this event was parsed */\n  parse_time: string;\n\n  /** The schema version: */\n  hdf_splunk_schema: string;\n\n  /** The sha256 hash of the profile that is/contains this event */\n  profile_sha256: string;\n\n  /** The start time of the control in ISO format */\n  startTime: string;\n\n  /** The control ID, repeated for convenience in splunk searches */\n  control_id: string;\n}\n\n/** The meta information for an event with the \"evaluation\" subtype */\nexport interface ExecutionMetaInfo\n  extends Omit<AbsMetaInfo, 'control_id' | 'startTime' | 'profile_sha256'> {\n  subtype: 'header';\n}\n\n/** The meta information for an event with the \"profile\" subtype */\nexport interface ProfileMetaInfo\n  extends Omit<AbsMetaInfo, 'control_id' | 'startTime'> {\n  subtype: 'profile';\n}\n\n/** The meta information for an event with the \"control\" subtype */\nexport interface ControlMetaInfo extends AbsMetaInfo {\n  subtype: 'control';\n}\n\n/** This is what we expect to find in every parsed event representing an Evaluation\n * Note that Profiles will typically be initially empty\n */\nexport interface ExecutionPayload {\n  meta: ExecutionMetaInfo;\n  profiles: ProfilePayload[];\n}\n\n/** This is what we expect to find in every parsed event representing a Profile.\n * Note that controls will typically be initially empty\n */\nexport interface ProfilePayload {\n  meta: ProfileMetaInfo;\n  controls: ControlPayload[];\n}\n\n/** This is what we expect to find in every parsed event representing a Control */\nexport interface ControlPayload {\n  meta: ControlMetaInfo;\n}\n\n// Could be any!\nexport type UnknownPayload = ExecutionPayload | ProfilePayload | ControlPayload;\n\n/* Job states */\ntype CompleteJobStatus = 'succeeded' | 'failed';\ntype PendingJobStatus = 'pending'; // There are others, but we don't handle them for now\ntype JobStatus = CompleteJobStatus | PendingJobStatus;\ninterface JobState {\n  status: JobStatus;\n  jobId: JobID;\n}\n\n/** This info is used to negotiate splunk connections */\nexport class SplunkEndpoint {\n  /** The full host information, including port (typically 8089).\n   * EX: https://localhost:8089\n   */\n  host: string;\n\n  /** Username to use for authentication */\n  username: string;\n\n  /** Password to use for authentication */\n  password: string;\n\n  constructor(host: string, username: string, password: string) {\n    this.host = host;\n    this.username = username;\n    this.password = password;\n  }\n\n  /** Checks whether we're able to successfully get jobs,\n   * which indicates proper auth.\n   *\n   * Will error if we aren't\n   */\n\n  process_response(response: Response) {\n    if (!response.ok) {\n      throw process_error(response);\n    }\n    return response.text();\n  }\n\n  async check_auth(): Promise<void> {\n    return fetch(`${this.host}/services/search/jobs`, {\n      headers: {\n        Authorization: this.authString\n      },\n      method: 'GET'\n    }).then(\n      (response) => {\n        if (!response.ok) {\n          throw process_error(response);\n        }\n      },\n      (failure) => {\n        throw process_error(failure);\n      }\n    );\n  }\n\n  /** Provides a list of Evaluation meta headers from recent executions.\n   * We should eventually change this to allow more specific criteria\n   */\n  async fetch_execution_list(): Promise<ExecutionMetaInfo[]> {\n    // This search lists evaluation headers\n    const getExecutionsSearch =\n      'spath \"meta.subtype\" | search \"meta.subtype\"=header';\n\n    return this.hdf_event_search(getExecutionsSearch).then((events) => {\n      // Because we only searched for headers, we can assume these to be eval events\n      const evalEvents = events as ExecutionPayload[];\n\n      // Could perhaps just return e but I'd rather people didn't screw themselves\n      return evalEvents.map((e) => e.meta);\n    });\n  }\n\n  async get_execution_events(executionGuid: string): Promise<UnknownPayload[]> {\n    // This search, provided a guid, returns all headers for that guid\n    const specificEvaluation = `spath \"meta.guid\" | search \"meta.guid\"=${executionGuid}`;\n    return this.hdf_event_search(specificEvaluation);\n  }\n\n  async get_execution(executionGuid: string): Promise<ExecJSON.Execution> {\n    return this.get_execution_events(executionGuid)\n      .then((events) => consolidate_payloads(events))\n      .then((execs) => {\n        if (execs.length !== 1) {\n          throw SplunkErrorCode.InvalidGUID;\n        } else {\n          return execs[0];\n        }\n      })\n      .then((fullEvent) => {\n        // This is dumb and we should make the inspecjs layer more accepting of many file types\n        let result: ConversionResult;\n        try {\n          result = convertFile(JSON.stringify(fullEvent));\n        } catch (e) {\n          throw SplunkErrorCode.SchemaViolation;\n        }\n\n        // Determine what sort of file we (hopefully) have, then add it\n        if (result['1_0_ExecJson']) {\n          // Handle as exec\n          return result['1_0_ExecJson'];\n        } else {\n          throw SplunkErrorCode.SchemaViolation;\n        }\n      });\n  }\n\n  /** Creates a proper base64 encoded auth string, using this objects credentials. */\n  private get authString(): string {\n    return basic_auth(this.username, this.password);\n  }\n\n  /** Performs the entire process of search string -> results array\n   *  Performs no consolidation.\n   *  Assumes your search string is properly constrained to the hdf index\n   */\n  async hdf_event_search(searchString: string): Promise<UnknownPayload[]> {\n    return this.create_search(searchString)\n      .then((jobId) => this.pend_job(jobId, 500))\n      .then((jobState) => {\n        if (jobState.status === 'failed') {\n          throw SplunkErrorCode.SearchFailed;\n        }\n\n        return this.get_search_results(jobState.jobId);\n      })\n      .catch((error) => {\n        throw process_error(error);\n      });\n  }\n\n  /** Returns the job id */\n  private async create_search(searchString: string): Promise<JobID> {\n    return fetch(`${this.host}/services/search/jobs`, {\n      method: 'POST',\n      headers: new Headers({\n        Authorization: this.authString\n      }),\n      body: `search=search index=\"hdf\" | ${searchString}`\n    })\n      .then(this.process_response)\n      .then((text) => {\n        // Parse the xml\n        const xml = xml2js(text, {\n          compact: true\n        }) as ElementCompact;\n        return xml.response.sid._text as string;\n      });\n  }\n\n  /** Returns the current state of the job */\n  private async check_job(jobId: JobID): Promise<JobState> {\n    return fetch(`${this.host}/services/search/jobs/${jobId}`, {\n      method: 'GET',\n      headers: new Headers({\n        Authorization: this.authString\n      })\n    })\n      .then(this.process_response)\n      .then((text) => {\n        // Parse the xml\n        const xml = xml2js(text, {\n          compact: true\n        }) as ElementCompact;\n\n        // Get the keys, and find the one with name \"dispatchState\"\n        const keys = xml.entry.content['s:dict']['s:key'];\n        let state: string | undefined;\n        for (const k of keys) {\n          if (k._attributes.name === 'dispatchState') {\n            state = k._text;\n          }\n        }\n\n        // Check we found state\n        if (!state) {\n          // It probably failed if we can't find it lol\n          state = 'FAILED';\n        }\n\n        // Decide result based on state\n        let status: JobStatus;\n        if (state === 'DONE') {\n          status = 'succeeded';\n        } else if (state === 'FAILED') {\n          status = 'failed';\n        } else {\n          status = 'pending';\n        }\n\n        // Construct the state\n        return {\n          status,\n          jobId\n        };\n      });\n  }\n\n  /** Continually checks the job until resolution */\n  private async pend_job(jobId: JobID, interval: number): Promise<JobState> {\n    /* eslint-disable */\n        while (true) {\n            /* eslint-enable */\n      const state = await this.check_job(jobId);\n      if (state.status === 'pending') {\n        await delay(interval);\n      } else {\n        return state;\n      }\n    }\n  }\n\n  /** Gets the search results for a given job id, if it is done */\n  private async get_search_results(jobId: JobID): Promise<UnknownPayload[]> {\n    return fetch(\n      `${this.host}/services/search/jobs/${jobId}/results/?output_mode=json&count=0`,\n      {\n        headers: {\n          Authorization: this.authString\n        },\n        method: 'GET'\n      }\n    )\n      .then((response) => {\n        if (!response.ok) {\n          throw process_error(response);\n        }\n        return response.json();\n      })\n      .then((data) => {\n        // We basically can't, and really shouldn't, do typescript here. Output is 50% guaranteed to be wonk\n        // Get all the raws\n        const raws: Array<string> = data['results'].map(\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          (datum: any) => datum._raw\n        );\n\n        // Parse to json, and freeze\n        const parsed = [] as UnknownPayload[];\n        for (const v of raws) {\n          try {\n            parsed.push(JSON.parse(v) as UnknownPayload);\n          } catch (err) {\n            // eslint-disable-next-line no-console\n            console.warn(err);\n          }\n        }\n\n        return parsed;\n      });\n  }\n}\n\n/** Given: A list of all payloads from a search,\n * Produce: A list of Evaluation payloads containing all data properly reconstructed, recursively, into a \"normal\"\n * HDF heirarchy.\n *\n * TODO: Provide a mechanism for also returning orphaned items\n */\nexport function consolidate_payloads(\n  payloads: UnknownPayload[]\n): ExecutionPayload[] {\n  // Group by exec id\n  const grouped = group_by(payloads, (pl) => pl.meta.guid);\n\n  const built = map_hash(grouped, consolidate_file_payloads);\n\n  return Object.values(built);\n}\n\n/** Given: A list of all payloads from a search with the same GUID\n * Produce: A single EvaluationPayload containing all of these payloads reconstructed into the expected HDF heirarchy\n */\nfunction consolidate_file_payloads(\n  filePayloads: UnknownPayload[]\n): ExecutionPayload {\n  // In the end we wish to produce a single evaluation EventPayload which in fact contains all data for the guid\n  // Group by subtype\n  const subtypes = group_by(filePayloads, (event) => event.meta.subtype);\n  const execEvents = (subtypes['header'] || []) as ExecutionPayload[];\n  const profileEvents = (subtypes['profile'] || []) as ProfilePayload[];\n  const controlEvents = (subtypes['control'] || []) as ControlPayload[];\n\n  // Verify we only have one exec event\n  if (execEvents.length !== 1) {\n    throw new Error(\n      `Incorrect # of Evaluation events. Expected 1, got ${execEvents.length}`\n    );\n  }\n\n  // Pull it out\n  const exec = execEvents[0];\n\n  // Put all the profiles into the exec\n  exec.profiles.push(...profileEvents);\n\n  // Group controls, and then put them into the profiles\n  const shaGroupedControls = group_by(\n    controlEvents,\n    (ctrl) => ctrl.meta.profile_sha256\n  );\n  for (const profile of profileEvents) {\n    // Get the corresponding controls, and put them into the profile\n    const sha = profile.meta.profile_sha256;\n    const corrControls = shaGroupedControls[sha] || [];\n    profile.controls.push(...corrControls);\n  }\n\n  // Spit it back out\n  return exec;\n}\n\nexport enum SplunkErrorCode {\n  BadNetwork, // Server could not be reached, either due to bad address or bad CORS\n  BadUrl, // URL poorly formed\n  PageNotFound, // Server gave error 404\n  BadAuth, // Authorization credentials are no good\n  SearchFailed, // For whatever reason, the splunk search failed\n  ConsolidationFailed, // Something went wrong during event consolidation phase\n  SchemaViolation, // The data we got out isn't valid HDF. Hope to not see this too often\n  InvalidGUID, // If the provided GUID did not match to exactly one header\n  UnknownError // No clue!\n}\n\n/** Converts Responses and Errorcodes into purely just errorcodes */\nexport function process_error(\n  r: Response | SplunkErrorCode | TypeError\n): SplunkErrorCode {\n  if (r instanceof TypeError) {\n    if (r.message.includes('NetworkError')) {\n      return SplunkErrorCode.BadNetwork;\n    } else if (r.message.includes('not a valid URL')) {\n      return SplunkErrorCode.BadUrl;\n    }\n  } else if (r instanceof Response) {\n    // Based on the network code, guess\n    const response = r;\n    switch (response.status) {\n      case 401: // Bad username/password\n        return SplunkErrorCode.BadAuth;\n      case 404: // URL got borked\n        return SplunkErrorCode.PageNotFound;\n      default:\n        return SplunkErrorCode.UnknownError;\n    }\n  } else if (typeof r === typeof SplunkErrorCode.UnknownError) {\n    // It's already an error code - pass along\n    return r;\n  }\n  // idk lol\n  return SplunkErrorCode.UnknownError;\n}\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/utilities/treemap_util.ts": "/**\n * Tools used for generating the treemaps consumed by, of course, the Treemap card and associated components.\n */\n\nimport {ColorHack} from '@/store/color_hack';\nimport Chroma from 'chroma-js';\nimport * as d3 from 'd3';\nimport {\n  ContextualizedControl,\n  FULL_NIST_HIERARCHY,\n  NistControl,\n  NistHierarchyNode\n} from 'inspecjs';\nimport {control_unique_key} from './format_util';\n\n// How deep into nist trees we allow\nconst depthMax = 2;\n\n/** A simple wrapper type representing what any node's data might be in our treemap */\ninterface AbsTreemapNode {\n  title: string;\n  subtitle?: string;\n  hovertext?: string;\n  key: string;\n  color?: Chroma.Color;\n  parent: TreemapNodeParent | null; // The parent of this node.\n  nist_control: NistControl; // The nist control which this node is associated with. Not necessarily unique (e.g. leaves)\n}\nexport interface TreemapNodeParent extends AbsTreemapNode {\n  children: TreemapNode[]; // Maps the next sub-specifier to children\n}\n\nexport interface TreemapNodeLeaf extends AbsTreemapNode {\n  control: ContextualizedControl;\n}\n\nexport function is_leaf(n: TreemapNode): n is TreemapNodeLeaf {\n  return (n as TreemapNodeLeaf).control !== undefined;\n}\n\nexport function is_parent(n: TreemapNode): n is TreemapNodeParent {\n  return (n as TreemapNodeParent).children !== undefined;\n}\n\n/** The type of our treemap nodes, prior to rendering */\nexport type TreemapNode = TreemapNodeLeaf | TreemapNodeParent;\nexport type D3TreemapNode = d3.HierarchyNode<TreemapNode>;\n\n/**\n * Converts a list of controls to treemap leaves.\n * Actually a one-to-many mapping since we must make a unique leaf for each nist control on each control!\n * @param controls The controls to build into a nist node map\n */\nfunction controls_to_nist_node_data(\n  contextualizedControls: Readonly<ContextualizedControl[]>,\n  colors: ColorHack\n): TreemapNodeLeaf[] {\n  return contextualizedControls.flatMap((cc) => {\n    // Get the status color\n    const color = Chroma.hex(colors.colorForStatus(cc.root.hdf.status));\n    // Now make leaves for each nist control\n    return cc.root.hdf.parsedNistTags.map((nc) => {\n      return {\n        title: cc.data.id,\n        subtitle: cc.data.title || undefined,\n        hovertext: cc.data.desc || undefined,\n        key: control_unique_key(cc) + nc.rawText,\n        control: cc,\n        nist_control: nc,\n        color,\n        parent: null // We set this later\n      };\n    });\n  });\n}\n\n/** Builds a scaffolding for the nist items using the given root.\n * Also constructs a lookup table of control nodes.\n * Only goes maxDepth deep.\n */\nfunction recursive_nist_map(\n  parent: TreemapNodeParent | null,\n  node: Readonly<NistHierarchyNode>,\n  controlLookup: {[key: string]: TreemapNodeParent},\n  maxDepth: number\n): TreemapNodeParent {\n  // Init child list\n  const children: TreemapNode[] = [];\n\n  // Make our final value\n  const ret: TreemapNodeParent = {\n    key: node.control.rawText || '',\n    title: node.control.rawText || '',\n    nist_control: node.control,\n    parent,\n    children\n  };\n\n  // Fill our children\n  if (node.control.subSpecifiers.length < maxDepth) {\n    node.children.forEach((child) => {\n      // Assign it, recursively computing the rest\n      children.push(recursive_nist_map(ret, child, controlLookup, maxDepth));\n    });\n  }\n\n  // Save to lookup\n  controlLookup[lookup_key_for(node.control, maxDepth)] = ret;\n  return ret;\n}\n\n/** Colorizes a treemap based on each nodes children. */\nfunction colorize_tree_map(root: TreemapNodeParent) {\n  // First colorize children, recursively\n  root.children.forEach((child) => {\n    if (is_parent(child)) {\n      colorize_tree_map(child);\n    }\n  });\n\n  // Now all children should have valid colors\n  // We decide this node's color as a composite of all underlying node colors\n  const childColors = root.children\n    .map((c) => c.color)\n    .filter((c): c is Chroma.Color => !!c);\n  // If we have any, then set our color\n  if (childColors.length) {\n    // Set the color\n    const avgColor = Chroma.average(childColors);\n    root.color = avgColor;\n  }\n}\n\n/** Generates a lookup key for the given control */\nfunction lookup_key_for(x: NistControl, maxDepth: number): string {\n  if (maxDepth) {\n    return x.subSpecifiers.slice(0, maxDepth).join('-');\n  } else {\n    return x.subSpecifiers.join('-');\n  }\n}\n\n/** Populates a treemap using the given lookup table */\nfunction populate_tree_map(\n  lookup: {[key: string]: TreemapNodeParent},\n  leaves: TreemapNodeLeaf[],\n  maxDepth: number\n) {\n  // Populate it\n  leaves.forEach((leaf) => {\n    const parent = lookup[lookup_key_for(leaf.nist_control, maxDepth)];\n    if (parent) {\n      // We found a node that will accept it (matches its control)\n      // We can do this as because we know we constructed these to only have empty children\n      parent.children.push(leaf);\n      leaf.parent = parent;\n    } else {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `Warning: unable to assign control ${leaf.nist_control.rawText} to valid treemap leaf`\n      );\n    }\n  });\n}\n\n/**\n * Assembles the provided leaves into a nist map.\n * Colorizes nodes as appropriate, and assigns parentage\n */\nfunction build_populated_nist_map(data: TreemapNodeLeaf[]): TreemapNodeParent {\n  // Build our scaffold\n  const lookup: {[key: string]: TreemapNodeParent} = {};\n  const rootChildren: TreemapNodeParent[] = [];\n  const root: TreemapNodeParent = {\n    key: 'tree_root',\n    title: 'NIST-853 Controls',\n    children: rootChildren,\n    parent: null,\n    nist_control: new NistControl([], 'NIST-853')\n  };\n\n  // Fill out children, recursively\n  FULL_NIST_HIERARCHY.forEach((n) => {\n    const child = recursive_nist_map(root, n, lookup, depthMax);\n    rootChildren.push(child);\n  });\n\n  // Populate them with leaves\n  populate_tree_map(lookup, data, depthMax);\n\n  // Colorize it\n  colorize_tree_map(root);\n\n  // Done\n  return root;\n}\n\n/**\n * Generates a tree map from the given nist hash, using the size of each category to inversely scale it with controls.\n * Thus each category has a fixed weight!\n * Categories/Families are further sorted by name, and the\n *\n * @param data The nist hash to turn into a tree map\n */\nfunction node_data_to_tree_map(\n  data: Readonly<TreemapNodeParent>\n): D3TreemapNode {\n  return d3\n    .hierarchy<TreemapNode>(data, (d: TreemapNode) => {\n      if (is_parent(d)) {\n        return d.children;\n      }\n      return null;\n    })\n    .sort((a, b) => a.data.title.localeCompare(b.data.title))\n    .sum((root) => {\n      if (is_parent(root)) {\n        if (root.children.length === 0) {\n          return 1;\n        }\n      } else if (root.parent !== null) {\n        return 1.0 / root.parent!.children.length;\n      }\n      return 0;\n    });\n}\n\n/** Does all the steps */\nexport function build_nist_tree_map(\n  data: Readonly<ContextualizedControl[]>,\n  colors: ColorHack\n): D3TreemapNode {\n  const leaves = controls_to_nist_node_data(data, colors);\n  const b = build_populated_nist_map(leaves);\n  return node_data_to_tree_map(b);\n}\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/components/cards/controltable/ControlRowDetails.vue": "<template>\n  <v-row no-gutters dense class=\"pb-1\">\n    <v-col cols=\"12\" class=\"font-weight-bold\">\n      <v-card>\n        <v-tabs v-model=\"localTab\" fixed-tabs show-arrows @change=\"tab_change\">\n          <!-- Declare our tabs -->\n          <v-tab href=\"#tab-test\"> Test </v-tab>\n          <v-tab href=\"#tab-details\"> Details </v-tab>\n          <v-tab href=\"#tab-code\"> Code </v-tab>\n\n          <v-tab-item value=\"tab-test\">\n            <div class=\"pa-4\">\n              <div v-if=\"caveat\">\n                Caveat: {{ caveat }}\n                <v-divider />\n                <br />\n              </div>\n              <!-- eslint-disable-next-line vue/no-v-html -->\n              <div v-html=\"sanitize_html(main_desc)\" />\n            </div>\n            <ControlRowCol\n              v-for=\"(result, index) in control.root.hdf.segments\"\n              :key=\"'col' + index\"\n              :class=\"zebra(index)\"\n              :result=\"result\"\n              :status-code=\"result.status\"\n            />\n          </v-tab-item>\n\n          <v-tab-item value=\"tab-details\">\n            <v-container fluid>\n              <!-- Create a row for each detail -->\n              <template v-for=\"(detail, index) in details\">\n                <v-row :key=\"'tab' + index\" :class=\"zebra(index)\">\n                  <v-col cols=\"12\" :class=\"detail.class\">\n                    <h3>{{ detail.name }}:</h3>\n                    <!-- eslint-disable vue/no-v-html -->\n                    <h4 class=\"mono\" v-html=\"sanitize_html(detail.value)\" />\n                    <!-- eslint-enable vue/no-v-html -->\n                  </v-col>\n                  <v-divider />\n                </v-row>\n              </template>\n            </v-container>\n          </v-tab-item>\n\n          <v-tab-item value=\"tab-code\">\n            <v-container fluid>\n              <v-row>\n                <v-col cols=\"12\">\n                  <prism language=\"ruby\">{{ control.full_code }}</prism>\n                </v-col>\n              </v-row>\n            </v-container>\n          </v-tab-item>\n        </v-tabs>\n      </v-card>\n    </v-col>\n  </v-row>\n</template>\n\n<script lang=\"ts\">\nimport ControlRowCol from '@/components/cards/controltable/ControlRowCol.vue';\nimport HtmlSanitizeMixin from '@/mixins/HtmlSanitizeMixin';\nimport {ContextualizedControl} from 'inspecjs';\nimport _ from 'lodash';\n//TODO: add line numbers\nimport 'prismjs';\nimport 'prismjs/components/prism-makefile.js';\nimport 'prismjs/components/prism-ruby.js';\nimport 'prismjs/themes/prism-tomorrow.css';\nimport Component, {mixins} from 'vue-class-component';\n//@ts-ignore\nimport Prism from 'vue-prism-component';\nimport {Prop, Watch} from 'vue-property-decorator';\n\ninterface Detail {\n  name: string;\n  value: string;\n  class?: string;\n}\n\n@Component({\n  components: {\n    ControlRowCol,\n    Prism\n  }\n})\nexport default class ControlRowDetails extends mixins(HtmlSanitizeMixin) {\n  @Prop({type: String, default: 'tab-test'}) readonly tab!: string;\n  @Prop({type: Object, required: true})\n  readonly control!: ContextualizedControl;\n\n  localTab = this.tab;\n\n  @Watch('tab')\n  onTabChanged(newTab?: string, _oldVal?: string) {\n    if (newTab) {\n      this.localTab = newTab;\n    }\n  }\n\n  get cciControlString(): string | null {\n    const cci = this.control.hdf.wraps.tags.cci;\n    if (!cci) {\n      return null;\n    } else if (Array.isArray(cci)) {\n      return cci.join(', ');\n    } else {\n      return cci;\n    }\n  }\n\n  get main_desc(): string {\n    if (this.control.data.desc) {\n      return this.control.data.desc.trim();\n    } else {\n      return 'No description';\n    }\n  }\n\n  tab_change(tab: string) {\n    this.$emit('update:tab', tab);\n  }\n\n  /** Shown above the description */\n  get header(): string {\n    const msgSplit = this.control.root.hdf.finding_details.split(':');\n    if (msgSplit.length === 1) {\n      return msgSplit[0] + '.';\n    } else {\n      return msgSplit[0] + ':';\n    }\n  }\n\n  get caveat(): string | undefined {\n    return this.control.hdf.descriptions.caveat;\n  }\n\n  get details(): Detail[] {\n    const c = this.control;\n    const detailsMap = new Map();\n\n    detailsMap.set('Control', c.data.id);\n    detailsMap.set('Title', c.data.title);\n    detailsMap.set('Caveat', c.hdf.descriptions.caveat);\n    detailsMap.set('Desc', c.data.desc);\n    detailsMap.set('Rationale', c.hdf.descriptions.rationale);\n    detailsMap.set('Severity', c.root.hdf.severity);\n    detailsMap.set('Impact', c.data.impact);\n    detailsMap.set('Nist controls', c.hdf.rawNistTags.join(', '));\n    detailsMap.set('CCI controls', this.cciControlString);\n    detailsMap.set('Check', c.hdf.descriptions.check || c.data.tags.check);\n    detailsMap.set('Fix', c.hdf.descriptions.fix || c.data.tags.fix);\n    detailsMap.set('CWE ID', _.get(c, 'hdf.wraps.tags.cweid'));\n\n    for (const prop in c.hdf.descriptions) {\n      if (!detailsMap.has(_.capitalize(prop))) {\n        detailsMap.set(_.capitalize(prop), c.hdf.descriptions[prop]);\n      }\n    }\n    return Array.from(detailsMap, ([name, value]) => ({name, value})).filter(\n      (v) => v.value\n    );\n  }\n\n  //for zebra background\n  zebra(ix: number): string {\n    if (ix % 2 === 0) {\n      return 'zebra-table';\n    }\n    return 'non-zebra-table';\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n@import '@/sass/control-row-format.scss';\n\n.clickable {\n  cursor: pointer;\n}\n\n.v-application {\n  code.language-ruby {\n    border: none;\n    box-shadow: none;\n  }\n}\n\npre {\n  white-space: pre-wrap; /* Since CSS 2.1 */\n  white-space: -moz-pre-wrap; /* Mozilla, since 1999 */\n  white-space: -pre-wrap; /* Opera 4-6 */\n  white-space: -o-pre-wrap; /* Opera 7 */\n  word-wrap: break-word; /* Internet Explorer 5.5+ */\n}\n.theme--dark .zebra-table {\n  background-color: var(--v-secondary-lighten2);\n  max-width: 99.9%;\n  margin: auto;\n}\n\n.theme--dark .non-zebra-table {\n  max-width: 99.9%;\n  margin: auto;\n}\n\n.code-card {\n  height: inherit;\n  margin: inherit;\n  white-space: auto;\n}\n.wset {\n  min-width: 125px;\n  justify-content: center;\n}\n\n.right {\n  margin-left: -1px;\n}\n</style>\n\n",
  "/api/sources/raw?key=test:apps/backend/src/evaluations/evaluations.service.spec.ts": "import {NotFoundException} from '@nestjs/common';\nimport {SequelizeModule} from '@nestjs/sequelize';\nimport {Test} from '@nestjs/testing';\nimport {\n  CREATE_EVALUATION_DTO_WITHOUT_FILENAME,\n  CREATE_EVALUATION_DTO_WITHOUT_TAGS,\n  EVALUATION_WITH_TAGS_1,\n  UPDATE_EVALUATION,\n  UPDATE_EVALUATION_DATA_ONLY,\n  UPDATE_EVALUATION_FILENAME_ONLY\n} from '../../test/constants/evaluations-test.constant';\nimport {GROUP_1} from '../../test/constants/groups-test.constant';\nimport {CREATE_USER_DTO_TEST_OBJ} from '../../test/constants/users-test.constant';\nimport {DatabaseModule} from '../database/database.module';\nimport {DatabaseService} from '../database/database.service';\nimport {EvaluationTagsModule} from '../evaluation-tags/evaluation-tags.module';\nimport {EvaluationTagsService} from '../evaluation-tags/evaluation-tags.service';\nimport {GroupEvaluation} from '../group-evaluations/group-evaluation.model';\nimport {GroupUser} from '../group-users/group-user.model';\nimport {Group} from '../groups/group.model';\nimport {GroupsService} from '../groups/groups.service';\nimport {UserDto} from '../users/dto/user.dto';\nimport {UsersModule} from '../users/users.module';\nimport {UsersService} from '../users/users.service';\nimport {EvaluationDto} from './dto/evaluation.dto';\nimport {Evaluation} from './evaluation.model';\nimport {EvaluationsService} from './evaluations.service';\n\ndescribe('EvaluationsService', () => {\n  let evaluationsService: EvaluationsService;\n  let evaluationTagsService: EvaluationTagsService;\n  let databaseService: DatabaseService;\n  let usersService: UsersService;\n  let user: UserDto;\n  let groupsService: GroupsService;\n\n  beforeAll(async () => {\n    const module = await Test.createTestingModule({\n      imports: [\n        DatabaseModule,\n        SequelizeModule.forFeature([\n          Evaluation,\n          GroupUser,\n          Group,\n          GroupEvaluation\n        ]),\n        EvaluationTagsModule,\n        UsersModule\n      ],\n      providers: [\n        EvaluationsService,\n        DatabaseService,\n        UsersService,\n        GroupsService\n      ]\n    }).compile();\n\n    evaluationsService = module.get<EvaluationsService>(EvaluationsService);\n    evaluationTagsService = module.get<EvaluationTagsService>(\n      EvaluationTagsService\n    );\n    databaseService = module.get<DatabaseService>(DatabaseService);\n    usersService = module.get<UsersService>(UsersService);\n    groupsService = module.get<GroupsService>(GroupsService);\n  });\n\n  beforeEach(async () => {\n    await databaseService.cleanAll();\n    user = new UserDto(await usersService.create(CREATE_USER_DTO_TEST_OBJ));\n  });\n\n  describe('findAll', () => {\n    it('should find all evaluations', async () => {\n      let evaluationsDtoArray = await evaluationsService.findAll();\n      expect(evaluationsDtoArray).toEqual([]);\n\n      await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n      await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n      evaluationsDtoArray = await evaluationsService.findAll();\n      expect(evaluationsDtoArray.length).toEqual(2);\n    });\n\n    it('should include the evaluation user', async () => {\n      await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n\n      const evaluations = await evaluationsService.findAll();\n      expect(new UserDto(evaluations[0].user)).toEqual(user);\n    });\n\n    it('should include the evaluation group and group users', async () => {\n      const group = await groupsService.create(GROUP_1);\n      const owner = await usersService.findById(user.id);\n      const evaluation = await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n\n      let evaluations = await evaluationsService.findAll();\n      expect(evaluations[0].groups[0]).not.toBeDefined();\n\n      await groupsService.addEvaluationToGroup(group, evaluation);\n      await groupsService.addUserToGroup(group, owner, 'owner');\n\n      evaluations = await evaluationsService.findAll();\n      const foundGroup = evaluations[0].groups[0];\n      expect(foundGroup).toBeDefined();\n      expect(foundGroup.id).toEqual(group.id);\n      expect(foundGroup.users.length).toEqual(1);\n      expect(foundGroup.users[0].id).toEqual(owner.id);\n      expect(foundGroup.users[0].GroupUser.role).toEqual('owner');\n    });\n  });\n\n  describe('findById', () => {\n    it('should find evaluations by id', async () => {\n      expect.assertions(1);\n      const evaluation = await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n      const foundEvaluation = await evaluationsService.findById(evaluation.id);\n      expect(new EvaluationDto(evaluation)).toEqual(\n        new EvaluationDto(foundEvaluation)\n      );\n    });\n\n    it('should throw an error if an evaluation does not exist', async () => {\n      expect.assertions(1);\n      await expect(evaluationsService.findById('-1')).rejects.toThrow(\n        NotFoundException\n      );\n    });\n  });\n\n  describe('create', () => {\n    it('should create a new evaluation with evaluation tags', async () => {\n      const evaluation = await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n      expect(evaluation.id).toBeDefined();\n      expect(evaluation.updatedAt).toBeDefined();\n      expect(evaluation.createdAt).toBeDefined();\n      expect(evaluation.data).toEqual({});\n      expect(evaluation.filename).toEqual(EVALUATION_WITH_TAGS_1.filename);\n      expect(evaluation.evaluationTags[0].evaluationId).toBeDefined();\n      expect(evaluation.evaluationTags[0].updatedAt).toBeDefined();\n      expect(evaluation.evaluationTags[0].createdAt).toBeDefined();\n\n      if (EVALUATION_WITH_TAGS_1.evaluationTags === undefined) {\n        throw new TypeError(\n          'Evaluation fixture does not have any associated tags.'\n        );\n      }\n\n      expect(evaluation.evaluationTags?.[0].value).toEqual(\n        EVALUATION_WITH_TAGS_1.evaluationTags[0].value\n      );\n    });\n\n    it('should create a new evaluation without evaluation tags', async () => {\n      const evaluation = await evaluationsService.create({\n        ...CREATE_EVALUATION_DTO_WITHOUT_TAGS,\n        data: {},\n        userId: user.id\n      });\n      expect(evaluation.id).toBeDefined();\n      expect(evaluation.updatedAt).toBeDefined();\n      expect(evaluation.createdAt).toBeDefined();\n      expect(evaluation.data).toEqual({});\n      expect(evaluation.filename).toEqual(\n        CREATE_EVALUATION_DTO_WITHOUT_TAGS.filename\n      );\n      expect(evaluation.evaluationTags).not.toBeDefined();\n      expect((await evaluationTagsService.findAll()).length).toBe(0);\n    });\n\n    it('should throw an error when missing the filename field', async () => {\n      expect.assertions(1);\n      await expect(\n        evaluationsService.create({\n          ...CREATE_EVALUATION_DTO_WITHOUT_FILENAME,\n          data: {},\n          userId: user.id\n        })\n      ).rejects.toThrow(\n        'notNull Violation: Evaluation.filename cannot be null'\n      );\n    });\n  });\n\n  describe('update', () => {\n    it('should throw an error if an evaluation does not exist', async () => {\n      expect.assertions(1);\n      await expect(\n        evaluationsService.update('-1', UPDATE_EVALUATION)\n      ).rejects.toThrow(NotFoundException);\n    });\n\n    it('should update all fields of an evaluation', async () => {\n      const evaluation = await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n      const updatedEvaluation = await evaluationsService.update(\n        evaluation.id,\n        UPDATE_EVALUATION\n      );\n      expect(updatedEvaluation.id).toEqual(evaluation.id);\n      expect(updatedEvaluation.createdAt).toEqual(evaluation.createdAt);\n      expect(updatedEvaluation.updatedAt).not.toEqual(evaluation.updatedAt);\n      expect(updatedEvaluation.data).not.toEqual(evaluation.data);\n      expect(updatedEvaluation.filename).not.toEqual(evaluation.filename);\n    });\n\n    it('should only update data if provided', async () => {\n      const evaluation = await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n      const updatedEvaluation = await evaluationsService.update(\n        evaluation.id,\n        UPDATE_EVALUATION_DATA_ONLY\n      );\n      expect(updatedEvaluation.id).toEqual(evaluation.id);\n      expect(updatedEvaluation.createdAt).toEqual(evaluation.createdAt);\n      expect(updatedEvaluation.updatedAt).not.toEqual(evaluation.updatedAt);\n      expect(updatedEvaluation.evaluationTags.length).toEqual(\n        evaluation.evaluationTags.length\n      );\n      expect(updatedEvaluation.data).not.toEqual(evaluation.data);\n      expect(updatedEvaluation.filename).toEqual(evaluation.filename);\n    });\n\n    it('should only update filename if provided', async () => {\n      const evaluation = await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n\n      const updatedEvaluation = await evaluationsService.update(\n        evaluation.id,\n        UPDATE_EVALUATION_FILENAME_ONLY\n      );\n      expect(updatedEvaluation.id).toEqual(evaluation.id);\n      expect(updatedEvaluation.createdAt).toEqual(evaluation.createdAt);\n      expect(updatedEvaluation.updatedAt).not.toEqual(evaluation.updatedAt);\n      expect(updatedEvaluation.evaluationTags.length).toEqual(\n        evaluation.evaluationTags.length\n      );\n      expect(updatedEvaluation.data).toEqual(evaluation.data);\n      expect(updatedEvaluation.filename).not.toEqual(evaluation.filename);\n    });\n  });\n\n  describe('remove', () => {\n    it('should remove an evaluation and its evaluation tags given an id', async () => {\n      const evaluation = await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n      const removedEvaluation = await evaluationsService.remove(evaluation.id);\n      const foundEvaluationTags = await evaluationTagsService.findAll();\n      expect(foundEvaluationTags.length).toEqual(0);\n      expect(new EvaluationDto(removedEvaluation)).toEqual(\n        new EvaluationDto(evaluation)\n      );\n\n      await expect(\n        evaluationsService.findById(removedEvaluation.id)\n      ).rejects.toThrow(NotFoundException);\n    });\n\n    it('should throw an error when the evaluation does not exist', async () => {\n      expect.assertions(1);\n      await expect(evaluationsService.findById('-1')).rejects.toThrow(\n        NotFoundException\n      );\n    });\n  });\n\n  afterAll(async () => {\n    await databaseService.cleanAll();\n    await databaseService.closeConnection();\n  });\n});\n\n",
  "/api/sources/raw?key=test:apps/backend/src/config/config.service.spec.ts": "import * as dotenv from 'dotenv';\nimport mock from 'mock-fs';\nimport {\n  DATABASE_URL_MOCK_ENV,\n  ENV_MOCK_FILE,\n  SIMPLE_ENV_MOCK_FILE\n} from '../../test/constants/env-test.constant';\nimport {ConfigService} from './config.service';\n\n/* If you run the test without --silent , you need to add console.log() before you mock out the\nfile system in the beforeAll() or it'll throw an error (this is a documented bug which can be\nfound at https://github.com/tschaub/mock-fs/issues/234).\nIf you run the test with --silent (which we do by default), you don't need the log statement. */\ndescribe('Config Service', () => {\n  beforeAll(async () => {\n    // eslint-disable-next-line no-console\n    console.log();\n    // Used as an empty file system\n    mock({\n      // No files created (.env file does not exist yet)\n    });\n  });\n\n  describe('Tests the get function when .env file does not exist', () => {\n    it('should return undefined because env variable does not exist', () => {\n      const configService = new ConfigService();\n      expect(configService.get('DATABASE_NAME')).toBe(undefined);\n    });\n\n    it('should print to the console about how it was unable to read .env file', () => {\n      const consoleSpy = jest.spyOn(console, 'log');\n      // Used to make sure logs are outputted\n      new ConfigService();\n      expect(consoleSpy).toHaveBeenCalledWith(\n        'Unable to read configuration file `.env`!'\n      );\n      expect(consoleSpy).toHaveBeenCalledWith(\n        'Falling back to environment or undefined values!'\n      );\n    });\n  });\n\n  describe('Tests the get function when .env file does exist', () => {\n    beforeAll(() => {\n      // Mock .env file\n      mock({\n        '.env': ENV_MOCK_FILE\n      });\n    });\n\n    it('should return the correct database name', () => {\n      const configService = new ConfigService();\n      expect(configService.get('PORT')).toEqual('8000');\n      expect(configService.get('DATABASE_HOST')).toEqual('localhost');\n      expect(configService.get('DATABASE_PORT')).toEqual('5432');\n      expect(configService.get('DATABASE_USERNAME')).toEqual('postgres');\n      expect(configService.get('DATABASE_PASSWORD')).toEqual('postgres');\n      expect(configService.get('DATABASE_NAME')).toEqual(\n        'heimdallts_jest_testing_service_db'\n      );\n      expect(configService.get('JWT_SECRET')).toEqual('abc123');\n      expect(configService.get('NODE_ENV')).toEqual('test');\n    });\n\n    it('should return undefined because env variable does not exist', () => {\n      const configService = new ConfigService();\n      expect(configService.get('INVALID_VARIABLE')).toBe(undefined);\n    });\n  });\n\n  describe('Tests the get function when environment file is sourced externally', () => {\n    beforeAll(() => {\n      // Mock .env file\n      mock({\n        '.env-loaded-externally': SIMPLE_ENV_MOCK_FILE\n      });\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      dotenv.config({path: '.env-loaded-externally'});\n    });\n\n    it('should return the correct database port', () => {\n      const configService = new ConfigService();\n      expect(configService.get('PORT')).toEqual('8001');\n    });\n\n    it('should return undefined because env variable does not exist', () => {\n      const configService = new ConfigService();\n      expect(configService.get('INVALID_VARIABLE')).toBe(undefined);\n    });\n  });\n\n  describe('When using DATABASE_URL', () => {\n    beforeAll(() => {\n      mock({\n        '.env': DATABASE_URL_MOCK_ENV\n      });\n    });\n\n    it('should correctly parse DATABASE_URL into its components', () => {\n      const configService = new ConfigService();\n      expect(configService.get('DATABASE_HOST')).toEqual(\n        'ec2-00-000-11-123.compute-1.amazonaws.com'\n      );\n      expect(configService.get('DATABASE_PORT')).toEqual('5432');\n      expect(configService.get('DATABASE_USERNAME')).toEqual(\n        'abcdefghijk123456'\n      );\n      expect(configService.get('DATABASE_PASSWORD')).toEqual(\n        '000011112222333344455556666777778889999aaaabbbbccccddddeeeffff'\n      );\n      expect(configService.get('DATABASE_NAME')).toEqual('database01');\n    });\n  });\n\n  describe('Tests for thrown errors', () => {\n    it('should throw an EACCES error', () => {\n      expect.assertions(1);\n      mock({\n        '.env': mock.file({\n          content: 'DATABASE_NAME=heimdallts_jest_testing_service_db',\n          mode: 0o000 // Set file system permissions to none\n        })\n      });\n      expect(() => new ConfigService()).toThrowError(\n        \"EACCES: permission denied, open '.env'\"\n      );\n    });\n\n    it('should throw an error in the get function', () => {\n      mock({\n        '.env': ENV_MOCK_FILE\n      });\n      const configService = new ConfigService();\n      jest.spyOn(configService, 'get').mockImplementationOnce(() => {\n        throw new Error('');\n      });\n      expect(() => configService.get('DATABASE_NAME')).toThrowError();\n    });\n  });\n\n  describe('Set', () => {\n    it('should set a key value', () => {\n      const configService = new ConfigService();\n      configService.set('test', 'value');\n      expect(configService.get('test')).toBe('value');\n    });\n  });\n\n  afterAll(() => {\n    // Restore the fs binding to the real file system\n    mock.restore();\n  });\n});\n\n",
  "/api/sources/raw?key=test:apps/backend/src/pipes/password-complexity.pipe.spec.ts": "import {ArgumentMetadata, BadRequestException} from '@nestjs/common';\nimport {\n  CREATE_USER_DTO_TEST_OBJ,\n  CREATE_USER_DTO_TEST_OBJ_WITH_MISSING_PASSWORD_FIELD,\n  UPDATE_USER_DTO_TEST_OBJ,\n  UPDATE_USER_DTO_TEST_WITHOUT_PASSWORD,\n  UPDATE_USER_DTO_WITHOUT_PASSWORD_FIELDS\n} from '../../test/constants/users-test.constant';\nimport {PasswordComplexityPipe} from './password-complexity.pipe';\n\ndescribe('PasswordComplexityPipe', () => {\n  let passwordComplexityPipe: PasswordComplexityPipe;\n  let metaData: ArgumentMetadata;\n\n  beforeEach(() => {\n    passwordComplexityPipe = new PasswordComplexityPipe();\n  });\n\n  it('should make sure that the passwords-complexity pipe is defined', () => {\n    expect(passwordComplexityPipe).toBeDefined();\n  });\n\n  describe('Helper Function Tests', () => {\n    describe('hasClasses', () => {\n      it('should fail because the password length is less than 15 characters and it has all character classes', () => {\n        expect(passwordComplexityPipe.hasClasses('$7aB')).toBeFalsy();\n      });\n\n      it('should fail because the password does not contain a special character', () => {\n        expect(\n          passwordComplexityPipe.hasClasses('Testpasswordwithoutspecialchar7')\n        ).toBeFalsy();\n      });\n\n      it('should fail because the password does not contain a number', () => {\n        expect(\n          passwordComplexityPipe.hasClasses('Testpasswordwithoutnumber$')\n        ).toBeFalsy();\n      });\n\n      it('should fail because the password does not contain an uppercase letter', () => {\n        expect(\n          passwordComplexityPipe.hasClasses('testpasswordwithoutuppercase7$')\n        ).toBeFalsy();\n      });\n\n      it('should fail because the password does not contain a lowercase letter', () => {\n        expect(\n          passwordComplexityPipe.hasClasses('TESTPASSWORDWITHOUTLOWERCASE7$')\n        ).toBeFalsy();\n      });\n\n      it('should pass because the password has all character classes and is at least 15 characters', () => {\n        expect(\n          passwordComplexityPipe.hasClasses('Atestpassword7$')\n        ).toBeTruthy();\n      });\n    });\n\n    describe('noRepeats', () => {\n      it('should fail because there is more than 3 consecutive repeating lowercase characters in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('aaaa')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 lowercase characters back-to-back in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('test')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 consecutive repeating uppercase characters in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('AAAA')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 uppercase characters back-to-back in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('TEST')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 consecutive repeating numbers in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('7777')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 numbers back-to-back in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('1078')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 consecutive repeating numbers in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('$$$$')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 special characters back-to-back in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('!@#$')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 consecutive white spaces in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('spa    ce')).toBeFalsy();\n      });\n\n      it('should pass because the password meets all the minimum requirements', () => {\n        expect(passwordComplexityPipe.noRepeats('aaaBBB111$$$')).toBeTruthy();\n      });\n    });\n  });\n\n  /* Tests the complexity of a user's password and that when it meets the requirements of:\n    15 characters or longer, at least 1 uppercase letter, lowercase letter, number, special character,\n    the password meets the requirements of not containing more than three consecutive repeating\n    characters, and it contains no more than four repeating characters from the same character class,\n    the same dto object will be returned*/\n  describe('Test Valid Password', () => {\n    it('should return the same CreateUserDto', () => {\n      expect(\n        passwordComplexityPipe.transform(CREATE_USER_DTO_TEST_OBJ, metaData)\n      ).toEqual(CREATE_USER_DTO_TEST_OBJ);\n    });\n\n    it('should return the same UpdateUserDto', () => {\n      expect(\n        passwordComplexityPipe.transform(UPDATE_USER_DTO_TEST_OBJ, metaData)\n      ).toEqual(UPDATE_USER_DTO_TEST_OBJ);\n    });\n\n    it('should return UpdateUserDto if password fields are null', () => {\n      expect(\n        passwordComplexityPipe.transform(\n          UPDATE_USER_DTO_WITHOUT_PASSWORD_FIELDS,\n          metaData\n        )\n      ).toEqual(UPDATE_USER_DTO_WITHOUT_PASSWORD_FIELDS);\n    });\n  });\n\n  /* Tests that when a password does not meet all the minimum requirements,\n    a BadRequestException is thrown */\n  describe('Test Invalid Password', () => {\n    it('should throw a BadRequestException for CreateUserDto', () => {\n      expect(() =>\n        passwordComplexityPipe.transform(\n          CREATE_USER_DTO_TEST_OBJ_WITH_MISSING_PASSWORD_FIELD,\n          metaData\n        )\n      ).toThrowError(BadRequestException);\n      expect(() =>\n        passwordComplexityPipe.transform(\n          CREATE_USER_DTO_TEST_OBJ_WITH_MISSING_PASSWORD_FIELD,\n          metaData\n        )\n      ).toThrowError(\n        'Password does not meet complexity requirements. Passwords are a minimum of 15' +\n          ' characters in length. Passwords must contain at least one special character, number, upper-case letter, and' +\n          ' lower-case letter. Passwords cannot contain more than three consecutive repeating characters.' +\n          ' Passwords cannot contain more than four repeating characters from the same character class.'\n      );\n    });\n\n    it('should throw a BadRequestException for UpdateUserDto', () => {\n      expect(() =>\n        passwordComplexityPipe.transform(\n          UPDATE_USER_DTO_TEST_WITHOUT_PASSWORD,\n          metaData\n        )\n      ).toThrowError(BadRequestException);\n      expect(() =>\n        passwordComplexityPipe.transform(\n          UPDATE_USER_DTO_TEST_WITHOUT_PASSWORD,\n          metaData\n        )\n      ).toThrowError(\n        'Password does not meet complexity requirements. Passwords are a minimum of 15' +\n          ' characters in length. Passwords must contain at least one special character, number, upper-case letter, and' +\n          ' lower-case letter. Passwords cannot contain more than three consecutive repeating characters.' +\n          ' Passwords cannot contain more than four repeating characters from the same character class.'\n      );\n    });\n  });\n});\n\n",
  "/api/sources/raw?key=test:apps/backend/src/pipes/passwords-match.pipe.spec.ts": "import {ArgumentMetadata, BadRequestException} from '@nestjs/common';\nimport {\n  CREATE_USER_DTO_TEST_OBJ,\n  CREATE_USER_DTO_TEST_OBJ_WITH_UNMATCHING_PASSWORDS,\n  UPDATE_USER_DTO_TEST_OBJ,\n  UPDATE_USER_DTO_WITHOUT_PASSWORD_FIELDS\n} from '../../test/constants/users-test.constant';\nimport {PasswordsMatchPipe} from './passwords-match.pipe';\n\ndescribe('PasswordsMatchPipe', () => {\n  let passwordsMatchPipe: PasswordsMatchPipe;\n  let metaData: ArgumentMetadata;\n\n  beforeEach(() => {\n    passwordsMatchPipe = new PasswordsMatchPipe();\n  });\n\n  it('should make sure that the passwords-match pipe is defined', () => {\n    expect(passwordsMatchPipe).toBeDefined();\n  });\n\n  /* Tests that when password and passwordConfirmation match,\n   the same CreateUserDto obj that is passed to the pipeline, is returned */\n  describe('Test Matching Passwords', () => {\n    it('should return the same CreateUserDto', () => {\n      expect(\n        passwordsMatchPipe.transform(CREATE_USER_DTO_TEST_OBJ, metaData)\n      ).toEqual(CREATE_USER_DTO_TEST_OBJ);\n    });\n\n    it('should return the same UpdateUserDto', () => {\n      expect(\n        passwordsMatchPipe.transform(UPDATE_USER_DTO_TEST_OBJ, metaData)\n      ).toEqual(UPDATE_USER_DTO_TEST_OBJ);\n    });\n\n    it('should return UpdateUserDto if password fields are null', () => {\n      expect(\n        passwordsMatchPipe.transform(\n          UPDATE_USER_DTO_WITHOUT_PASSWORD_FIELDS,\n          metaData\n        )\n      ).toEqual(UPDATE_USER_DTO_WITHOUT_PASSWORD_FIELDS);\n    });\n  });\n\n  /* Tests that when password and passwordConfirmation don't match,\n    a BadRequestException is thrown */\n  describe('Test Mismatching Passwords', () => {\n    it('should throw a Bad Request Exception', () => {\n      expect(() =>\n        passwordsMatchPipe.transform(\n          CREATE_USER_DTO_TEST_OBJ_WITH_UNMATCHING_PASSWORDS,\n          metaData\n        )\n      ).toThrowError(BadRequestException);\n      expect(() =>\n        passwordsMatchPipe.transform(\n          CREATE_USER_DTO_TEST_OBJ_WITH_UNMATCHING_PASSWORDS,\n          metaData\n        )\n      ).toThrowError('Passwords do not match');\n    });\n  });\n});\n\n",
  "/api/rules/show?key=typescript:S3776": {
    "rule": {
      "key": "typescript:S3776",
      "repo": "typescript",
      "name": "Cognitive Complexity of functions should not be too high",
      "createdAt": "2021-08-13T16:14:42+0000",
      "htmlDesc": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>",
      "mdDesc": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>",
      "severity": "CRITICAL",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "brain-overload"
      ],
      "lang": "ts",
      "langName": "TypeScript",
      "params": [
        {
          "key": "threshold",
          "htmlDesc": "The maximum authorized complexity.",
          "defaultValue": 15,
          "type": "INTEGER"
        }
      ],
      "defaultDebtRemFnType": "LINEAR_OFFSET",
      "defaultDebtRemFnCoeff": "1min",
      "defaultDebtRemFnOffset": "5min",
      "effortToFixDescription": "per complexity point over the threshold",
      "debtOverloaded": false,
      "debtRemFnType": "LINEAR_OFFSET",
      "debtRemFnCoeff": "1min",
      "debtRemFnOffset": "5min",
      "type": "CODE_SMELL",
      "defaultRemFnType": "LINEAR_OFFSET",
      "defaultRemFnGapMultiplier": "1min",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "LINEAR_OFFSET",
      "remFnGapMultiplier": "1min",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "gapDescription": "per complexity point over the threshold",
      "scope": "MAIN",
      "isExternal": false
    },
    "actives": []
  },
  "/api/rules/show?key=typescript:S3317": {
    "rule": {
      "key": "typescript:S3317",
      "repo": "typescript",
      "name": "Default export names and file names should match",
      "createdAt": "2021-08-13T16:14:42+0000",
      "htmlDesc": "<p>By convention, a file that exports only one class, function, or constant should be named for that class, function or constant. Anything else may\nconfuse maintainers.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n// file path: myclass.js  -- Noncompliant\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n// file path: MyClass.js\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Exceptions</h2>\n<p>Case, underscores ( <code>_</code> ) and dashes (<code>-</code>) are ignored from the name comparison.</p>",
      "mdDesc": "<p>By convention, a file that exports only one class, function, or constant should be named for that class, function or constant. Anything else may\nconfuse maintainers.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n// file path: myclass.js  -- Noncompliant\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n// file path: MyClass.js\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Exceptions</h2>\n<p>Case, underscores ( <code>_</code> ) and dashes (<code>-</code>) are ignored from the name comparison.</p>",
      "severity": "MINOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "confusing",
        "convention",
        "es2015"
      ],
      "lang": "ts",
      "langName": "TypeScript",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "CODE_SMELL",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    "actives": []
  },
  "/api/rules/show?key=typescript:S1117": {
    "rule": {
      "key": "typescript:S1117",
      "repo": "typescript",
      "name": "Variables should not be shadowed",
      "createdAt": "2021-08-13T16:14:42+0000",
      "htmlDesc": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>",
      "mdDesc": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "pitfall",
        "suspicious"
      ],
      "lang": "ts",
      "langName": "TypeScript",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "CODE_SMELL",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    "actives": []
  },
  "/api/rules/show?key=typescript:S3358": {
    "rule": {
      "key": "typescript:S3358",
      "repo": "typescript",
      "name": "Ternary operators should not be nested",
      "createdAt": "2021-08-13T16:14:42+0000",
      "htmlDesc": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>",
      "mdDesc": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "confusing"
      ],
      "lang": "ts",
      "langName": "TypeScript",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "CODE_SMELL",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    "actives": []
  },
  "/api/rules/show?key=typescript:S4325": {
    "rule": {
      "key": "typescript:S4325",
      "repo": "typescript",
      "name": "Redundant casts and non-null assertions should be avoided",
      "createdAt": "2021-08-13T16:14:42+0000",
      "htmlDesc": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>",
      "mdDesc": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>",
      "severity": "MINOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "redundant"
      ],
      "lang": "ts",
      "langName": "TypeScript",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "1min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "1min",
      "type": "CODE_SMELL",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "1min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "1min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    "actives": []
  },
  "/api/rules/show?key=typescript:S4138": {
    "rule": {
      "key": "typescript:S4138",
      "repo": "typescript",
      "name": "\"for of\" should be used with Iterables",
      "createdAt": "2021-08-13T16:14:42+0000",
      "htmlDesc": "<p>If you have an iterable, such as an array, set, or list, your best option for looping through its values is the <code>for of</code> syntax. Use a\ncounter, and …​ well you’ll get the right behavior, but your code just isn’t as clean or clear.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nconst arr = [4, 3, 2, 1];\n\nfor (let i = 0; i &lt; arr.length; i++) {  // Noncompliant\n  console.log(arr[i]);\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nconst arr = [4, 3, 2, 1];\n\nfor (let value of arr) {\n  console.log(value);\n}\n</pre>",
      "mdDesc": "<p>If you have an iterable, such as an array, set, or list, your best option for looping through its values is the <code>for of</code> syntax. Use a\ncounter, and …​ well you’ll get the right behavior, but your code just isn’t as clean or clear.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nconst arr = [4, 3, 2, 1];\n\nfor (let i = 0; i &lt; arr.length; i++) {  // Noncompliant\n  console.log(arr[i]);\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nconst arr = [4, 3, 2, 1];\n\nfor (let value of arr) {\n  console.log(value);\n}\n</pre>",
      "severity": "MINOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "clumsy"
      ],
      "lang": "ts",
      "langName": "TypeScript",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "CODE_SMELL",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    "actives": []
  },
  "/api/rules/show?key=typescript:S4144": {
    "rule": {
      "key": "typescript:S4144",
      "repo": "typescript",
      "name": "Functions should not have identical implementations",
      "createdAt": "2021-08-13T16:14:42+0000",
      "htmlDesc": "<p>When two functions have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but\nmay be confusing to maintainers. In the latter case, the code should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {  // Noncompliant\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {\n  return calculateCode();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Functions with fewer than 3 lines are ignored.</p>",
      "mdDesc": "<p>When two functions have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but\nmay be confusing to maintainers. In the latter case, the code should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {  // Noncompliant\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {\n  return calculateCode();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Functions with fewer than 3 lines are ignored.</p>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "confusing",
        "duplicate",
        "suspicious"
      ],
      "lang": "ts",
      "langName": "TypeScript",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "15min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "15min",
      "type": "CODE_SMELL",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "15min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "15min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    "actives": []
  },
  "/api/rules/show?key=typescript:S1135": {
    "rule": {
      "key": "typescript:S1135",
      "repo": "typescript",
      "name": "Track uses of \"TODO\" tags",
      "createdAt": "2021-08-13T16:14:42+0000",
      "htmlDesc": "<p><code>TODO</code> tags are commonly used to mark places where some more code is required, but which the developer wants to implement later.</p>\n<p>Sometimes the developer will not have the time or will simply forget to get back to that tag.</p>\n<p>This rule is meant to track those tags and to ensure that they do not go unnoticed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction doSomething() {\n  // TODO\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/546.html\">MITRE, CWE-546</a> - Suspicious Comment </li>\n</ul>",
      "mdDesc": "<p><code>TODO</code> tags are commonly used to mark places where some more code is required, but which the developer wants to implement later.</p>\n<p>Sometimes the developer will not have the time or will simply forget to get back to that tag.</p>\n<p>This rule is meant to track those tags and to ensure that they do not go unnoticed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction doSomething() {\n  // TODO\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/546.html\">MITRE, CWE-546</a> - Suspicious Comment </li>\n</ul>",
      "severity": "INFO",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "cwe"
      ],
      "lang": "ts",
      "langName": "TypeScript",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "0min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "0min",
      "type": "CODE_SMELL",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "0min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "0min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    "actives": []
  },
  "/api/rules/show?key=typescript:S1848": {
    "rule": {
      "key": "typescript:S1848",
      "repo": "typescript",
      "name": "Objects should not be created to be dropped immediately without being used",
      "createdAt": "2021-08-13T16:14:42+0000",
      "htmlDesc": "<p>There is no good reason to create a new object to not do anything with it. Most of the time, this is due to a missing piece of code and so could\nlead to an unexpected behavior in production.</p>\n<p>If it was done on purpose because the constructor has side-effects, then that side-effect code should be moved into a separate method and called\ndirectly.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nnew MyConstructor(); // Non-Compliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar something = new MyConstructor();  // Compliant\n</pre>\n<h2>Exceptions</h2>\n<p>Immediately dropped new objects inside <code>try</code>-statements are ignored.</p>\n<pre>\ntry {\n  new MyConstructor();\n} catch (e) {\n  /* ... */\n}\n</pre>",
      "mdDesc": "<p>There is no good reason to create a new object to not do anything with it. Most of the time, this is due to a missing piece of code and so could\nlead to an unexpected behavior in production.</p>\n<p>If it was done on purpose because the constructor has side-effects, then that side-effect code should be moved into a separate method and called\ndirectly.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nnew MyConstructor(); // Non-Compliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar something = new MyConstructor();  // Compliant\n</pre>\n<h2>Exceptions</h2>\n<p>Immediately dropped new objects inside <code>try</code>-statements are ignored.</p>\n<pre>\ntry {\n  new MyConstructor();\n} catch (e) {\n  /* ... */\n}\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "ts",
      "langName": "TypeScript",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    "actives": []
  },
  "/api/issues/search?componentKeys=test&types=CODE_SMELL,BUG,VULNERABILITY&p=1": {
    "total": 68,
    "p": 1,
    "ps": 100,
    "paging": {
      "pageIndex": 1,
      "pageSize": 100,
      "total": 68
    },
    "effortTotal": 475,
    "issues": [
      {
        "key": "AXtAUPqUi8r-LMdMzpgJ",
        "rule": "typescript:S3776",
        "severity": "CRITICAL",
        "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
        "project": "test",
        "line": 353,
        "hash": "c8784c25364adaf775f446d53048aaad",
        "textRange": {
          "startLine": 353,
          "endLine": 353,
          "startOffset": 6,
          "endOffset": 11
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 363,
                  "endLine": 363,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 363,
                  "endLine": 363,
                  "startOffset": 36,
                  "endOffset": 38
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 366,
                  "endLine": 366,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 369,
                  "endLine": 369,
                  "startOffset": 11,
                  "endOffset": 13
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 370,
                  "endLine": 370,
                  "startOffset": 38,
                  "endOffset": 40
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 374,
                  "endLine": 374,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 377,
                  "endLine": 377,
                  "startOffset": 11,
                  "endOffset": 13
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 378,
                  "endLine": 378,
                  "startOffset": 40,
                  "endOffset": 42
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 382,
                  "endLine": 382,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 385,
                  "endLine": 385,
                  "startOffset": 11,
                  "endOffset": 13
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 385,
                  "endLine": 385,
                  "startOffset": 44,
                  "endOffset": 46
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 387,
                  "endLine": 387,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 390,
                  "endLine": 390,
                  "startOffset": 11,
                  "endOffset": 13
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 399,
                  "endLine": 399,
                  "startOffset": 6,
                  "endOffset": 10
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 391,
                  "endLine": 391,
                  "startOffset": 39,
                  "endOffset": 41
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 396,
                  "endLine": 396,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 404,
                  "endLine": 404,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 410,
                  "endLine": 410,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Refactor this function to reduce its Cognitive Complexity from 23 to the 15 allowed.",
        "effort": "13min",
        "debt": "13min",
        "author": "rbclark@mitre.org",
        "tags": [
          "brain-overload"
        ],
        "creationDate": "2021-08-05T18:34:07+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "\n  /** Return items sorted and filters out viewed controls */\n  get items(): ListElt[] {\n    // Controls ascending/descending\n    let factor = 1;\n    // Whether or not we need to sort",
        "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
      },
      {
        "key": "AXtAUPhHi8r-LMdMzpf2",
        "rule": "typescript:S3317",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/components/global/upload_tabs/aws/AuthStepBasic.vue",
        "project": "test",
        "flows": [],
        "status": "OPEN",
        "message": "Rename this file to \"S3Reader\"",
        "effort": "5min",
        "debt": "5min",
        "author": "rbclark@mitre.org",
        "tags": [
          "confusing",
          "convention",
          "es2015"
        ],
        "creationDate": "2021-08-05T18:34:07+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "",
        "summary": "<p>By convention, a file that exports only one class, function, or constant should be named for that class, function or constant. Anything else may\nconfuse maintainers.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n// file path: myclass.js  -- Noncompliant\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n// file path: MyClass.js\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Exceptions</h2>\n<p>Case, underscores ( <code>_</code> ) and dashes (<code>-</code>) are ignored from the name comparison.</p>"
      },
      {
        "key": "AXtAUPnEi8r-LMdMzpf3",
        "rule": "typescript:S3317",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/components/global/upload_tabs/aws/AuthStepMFA.vue",
        "project": "test",
        "flows": [],
        "status": "OPEN",
        "message": "Rename this file to \"S3Reader\"",
        "effort": "5min",
        "debt": "5min",
        "author": "rbclark@mitre.org",
        "tags": [
          "confusing",
          "convention",
          "es2015"
        ],
        "creationDate": "2021-08-05T18:34:07+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "",
        "summary": "<p>By convention, a file that exports only one class, function, or constant should be named for that class, function or constant. Anything else may\nconfuse maintainers.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n// file path: myclass.js  -- Noncompliant\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n// file path: MyClass.js\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Exceptions</h2>\n<p>Case, underscores ( <code>_</code> ) and dashes (<code>-</code>) are ignored from the name comparison.</p>"
      },
      {
        "key": "AXtAUPy-i8r-LMdMzphZ",
        "rule": "typescript:S3776",
        "severity": "CRITICAL",
        "component": "test:libs/hdf-converters/src/base-converter.ts",
        "project": "test",
        "line": 195,
        "hash": "e3a2905493498652453fa20fca99f9b9",
        "textRange": {
          "startLine": 195,
          "endLine": 195,
          "startOffset": 2,
          "endOffset": 13
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 199,
                  "endLine": 199,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 202,
                  "endLine": 202,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 215,
                  "endLine": 215,
                  "startOffset": 6,
                  "endOffset": 10
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 211,
                  "endLine": 211,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 220,
                  "endLine": 220,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 245,
                  "endLine": 245,
                  "startOffset": 8,
                  "endOffset": 12
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 222,
                  "endLine": 222,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 238,
                  "endLine": 238,
                  "startOffset": 10,
                  "endOffset": 14
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 231,
                  "endLine": 231,
                  "startOffset": 10,
                  "endOffset": 12
                },
                "msg": "+4 (incl. 3 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 234,
                  "endLine": 234,
                  "startOffset": 10,
                  "endOffset": 12
                },
                "msg": "+4 (incl. 3 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 239,
                  "endLine": 239,
                  "startOffset": 10,
                  "endOffset": 12
                },
                "msg": "+4 (incl. 3 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 241,
                  "endLine": 241,
                  "startOffset": 12,
                  "endOffset": 16
                },
                "msg": "+1"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Refactor this function to reduce its Cognitive Complexity from 25 to the 15 allowed.",
        "effort": "15min",
        "debt": "15min",
        "author": "rbclark@mitre.org",
        "tags": [
          "brain-overload"
        ],
        "creationDate": "2021-08-05T16:58:31+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "  }\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  handleArray<T extends object>(\n    file: Record<string, unknown>,\n    v: Array<T & ILookupPath>\n  ): Array<T> {",
        "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzph5",
        "rule": "typescript:S3776",
        "severity": "CRITICAL",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 228,
        "hash": "5fd6dcc3adfc524cd3dd083080299a0c",
        "textRange": {
          "startLine": 228,
          "endLine": 228,
          "startOffset": 9,
          "endOffset": 18
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 286,
                  "endLine": 286,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 287,
                  "endLine": 287,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 288,
                  "endLine": 288,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 291,
                  "endLine": 291,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 292,
                  "endLine": 292,
                  "startOffset": 4,
                  "endOffset": 9
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 292,
                  "endLine": 292,
                  "startOffset": 35,
                  "endOffset": 37
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 295,
                  "endLine": 295,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 296,
                  "endLine": 296,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 297,
                  "endLine": 297,
                  "startOffset": 50,
                  "endOffset": 51
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 298,
                  "endLine": 298,
                  "startOffset": 50,
                  "endOffset": 51
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 299,
                  "endLine": 299,
                  "startOffset": 50,
                  "endOffset": 51
                },
                "msg": "+4 (incl. 3 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 303,
                  "endLine": 303,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 303,
                  "endLine": 303,
                  "startOffset": 21,
                  "endOffset": 23
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 230,
                  "endLine": 230,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 237,
                  "endLine": 237,
                  "startOffset": 8,
                  "endOffset": 11
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 241,
                  "endLine": 241,
                  "startOffset": 14,
                  "endOffset": 19
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 247,
                  "endLine": 247,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 253,
                  "endLine": 253,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 258,
                  "endLine": 258,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 262,
                  "endLine": 262,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 269,
                  "endLine": 269,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 269,
                  "endLine": 269,
                  "startOffset": 52,
                  "endOffset": 54
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 275,
                  "endLine": 275,
                  "startOffset": 69,
                  "endOffset": 70
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 279,
                  "endLine": 279,
                  "startOffset": 12,
                  "endOffset": 14
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Refactor this function to reduce its Cognitive Complexity from 44 to the 15 allowed.",
        "effort": "34min",
        "debt": "34min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "brain-overload"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "}\n\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);",
        "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzph9",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 238,
        "hash": "c18b29c89a7108ee069bbe31d8a88c35",
        "textRange": {
          "startLine": 238,
          "endLine": 238,
          "startOffset": 18,
          "endOffset": 21
        },
        "flows": [],
        "status": "OPEN",
        "message": "'typ' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        const l = typs.length;\n        for (let i = 0; i < l; i++) {\n            const typ = typs[i];\n            try {\n                return transform(val, typ, getProps);\n            } catch (_) {}",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzpiC",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 268,
        "hash": "00fba73079d5d65a34ef9c6a86abaae5",
        "textRange": {
          "startLine": 268,
          "endLine": 268,
          "startOffset": 75,
          "endOffset": 83
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {\n        if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n            return invalidValue(\"object\", val);\n        }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzpiD",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 273,
        "hash": "f55f8faca787b16a5de85276cda27696",
        "textRange": {
          "startLine": 273,
          "endLine": 273,
          "startOffset": 50,
          "endOffset": 53
        },
        "flows": [],
        "status": "OPEN",
        "message": "'key' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        }\n        const result: any = {};\n        Object.getOwnPropertyNames(props).forEach(key => {\n            const prop = props[key];\n            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;\n            result[prop.key] = transform(v, prop.typ, getProps, prop.key);",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzpiE",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 278,
        "hash": "85cdf91827cdae6313afff45d00a55bf",
        "textRange": {
          "startLine": 278,
          "endLine": 278,
          "startOffset": 48,
          "endOffset": 51
        },
        "flows": [],
        "status": "OPEN",
        "message": "'key' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "            result[prop.key] = transform(v, prop.typ, getProps, prop.key);\n        });\n        Object.getOwnPropertyNames(val).forEach(key => {\n            if (!Object.prototype.hasOwnProperty.call(props, key)) {\n                result[key] = transform(val[key], additional, getProps, key);\n            }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzpiF",
        "rule": "typescript:S3358",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 298,
        "hash": "312531a9243571ab2555c04a21adee70",
        "textRange": {
          "startLine": 298,
          "endLine": 300,
          "startOffset": 14,
          "endOffset": 36
        },
        "flows": [],
        "status": "OPEN",
        "message": "Extract this nested ternary operation into an independent statement.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "confusing"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    if (typeof typ === \"object\") {\n        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);",
        "summary": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>"
      },
      {
        "key": "AXtAUP0Ii8r-LMdMzpiG",
        "rule": "typescript:S3358",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 299,
        "hash": "8a63580931669d2f7b7d79bda6f68a08",
        "textRange": {
          "startLine": 299,
          "endLine": 300,
          "startOffset": 14,
          "endOffset": 36
        },
        "flows": [],
        "status": "OPEN",
        "message": "Extract this nested ternary operation into an independent statement.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "confusing"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);",
        "summary": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzphr",
        "rule": "typescript:S3776",
        "severity": "CRITICAL",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 90,
        "hash": "5fd6dcc3adfc524cd3dd083080299a0c",
        "textRange": {
          "startLine": 90,
          "endLine": 90,
          "startOffset": 9,
          "endOffset": 18
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 148,
                  "endLine": 148,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 149,
                  "endLine": 149,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 150,
                  "endLine": 150,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 153,
                  "endLine": 153,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 154,
                  "endLine": 154,
                  "startOffset": 4,
                  "endOffset": 9
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 154,
                  "endLine": 154,
                  "startOffset": 35,
                  "endOffset": 37
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 157,
                  "endLine": 157,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 158,
                  "endLine": 158,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 159,
                  "endLine": 159,
                  "startOffset": 50,
                  "endOffset": 51
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 160,
                  "endLine": 160,
                  "startOffset": 50,
                  "endOffset": 51
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 161,
                  "endLine": 161,
                  "startOffset": 50,
                  "endOffset": 51
                },
                "msg": "+4 (incl. 3 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 165,
                  "endLine": 165,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 165,
                  "endLine": 165,
                  "startOffset": 21,
                  "endOffset": 23
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 92,
                  "endLine": 92,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 99,
                  "endLine": 99,
                  "startOffset": 8,
                  "endOffset": 11
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 103,
                  "endLine": 103,
                  "startOffset": 14,
                  "endOffset": 19
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 109,
                  "endLine": 109,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 115,
                  "endLine": 115,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 120,
                  "endLine": 120,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 124,
                  "endLine": 124,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 131,
                  "endLine": 131,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 131,
                  "endLine": 131,
                  "startOffset": 52,
                  "endOffset": 54
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 137,
                  "endLine": 137,
                  "startOffset": 69,
                  "endOffset": 70
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 141,
                  "endLine": 141,
                  "startOffset": 12,
                  "endOffset": 14
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Refactor this function to reduce its Cognitive Complexity from 44 to the 15 allowed.",
        "effort": "34min",
        "debt": "34min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "brain-overload"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "}\n\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);",
        "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzph0",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 130,
        "hash": "00fba73079d5d65a34ef9c6a86abaae5",
        "textRange": {
          "startLine": 130,
          "endLine": 130,
          "startOffset": 75,
          "endOffset": 83
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {\n        if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n            return invalidValue(\"object\", val);\n        }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzph1",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 135,
        "hash": "f55f8faca787b16a5de85276cda27696",
        "textRange": {
          "startLine": 135,
          "endLine": 135,
          "startOffset": 50,
          "endOffset": 53
        },
        "flows": [],
        "status": "OPEN",
        "message": "'key' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        }\n        const result: any = {};\n        Object.getOwnPropertyNames(props).forEach(key => {\n            const prop = props[key];\n            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;\n            result[prop.key] = transform(v, prop.typ, getProps, prop.key);",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzph2",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 140,
        "hash": "85cdf91827cdae6313afff45d00a55bf",
        "textRange": {
          "startLine": 140,
          "endLine": 140,
          "startOffset": 48,
          "endOffset": 51
        },
        "flows": [],
        "status": "OPEN",
        "message": "'key' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "            result[prop.key] = transform(v, prop.typ, getProps, prop.key);\n        });\n        Object.getOwnPropertyNames(val).forEach(key => {\n            if (!Object.prototype.hasOwnProperty.call(props, key)) {\n                result[key] = transform(val[key], additional, getProps, key);\n            }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzph3",
        "rule": "typescript:S3358",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 160,
        "hash": "312531a9243571ab2555c04a21adee70",
        "textRange": {
          "startLine": 160,
          "endLine": 162,
          "startOffset": 14,
          "endOffset": 36
        },
        "flows": [],
        "status": "OPEN",
        "message": "Extract this nested ternary operation into an independent statement.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "confusing"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    if (typeof typ === \"object\") {\n        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);",
        "summary": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzph4",
        "rule": "typescript:S3358",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 161,
        "hash": "8a63580931669d2f7b7d79bda6f68a08",
        "textRange": {
          "startLine": 161,
          "endLine": 162,
          "startOffset": 14,
          "endOffset": 36
        },
        "flows": [],
        "status": "OPEN",
        "message": "Extract this nested ternary operation into an independent statement.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "confusing"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);",
        "summary": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphd",
        "rule": "typescript:S3776",
        "severity": "CRITICAL",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 147,
        "hash": "5fd6dcc3adfc524cd3dd083080299a0c",
        "textRange": {
          "startLine": 147,
          "endLine": 147,
          "startOffset": 9,
          "endOffset": 18
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 205,
                  "endLine": 205,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 206,
                  "endLine": 206,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 207,
                  "endLine": 207,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 210,
                  "endLine": 210,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 211,
                  "endLine": 211,
                  "startOffset": 4,
                  "endOffset": 9
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 211,
                  "endLine": 211,
                  "startOffset": 35,
                  "endOffset": 37
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 214,
                  "endLine": 214,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 215,
                  "endLine": 215,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 216,
                  "endLine": 216,
                  "startOffset": 50,
                  "endOffset": 51
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 217,
                  "endLine": 217,
                  "startOffset": 50,
                  "endOffset": 51
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 218,
                  "endLine": 218,
                  "startOffset": 50,
                  "endOffset": 51
                },
                "msg": "+4 (incl. 3 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 222,
                  "endLine": 222,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 222,
                  "endLine": 222,
                  "startOffset": 21,
                  "endOffset": 23
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 149,
                  "endLine": 149,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 156,
                  "endLine": 156,
                  "startOffset": 8,
                  "endOffset": 11
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 160,
                  "endLine": 160,
                  "startOffset": 14,
                  "endOffset": 19
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 166,
                  "endLine": 166,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 172,
                  "endLine": 172,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 177,
                  "endLine": 177,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 181,
                  "endLine": 181,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 188,
                  "endLine": 188,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 188,
                  "endLine": 188,
                  "startOffset": 52,
                  "endOffset": 54
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 194,
                  "endLine": 194,
                  "startOffset": 69,
                  "endOffset": 70
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 198,
                  "endLine": 198,
                  "startOffset": 12,
                  "endOffset": 14
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Refactor this function to reduce its Cognitive Complexity from 44 to the 15 allowed.",
        "effort": "34min",
        "debt": "34min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "brain-overload"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "}\n\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);",
        "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphh",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 157,
        "hash": "c18b29c89a7108ee069bbe31d8a88c35",
        "textRange": {
          "startLine": 157,
          "endLine": 157,
          "startOffset": 18,
          "endOffset": 21
        },
        "flows": [],
        "status": "OPEN",
        "message": "'typ' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        const l = typs.length;\n        for (let i = 0; i < l; i++) {\n            const typ = typs[i];\n            try {\n                return transform(val, typ, getProps);\n            } catch (_) {}",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphm",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 187,
        "hash": "00fba73079d5d65a34ef9c6a86abaae5",
        "textRange": {
          "startLine": 187,
          "endLine": 187,
          "startOffset": 75,
          "endOffset": 83
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {\n        if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n            return invalidValue(\"object\", val);\n        }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphn",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 192,
        "hash": "f55f8faca787b16a5de85276cda27696",
        "textRange": {
          "startLine": 192,
          "endLine": 192,
          "startOffset": 50,
          "endOffset": 53
        },
        "flows": [],
        "status": "OPEN",
        "message": "'key' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        }\n        const result: any = {};\n        Object.getOwnPropertyNames(props).forEach(key => {\n            const prop = props[key];\n            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;\n            result[prop.key] = transform(v, prop.typ, getProps, prop.key);",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzpho",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 197,
        "hash": "85cdf91827cdae6313afff45d00a55bf",
        "textRange": {
          "startLine": 197,
          "endLine": 197,
          "startOffset": 48,
          "endOffset": 51
        },
        "flows": [],
        "status": "OPEN",
        "message": "'key' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "            result[prop.key] = transform(v, prop.typ, getProps, prop.key);\n        });\n        Object.getOwnPropertyNames(val).forEach(key => {\n            if (!Object.prototype.hasOwnProperty.call(props, key)) {\n                result[key] = transform(val[key], additional, getProps, key);\n            }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphp",
        "rule": "typescript:S3358",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 217,
        "hash": "312531a9243571ab2555c04a21adee70",
        "textRange": {
          "startLine": 217,
          "endLine": 219,
          "startOffset": 14,
          "endOffset": 36
        },
        "flows": [],
        "status": "OPEN",
        "message": "Extract this nested ternary operation into an independent statement.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "confusing"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    if (typeof typ === \"object\") {\n        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);",
        "summary": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphq",
        "rule": "typescript:S3358",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 218,
        "hash": "8a63580931669d2f7b7d79bda6f68a08",
        "textRange": {
          "startLine": 218,
          "endLine": 219,
          "startOffset": 14,
          "endOffset": 36
        },
        "flows": [],
        "status": "OPEN",
        "message": "Extract this nested ternary operation into an independent statement.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "confusing"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);",
        "summary": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPqri8r-LMdMzpgL",
        "rule": "typescript:S3776",
        "severity": "CRITICAL",
        "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
        "project": "test",
        "line": 71,
        "hash": "033d83583fb5666efff076b608fc30c3",
        "textRange": {
          "startLine": 71,
          "endLine": 71,
          "startOffset": 6,
          "endOffset": 19
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                "textRange": {
                  "startLine": 78,
                  "endLine": 78,
                  "startOffset": 6,
                  "endOffset": 9
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                "textRange": {
                  "startLine": 80,
                  "endLine": 80,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                "textRange": {
                  "startLine": 99,
                  "endLine": 99,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                "textRange": {
                  "startLine": 105,
                  "endLine": 105,
                  "startOffset": 10,
                  "endOffset": 14
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                "textRange": {
                  "startLine": 100,
                  "endLine": 100,
                  "startOffset": 10,
                  "endOffset": 12
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                "textRange": {
                  "startLine": 102,
                  "endLine": 102,
                  "startOffset": 12,
                  "endOffset": 16
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                "textRange": {
                  "startLine": 100,
                  "endLine": 100,
                  "startOffset": 31,
                  "endOffset": 33
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                "textRange": {
                  "startLine": 109,
                  "endLine": 109,
                  "startOffset": 6,
                  "endOffset": 11
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                "textRange": {
                  "startLine": 88,
                  "endLine": 88,
                  "startOffset": 10,
                  "endOffset": 12
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                "textRange": {
                  "startLine": 95,
                  "endLine": 95,
                  "startOffset": 12,
                  "endOffset": 16
                },
                "msg": "+1"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Refactor this function to reduce its Cognitive Complexity from 16 to the 15 allowed.",
        "effort": "6min",
        "debt": "6min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "brain-overload"
        ],
        "creationDate": "2021-06-30T16:09:04+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "\n  /** The currently selected treemap node. Wrapped to avoid initialization woes */\n  get selected_node(): d3.HierarchyRectangularNode<TreemapNode> {\n    // Get typed versions of the curr state\n    // Set curr to root\n    let curr = this.treemap_layout;",
        "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
      },
      {
        "key": "AXtAUPnSi8r-LMdMzpf4",
        "rule": "typescript:S4325",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/components/global/upload_tabs/aws/FileList.vue",
        "project": "test",
        "line": 79,
        "hash": "8a88aeebc2f9b4b0ecc10da38885032e",
        "textRange": {
          "startLine": 79,
          "endLine": 79,
          "startOffset": 41,
          "endOffset": 50
        },
        "flows": [],
        "status": "OPEN",
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "effort": "1min",
        "debt": "1min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "redundant"
        ],
        "creationDate": "2021-06-30T16:09:04+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "\n    // Fetch it from s3, and promise to submit it to be loaded afterwards\n    await fetch_s3_file(this.auth.creds, file.Key!, this.formBucketName).then(\n      (content) => {\n        InspecIntakeModule.loadText({\n          text: content,",
        "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPnsi8r-LMdMzpf6",
        "rule": "typescript:S4325",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/components/global/upload_tabs/aws/S3Reader.vue",
        "project": "test",
        "line": 184,
        "hash": "9a4009784ecd065c4fe9baa831240022",
        "textRange": {
          "startLine": 184,
          "endLine": 184,
          "startOffset": 22,
          "endOffset": 39
        },
        "flows": [],
        "status": "OPEN",
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "effort": "1min",
        "debt": "1min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "redundant"
        ],
        "creationDate": "2021-06-30T16:09:04+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "   */\n  async load_bucket(name: string) {\n    const s3 = new S3(this.assumedRole!.creds);\n    await s3\n      .listObjectsV2({\n        Bucket: name,",
        "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPr3i8r-LMdMzpgO",
        "rule": "typescript:S4325",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/store/data_filters.ts",
        "project": "test",
        "line": 96,
        "hash": "13967f9141b7884039ec8d6481313af7",
        "textRange": {
          "startLine": 96,
          "endLine": 103,
          "startOffset": 32,
          "endOffset": 41
        },
        "flows": [],
        "status": "OPEN",
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "effort": "1min",
        "debt": "1min",
        "author": "sheikholeslam@mitre.org",
        "tags": [
          "redundant"
        ],
        "creationDate": "2021-06-23T16:08:32+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "  const asHDF = contextControl.root.hdf;\n  // Get our (non-null) searchable data\n  const searchables: string[] = [\n    asHDF.wraps.id,\n    asHDF.wraps.title,\n    asHDF.wraps.code,\n    asHDF.severity,\n    asHDF.status,\n    asHDF.finding_details\n  ].filter((s) => s !== null) as string[];\n\n  // See if any contain term\n  return searchables.some((s) => s.toLowerCase().includes(term));",
        "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPs3i8r-LMdMzpgS",
        "rule": "typescript:S4325",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/utilities/format_util.ts",
        "project": "test",
        "line": 29,
        "hash": "0c2f340c5bacde239d24920b8a453c6b",
        "textRange": {
          "startLine": 29,
          "endLine": 29,
          "startOffset": 6,
          "endOffset": 60
        },
        "flows": [],
        "status": "OPEN",
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "effort": "1min",
        "debt": "1min",
        "author": "sheikholeslam@mitre.org",
        "tags": [
          "redundant"
        ],
        "creationDate": "2021-06-23T14:32:15+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "  } else {\n    return `${execution_unique_key(\n      profile.sourcedFrom as SourcedContextualizedEvaluation\n    )}-${profile.data.name}`;\n  }\n}",
        "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
      },
      {
        "key": "AXtAUP0Vi8r-LMdMzpiH",
        "rule": "typescript:S3776",
        "severity": "CRITICAL",
        "component": "test:libs/inspecjs/src/context.ts",
        "project": "test",
        "line": 153,
        "hash": "bd47be4985f547192f96954033d9e458",
        "textRange": {
          "startLine": 153,
          "endLine": 153,
          "startOffset": 16,
          "endOffset": 39
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 162,
                  "endLine": 162,
                  "startOffset": 2,
                  "endOffset": 5
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 176,
                  "endLine": 176,
                  "startOffset": 2,
                  "endOffset": 5
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 181,
                  "endLine": 181,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 188,
                  "endLine": 188,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 199,
                  "endLine": 199,
                  "startOffset": 2,
                  "endOffset": 5
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 208,
                  "endLine": 208,
                  "startOffset": 2,
                  "endOffset": 5
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 210,
                  "endLine": 210,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 233,
                  "endLine": 233,
                  "startOffset": 6,
                  "endOffset": 10
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 210,
                  "endLine": 210,
                  "startOffset": 42,
                  "endOffset": 44
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 213,
                  "endLine": 213,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 220,
                  "endLine": 220,
                  "startOffset": 6,
                  "endOffset": 9
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 226,
                  "endLine": 226,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+4 (incl. 3 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 245,
                  "endLine": 245,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 250,
                  "endLine": 250,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 252,
                  "endLine": 252,
                  "startOffset": 8,
                  "endOffset": 12
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 241,
                  "endLine": 241,
                  "startOffset": 30,
                  "endOffset": 32
                },
                "msg": "+1"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Refactor this function to reduce its Cognitive Complexity from 31 to the 15 allowed.",
        "effort": "21min",
        "debt": "21min",
        "author": "sheikholeslam@mitre.org",
        "tags": [
          "brain-overload"
        ],
        "creationDate": "2021-06-23T14:32:15+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "}\n\nexport function contextualizeEvaluation(\n  evaluation: AnyEval\n): ContextualizedEvaluation {\n  // To begin, create basic context for profiles and evaluation",
        "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzpiB",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 257,
        "hash": "ec0d349e10fedfa2b54a27dd6cf235ca",
        "textRange": {
          "startLine": 257,
          "endLine": 257,
          "startOffset": 27,
          "endOffset": 35
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "sheikholeslam@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-06-23T14:32:15+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformDate(val: any): any {\n        if (val === null) {\n            return null;\n        }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzphz",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 119,
        "hash": "ec0d349e10fedfa2b54a27dd6cf235ca",
        "textRange": {
          "startLine": 119,
          "endLine": 119,
          "startOffset": 27,
          "endOffset": 35
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "sheikholeslam@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-06-23T14:32:15+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformDate(val: any): any {\n        if (val === null) {\n            return null;\n        }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphl",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 176,
        "hash": "ec0d349e10fedfa2b54a27dd6cf235ca",
        "textRange": {
          "startLine": 176,
          "endLine": 176,
          "startOffset": 27,
          "endOffset": 35
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "sheikholeslam@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-06-23T14:32:15+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformDate(val: any): any {\n        if (val === null) {\n            return null;\n        }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzphv",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 100,
        "hash": "c18b29c89a7108ee069bbe31d8a88c35",
        "textRange": {
          "startLine": 100,
          "endLine": 100,
          "startOffset": 18,
          "endOffset": 21
        },
        "flows": [],
        "status": "OPEN",
        "message": "'typ' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "sheikholeslam@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-06-22T15:34:30+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        const l = typs.length;\n        for (let i = 0; i < l; i++) {\n            const typ = typs[i];\n            try {\n                return transform(val, typ, getProps);\n            } catch (_) {}",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzdi8r-LMdMzphc",
        "rule": "typescript:S3776",
        "severity": "CRITICAL",
        "component": "test:libs/inspecjs/src/nist.ts",
        "project": "test",
        "line": 126,
        "hash": "99d4f34dee5a16b69df60f274112f848",
        "textRange": {
          "startLine": 126,
          "endLine": 126,
          "startOffset": 2,
          "endOffset": 10
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 131,
                  "endLine": 131,
                  "startOffset": 24,
                  "endOffset": 26
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 132,
                  "endLine": 132,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 136,
                  "endLine": 136,
                  "startOffset": 4,
                  "endOffset": 7
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 136,
                  "endLine": 136,
                  "startOffset": 34,
                  "endOffset": 36
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 140,
                  "endLine": 140,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 142,
                  "endLine": 142,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 142,
                  "endLine": 142,
                  "startOffset": 29,
                  "endOffset": 31
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 147,
                  "endLine": 147,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 148,
                  "endLine": 148,
                  "startOffset": 10,
                  "endOffset": 12
                },
                "msg": "+4 (incl. 3 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 153,
                  "endLine": 153,
                  "startOffset": 10,
                  "endOffset": 12
                },
                "msg": "+4 (incl. 3 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 160,
                  "endLine": 160,
                  "startOffset": 13,
                  "endOffset": 15
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 162,
                  "endLine": 162,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 166,
                  "endLine": 166,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Refactor this function to reduce its Cognitive Complexity from 28 to the 15 allowed.",
        "effort": "18min",
        "debt": "18min",
        "author": "sheikholeslam@mitre.org",
        "tags": [
          "brain-overload"
        ],
        "creationDate": "2021-06-22T15:34:30+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "   * Avoid repeating this if possible.\n   */\n  canonize(config: CanonizationConfig): string {\n    config = default_partial_config(config);\n    const ss = this.subSpecifiers;\n",
        "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
      },
      {
        "key": "AXtAUPrqi8r-LMdMzpgN",
        "rule": "typescript:S4325",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/store/data_store.ts",
        "project": "test",
        "line": 81,
        "hash": "3899fef5cfc73d590869dd79cb4cc7e9",
        "textRange": {
          "startLine": 81,
          "endLine": 83,
          "startOffset": 11,
          "endOffset": 39
        },
        "flows": [],
        "status": "OPEN",
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "effort": "1min",
        "debt": "1min",
        "author": "66680985+camdenmoors@users.noreply.github.com",
        "tags": [
          "redundant"
        ],
        "creationDate": "2021-04-06T20:31:54+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "   */\n  get contextualExecutionProfiles(): readonly SourcedContextualizedProfile[] {\n    return this.contextualExecutions.flatMap(\n      (evaluation) => evaluation.contains\n    ) as SourcedContextualizedProfile[];\n  }\n\n  /**",
        "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPqii8r-LMdMzpgK",
        "rule": "typescript:S4325",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/components/cards/treemap/Cell.vue",
        "project": "test",
        "line": 84,
        "hash": "132666a69b184b8b50ac1bf8e461a4d6",
        "textRange": {
          "startLine": 84,
          "endLine": 84,
          "startOffset": 7,
          "endOffset": 40
        },
        "flows": [],
        "status": "OPEN",
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "effort": "1min",
        "debt": "1min",
        "author": "rbclark@mitre.org",
        "tags": [
          "redundant"
        ],
        "creationDate": "2020-10-14T22:38:18+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    return (\n      this.is_control && // We are a control\n      (this.node.data as TreemapNodeLeaf).control.data.id ===\n        this.selectedControlId // Our control id matches\n    );\n  }",
        "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPnSi8r-LMdMzpf5",
        "rule": "typescript:S4325",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/components/global/upload_tabs/aws/FileList.vue",
        "project": "test",
        "line": 83,
        "hash": "74f2f0146720ebd242fef2ef1727b1cd",
        "textRange": {
          "startLine": 83,
          "endLine": 83,
          "startOffset": 20,
          "endOffset": 29
        },
        "flows": [],
        "status": "OPEN",
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "effort": "1min",
        "debt": "1min",
        "author": "rbclark@mitre.org",
        "tags": [
          "redundant"
        ],
        "creationDate": "2020-09-22T22:33:07+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        InspecIntakeModule.loadText({\n          text: content,\n          filename: file.Key!\n        }).then((uniqueId) => this.$emit('got-files', [uniqueId]));\n      }\n    );",
        "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPrPi8r-LMdMzpgM",
        "rule": "typescript:S4138",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/components/generic/ApexLineChart.vue",
        "project": "test",
        "line": 46,
        "hash": "9acd2d681bf613b90597cfd8bcf316e8",
        "textRange": {
          "startLine": 46,
          "endLine": 48,
          "startOffset": 4,
          "endOffset": 5
        },
        "flows": [],
        "status": "OPEN",
        "message": "Expected a `for-of` loop instead of a `for` loop with this simple iteration.",
        "effort": "5min",
        "debt": "5min",
        "author": "51336847+cjdoherty@users.noreply.github.com",
        "tags": [
          "clumsy"
        ],
        "creationDate": "2020-08-26T14:02:11+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "  get label_colors(): string[] {\n    const colors = [];\n    for (let i = 0; i < this.categories.length; i++) {\n      colors.push('#FFFFFF');\n    }\n    return colors;\n  }\n",
        "summary": "<p>If you have an iterable, such as an array, set, or list, your best option for looping through its values is the <code>for of</code> syntax. Use a\ncounter, and …​ well you’ll get the right behavior, but your code just isn’t as clean or clear.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nconst arr = [4, 3, 2, 1];\n\nfor (let i = 0; i &lt; arr.length; i++) {  // Noncompliant\n  console.log(arr[i]);\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nconst arr = [4, 3, 2, 1];\n\nfor (let value of arr) {\n  console.log(value);\n}\n</pre>"
      },
      {
        "key": "AXtAUPsri8r-LMdMzpgQ",
        "rule": "typescript:S4325",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/utilities/delta_util.ts",
        "project": "test",
        "line": 158,
        "hash": "1ff214edad50c0e11919635e4a4da1fe",
        "textRange": {
          "startLine": 158,
          "endLine": 158,
          "startOffset": 10,
          "endOffset": 28
        },
        "flows": [],
        "status": "OPEN",
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "effort": "1min",
        "debt": "1min",
        "author": "51336847+cjdoherty@users.noreply.github.com",
        "tags": [
          "redundant"
        ],
        "creationDate": "2020-08-26T14:02:11+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "  for (const prof of ev.contains) {\n    for (const ctrl of prof.contains) {\n      if (ctrl.hdf.segments!.length) {\n        return ctrl.hdf.segments![0].start_time;\n      }\n    }",
        "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPssi8r-LMdMzpgR",
        "rule": "typescript:S4325",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/utilities/delta_util.ts",
        "project": "test",
        "line": 159,
        "hash": "a35b4c61d3b8c13f7961feca7a6ec00c",
        "textRange": {
          "startLine": 159,
          "endLine": 159,
          "startOffset": 15,
          "endOffset": 33
        },
        "flows": [],
        "status": "OPEN",
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "effort": "1min",
        "debt": "1min",
        "author": "51336847+cjdoherty@users.noreply.github.com",
        "tags": [
          "redundant"
        ],
        "creationDate": "2020-08-26T14:02:11+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    for (const ctrl of prof.contains) {\n      if (ctrl.hdf.segments!.length) {\n        return ctrl.hdf.segments![0].start_time;\n      }\n    }\n  }",
        "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPt6i8r-LMdMzpgU",
        "rule": "typescript:S4144",
        "severity": "MAJOR",
        "component": "test:apps/frontend/tests/unit/Compare.spec.ts",
        "project": "test",
        "line": 46,
        "hash": "a68d822d383917a99ac357fd376a830d",
        "textRange": {
          "startLine": 46,
          "endLine": 46,
          "startOffset": 55,
          "endOffset": 57
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:apps/frontend/tests/unit/Compare.spec.ts",
                "textRange": {
                  "startLine": 38,
                  "endLine": 38,
                  "startOffset": 55,
                  "endOffset": 57
                },
                "msg": "Original implementation"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Update this function so that its implementation is not identical to the one on line 38.",
        "effort": "15min",
        "debt": "15min",
        "author": "51336847+cjdoherty@users.noreply.github.com",
        "tags": [
          "confusing",
          "duplicate",
          "suspicious"
        ],
        "creationDate": "2020-08-26T14:02:11+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "  });\n\n  it('does not recount same controls with 3 files', () => {\n    loadSample('NGINX With Failing Tests');\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets",
        "summary": "<p>When two functions have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but\nmay be confusing to maintainers. In the latter case, the code should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {  // Noncompliant\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {\n  return calculateCode();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Functions with fewer than 3 lines are ignored.</p>"
      },
      {
        "key": "AXtAUPtAi8r-LMdMzpgT",
        "rule": "typescript:S1135",
        "severity": "INFO",
        "component": "test:apps/frontend/src/utilities/splunk_util.ts",
        "project": "test",
        "line": 341,
        "hash": "4ad01e433047b4d0b74d3a3bd46ae007",
        "textRange": {
          "startLine": 341,
          "endLine": 341,
          "startOffset": 3,
          "endOffset": 7
        },
        "flows": [],
        "status": "OPEN",
        "message": "Complete the task associated to this \"TODO\" comment.",
        "effort": "0min",
        "debt": "0min",
        "author": "51966679+mitriol@users.noreply.github.com",
        "tags": [
          "cwe"
        ],
        "creationDate": "2020-08-26T14:01:58+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": " * HDF heirarchy.\n *\n * TODO: Provide a mechanism for also returning orphaned items\n */\nexport function consolidate_payloads(\n  payloads: UnknownPayload[]",
        "summary": "<p><code>TODO</code> tags are commonly used to mark places where some more code is required, but which the developer wants to implement later.</p>\n<p>Sometimes the developer will not have the time or will simply forget to get back to that tag.</p>\n<p>This rule is meant to track those tags and to ensure that they do not go unnoticed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction doSomething() {\n  // TODO\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/546.html\">MITRE, CWE-546</a> - Suspicious Comment </li>\n</ul>"
      },
      {
        "key": "AXtAUPsYi8r-LMdMzpgP",
        "rule": "typescript:S4325",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/utilities/treemap_util.ts",
        "project": "test",
        "line": 222,
        "hash": "9a78ca4b58afc6956625e79056466a00",
        "textRange": {
          "startLine": 222,
          "endLine": 222,
          "startOffset": 21,
          "endOffset": 33
        },
        "flows": [],
        "status": "OPEN",
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "effort": "1min",
        "debt": "1min",
        "author": "51966679+mitriol@users.noreply.github.com",
        "tags": [
          "redundant"
        ],
        "creationDate": "2020-08-26T14:01:23+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        }\n      } else if (root.parent !== null) {\n        return 1.0 / root.parent!.children.length;\n      }\n      return 0;\n    });",
        "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPp3i8r-LMdMzpgG",
        "rule": "typescript:S1135",
        "severity": "INFO",
        "component": "test:apps/frontend/src/components/cards/controltable/ControlRowDetails.vue",
        "project": "test",
        "line": 67,
        "hash": "b3b8610f2f997ad05a0cc9fcc8d5aa17",
        "textRange": {
          "startLine": 67,
          "endLine": 67,
          "startOffset": 2,
          "endOffset": 6
        },
        "flows": [],
        "status": "OPEN",
        "message": "Complete the task associated to this \"TODO\" comment.",
        "effort": "0min",
        "debt": "0min",
        "author": "lippold@gmail.com",
        "tags": [
          "cwe"
        ],
        "creationDate": "2020-08-26T14:01:02+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "import {ContextualizedControl} from 'inspecjs';\nimport _ from 'lodash';\n//TODO: add line numbers\nimport 'prismjs';\nimport 'prismjs/components/prism-makefile.js';\nimport 'prismjs/components/prism-ruby.js';",
        "summary": "<p><code>TODO</code> tags are commonly used to mark places where some more code is required, but which the developer wants to implement later.</p>\n<p>Sometimes the developer will not have the time or will simply forget to get back to that tag.</p>\n<p>This rule is meant to track those tags and to ensure that they do not go unnoticed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction doSomething() {\n  // TODO\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/546.html\">MITRE, CWE-546</a> - Suspicious Comment </li>\n</ul>"
      },
      {
        "key": "AXtAUPuhi8r-LMdMzpgV",
        "rule": "typescript:S4144",
        "severity": "MAJOR",
        "component": "test:apps/backend/src/evaluations/evaluations.service.spec.ts",
        "project": "test",
        "line": 293,
        "hash": "4fb693e4f6656b1e3dbad68b47593776",
        "textRange": {
          "startLine": 293,
          "endLine": 293,
          "startOffset": 76,
          "endOffset": 78
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:apps/backend/src/evaluations/evaluations.service.spec.ts",
                "textRange": {
                  "startLine": 141,
                  "endLine": 141,
                  "startOffset": 73,
                  "endOffset": 75
                },
                "msg": "Original implementation"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Update this function so that its implementation is not identical to the one on line 141.",
        "effort": "15min",
        "debt": "15min",
        "author": "kfagan@mitre.org",
        "tags": [
          "confusing",
          "duplicate",
          "suspicious"
        ],
        "creationDate": "2020-08-19T20:43:00+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    });\n\n    it('should throw an error when the evaluation does not exist', async () => {\n      expect.assertions(1);\n      await expect(evaluationsService.findById('-1')).rejects.toThrow(\n        NotFoundException",
        "summary": "<p>When two functions have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but\nmay be confusing to maintainers. In the latter case, the code should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {  // Noncompliant\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {\n  return calculateCode();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Functions with fewer than 3 lines are ignored.</p>"
      },
      {
        "key": "AXtAUPwji8r-LMdMzpga",
        "rule": "typescript:S1848",
        "severity": "MAJOR",
        "component": "test:apps/backend/src/config/config.service.spec.ts",
        "project": "test",
        "line": 33,
        "hash": "3cf63da6002c83ff5e01af3ea9a377fe",
        "textRange": {
          "startLine": 33,
          "endLine": 33,
          "startOffset": 6,
          "endOffset": 23
        },
        "flows": [],
        "status": "OPEN",
        "message": "Either remove this useless object instantiation of \"ConfigService\" or use it.",
        "effort": "5min",
        "debt": "5min",
        "author": "60075714+samuelsunvold@users.noreply.github.com",
        "tags": [],
        "creationDate": "2020-07-01T16:16:10+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "BUG",
        "scope": "MAIN",
        "snip": "      const consoleSpy = jest.spyOn(console, 'log');\n      // Used to make sure logs are outputted\n      new ConfigService();\n      expect(consoleSpy).toHaveBeenCalledWith(\n        'Unable to read configuration file `.env`!'\n      );",
        "summary": "<p>There is no good reason to create a new object to not do anything with it. Most of the time, this is due to a missing piece of code and so could\nlead to an unexpected behavior in production.</p>\n<p>If it was done on purpose because the constructor has side-effects, then that side-effect code should be moved into a separate method and called\ndirectly.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nnew MyConstructor(); // Non-Compliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar something = new MyConstructor();  // Compliant\n</pre>\n<h2>Exceptions</h2>\n<p>Immediately dropped new objects inside <code>try</code>-statements are ignored.</p>\n<pre>\ntry {\n  new MyConstructor();\n} catch (e) {\n  /* ... */\n}\n</pre>"
      },
      {
        "key": "AXtAUPwFi8r-LMdMzpgY",
        "rule": "typescript:S4144",
        "severity": "MAJOR",
        "component": "test:apps/backend/src/pipes/password-complexity.pipe.spec.ts",
        "project": "test",
        "line": 141,
        "hash": "7bdcb56ce070e980805d0246390b76f1",
        "textRange": {
          "startLine": 141,
          "endLine": 141,
          "startOffset": 16,
          "endOffset": 18
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:apps/backend/src/pipes/password-complexity.pipe.spec.ts",
                "textRange": {
                  "startLine": 135,
                  "endLine": 135,
                  "startOffset": 16,
                  "endOffset": 18
                },
                "msg": "Original implementation"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Update this function so that its implementation is not identical to the one on line 135.",
        "effort": "15min",
        "debt": "15min",
        "author": "kfagan@mitre.org",
        "tags": [
          "confusing",
          "duplicate",
          "suspicious"
        ],
        "creationDate": "2020-07-01T13:38:16+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        )\n      ).toThrowError(BadRequestException);\n      expect(() =>\n        passwordComplexityPipe.transform(\n          CREATE_USER_DTO_TEST_OBJ_WITH_MISSING_PASSWORD_FIELD,\n          metaData",
        "summary": "<p>When two functions have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but\nmay be confusing to maintainers. In the latter case, the code should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {  // Noncompliant\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {\n  return calculateCode();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Functions with fewer than 3 lines are ignored.</p>"
      },
      {
        "key": "AXtAUPwFi8r-LMdMzpgZ",
        "rule": "typescript:S4144",
        "severity": "MAJOR",
        "component": "test:apps/backend/src/pipes/password-complexity.pipe.spec.ts",
        "project": "test",
        "line": 161,
        "hash": "7bdcb56ce070e980805d0246390b76f1",
        "textRange": {
          "startLine": 161,
          "endLine": 161,
          "startOffset": 16,
          "endOffset": 18
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:apps/backend/src/pipes/password-complexity.pipe.spec.ts",
                "textRange": {
                  "startLine": 155,
                  "endLine": 155,
                  "startOffset": 16,
                  "endOffset": 18
                },
                "msg": "Original implementation"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Update this function so that its implementation is not identical to the one on line 155.",
        "effort": "15min",
        "debt": "15min",
        "author": "kfagan@mitre.org",
        "tags": [
          "confusing",
          "duplicate",
          "suspicious"
        ],
        "creationDate": "2020-07-01T13:38:16+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        )\n      ).toThrowError(BadRequestException);\n      expect(() =>\n        passwordComplexityPipe.transform(\n          UPDATE_USER_DTO_TEST_WITHOUT_PASSWORD,\n          metaData",
        "summary": "<p>When two functions have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but\nmay be confusing to maintainers. In the latter case, the code should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {  // Noncompliant\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {\n  return calculateCode();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Functions with fewer than 3 lines are ignored.</p>"
      },
      {
        "key": "AXtAUPv_i8r-LMdMzpgX",
        "rule": "typescript:S4144",
        "severity": "MAJOR",
        "component": "test:apps/backend/src/pipes/passwords-match.pipe.spec.ts",
        "project": "test",
        "line": 57,
        "hash": "7bdcb56ce070e980805d0246390b76f1",
        "textRange": {
          "startLine": 57,
          "endLine": 57,
          "startOffset": 16,
          "endOffset": 18
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:apps/backend/src/pipes/passwords-match.pipe.spec.ts",
                "textRange": {
                  "startLine": 51,
                  "endLine": 51,
                  "startOffset": 16,
                  "endOffset": 18
                },
                "msg": "Original implementation"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Update this function so that its implementation is not identical to the one on line 51.",
        "effort": "15min",
        "debt": "15min",
        "author": "kfagan@mitre.org",
        "tags": [
          "confusing",
          "duplicate",
          "suspicious"
        ],
        "creationDate": "2020-07-01T13:38:16+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        )\n      ).toThrowError(BadRequestException);\n      expect(() =>\n        passwordsMatchPipe.transform(\n          CREATE_USER_DTO_TEST_OBJ_WITH_UNMATCHING_PASSWORDS,\n          metaData",
        "summary": "<p>When two functions have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but\nmay be confusing to maintainers. In the latter case, the code should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {  // Noncompliant\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {\n  return calculateCode();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Functions with fewer than 3 lines are ignored.</p>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzph6",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 229,
        "hash": "b981ea8d10d148243a1b3b9ee8a0c3a4",
        "textRange": {
          "startLine": 229,
          "endLine": 229,
          "startOffset": 32,
          "endOffset": 43
        },
        "flows": [],
        "status": "OPEN",
        "message": "'typ' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzph7",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 229,
        "hash": "b981ea8d10d148243a1b3b9ee8a0c3a4",
        "textRange": {
          "startLine": 229,
          "endLine": 229,
          "startOffset": 45,
          "endOffset": 53
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzph8",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 234,
        "hash": "c0531a3bd0eb2b95bf1124e7638d6e3d",
        "textRange": {
          "startLine": 234,
          "endLine": 234,
          "startOffset": 41,
          "endOffset": 49
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformUnion(typs: any[], val: any): any {\n        // val must validate against one typ in typs\n        const l = typs.length;\n        for (let i = 0; i < l; i++) {",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzph-",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 246,
        "hash": "f326b05dbcd91d3c9c8640bc74bcce26",
        "textRange": {
          "startLine": 246,
          "endLine": 246,
          "startOffset": 44,
          "endOffset": 52
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformEnum(cases: string[], val: any): any {\n        if (cases.indexOf(val) !== -1) return val;\n        return invalidValue(cases, val);\n    }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzph_",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 251,
        "hash": "1c3e797b8d85c13b868b149ec110baa3",
        "textRange": {
          "startLine": 251,
          "endLine": 251,
          "startOffset": 28,
          "endOffset": 36
        },
        "flows": [],
        "status": "OPEN",
        "message": "'typ' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzpiA",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 251,
        "hash": "1c3e797b8d85c13b868b149ec110baa3",
        "textRange": {
          "startLine": 251,
          "endLine": 251,
          "startOffset": 38,
          "endOffset": 46
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzphs",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 91,
        "hash": "b981ea8d10d148243a1b3b9ee8a0c3a4",
        "textRange": {
          "startLine": 91,
          "endLine": 91,
          "startOffset": 32,
          "endOffset": 43
        },
        "flows": [],
        "status": "OPEN",
        "message": "'typ' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzpht",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 91,
        "hash": "b981ea8d10d148243a1b3b9ee8a0c3a4",
        "textRange": {
          "startLine": 91,
          "endLine": 91,
          "startOffset": 45,
          "endOffset": 53
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzphu",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 96,
        "hash": "c0531a3bd0eb2b95bf1124e7638d6e3d",
        "textRange": {
          "startLine": 96,
          "endLine": 96,
          "startOffset": 41,
          "endOffset": 49
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformUnion(typs: any[], val: any): any {\n        // val must validate against one typ in typs\n        const l = typs.length;\n        for (let i = 0; i < l; i++) {",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzphw",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 108,
        "hash": "f326b05dbcd91d3c9c8640bc74bcce26",
        "textRange": {
          "startLine": 108,
          "endLine": 108,
          "startOffset": 44,
          "endOffset": 52
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformEnum(cases: string[], val: any): any {\n        if (cases.indexOf(val) !== -1) return val;\n        return invalidValue(cases, val);\n    }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzphx",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 113,
        "hash": "1c3e797b8d85c13b868b149ec110baa3",
        "textRange": {
          "startLine": 113,
          "endLine": 113,
          "startOffset": 28,
          "endOffset": 36
        },
        "flows": [],
        "status": "OPEN",
        "message": "'typ' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzphy",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 113,
        "hash": "1c3e797b8d85c13b868b149ec110baa3",
        "textRange": {
          "startLine": 113,
          "endLine": 113,
          "startOffset": 38,
          "endOffset": 46
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphe",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 148,
        "hash": "b981ea8d10d148243a1b3b9ee8a0c3a4",
        "textRange": {
          "startLine": 148,
          "endLine": 148,
          "startOffset": 32,
          "endOffset": 43
        },
        "flows": [],
        "status": "OPEN",
        "message": "'typ' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphf",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 148,
        "hash": "b981ea8d10d148243a1b3b9ee8a0c3a4",
        "textRange": {
          "startLine": 148,
          "endLine": 148,
          "startOffset": 45,
          "endOffset": 53
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphg",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 153,
        "hash": "c0531a3bd0eb2b95bf1124e7638d6e3d",
        "textRange": {
          "startLine": 153,
          "endLine": 153,
          "startOffset": 41,
          "endOffset": 49
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformUnion(typs: any[], val: any): any {\n        // val must validate against one typ in typs\n        const l = typs.length;\n        for (let i = 0; i < l; i++) {",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphi",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 165,
        "hash": "f326b05dbcd91d3c9c8640bc74bcce26",
        "textRange": {
          "startLine": 165,
          "endLine": 165,
          "startOffset": 44,
          "endOffset": 52
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformEnum(cases: string[], val: any): any {\n        if (cases.indexOf(val) !== -1) return val;\n        return invalidValue(cases, val);\n    }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphj",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 170,
        "hash": "1c3e797b8d85c13b868b149ec110baa3",
        "textRange": {
          "startLine": 170,
          "endLine": 170,
          "startOffset": 28,
          "endOffset": 36
        },
        "flows": [],
        "status": "OPEN",
        "message": "'typ' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphk",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 170,
        "hash": "1c3e797b8d85c13b868b149ec110baa3",
        "textRange": {
          "startLine": 170,
          "endLine": 170,
          "startOffset": 38,
          "endOffset": 46
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      }
    ],
    "components": [
      {
        "key": "test:apps/frontend/src/components/cards/controltable/ControlRowDetails.vue",
        "enabled": true,
        "qualifier": "FIL",
        "name": "ControlRowDetails.vue",
        "longName": "apps/frontend/src/components/cards/controltable/ControlRowDetails.vue",
        "path": "apps/frontend/src/components/cards/controltable/ControlRowDetails.vue"
      },
      {
        "key": "test:apps/backend/src/pipes/passwords-match.pipe.spec.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "passwords-match.pipe.spec.ts",
        "longName": "apps/backend/src/pipes/passwords-match.pipe.spec.ts",
        "path": "apps/backend/src/pipes/passwords-match.pipe.spec.ts"
      },
      {
        "key": "test:apps/backend/src/pipes/password-complexity.pipe.spec.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "password-complexity.pipe.spec.ts",
        "longName": "apps/backend/src/pipes/password-complexity.pipe.spec.ts",
        "path": "apps/backend/src/pipes/password-complexity.pipe.spec.ts"
      },
      {
        "key": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
        "enabled": true,
        "qualifier": "FIL",
        "name": "ControlTable.vue",
        "longName": "apps/frontend/src/components/cards/controltable/ControlTable.vue",
        "path": "apps/frontend/src/components/cards/controltable/ControlTable.vue"
      },
      {
        "key": "test:libs/hdf-converters/src/base-converter.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "base-converter.ts",
        "longName": "libs/hdf-converters/src/base-converter.ts",
        "path": "libs/hdf-converters/src/base-converter.ts"
      },
      {
        "key": "test:apps/frontend/src/utilities/treemap_util.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "treemap_util.ts",
        "longName": "apps/frontend/src/utilities/treemap_util.ts",
        "path": "apps/frontend/src/utilities/treemap_util.ts"
      },
      {
        "key": "test:apps/frontend/src/store/data_store.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "data_store.ts",
        "longName": "apps/frontend/src/store/data_store.ts",
        "path": "apps/frontend/src/store/data_store.ts"
      },
      {
        "key": "test:apps/frontend/src/store/data_filters.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "data_filters.ts",
        "longName": "apps/frontend/src/store/data_filters.ts",
        "path": "apps/frontend/src/store/data_filters.ts"
      },
      {
        "key": "test:apps/backend/src/evaluations/evaluations.service.spec.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "evaluations.service.spec.ts",
        "longName": "apps/backend/src/evaluations/evaluations.service.spec.ts",
        "path": "apps/backend/src/evaluations/evaluations.service.spec.ts"
      },
      {
        "key": "test:apps/frontend/src/components/global/upload_tabs/aws/S3Reader.vue",
        "enabled": true,
        "qualifier": "FIL",
        "name": "S3Reader.vue",
        "longName": "apps/frontend/src/components/global/upload_tabs/aws/S3Reader.vue",
        "path": "apps/frontend/src/components/global/upload_tabs/aws/S3Reader.vue"
      },
      {
        "key": "test:apps/frontend/src/components/global/upload_tabs/aws/FileList.vue",
        "enabled": true,
        "qualifier": "FIL",
        "name": "FileList.vue",
        "longName": "apps/frontend/src/components/global/upload_tabs/aws/FileList.vue",
        "path": "apps/frontend/src/components/global/upload_tabs/aws/FileList.vue"
      },
      {
        "key": "test:apps/frontend/src/components/global/upload_tabs/aws/AuthStepMFA.vue",
        "enabled": true,
        "qualifier": "FIL",
        "name": "AuthStepMFA.vue",
        "longName": "apps/frontend/src/components/global/upload_tabs/aws/AuthStepMFA.vue",
        "path": "apps/frontend/src/components/global/upload_tabs/aws/AuthStepMFA.vue"
      },
      {
        "key": "test:apps/frontend/src/components/global/upload_tabs/aws/AuthStepBasic.vue",
        "enabled": true,
        "qualifier": "FIL",
        "name": "AuthStepBasic.vue",
        "longName": "apps/frontend/src/components/global/upload_tabs/aws/AuthStepBasic.vue",
        "path": "apps/frontend/src/components/global/upload_tabs/aws/AuthStepBasic.vue"
      },
      {
        "key": "test:apps/frontend/src/utilities/delta_util.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "delta_util.ts",
        "longName": "apps/frontend/src/utilities/delta_util.ts",
        "path": "apps/frontend/src/utilities/delta_util.ts"
      },
      {
        "key": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
        "enabled": true,
        "qualifier": "FIL",
        "name": "Treemap.vue",
        "longName": "apps/frontend/src/components/cards/treemap/Treemap.vue",
        "path": "apps/frontend/src/components/cards/treemap/Treemap.vue"
      },
      {
        "key": "test:apps/frontend/tests/unit/Compare.spec.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "Compare.spec.ts",
        "longName": "apps/frontend/tests/unit/Compare.spec.ts",
        "path": "apps/frontend/tests/unit/Compare.spec.ts"
      },
      {
        "key": "test:apps/frontend/src/utilities/format_util.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "format_util.ts",
        "longName": "apps/frontend/src/utilities/format_util.ts",
        "path": "apps/frontend/src/utilities/format_util.ts"
      },
      {
        "key": "test:apps/frontend/src/utilities/splunk_util.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "splunk_util.ts",
        "longName": "apps/frontend/src/utilities/splunk_util.ts",
        "path": "apps/frontend/src/utilities/splunk_util.ts"
      },
      {
        "key": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "exec-jsonmin.ts",
        "longName": "libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "path": "libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts"
      },
      {
        "key": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "exec-json.ts",
        "longName": "libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "path": "libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts"
      },
      {
        "key": "test:apps/frontend/src/components/cards/treemap/Cell.vue",
        "enabled": true,
        "qualifier": "FIL",
        "name": "Cell.vue",
        "longName": "apps/frontend/src/components/cards/treemap/Cell.vue",
        "path": "apps/frontend/src/components/cards/treemap/Cell.vue"
      },
      {
        "key": "test:libs/inspecjs/src/context.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "context.ts",
        "longName": "libs/inspecjs/src/context.ts",
        "path": "libs/inspecjs/src/context.ts"
      },
      {
        "key": "test:apps/frontend/src/components/generic/ApexLineChart.vue",
        "enabled": true,
        "qualifier": "FIL",
        "name": "ApexLineChart.vue",
        "longName": "apps/frontend/src/components/generic/ApexLineChart.vue",
        "path": "apps/frontend/src/components/generic/ApexLineChart.vue"
      },
      {
        "key": "test:libs/inspecjs/src/nist.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "nist.ts",
        "longName": "libs/inspecjs/src/nist.ts",
        "path": "libs/inspecjs/src/nist.ts"
      },
      {
        "key": "test",
        "enabled": true,
        "qualifier": "TRK",
        "name": "test",
        "longName": "test"
      },
      {
        "key": "test:apps/backend/src/config/config.service.spec.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "config.service.spec.ts",
        "longName": "apps/backend/src/config/config.service.spec.ts",
        "path": "apps/backend/src/config/config.service.spec.ts"
      },
      {
        "key": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "profile-json.ts",
        "longName": "libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "path": "libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts"
      }
    ],
    "facets": []
  },
  "/api/sources/raw?key=test:apps/frontend/src/components/cards/controltable/ControlTable.vue": "<template>\n  <v-container fluid class=\"font-weight-bold\">\n    <div\n      ref=\"controlTableTitle\"\n      :class=\"\n        $vuetify.breakpoint.smAndDown\n          ? 'control-table-title'\n          : 'pinned-header control-table-title'\n      \"\n      :style=\"controlTableTitleStyle\"\n    >\n      <!-- Toolbar -->\n      <v-row v-resize=\"onResize\">\n        <v-row>\n          <v-col cols=\"12\" md=\"3\" class=\"pb-0\">\n            <v-card-title class=\"pb-0\">Results View Data</v-card-title>\n          </v-col>\n          <v-spacer />\n          <v-col cols=\"3\" md=\"auto\" class=\"text-right pl-6 pb-0\">\n            <v-switch\n              v-model=\"displayUnviewedControls\"\n              label=\"Show Only Unviewed\"\n            />\n          </v-col>\n          <v-col cols=\"3\" md=\"auto\" class=\"text-right pb-0\">\n            <v-switch v-model=\"syncTabs\" label=\"Sync Tabs\" />\n          </v-col>\n          <v-col cols=\"3\" md=\"auto\" class=\"text-right pb-0\">\n            <v-switch\n              v-model=\"singleExpand\"\n              label=\"Single Expand\"\n              @change=\"handleToggleSingleExpand\"\n            />\n          </v-col>\n          <v-col cols=\"3\" md=\"auto\" class=\"text-right pb-0\">\n            <v-switch v-model=\"expandAll\" label=\"Expand All\" class=\"mr-5\" />\n          </v-col>\n        </v-row>\n      </v-row>\n\n      <!-- Header. This should mirror the structure of ControlRowHeader -->\n      <ResponsiveRowSwitch>\n        <template #status>\n          <ColumnHeader\n            text=\"Status\"\n            :sort=\"sortStatus\"\n            @input=\"set_sort('status', $event)\"\n          />\n        </template>\n\n        <template #set>\n          <ColumnHeader\n            text=\"Result Set\"\n            :sort=\"sortSet\"\n            @input=\"set_sort('set', $event)\"\n          />\n        </template>\n\n        <template #id>\n          <ColumnHeader\n            text=\"ID\"\n            :sort=\"sortId\"\n            @input=\"set_sort('id', $event)\"\n          />\n        </template>\n\n        <template #severity>\n          <ColumnHeader\n            :text=\"showImpact ? 'Impact' : 'Severity'\"\n            :sort=\"sortSeverity\"\n            @input=\"set_sort('severity', $event)\"\n          />\n        </template>\n\n        <template #title>\n          <ColumnHeader text=\"Title\" sort=\"disabled\" />\n        </template>\n\n        <template #tags>\n          <ColumnHeader text=\"800-53 Controls & CCIs\" sort=\"disabled\" />\n        </template>\n\n        <template #runTime>\n          <ColumnHeader\n            text=\"Run Time\"\n            :sort=\"sortRunTime\"\n            @input=\"set_sort('runTime', $event)\"\n          />\n        </template>\n\n        <template #viewed class=\"my-2 px-1\">\n          <ColumnHeader\n            text=\"Controls Viewed\"\n            sort=\"disabled\"\n            :viewed-header=\"true\"\n            :number-of-viewed-controls=\"viewedControlIds.length\"\n            :number-of-all-controls=\"raw_items.length\"\n          />\n        </template>\n      </ResponsiveRowSwitch>\n    </div>\n\n    <!-- Body -->\n    <v-lazy\n      v-for=\"item in items\"\n      :key=\"item.key\"\n      min-height=\"50\"\n      transition=\"fade-transition\"\n    >\n      <div :id=\"striptoChars(item.key)\">\n        <ControlRowHeader\n          :class=\"$vuetify.breakpoint.smAndDown ? '' : 'pinned-header'\"\n          :style=\"controlRowPinOffset\"\n          :control=\"item.control\"\n          :expanded=\"expanded.includes(item.key)\"\n          :show-impact=\"showImpact\"\n          :viewed-controls=\"viewedControlIds\"\n          @toggle=\"toggle(item.key)\"\n          @control-viewed=\"toggleControlViewed\"\n        />\n        <ControlRowDetails\n          v-if=\"expanded.includes(item.key)\"\n          :control=\"item.control\"\n          :tab=\"syncTabs ? syncTab : undefined\"\n          @update:tab=\"updateTab\"\n        />\n      </div>\n    </v-lazy>\n  </v-container>\n</template>\n\n<script lang=\"ts\">\nimport ControlRowDetails from '@/components/cards/controltable/ControlRowDetails.vue';\nimport ControlRowHeader, {\n  getControlRunTime\n} from '@/components/cards/controltable/ControlRowHeader.vue';\nimport ResponsiveRowSwitch from '@/components/cards/controltable/ResponsiveRowSwitch.vue';\nimport ColumnHeader, {Sort} from '@/components/generic/ColumnHeader.vue';\nimport {Filter, FilteredDataModule} from '@/store/data_filters';\nimport {HeightsModule} from '@/store/heights';\nimport {control_unique_key} from '@/utilities/format_util';\nimport {ContextualizedControl} from 'inspecjs';\nimport _ from 'lodash';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\nimport {Prop, Ref} from 'vue-property-decorator';\n\n// Tracks the visibility of an HDF control\ninterface ListElt {\n  // A unique id to be used as a key.\n  key: string;\n\n  filename: string;\n\n  // Computed values for status and severity \"value\", for sorting\n  status_val: number;\n  severity_val: number;\n\n  control: ContextualizedControl;\n}\n\n@Component({\n  components: {\n    ControlRowHeader,\n    ControlRowDetails,\n    ColumnHeader,\n    ResponsiveRowSwitch\n  }\n})\nexport default class ControlTable extends Vue {\n  @Ref('controlTableTitle') readonly controlTableTitle!: Element;\n  @Prop({type: Object, required: true}) readonly filter!: Filter;\n  @Prop({type: Boolean, required: true}) readonly showImpact!: boolean;\n\n  // Whether to allow multiple expansions\n  singleExpand = true;\n\n  // If the currently selected tab should sync\n  syncTabs = false;\n  syncTab = 'tab-test';\n\n  // List of currently expanded options. If unique id is in here, it is expanded\n  expanded: Array<string> = [];\n\n  // Sorts\n  sortId: Sort = 'none';\n  sortStatus: Sort = 'none';\n  sortSet: Sort = 'none';\n  sortSeverity: Sort = 'none';\n  sortRunTime: Sort = 'none';\n\n  // Used for viewed/unviewed controls.\n  viewedControlIds: string[] = [];\n  displayUnviewedControls = true;\n\n  toggleControlViewed(control: ContextualizedControl) {\n    const alreadyViewed = this.viewedControlIds.indexOf(control.data.id);\n    // If the control hasn't been marked as viewed yet, mark it as viewed.\n    if (alreadyViewed === -1) {\n      this.viewedControlIds.push(control.data.id);\n    }\n    // Else, remove it from the view controls array.\n    else {\n      this.viewedControlIds.splice(alreadyViewed, 1);\n    }\n  }\n\n  mounted() {\n    this.onResize();\n  }\n\n  onResize() {\n    // Allow the page to settle before checking the controlTableHeader height\n    // (this is what $nextTick is supposed to do but it's firing too quickly)\n    setTimeout(() => {\n      HeightsModule.setControlTableHeaderHeight(\n        this.controlTableTitle?.clientHeight\n      );\n    }, 2000);\n  }\n\n  /** Callback to handle setting a new sort */\n  set_sort(column: string, newSort: Sort) {\n    this.sortId = 'none';\n    this.sortSet = 'none';\n    this.sortStatus = 'none';\n    this.sortSeverity = 'none';\n    this.sortRunTime = 'none';\n    switch (column) {\n      case 'id':\n        this.sortId = newSort;\n        break;\n      case 'status':\n        this.sortStatus = newSort;\n        break;\n      case 'set':\n        this.sortSet = newSort;\n        break;\n      case 'severity':\n        this.sortSeverity = newSort;\n        break;\n      case 'runTime':\n        this.sortRunTime = newSort;\n        break;\n    }\n  }\n\n  get expandAll() {\n    return this.expanded.length === this.items.length;\n  }\n\n  set expandAll(value: boolean) {\n    if (value) {\n      this.singleExpand = false;\n      this.expanded = this.items.map((items) => items.key);\n    } else {\n      this.expanded = [];\n    }\n  }\n\n  get controlTableTitleStyle() {\n    return {top: `${HeightsModule.topbarHeight}px`};\n  }\n\n  get controlRowPinOffset() {\n    // There is ~10px of padding being added which makes the ControlRowHeader look out of place\n    return {top: `${this.topOfPage - 10}px`};\n  }\n\n  // The top of the page, relative to the topbar and the title bar\n  get topOfPage() {\n    return HeightsModule.topbarHeight + HeightsModule.controlTableHeaderHeight;\n  }\n\n  /** Closes all open controls when single-expand is re-enabled */\n  async handleToggleSingleExpand(singleExpand: boolean): Promise<void> {\n    if (singleExpand) {\n      this.expandAll = false;\n    }\n  }\n\n  async updateTab(tab: string) {\n    this.syncTab = tab;\n  }\n\n  /** Toggles the given expansion of a control details panel */\n  toggle(key: string) {\n    if (this.singleExpand) {\n      // Check if key already there\n      const had = this.expanded.includes(key);\n\n      // Clear\n      this.expanded = [];\n\n      // If key is new, add it\n      if (!had) {\n        this.expanded.push(key);\n        this.jump_to_key(key);\n      }\n    } else {\n      // Add or remove it from the set, as appropriate. Shortcut this by only adding if delete fails\n      const i = this.expanded.indexOf(key);\n      if (i < 0) {\n        this.expanded.push(key);\n        this.jump_to_key(key);\n      } else {\n        this.expanded.splice(i, 1);\n      }\n    }\n  }\n\n  jump_to_key(key: string) {\n    if (!this.$vuetify.breakpoint.smAndDown) {\n      this.$nextTick(() => {\n        this.$vuetify.goTo(`#${this.striptoChars(key)}`, {\n          offset: this.topOfPage,\n          duration: 300\n        });\n      });\n    }\n  }\n\n  striptoChars(key: string) {\n    return key.replace(/[^a-z0-9]/gi, '');\n  }\n\n  /** Return items as key, value pairs */\n  get raw_items(): ListElt[] {\n    return FilteredDataModule.controls(this.filter).map((d) => {\n      const key = control_unique_key(d);\n\n      // File, hdf wrapper\n      return {\n        key,\n        control: d,\n        status_val: [\n          'Passed',\n          'Not Applicable',\n          'No Data',\n          'Not Reviewed',\n          'Profile Error',\n          'Failed'\n        ].indexOf(d.root.hdf.status),\n        severity_val: ['none', 'low', 'medium', 'high', 'critical'].indexOf(\n          d.root.hdf.severity\n        ),\n        filename: _.get(d, 'sourcedFrom.sourcedFrom.from_file.filename')\n      };\n    });\n  }\n\n  /** Return items sorted and filters out viewed controls */\n  get items(): ListElt[] {\n    // Controls ascending/descending\n    let factor = 1;\n    // Whether or not we need to sort\n    let sort = true;\n    // Our comparator function\n    let cmp: (a: ListElt, b: ListElt) => number;\n\n    let items = this.raw_items;\n\n    if (this.sortId === 'ascending' || this.sortId === 'descending') {\n      cmp = (a: ListElt, b: ListElt) =>\n        a.control.data.id.localeCompare(b.control.data.id);\n      if (this.sortId === 'ascending') {\n        factor = -1;\n      }\n    } else if (\n      this.sortStatus === 'ascending' ||\n      this.sortStatus === 'descending'\n    ) {\n      cmp = (a: ListElt, b: ListElt) => a.status_val - b.status_val;\n      if (this.sortStatus === 'ascending') {\n        factor = -1;\n      }\n    } else if (\n      this.sortSeverity === 'ascending' ||\n      this.sortSeverity === 'descending'\n    ) {\n      cmp = (a: ListElt, b: ListElt) => a.severity_val - b.severity_val;\n      if (this.sortSeverity === 'ascending') {\n        factor = -1;\n      }\n    } else if (this.sortSet === 'ascending' || this.sortSet === 'descending') {\n      cmp = (a: ListElt, b: ListElt) => a.filename.localeCompare(b.filename);\n      if (this.sortSet === 'ascending') {\n        factor = -1;\n      }\n    } else if (\n      this.sortRunTime === 'ascending' ||\n      this.sortRunTime === 'descending'\n    ) {\n      cmp = (a: ListElt, b: ListElt) =>\n        getControlRunTime(b.control) - getControlRunTime(a.control);\n      if (this.sortRunTime === 'ascending') {\n        factor = -1;\n      }\n    } else {\n      sort = false;\n    }\n\n    // Displays only unviewed controls.\n    if (this.displayUnviewedControls) {\n      items = items.filter(\n        (val) => !this.viewedControlIds.includes(val.control.data.id)\n      );\n    }\n\n    if (sort === true) {\n      items = items.sort((a, b) => cmp(a, b) * factor);\n    }\n\n    return items;\n  }\n}\n</script>\n\n<style scoped>\n.pinned-header {\n  position: sticky;\n  z-index: 2;\n  padding-top: 2px;\n  padding-bottom: 2px;\n}\n\n.control-table-title {\n  background-color: var(--v-secondary-lighten1);\n  z-index: 10;\n}\n</style>\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/components/global/upload_tabs/aws/AuthStepBasic.vue": "<template>\n  <v-stepper-content step=\"1\">\n    <v-form v-model=\"valid\">\n      <v-text-field\n        :value=\"accessToken\"\n        label=\"User Account Access Token\"\n        lazy-validation=\"lazy\"\n        :rules=\"[reqRule]\"\n        @input=\"change_access_token\"\n      />\n      <v-text-field\n        :value=\"secretToken\"\n        label=\"User Account Secret Token\"\n        type=\"password\"\n        :rules=\"[reqRule]\"\n        @input=\"change_secret_token\"\n      />\n    </v-form>\n    <v-btn\n      color=\"primary\"\n      :disabled=\"!valid\"\n      class=\"my-2 mr-3\"\n      @click=\"$emit('auth-basic')\"\n    >\n      Basic Login\n    </v-btn>\n    <v-btn\n      color=\"green\"\n      :disabled=\"!valid\"\n      class=\"my-2 mr-3\"\n      @click=\"$emit('goto-mfa')\"\n    >\n      MFA Login\n    </v-btn>\n  </v-stepper-content>\n</template>\n\n<script lang=\"ts\">\nimport FileList from '@/components/global/upload_tabs/aws/FileList.vue';\nimport {LocalStorageVal} from '@/utilities/helper_util';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\nimport {Prop} from 'vue-property-decorator';\n\n/** Localstorage keys */\nconst localAccessToken = new LocalStorageVal<string>('aws_s3_access_token');\nconst localSecretToken = new LocalStorageVal<string>('aws_s3_secret_token');\n\n/**\n * File reader component for taking in inspec JSON data.\n * Uploads data to the store with unique IDs asynchronously as soon as data is entered.\n * Emits \"got-files\" with a list of the unique_ids of the loaded files.\n */\n@Component({\n  components: {\n    FileList\n  }\n})\nexport default class S3Reader extends Vue {\n  @Prop({type: String}) readonly accessToken!: string;\n  @Prop({type: String}) readonly secretToken!: string;\n\n  /** Models if currently displayed form is valid.\n   * Shouldn't be used to interpret literally anything else as valid - just checks fields filled\n   */\n  valid = false;\n\n  /** Form required field rules. Maybe eventually expand to other stuff */\n  reqRule = (v: string | null | undefined) =>\n    (v || '').trim().length > 0 || 'Field is Required';\n\n  // Callback for change in access token\n  change_access_token(token: string) {\n    localAccessToken.set(token);\n    this.$emit('update:accessToken', token);\n  }\n\n  // Callback for change in secret token\n  change_secret_token(token: string) {\n    localSecretToken.set(token);\n    this.$emit('update:secretToken', token);\n  }\n\n  /** On mount, try to look up stored auth info */\n  mounted() {\n    // Load our credentials\n    this.change_access_token(localAccessToken.get_default(''));\n    this.change_secret_token(localSecretToken.get_default(''));\n  }\n}\n</script>\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/components/global/upload_tabs/aws/AuthStepMFA.vue": "<template>\n  <v-stepper-content step=\"2\">\n    <v-form v-model=\"valid\">\n      <v-text-field\n        :value=\"mfaToken\"\n        label=\"MFA Token\"\n        :rules=\"[reqRule, mfaRule]\"\n        @input=\"change_mfa_token\"\n        @keyup.enter=\"proceed\"\n      />\n      <v-text-field\n        :value=\"mfaSerial\"\n        label=\"MFA Device ARN (Optional)\"\n        hint=\"Defaults to virtual IAM device\"\n        @input=\"changeMFASerial\"\n        @keyup.enter=\"proceed\"\n      />\n      <v-btn\n        color=\"primary\"\n        :disabled=\"!valid\"\n        class=\"my-2 mr-2\"\n        @click=\"$emit('auth-mfa')\"\n      >\n        Login\n      </v-btn>\n      <v-btn color=\"red\" class=\"my-2 ml-2\" @click=\"proceed\"> Cancel </v-btn>\n    </v-form>\n  </v-stepper-content>\n</template>\n\n<script lang=\"ts\">\nimport {LocalStorageVal} from '@/utilities/helper_util';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\nimport {PropSync} from 'vue-property-decorator';\n\n/** Localstorage keys */\nconst localMFASerial = new LocalStorageVal<string>('aws_s3_mfa_serial');\n\n/**\n * File reader component for taking in inspec JSON data.\n * Uploads data to the store with unique IDs asynchronously as soon as data is entered.\n * Emits \"got-files\" with a list of the unique_ids of the loaded files.\n */\n@Component\nexport default class S3Reader extends Vue {\n  @PropSync('mfaToken', {type: String}) token!: string;\n  @PropSync('mfaSerial', {type: String}) serial!: string;\n  /** Models if currently displayed form is valid.\n   * Shouldn't be used to interpret literally anything else as valid - just checks fields filled\n   */\n  valid = false;\n\n  /** Form required field rules. Maybe eventually expand to other stuff */\n  reqRule = (v: string | null | undefined) =>\n    (v || '').trim().length > 0 || 'Field is Required';\n\n  mfaRule = (v: string | null | undefined) =>\n    (v || '').trim().match('^\\\\d{6}$') !== null ||\n    'Field must be the 6 number code from a valid authenticator device';\n\n  /** On mount, try to look up stored auth info */\n  mounted() {\n    this.changeMFASerial(localMFASerial.get_default(''));\n  }\n\n  /** Handles changes to mfa serial */\n  change_mfa_token(newValue: string) {\n    this.token = newValue;\n  }\n\n  /** Handles changes to mfa token */\n  changeMFASerial(newValue: string) {\n    localMFASerial.set(newValue);\n    this.serial = newValue;\n  }\n\n  /** When button is pressed or enter is pressed */\n  proceed() {\n    this.$emit('exit-mfa');\n  }\n}\n</script>\n\n",
  "/api/sources/raw?key=test:libs/hdf-converters/src/base-converter.ts": "import {createHash} from 'crypto';\nimport * as htmlparser from 'htmlparser2';\nimport {ExecJSON} from 'inspecjs';\nimport _ from 'lodash';\n\nexport interface ILookupPath {\n  path?: string;\n  transformer?: (value: unknown) => unknown;\n  arrayTransformer?: (value: unknown[], file: unknown) => unknown[];\n  key?: string;\n}\n\nexport type ObjectEntries<T> = {[K in keyof T]: readonly [K, T[K]]}[keyof T];\n/* eslint-disable @typescript-eslint/ban-types */\nexport type MappedTransform<T, U extends ILookupPath> = {\n  [K in keyof T]: Exclude<T[K], undefined | null> extends Array<any>\n    ? MappedTransform<T[K], U>\n    : T[K] extends Function\n    ? T[K]\n    : T[K] extends object\n    ? MappedTransform<\n        T[K] &\n          (U & {\n            arrayTransformer?: (\n              value: unknown[],\n              file: Record<string, unknown>\n            ) => T[K][];\n          }),\n        U\n      >\n    : T[K] | (U & {transformer?: (value: unknown) => T[K]});\n};\nexport type MappedReform<T, U> = {\n  [K in keyof T]: Exclude<T[K], undefined | null> extends Array<any>\n    ? MappedReform<T[K], U>\n    : T[K] extends object\n    ? MappedReform<T[K] & U, U>\n    : Exclude<T[K], U>;\n};\n/* eslint-enable @typescript-eslint/ban-types */\n\n// Hashing Function\nexport function generateHash(data: string, algorithm = 'sha256'): string {\n  const hash = createHash(algorithm);\n  return hash.update(data).digest('hex');\n}\n\nexport function parseHtml(input: unknown): string {\n  const textData: string[] = [];\n  const myParser = new htmlparser.Parser({\n    ontext(text: string) {\n      textData.push(text);\n    }\n  });\n  if (typeof input === 'string') {\n    myParser.write(input);\n  }\n  return textData.join('');\n}\nexport function impactMapping(\n  mapping: Map<string, number>\n): (severity: unknown) => number {\n  return (severity: unknown): number => {\n    if (typeof severity === 'string' || typeof severity === 'number') {\n      return mapping.get(severity.toString().toLowerCase()) || 0;\n    } else {\n      return 0;\n    }\n  };\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction collapseDuplicates<T extends object>(\n  array: Array<T>,\n  key: string,\n  collapseResults: boolean\n): Array<T> {\n  const seen = new Map<string, number>();\n  const newArray: T[] = [];\n  let counter = 0;\n  array.forEach((item: T) => {\n    const propertyValue = _.get(item, key);\n    if (typeof propertyValue === 'string') {\n      const index = seen.get(propertyValue) || 0;\n      if (!seen.has(propertyValue)) {\n        newArray.push(item);\n        seen.set(propertyValue, counter);\n        counter++;\n      } else {\n        const oldResult = _.get(\n          newArray[index],\n          'results'\n        ) as ExecJSON.ControlResult[];\n        const descriptions = oldResult.map((element) =>\n          _.get(element, 'code_desc')\n        );\n        if (collapseResults) {\n          if (\n            descriptions.indexOf(\n              _.get(item, 'results[0].code_desc') as string\n            ) === -1\n          ) {\n            _.set(\n              newArray[index],\n              'results',\n              oldResult.concat(\n                _.get(item, 'results') as ExecJSON.ControlResult[]\n              )\n            );\n          }\n        } else {\n          _.set(\n            newArray[index],\n            'results',\n            oldResult.concat(_.get(item, 'results') as ExecJSON.ControlResult[])\n          );\n        }\n      }\n    }\n  });\n  return newArray;\n}\nexport class BaseConverter {\n  data: Record<string, unknown>;\n  mappings?: MappedTransform<ExecJSON.Execution, ILookupPath>;\n  collapseResults: boolean;\n\n  constructor(data: Record<string, unknown>, collapseResults = false) {\n    this.data = data;\n    this.collapseResults = collapseResults;\n  }\n  setMappings(\n    mappings: MappedTransform<ExecJSON.Execution, ILookupPath>\n  ): void {\n    this.mappings = mappings;\n  }\n  toHdf(): ExecJSON.Execution {\n    if (this.mappings === undefined) {\n      throw new Error('Mappings must be provided');\n    } else {\n      const v = this.convertInternal(this.data, this.mappings);\n      v.profiles.forEach((element) => {\n        element.sha256 = generateHash(JSON.stringify(element));\n      });\n      return v;\n    }\n  }\n\n  objectMap<T, V>(obj: T, fn: (v: ObjectEntries<T>) => V): {[K in keyof T]: V} {\n    return Object.fromEntries(\n      Object.entries(obj).map(([k, v]) => [k, fn(v)])\n    ) as Record<keyof T, V>;\n  }\n  convertInternal<T>(\n    file: Record<string, unknown>,\n    fields: T\n  ): MappedReform<T, ILookupPath> {\n    const result = this.objectMap(fields, (v: ObjectEntries<T>) =>\n      this.evaluate(file, v)\n    );\n    return result as MappedReform<T, ILookupPath>;\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  evaluate<T extends object>(\n    file: Record<string, unknown>,\n    v: Array<T> | T\n  ): T | Array<T> | MappedReform<T, ILookupPath> {\n    const transformer = _.get(v, 'transformer');\n    if (Array.isArray(v)) {\n      return this.handleArray(file, v);\n    } else if (\n      typeof v === 'string' ||\n      typeof v === 'number' ||\n      typeof v === 'boolean' ||\n      v === null\n    ) {\n      return v;\n    } else if (_.has(v, 'path')) {\n      if (typeof transformer === 'function') {\n        return transformer(this.handlePath(file, _.get(v, 'path') as string));\n      }\n      const pathVal = this.handlePath(file, _.get(v, 'path') as string);\n      if (Array.isArray(pathVal)) {\n        return pathVal as T[];\n      }\n      return pathVal as T;\n    }\n    if (typeof transformer === 'function') {\n      return transformer(file);\n    } else {\n      return this.convertInternal(file, v);\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  handleArray<T extends object>(\n    file: Record<string, unknown>,\n    v: Array<T & ILookupPath>\n  ): Array<T> {\n    if (v.length === 0) {\n      return [];\n    }\n    if (v[0].path === undefined) {\n      const arrayTransformer = v[0].arrayTransformer;\n      v = v.map((element) => {\n        return _.omit(element, ['arrayTransformer']) as T & ILookupPath;\n      });\n      let output: Array<T> = [];\n      v.forEach((element) => {\n        output.push(this.evaluate(file, element) as T);\n      });\n      if (arrayTransformer !== undefined) {\n        output = arrayTransformer(output, this.data) as T[];\n      }\n      return output;\n    } else {\n      const path = v[0].path;\n      const key = v[0].key;\n      const arrayTransformer = v[0].arrayTransformer;\n      const transformer = v[0].transformer;\n      if (this.hasPath(file, path)) {\n        const pathVal = this.handlePath(file, path);\n        if (Array.isArray(pathVal)) {\n          v = pathVal.map((element: Record<string, unknown>) => {\n            return _.omit(this.convertInternal(element, v[0]), [\n              'path',\n              'transformer',\n              'arrayTransformer',\n              'key'\n            ]) as T;\n          });\n          if (key !== undefined) {\n            v = collapseDuplicates(v, key, this.collapseResults);\n          }\n          if (arrayTransformer !== undefined) {\n            v = arrayTransformer(v, this.data) as T[];\n          }\n          return v;\n        } else {\n          if (transformer !== undefined) {\n            return [transformer(this.handlePath(file, path)) as T];\n          } else {\n            return [this.handlePath(file, path) as T];\n          }\n        }\n      } else {\n        return [];\n      }\n    }\n  }\n  handlePath(file: Record<string, unknown>, path: string): unknown {\n    if (path.startsWith('$.')) {\n      return _.get(this.data, path.slice(2)) || '';\n    } else {\n      return _.get(file, path) || '';\n    }\n  }\n  hasPath(file: Record<string, unknown>, path: string): boolean {\n    if (path.startsWith('$.')) {\n      return _.has(this.data, path.slice(2));\n    } else {\n      return _.has(file, path);\n    }\n  }\n}\n\n",
  "/api/sources/raw?key=test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts": "// To parse this data:\n//\n//   import { Convert, ExecJSON } from \"./file\";\n//\n//   const execJSON = Convert.toExecJSON(json);\n//\n// These functions will throw an error if the JSON doesn't\n// match the expected interface, even if the JSON is valid.\n\nexport interface ExecJSON {\n    platform:   Platform;\n    profiles:   ExecJSONProfile[];\n    statistics: Statistics;\n    version:    string;\n}\n\nexport interface Platform {\n    /**\n     * The name of the platform this was run on.\n     */\n    name: string;\n    /**\n     * The version of the platform this was run on.\n     */\n    release:    string;\n    target_id?: null | string;\n}\n\nexport interface ExecJSONProfile {\n    attributes:       { [key: string]: any }[];\n    controls:         ExecJSONControl[];\n    copyright?:       null | string;\n    copyright_email?: null | string;\n    depends?:         Dependency[] | null;\n    description?:     null | string;\n    groups:           ControlGroup[];\n    inspec_version?:  null | string;\n    license?:         null | string;\n    maintainer?:      null | string;\n    name:             string;\n    parent_profile?:  null | string;\n    sha256:           string;\n    skip_message?:    null | string;\n    status?:          null | string;\n    status_message?:  null | string;\n    summary?:         null | string;\n    supports:         SupportedPlatform[];\n    title?:           null | string;\n    version?:         null | string;\n}\n\nexport interface ExecJSONControl {\n    /**\n     * The raw source code of the control. Note that if this is an overlay control, it does not\n     * include the underlying source code\n     */\n    code?:         null | string;\n    desc?:         null | string;\n    descriptions?: ControlDescription[] | null;\n    /**\n     * The ID of this control\n     */\n    id:     string;\n    impact: number;\n    refs:   Reference[];\n    /**\n     * A list of all results of the controls describe blocks.\n     *\n     * For instance, if in the controls code we had the following:\n     * describe sshd_config do\n     * its('Port') { should cmp 22 }\n     * end\n     * The result of this block as a ControlResult would be appended to the results list.\n     */\n    results:         ControlResult[];\n    source_location: SourceLocation;\n    tags:            { [key: string]: any };\n    title?:          null | string;\n    waiver_data?:    null | WaiverData;\n}\n\nexport interface ControlDescription {\n    data:  string;\n    label: string;\n}\n\nexport interface Reference {\n    ref?: { [key: string]: any }[] | string;\n    url?: string;\n    uri?: string;\n}\n\nexport interface ControlResult {\n    backtrace?:    string[] | null;\n    code_desc:     string;\n    exception?:    null | string;\n    message?:      null | string;\n    resource?:     null | string;\n    run_time?:     number | null;\n    skip_message?: null | string;\n    start_time:    string;\n    status?:       ControlResultStatus | null;\n}\n\nexport enum ControlResultStatus {\n    Error = \"error\",\n    Failed = \"failed\",\n    Passed = \"passed\",\n    Skipped = \"skipped\",\n}\n\nexport interface SourceLocation {\n    /**\n     * The line at which this statement is located in the file\n     */\n    line?: number | null;\n    /**\n     * Path to the file that this statement originates from\n     */\n    ref?: null | string;\n}\n\nexport interface WaiverData {\n    expiration_date?:       null | string;\n    justification?:         null | string;\n    message?:               null | string;\n    run?:                   boolean | null;\n    skipped_due_to_waiver?: boolean | null | string;\n}\n\nexport interface Dependency {\n    branch?:         null | string;\n    compliance?:     null | string;\n    git?:            null | string;\n    name?:           null | string;\n    path?:           null | string;\n    status?:         null | string;\n    status_message?: null | string;\n    supermarket?:    null | string;\n    url?:            null | string;\n}\n\nexport interface ControlGroup {\n    /**\n     * The control IDs in this group\n     */\n    controls: string[];\n    /**\n     * The unique identifier of the group\n     */\n    id: string;\n    /**\n     * The name of the group\n     */\n    title?: null | string;\n}\n\nexport interface SupportedPlatform {\n    \"os-family\"?:       null | string;\n    \"os-name\"?:         null | string;\n    platform?:          null | string;\n    \"platform-family\"?: null | string;\n    \"platform-name\"?:   null | string;\n    release?:           null | string;\n}\n\nexport interface Statistics {\n    controls?: null | StatisticHash;\n    /**\n     * How long (in seconds) this inspec exec ran for.\n     */\n    duration?: number | null;\n}\n\n/**\n * Breakdowns of control statistics by result\n */\nexport interface StatisticHash {\n    failed?:  null | StatisticBlock;\n    passed?:  null | StatisticBlock;\n    skipped?: null | StatisticBlock;\n}\n\nexport interface StatisticBlock {\n    /**\n     * Total number of controls (in this category) for this inspec execution.\n     */\n    total: number;\n}\n\n// Converts JSON strings to/from your types\n// and asserts the results of JSON.parse at runtime\nexport class Convert {\n    public static toExecJSON(json: string): ExecJSON {\n        return cast(JSON.parse(json), r(\"ExecJSON\"));\n    }\n\n    public static execJSONToJson(value: ExecJSON): string {\n        return JSON.stringify(uncast(value, r(\"ExecJSON\")), null, 2);\n    }\n}\n\nfunction invalidValue(typ: any, val: any, key: any = ''): never {\n    if (key) {\n        throw Error(`Invalid value for key \"${key}\". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);\n    }\n    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );\n}\n\nfunction jsonToJSProps(typ: any): any {\n    if (typ.jsonToJS === undefined) {\n        const map: any = {};\n        typ.props.forEach((p: any) => map[p.json] = { key: p.js, typ: p.typ });\n        typ.jsonToJS = map;\n    }\n    return typ.jsonToJS;\n}\n\nfunction jsToJSONProps(typ: any): any {\n    if (typ.jsToJSON === undefined) {\n        const map: any = {};\n        typ.props.forEach((p: any) => map[p.js] = { key: p.json, typ: p.typ });\n        typ.jsToJSON = map;\n    }\n    return typ.jsToJSON;\n}\n\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }\n\n    function transformUnion(typs: any[], val: any): any {\n        // val must validate against one typ in typs\n        const l = typs.length;\n        for (let i = 0; i < l; i++) {\n            const typ = typs[i];\n            try {\n                return transform(val, typ, getProps);\n            } catch (_) {}\n        }\n        return invalidValue(typs, val);\n    }\n\n    function transformEnum(cases: string[], val: any): any {\n        if (cases.indexOf(val) !== -1) return val;\n        return invalidValue(cases, val);\n    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));\n    }\n\n    function transformDate(val: any): any {\n        if (val === null) {\n            return null;\n        }\n        const d = new Date(val);\n        if (isNaN(d.valueOf())) {\n            return invalidValue(\"Date\", val);\n        }\n        return d;\n    }\n\n    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {\n        if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n            return invalidValue(\"object\", val);\n        }\n        const result: any = {};\n        Object.getOwnPropertyNames(props).forEach(key => {\n            const prop = props[key];\n            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;\n            result[prop.key] = transform(v, prop.typ, getProps, prop.key);\n        });\n        Object.getOwnPropertyNames(val).forEach(key => {\n            if (!Object.prototype.hasOwnProperty.call(props, key)) {\n                result[key] = transform(val[key], additional, getProps, key);\n            }\n        });\n        return result;\n    }\n\n    if (typ === \"any\") return val;\n    if (typ === null) {\n        if (val === null) return val;\n        return invalidValue(typ, val);\n    }\n    if (typ === false) return invalidValue(typ, val);\n    while (typeof typ === \"object\" && typ.ref !== undefined) {\n        typ = typeMap[typ.ref];\n    }\n    if (Array.isArray(typ)) return transformEnum(typ, val);\n    if (typeof typ === \"object\") {\n        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);\n    return transformPrimitive(typ, val);\n}\n\nfunction cast<T>(val: any, typ: any): T {\n    return transform(val, typ, jsonToJSProps);\n}\n\nfunction uncast<T>(val: T, typ: any): any {\n    return transform(val, typ, jsToJSONProps);\n}\n\nfunction a(typ: any) {\n    return { arrayItems: typ };\n}\n\nfunction u(...typs: any[]) {\n    return { unionMembers: typs };\n}\n\nfunction o(props: any[], additional: any) {\n    return { props, additional };\n}\n\nfunction m(additional: any) {\n    return { props: [], additional };\n}\n\nfunction r(name: string) {\n    return { ref: name };\n}\n\nconst typeMap: any = {\n    \"ExecJSON\": o([\n        { json: \"platform\", js: \"platform\", typ: r(\"Platform\") },\n        { json: \"profiles\", js: \"profiles\", typ: a(r(\"ExecJSONProfile\")) },\n        { json: \"statistics\", js: \"statistics\", typ: r(\"Statistics\") },\n        { json: \"version\", js: \"version\", typ: \"\" },\n    ], \"any\"),\n    \"Platform\": o([\n        { json: \"name\", js: \"name\", typ: \"\" },\n        { json: \"release\", js: \"release\", typ: \"\" },\n        { json: \"target_id\", js: \"target_id\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"ExecJSONProfile\": o([\n        { json: \"attributes\", js: \"attributes\", typ: a(m(\"any\")) },\n        { json: \"controls\", js: \"controls\", typ: a(r(\"ExecJSONControl\")) },\n        { json: \"copyright\", js: \"copyright\", typ: u(undefined, u(null, \"\")) },\n        { json: \"copyright_email\", js: \"copyright_email\", typ: u(undefined, u(null, \"\")) },\n        { json: \"depends\", js: \"depends\", typ: u(undefined, u(a(r(\"Dependency\")), null)) },\n        { json: \"description\", js: \"description\", typ: u(undefined, u(null, \"\")) },\n        { json: \"groups\", js: \"groups\", typ: a(r(\"ControlGroup\")) },\n        { json: \"inspec_version\", js: \"inspec_version\", typ: u(undefined, u(null, \"\")) },\n        { json: \"license\", js: \"license\", typ: u(undefined, u(null, \"\")) },\n        { json: \"maintainer\", js: \"maintainer\", typ: u(undefined, u(null, \"\")) },\n        { json: \"name\", js: \"name\", typ: \"\" },\n        { json: \"parent_profile\", js: \"parent_profile\", typ: u(undefined, u(null, \"\")) },\n        { json: \"sha256\", js: \"sha256\", typ: \"\" },\n        { json: \"skip_message\", js: \"skip_message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"status\", js: \"status\", typ: u(undefined, u(null, \"\")) },\n        { json: \"status_message\", js: \"status_message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"summary\", js: \"summary\", typ: u(undefined, u(null, \"\")) },\n        { json: \"supports\", js: \"supports\", typ: a(r(\"SupportedPlatform\")) },\n        { json: \"title\", js: \"title\", typ: u(undefined, u(null, \"\")) },\n        { json: \"version\", js: \"version\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"ExecJSONControl\": o([\n        { json: \"code\", js: \"code\", typ: u(undefined, u(null, \"\")) },\n        { json: \"desc\", js: \"desc\", typ: u(undefined, u(null, \"\")) },\n        { json: \"descriptions\", js: \"descriptions\", typ: u(undefined, u(a(r(\"ControlDescription\")), null)) },\n        { json: \"id\", js: \"id\", typ: \"\" },\n        { json: \"impact\", js: \"impact\", typ: 3.14 },\n        { json: \"refs\", js: \"refs\", typ: a(r(\"Reference\")) },\n        { json: \"results\", js: \"results\", typ: a(r(\"ControlResult\")) },\n        { json: \"source_location\", js: \"source_location\", typ: r(\"SourceLocation\") },\n        { json: \"tags\", js: \"tags\", typ: m(\"any\") },\n        { json: \"title\", js: \"title\", typ: u(undefined, u(null, \"\")) },\n        { json: \"waiver_data\", js: \"waiver_data\", typ: u(undefined, u(null, r(\"WaiverData\"))) },\n    ], \"any\"),\n    \"ControlDescription\": o([\n        { json: \"data\", js: \"data\", typ: \"\" },\n        { json: \"label\", js: \"label\", typ: \"\" },\n    ], \"any\"),\n    \"Reference\": o([\n        { json: \"ref\", js: \"ref\", typ: u(undefined, u(a(m(\"any\")), \"\")) },\n        { json: \"url\", js: \"url\", typ: u(undefined, \"\") },\n        { json: \"uri\", js: \"uri\", typ: u(undefined, \"\") },\n    ], \"any\"),\n    \"ControlResult\": o([\n        { json: \"backtrace\", js: \"backtrace\", typ: u(undefined, u(a(\"\"), null)) },\n        { json: \"code_desc\", js: \"code_desc\", typ: \"\" },\n        { json: \"exception\", js: \"exception\", typ: u(undefined, u(null, \"\")) },\n        { json: \"message\", js: \"message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"resource\", js: \"resource\", typ: u(undefined, u(null, \"\")) },\n        { json: \"run_time\", js: \"run_time\", typ: u(undefined, u(3.14, null)) },\n        { json: \"skip_message\", js: \"skip_message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"start_time\", js: \"start_time\", typ: \"\" },\n        { json: \"status\", js: \"status\", typ: u(undefined, u(r(\"ControlResultStatus\"), null)) },\n    ], \"any\"),\n    \"SourceLocation\": o([\n        { json: \"line\", js: \"line\", typ: u(undefined, u(3.14, null)) },\n        { json: \"ref\", js: \"ref\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"WaiverData\": o([\n        { json: \"expiration_date\", js: \"expiration_date\", typ: u(undefined, u(null, \"\")) },\n        { json: \"justification\", js: \"justification\", typ: u(undefined, u(null, \"\")) },\n        { json: \"message\", js: \"message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"run\", js: \"run\", typ: u(undefined, u(true, null)) },\n        { json: \"skipped_due_to_waiver\", js: \"skipped_due_to_waiver\", typ: u(undefined, u(true, null, \"\")) },\n    ], \"any\"),\n    \"Dependency\": o([\n        { json: \"branch\", js: \"branch\", typ: u(undefined, u(null, \"\")) },\n        { json: \"compliance\", js: \"compliance\", typ: u(undefined, u(null, \"\")) },\n        { json: \"git\", js: \"git\", typ: u(undefined, u(null, \"\")) },\n        { json: \"name\", js: \"name\", typ: u(undefined, u(null, \"\")) },\n        { json: \"path\", js: \"path\", typ: u(undefined, u(null, \"\")) },\n        { json: \"status\", js: \"status\", typ: u(undefined, u(null, \"\")) },\n        { json: \"status_message\", js: \"status_message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"supermarket\", js: \"supermarket\", typ: u(undefined, u(null, \"\")) },\n        { json: \"url\", js: \"url\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"ControlGroup\": o([\n        { json: \"controls\", js: \"controls\", typ: a(\"\") },\n        { json: \"id\", js: \"id\", typ: \"\" },\n        { json: \"title\", js: \"title\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"SupportedPlatform\": o([\n        { json: \"os-family\", js: \"os-family\", typ: u(undefined, u(null, \"\")) },\n        { json: \"os-name\", js: \"os-name\", typ: u(undefined, u(null, \"\")) },\n        { json: \"platform\", js: \"platform\", typ: u(undefined, u(null, \"\")) },\n        { json: \"platform-family\", js: \"platform-family\", typ: u(undefined, u(null, \"\")) },\n        { json: \"platform-name\", js: \"platform-name\", typ: u(undefined, u(null, \"\")) },\n        { json: \"release\", js: \"release\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"Statistics\": o([\n        { json: \"controls\", js: \"controls\", typ: u(undefined, u(null, r(\"StatisticHash\"))) },\n        { json: \"duration\", js: \"duration\", typ: u(undefined, u(3.14, null)) },\n    ], \"any\"),\n    \"StatisticHash\": o([\n        { json: \"failed\", js: \"failed\", typ: u(undefined, u(null, r(\"StatisticBlock\"))) },\n        { json: \"passed\", js: \"passed\", typ: u(undefined, u(null, r(\"StatisticBlock\"))) },\n        { json: \"skipped\", js: \"skipped\", typ: u(undefined, u(null, r(\"StatisticBlock\"))) },\n    ], \"any\"),\n    \"StatisticBlock\": o([\n        { json: \"total\", js: \"total\", typ: 3.14 },\n    ], \"any\"),\n    \"ControlResultStatus\": [\n        \"error\",\n        \"failed\",\n        \"passed\",\n        \"skipped\",\n    ],\n};\n\n",
  "/api/sources/raw?key=test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts": "// To parse this data:\n//\n//   import { Convert, ExecJsonmin } from \"./file\";\n//\n//   const execJsonmin = Convert.toExecJsonmin(json);\n//\n// These functions will throw an error if the JSON doesn't\n// match the expected interface, even if the JSON is valid.\n\nexport interface ExecJsonmin {\n    controls:   ExecJSONMINControl[];\n    statistics: Statistics;\n    version:    string;\n}\n\nexport interface ExecJSONMINControl {\n    backtrace?:     string[] | null;\n    code_desc:      string;\n    exception?:     null | string;\n    id:             string;\n    message?:       null | string;\n    profile_id?:    null | string;\n    profile_sha256: string;\n    resource?:      null | string;\n    skip_message?:  null | string;\n    status:         string;\n}\n\nexport interface Statistics {\n    controls?: null | StatisticHash;\n    /**\n     * How long (in seconds) this inspec exec ran for.\n     */\n    duration: number;\n}\n\n/**\n * Breakdowns of control statistics by result\n */\nexport interface StatisticHash {\n    failed?:  null | StatisticBlock;\n    passed?:  null | StatisticBlock;\n    skipped?: null | StatisticBlock;\n}\n\nexport interface StatisticBlock {\n    /**\n     * Total number of controls (in this category) for this inspec execution.\n     */\n    total: number;\n}\n\n// Converts JSON strings to/from your types\n// and asserts the results of JSON.parse at runtime\nexport class Convert {\n    public static toExecJsonmin(json: string): ExecJsonmin {\n        return cast(JSON.parse(json), r(\"ExecJsonmin\"));\n    }\n\n    public static execJsonminToJson(value: ExecJsonmin): string {\n        return JSON.stringify(uncast(value, r(\"ExecJsonmin\")), null, 2);\n    }\n}\n\nfunction invalidValue(typ: any, val: any, key: any = ''): never {\n    if (key) {\n        throw Error(`Invalid value for key \"${key}\". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);\n    }\n    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );\n}\n\nfunction jsonToJSProps(typ: any): any {\n    if (typ.jsonToJS === undefined) {\n        const map: any = {};\n        typ.props.forEach((p: any) => map[p.json] = { key: p.js, typ: p.typ });\n        typ.jsonToJS = map;\n    }\n    return typ.jsonToJS;\n}\n\nfunction jsToJSONProps(typ: any): any {\n    if (typ.jsToJSON === undefined) {\n        const map: any = {};\n        typ.props.forEach((p: any) => map[p.js] = { key: p.json, typ: p.typ });\n        typ.jsToJSON = map;\n    }\n    return typ.jsToJSON;\n}\n\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }\n\n    function transformUnion(typs: any[], val: any): any {\n        // val must validate against one typ in typs\n        const l = typs.length;\n        for (let i = 0; i < l; i++) {\n            const typ = typs[i];\n            try {\n                return transform(val, typ, getProps);\n            } catch (_) {}\n        }\n        return invalidValue(typs, val);\n    }\n\n    function transformEnum(cases: string[], val: any): any {\n        if (cases.indexOf(val) !== -1) return val;\n        return invalidValue(cases, val);\n    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));\n    }\n\n    function transformDate(val: any): any {\n        if (val === null) {\n            return null;\n        }\n        const d = new Date(val);\n        if (isNaN(d.valueOf())) {\n            return invalidValue(\"Date\", val);\n        }\n        return d;\n    }\n\n    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {\n        if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n            return invalidValue(\"object\", val);\n        }\n        const result: any = {};\n        Object.getOwnPropertyNames(props).forEach(key => {\n            const prop = props[key];\n            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;\n            result[prop.key] = transform(v, prop.typ, getProps, prop.key);\n        });\n        Object.getOwnPropertyNames(val).forEach(key => {\n            if (!Object.prototype.hasOwnProperty.call(props, key)) {\n                result[key] = transform(val[key], additional, getProps, key);\n            }\n        });\n        return result;\n    }\n\n    if (typ === \"any\") return val;\n    if (typ === null) {\n        if (val === null) return val;\n        return invalidValue(typ, val);\n    }\n    if (typ === false) return invalidValue(typ, val);\n    while (typeof typ === \"object\" && typ.ref !== undefined) {\n        typ = typeMap[typ.ref];\n    }\n    if (Array.isArray(typ)) return transformEnum(typ, val);\n    if (typeof typ === \"object\") {\n        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);\n    return transformPrimitive(typ, val);\n}\n\nfunction cast<T>(val: any, typ: any): T {\n    return transform(val, typ, jsonToJSProps);\n}\n\nfunction uncast<T>(val: T, typ: any): any {\n    return transform(val, typ, jsToJSONProps);\n}\n\nfunction a(typ: any) {\n    return { arrayItems: typ };\n}\n\nfunction u(...typs: any[]) {\n    return { unionMembers: typs };\n}\n\nfunction o(props: any[], additional: any) {\n    return { props, additional };\n}\n\nfunction m(additional: any) {\n    return { props: [], additional };\n}\n\nfunction r(name: string) {\n    return { ref: name };\n}\n\nconst typeMap: any = {\n    \"ExecJsonmin\": o([\n        { json: \"controls\", js: \"controls\", typ: a(r(\"ExecJSONMINControl\")) },\n        { json: \"statistics\", js: \"statistics\", typ: r(\"Statistics\") },\n        { json: \"version\", js: \"version\", typ: \"\" },\n    ], \"any\"),\n    \"ExecJSONMINControl\": o([\n        { json: \"backtrace\", js: \"backtrace\", typ: u(undefined, u(a(\"\"), null)) },\n        { json: \"code_desc\", js: \"code_desc\", typ: \"\" },\n        { json: \"exception\", js: \"exception\", typ: u(undefined, u(null, \"\")) },\n        { json: \"id\", js: \"id\", typ: \"\" },\n        { json: \"message\", js: \"message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"profile_id\", js: \"profile_id\", typ: u(undefined, u(null, \"\")) },\n        { json: \"profile_sha256\", js: \"profile_sha256\", typ: \"\" },\n        { json: \"resource\", js: \"resource\", typ: u(undefined, u(null, \"\")) },\n        { json: \"skip_message\", js: \"skip_message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"status\", js: \"status\", typ: \"\" },\n    ], \"any\"),\n    \"Statistics\": o([\n        { json: \"controls\", js: \"controls\", typ: u(undefined, u(null, r(\"StatisticHash\"))) },\n        { json: \"duration\", js: \"duration\", typ: 3.14 },\n    ], \"any\"),\n    \"StatisticHash\": o([\n        { json: \"failed\", js: \"failed\", typ: u(undefined, u(null, r(\"StatisticBlock\"))) },\n        { json: \"passed\", js: \"passed\", typ: u(undefined, u(null, r(\"StatisticBlock\"))) },\n        { json: \"skipped\", js: \"skipped\", typ: u(undefined, u(null, r(\"StatisticBlock\"))) },\n    ], \"any\"),\n    \"StatisticBlock\": o([\n        { json: \"total\", js: \"total\", typ: 3.14 },\n    ], \"any\"),\n};\n\n",
  "/api/sources/raw?key=test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts": "// To parse this data:\n//\n//   import { Convert, ProfileJSON } from \"./file\";\n//\n//   const profileJSON = Convert.toProfileJSON(json);\n//\n// These functions will throw an error if the JSON doesn't\n// match the expected interface, even if the JSON is valid.\n\nexport interface ProfileJSON {\n    controls:         ProfileJSONControl[];\n    copyright?:       null | string;\n    copyright_email?: null | string;\n    depends?:         Dependency[] | null;\n    generator?:       null | Generator;\n    groups:           ControlGroup[];\n    inputs?:          { [key: string]: any }[] | null;\n    maintainer?:      null | string;\n    name:             string;\n    sha256:           string;\n    status?:          null | string;\n    supports:         SupportedPlatform[];\n    title?:           null | string;\n    version?:         null | string;\n}\n\nexport interface ProfileJSONControl {\n    /**\n     * The raw source code of the control. Note that if this is an overlay control, it does not\n     * include the underlying source code\n     */\n    code:          string;\n    desc?:         null | string;\n    descriptions?: { [key: string]: any } | null;\n    /**\n     * The ID of this control\n     */\n    id:               string;\n    impact:           number;\n    refs?:            Reference[] | null;\n    source_location?: null | SourceLocation;\n    tags:             { [key: string]: any };\n    title?:           null | string;\n}\n\nexport interface Reference {\n    ref?: { [key: string]: any }[] | string;\n    url?: string;\n    uri?: string;\n}\n\nexport interface SourceLocation {\n    /**\n     * The line at which this statement is located in the file\n     */\n    line?: number | null;\n    /**\n     * Path to the file that this statement originates from\n     */\n    ref?: null | string;\n}\n\nexport interface Dependency {\n    branch?:         null | string;\n    compliance?:     null | string;\n    git?:            null | string;\n    name?:           null | string;\n    path?:           null | string;\n    status?:         null | string;\n    status_message?: null | string;\n    supermarket?:    null | string;\n    url?:            null | string;\n}\n\nexport interface Generator {\n    /**\n     * The name of the software that generated this report.\n     */\n    name: string;\n    /**\n     * The version of the software that generated this report.\n     */\n    version: string;\n}\n\nexport interface ControlGroup {\n    /**\n     * The control IDs in this group\n     */\n    controls: string[];\n    /**\n     * The unique identifier of the group\n     */\n    id: string;\n    /**\n     * The name of the group\n     */\n    title?: null | string;\n}\n\nexport interface SupportedPlatform {\n    \"os-family\"?:       null | string;\n    \"os-name\"?:         null | string;\n    platform?:          null | string;\n    \"platform-family\"?: null | string;\n    \"platform-name\"?:   null | string;\n    release?:           null | string;\n}\n\n// Converts JSON strings to/from your types\n// and asserts the results of JSON.parse at runtime\nexport class Convert {\n    public static toProfileJSON(json: string): ProfileJSON {\n        return cast(JSON.parse(json), r(\"ProfileJSON\"));\n    }\n\n    public static profileJSONToJson(value: ProfileJSON): string {\n        return JSON.stringify(uncast(value, r(\"ProfileJSON\")), null, 2);\n    }\n}\n\nfunction invalidValue(typ: any, val: any, key: any = ''): never {\n    if (key) {\n        throw Error(`Invalid value for key \"${key}\". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);\n    }\n    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );\n}\n\nfunction jsonToJSProps(typ: any): any {\n    if (typ.jsonToJS === undefined) {\n        const map: any = {};\n        typ.props.forEach((p: any) => map[p.json] = { key: p.js, typ: p.typ });\n        typ.jsonToJS = map;\n    }\n    return typ.jsonToJS;\n}\n\nfunction jsToJSONProps(typ: any): any {\n    if (typ.jsToJSON === undefined) {\n        const map: any = {};\n        typ.props.forEach((p: any) => map[p.js] = { key: p.json, typ: p.typ });\n        typ.jsToJSON = map;\n    }\n    return typ.jsToJSON;\n}\n\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }\n\n    function transformUnion(typs: any[], val: any): any {\n        // val must validate against one typ in typs\n        const l = typs.length;\n        for (let i = 0; i < l; i++) {\n            const typ = typs[i];\n            try {\n                return transform(val, typ, getProps);\n            } catch (_) {}\n        }\n        return invalidValue(typs, val);\n    }\n\n    function transformEnum(cases: string[], val: any): any {\n        if (cases.indexOf(val) !== -1) return val;\n        return invalidValue(cases, val);\n    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));\n    }\n\n    function transformDate(val: any): any {\n        if (val === null) {\n            return null;\n        }\n        const d = new Date(val);\n        if (isNaN(d.valueOf())) {\n            return invalidValue(\"Date\", val);\n        }\n        return d;\n    }\n\n    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {\n        if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n            return invalidValue(\"object\", val);\n        }\n        const result: any = {};\n        Object.getOwnPropertyNames(props).forEach(key => {\n            const prop = props[key];\n            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;\n            result[prop.key] = transform(v, prop.typ, getProps, prop.key);\n        });\n        Object.getOwnPropertyNames(val).forEach(key => {\n            if (!Object.prototype.hasOwnProperty.call(props, key)) {\n                result[key] = transform(val[key], additional, getProps, key);\n            }\n        });\n        return result;\n    }\n\n    if (typ === \"any\") return val;\n    if (typ === null) {\n        if (val === null) return val;\n        return invalidValue(typ, val);\n    }\n    if (typ === false) return invalidValue(typ, val);\n    while (typeof typ === \"object\" && typ.ref !== undefined) {\n        typ = typeMap[typ.ref];\n    }\n    if (Array.isArray(typ)) return transformEnum(typ, val);\n    if (typeof typ === \"object\") {\n        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);\n    return transformPrimitive(typ, val);\n}\n\nfunction cast<T>(val: any, typ: any): T {\n    return transform(val, typ, jsonToJSProps);\n}\n\nfunction uncast<T>(val: T, typ: any): any {\n    return transform(val, typ, jsToJSONProps);\n}\n\nfunction a(typ: any) {\n    return { arrayItems: typ };\n}\n\nfunction u(...typs: any[]) {\n    return { unionMembers: typs };\n}\n\nfunction o(props: any[], additional: any) {\n    return { props, additional };\n}\n\nfunction m(additional: any) {\n    return { props: [], additional };\n}\n\nfunction r(name: string) {\n    return { ref: name };\n}\n\nconst typeMap: any = {\n    \"ProfileJSON\": o([\n        { json: \"controls\", js: \"controls\", typ: a(r(\"ProfileJSONControl\")) },\n        { json: \"copyright\", js: \"copyright\", typ: u(undefined, u(null, \"\")) },\n        { json: \"copyright_email\", js: \"copyright_email\", typ: u(undefined, u(null, \"\")) },\n        { json: \"depends\", js: \"depends\", typ: u(undefined, u(a(r(\"Dependency\")), null)) },\n        { json: \"generator\", js: \"generator\", typ: u(undefined, u(null, r(\"Generator\"))) },\n        { json: \"groups\", js: \"groups\", typ: a(r(\"ControlGroup\")) },\n        { json: \"inputs\", js: \"inputs\", typ: u(undefined, u(a(m(\"any\")), null)) },\n        { json: \"maintainer\", js: \"maintainer\", typ: u(undefined, u(null, \"\")) },\n        { json: \"name\", js: \"name\", typ: \"\" },\n        { json: \"sha256\", js: \"sha256\", typ: \"\" },\n        { json: \"status\", js: \"status\", typ: u(undefined, u(null, \"\")) },\n        { json: \"supports\", js: \"supports\", typ: a(r(\"SupportedPlatform\")) },\n        { json: \"title\", js: \"title\", typ: u(undefined, u(null, \"\")) },\n        { json: \"version\", js: \"version\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"ProfileJSONControl\": o([\n        { json: \"code\", js: \"code\", typ: \"\" },\n        { json: \"desc\", js: \"desc\", typ: u(undefined, u(null, \"\")) },\n        { json: \"descriptions\", js: \"descriptions\", typ: u(undefined, u(m(\"any\"), null)) },\n        { json: \"id\", js: \"id\", typ: \"\" },\n        { json: \"impact\", js: \"impact\", typ: 3.14 },\n        { json: \"refs\", js: \"refs\", typ: u(undefined, u(a(r(\"Reference\")), null)) },\n        { json: \"source_location\", js: \"source_location\", typ: u(undefined, u(null, r(\"SourceLocation\"))) },\n        { json: \"tags\", js: \"tags\", typ: m(\"any\") },\n        { json: \"title\", js: \"title\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"Reference\": o([\n        { json: \"ref\", js: \"ref\", typ: u(undefined, u(a(m(\"any\")), \"\")) },\n        { json: \"url\", js: \"url\", typ: u(undefined, \"\") },\n        { json: \"uri\", js: \"uri\", typ: u(undefined, \"\") },\n    ], \"any\"),\n    \"SourceLocation\": o([\n        { json: \"line\", js: \"line\", typ: u(undefined, u(3.14, null)) },\n        { json: \"ref\", js: \"ref\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"Dependency\": o([\n        { json: \"branch\", js: \"branch\", typ: u(undefined, u(null, \"\")) },\n        { json: \"compliance\", js: \"compliance\", typ: u(undefined, u(null, \"\")) },\n        { json: \"git\", js: \"git\", typ: u(undefined, u(null, \"\")) },\n        { json: \"name\", js: \"name\", typ: u(undefined, u(null, \"\")) },\n        { json: \"path\", js: \"path\", typ: u(undefined, u(null, \"\")) },\n        { json: \"status\", js: \"status\", typ: u(undefined, u(null, \"\")) },\n        { json: \"status_message\", js: \"status_message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"supermarket\", js: \"supermarket\", typ: u(undefined, u(null, \"\")) },\n        { json: \"url\", js: \"url\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"Generator\": o([\n        { json: \"name\", js: \"name\", typ: \"\" },\n        { json: \"version\", js: \"version\", typ: \"\" },\n    ], \"any\"),\n    \"ControlGroup\": o([\n        { json: \"controls\", js: \"controls\", typ: a(\"\") },\n        { json: \"id\", js: \"id\", typ: \"\" },\n        { json: \"title\", js: \"title\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"SupportedPlatform\": o([\n        { json: \"os-family\", js: \"os-family\", typ: u(undefined, u(null, \"\")) },\n        { json: \"os-name\", js: \"os-name\", typ: u(undefined, u(null, \"\")) },\n        { json: \"platform\", js: \"platform\", typ: u(undefined, u(null, \"\")) },\n        { json: \"platform-family\", js: \"platform-family\", typ: u(undefined, u(null, \"\")) },\n        { json: \"platform-name\", js: \"platform-name\", typ: u(undefined, u(null, \"\")) },\n        { json: \"release\", js: \"release\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n};\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/components/cards/treemap/Treemap.vue": "<template>\n  <v-container ref=\"treemapContainer\" fluid>\n    <v-row dense>\n      <v-col :cols=\"4\">\n        NIST SP 800-53 Security and Privacy Control Coverage\n      </v-col>\n      <v-col :cols=\"8\">\n        <v-btn :disabled=\"!allow_up\" block x-small @click=\"up\">\n          <v-icon v-if=\"allow_up\"> mdi-arrow-left </v-icon>\n          {{ 'NIST-SP-800-53 -> ' + value.join(' -> ') }}\n        </v-btn>\n      </v-col>\n    </v-row>\n    <v-row>\n      <v-col v-resize=\"on_resize\" :cols=\"12\">\n        <svg id=\"chartBody\" :width=\"width\" :height=\"height\">\n          <g\n            style=\"shape-rendering: crispEdges\"\n            preserveAspectRatio=\"xMidYMid meet\"\n          >\n            <!-- The body -->\n            <Cell\n              :selected_control_id=\"selected_control\"\n              :node=\"selected_node\"\n              :scales=\"scales\"\n              :depth=\"0\"\n              @select-node=\"select_node\"\n            />\n          </g>\n        </svg>\n      </v-col>\n    </v-row>\n  </v-container>\n</template>\n\n<script lang=\"ts\">\nimport Cell, {XYScale} from '@/components/cards/treemap/Cell.vue';\nimport {ColorHackModule} from '@/store/color_hack';\nimport {Filter, FilteredDataModule, TreeMapState} from '@/store/data_filters';\nimport {compare_arrays} from '@/utilities/helper_util';\nimport {\n  build_nist_tree_map,\n  is_leaf,\n  is_parent,\n  TreemapNode\n} from '@/utilities/treemap_util';\nimport * as d3 from 'd3';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\nimport {Prop, PropSync, Ref} from 'vue-property-decorator';\n\n// Respects a v-model of type TreeMapState\n@Component({\n  components: {\n    Cell\n  }\n})\nexport default class Treemap extends Vue {\n  @Ref('treemapContainer') readonly treemapContainer!: Element;\n  @Prop({type: Array, required: true}) readonly value!: TreeMapState;\n  @Prop({type: Object, required: true}) readonly filter!: Filter;\n  @PropSync('selected_control', {type: String}) syncedSelectedControl!:\n    | string\n    | null;\n\n  /** The svg internal coordinate space */\n  width = 1600;\n  height = 530;\n\n  /** The currently selected treemap node. Wrapped to avoid initialization woes */\n  get selected_node(): d3.HierarchyRectangularNode<TreemapNode> {\n    // Get typed versions of the curr state\n    // Set curr to root\n    let curr = this.treemap_layout;\n    let depth = 0;\n\n    try {\n      for (; depth < this.value.length; depth++) {\n        // If the current has no children, then just bail here\n        if (curr.children === undefined) {\n          throw Error('no children to go into');\n        }\n\n        // Fetch the next path spec\n        const nextSpecifiers = this.value.slice(0, depth + 1);\n\n        const newCurr = curr.children.find((child) => {\n          if (is_parent(child.data)) {\n            const ssA = child.data.nist_control.subSpecifiers;\n            return (\n              compare_arrays(ssA, nextSpecifiers, (a, b) =>\n                a.localeCompare(b)\n              ) === 0\n            );\n          } else {\n            return false; // We cannot go into a leaf (OR CAN WE? MUST DECIDE, AT SOME POINT)\n          }\n        });\n        if (newCurr) {\n          if (newCurr.children && newCurr.children.length) {\n            curr = newCurr;\n          } else {\n            throw Error('empty');\n          }\n        } else {\n          throw Error('truncate');\n        }\n      }\n    } catch (someTraversalError) {\n      // Slice to last successful depth. Slice is non inclusive so this works\n      this.set_path(this.value.slice(0, depth));\n    }\n\n    // Return as deep as we travelled\n    return curr;\n  }\n\n  /** Get our viewbox */\n  get view_box(): string {\n    return `0 0 ${this.width} ${this.height}`;\n  }\n\n  /** Get our scales */\n  get scales(): XYScale {\n    return {\n      scale_x: d3\n        .scaleLinear()\n        .domain([this.selected_node.x0, this.selected_node.x1])\n        .range([0, this.width]),\n      scale_y: d3\n        .scaleLinear()\n        .domain([this.selected_node.y0, this.selected_node.y1])\n        .range([0, this.height])\n    };\n  }\n\n  /** Generates a d3 heirarchy structure, with appropriate bounds to our width\n   *  detailing all of the controls in the nist hash */\n  get treemap_layout(): d3.HierarchyRectangularNode<TreemapNode> {\n    // Get the current filtered data\n    const controls = FilteredDataModule.controls(this.filter);\n\n    // Build the map\n    const hierarchy = build_nist_tree_map(controls, ColorHackModule);\n    return d3\n      .treemap<TreemapNode>()\n      .size([this.width, this.height])\n      .round(false)\n      .paddingInner(0)(hierarchy);\n  }\n\n  // Callbacks for our tree\n  select_node(n: d3.HierarchyRectangularNode<TreemapNode>): void {\n    // If it is a leaf, then select it\n    if (is_leaf(n.data)) {\n      const id = n.data.control.data.id;\n      this.syncedSelectedControl =\n        id !== this.syncedSelectedControl ? id : null;\n    } else {\n      // Otherwise, dive away. Set course for the leading title\n      const cntrl = n.data.nist_control;\n      if (cntrl) {\n        this.set_path(cntrl.subSpecifiers);\n      }\n    }\n  }\n\n  /** Submits an event to go up one node */\n  up(): void {\n    if (this.value.length) {\n      // Slice and dice, baybee\n      this.set_path(this.value.slice(0, this.value.length - 1));\n\n      // Also clear selected\n      this.syncedSelectedControl = null;\n    }\n  }\n\n  /** Typed method to wrap changes in the depth */\n  set_path(pathSpec: TreeMapState) {\n    this.$emit('input', pathSpec);\n  }\n\n  /** Controls whether we should allow up */\n  get allow_up(): boolean {\n    return this.value.length > 0;\n  }\n\n  /** Called on resize */\n  on_resize() {\n    this.width = this.treemapContainer.clientWidth;\n  }\n}\n</script>\n\n<style scoped>\ntext {\n  pointer-events: none;\n  font-weight: bold;\n  font-size: 1.1em;\n  fill: 'primary';\n}\n\nrect {\n  fill: none;\n}\n</style>\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/components/global/upload_tabs/aws/FileList.vue": "<template>\n  <v-stepper-content step=\"3\">\n    <div class=\"d-flex flex-column\">\n      <div class=\"d-flex justify-space-between\">\n        <v-text-field\n          v-model=\"formBucketName\"\n          label=\"Bucket name\"\n          @keyup.enter=\"load\"\n        />\n        <v-btn\n          title=\"Load\"\n          :disabled=\"formBucketName.length < 1\"\n          class=\"fill-height pa-0\"\n          @click=\"load\"\n        >\n          <v-icon>mdi-cloud-download</v-icon>\n        </v-btn>\n      </div>\n\n      <v-list :two-line=\"true\">\n        <v-list-item v-if=\"files.length === 0\"\n          >No items found! Try different terms?</v-list-item\n        >\n        <v-list-item v-for=\"(val, index) in files\" :key=\"val.Key\">\n          <v-list-item-content>\n            <!-- Title: The item key -->\n            <v-list-item-title>{{ val.Key }}</v-list-item-title>\n            <!-- Subtitle: Date of creation -->\n            <v-list-item-subtitle>\n              {{ val.LastModified }}\n            </v-list-item-subtitle>\n          </v-list-item-content>\n          <!-- Action: Click to add -->\n          <v-list-item-action>\n            <v-btn icon @click=\"load_file(index)\">\n              <v-icon>mdi-plus-circle</v-icon>\n            </v-btn>\n          </v-list-item-action>\n        </v-list-item>\n      </v-list>\n      <v-btn color=\"red\" class=\"my-2 mr-3\" @click=\"$emit('exit-list')\">\n        Cancel\n      </v-btn>\n    </div>\n  </v-stepper-content>\n</template>\n\n<script lang=\"ts\">\nimport {InspecIntakeModule} from '@/store/report_intake';\nimport {Auth, fetch_s3_file} from '@/utilities/aws_util';\nimport {LocalStorageVal} from '@/utilities/helper_util';\nimport S3 from 'aws-sdk/clients/s3';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\nimport {Prop} from 'vue-property-decorator';\n\n// Caches the bucket name\nconst localBucketName = new LocalStorageVal<string>('aws_bucket_name');\n\n@Component({\n  components: {}\n})\nexport default class FileList extends Vue {\n  @Prop({type: Object}) readonly auth!: Auth;\n  @Prop({type: Array}) readonly files!: S3.Object[];\n\n  /** The name written in the form */\n  formBucketName = '';\n\n  /** On mount, try to look up stored auth info */\n  /** Callback for when user selects a file.\n   * Loads it into our system.\n   */\n  async load_file(index: number): Promise<void> {\n    // Get it out of the list\n    const file = this.files[index];\n\n    // Fetch it from s3, and promise to submit it to be loaded afterwards\n    await fetch_s3_file(this.auth.creds, file.Key!, this.formBucketName).then(\n      (content) => {\n        InspecIntakeModule.loadText({\n          text: content,\n          filename: file.Key!\n        }).then((uniqueId) => this.$emit('got-files', [uniqueId]));\n      }\n    );\n  }\n\n  /** Recalls the last entered bucket name.  */\n  mounted() {\n    this.formBucketName = localBucketName.get_default('');\n  }\n\n  /** Handles when load button clicked */\n  load() {\n    localBucketName.set(this.formBucketName);\n    this.$emit('load-bucket', this.formBucketName);\n  }\n}\n</script>\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/components/global/upload_tabs/aws/S3Reader.vue": "<template>\n  <v-stepper v-model=\"step\" vertical class=\"elevation-0\">\n    <v-stepper-step :complete=\"!!assumedRole\" step=\"1\">\n      Account Credentials\n    </v-stepper-step>\n\n    <AuthStepBasic\n      :access-token.sync=\"accessToken\"\n      :secret-token.sync=\"secretToken\"\n      @auth-basic=\"handle_basic\"\n      @goto-mfa=\"handle_goto_mfa\"\n    />\n\n    <v-stepper-step :complete=\"!!assumedRole && assumedRole.from_mfa\" step=\"2\">\n      MFA Authorization\n    </v-stepper-step>\n\n    <AuthStepMFA\n      :mfa-token.sync=\"mfaToken\"\n      :mfa-serial.sync=\"mfaSerial\"\n      @auth-mfa=\"handle_proceed_mfa\"\n      @exit-mfa=\"handle_cancel_mfa\"\n    />\n\n    <v-stepper-step step=\"3\"> Browse Bucket </v-stepper-step>\n\n    <FileList\n      :auth=\"assumedRole\"\n      :files=\"files\"\n      @exit-list=\"handle_cancel_mfa\"\n      @got-files=\"got_files\"\n      @load-bucket=\"load_bucket\"\n    />\n  </v-stepper>\n</template>\n\n<script lang=\"ts\">\nimport AuthStepBasic from '@/components/global/upload_tabs/aws/AuthStepBasic.vue';\nimport AuthStepMFA from '@/components/global/upload_tabs/aws/AuthStepMFA.vue';\nimport FileList from '@/components/global/upload_tabs/aws/FileList.vue';\nimport {FileID} from '@/store/report_intake';\nimport {SnackbarModule} from '@/store/snackbar';\nimport {\n  Auth,\n  AUTH_DURATION,\n  get_session_token,\n  MFAInfo,\n  transcribe_error\n} from '@/utilities/aws_util';\nimport {LocalStorageVal} from '@/utilities/helper_util';\nimport S3 from 'aws-sdk/clients/s3';\nimport {AWSError} from 'aws-sdk/lib/error';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\n\n/** The cached session info */\nconst localSessionInformation = new LocalStorageVal<Auth | null>(\n  'aws_session_info'\n);\n\n/**\n * Uploads data to the store with unique IDs asynchronously as soon as data is entered.\n * Emits \"got-files\" with a list of the unique_ids of the loaded files.\n */\n@Component({\n  components: {\n    AuthStepBasic,\n    AuthStepMFA,\n    FileList\n  }\n})\nexport default class S3Reader extends Vue {\n  /** Form required field rules. Maybe eventually expand to other stuff */\n  reqRule = (v: string | null | undefined) =>\n    (v || '').trim().length > 0 || 'Field is Required';\n\n  /** Passed from step 1 to step 2 (MFA) if necessary */\n  /** State of all globally relevant fields */\n  accessToken = '';\n  secretToken = '';\n  mfaSerial = '';\n  mfaToken = '';\n\n  /** Our session information, generated by AWS STS */\n  assumedRole: Auth | null = null;\n\n  /** Current step */\n  step = 1;\n\n  /** Currently loaded file list from bucket */\n  files: S3.Object[] = [];\n\n  /**\n   * Handle a basic login.\n   * Gets a session token\n   */\n  handle_basic() {\n    // Attempt to assume role based on if we've determined 2fa necessary\n    get_session_token(this.accessToken, this.secretToken, AUTH_DURATION).then(\n      // Success of get session token - now need to determine if MFA necessary\n      (success) => {\n        this.assumedRole = success;\n        this.step = 3;\n      },\n\n      // Failure of initial get session token: want to set error normally\n      (failure) => {\n        this.handle_error(failure);\n      }\n    );\n  }\n\n  /** If the user tries to login by going to MFA, first check that the account is valid */\n  handle_goto_mfa() {\n    // Attempt to assume role based on if we've determined 2fa necessary\n    // Don't need the duration to be very long\n    get_session_token(this.accessToken, this.secretToken, 10).then(\n      // Success of get session token - now need to determine if MFA necessary\n      () => {\n        this.step = 2;\n      },\n\n      // Failure of initial get session token: want to set error normally\n      (failure) => {\n        this.handle_error(failure);\n      }\n    );\n  }\n\n  handle_cancel_mfa() {\n    this.step = 1;\n    this.mfaToken = '';\n    this.assumedRole = null; // Just in case\n  }\n\n  handle_exit_list() {\n    this.step = 1;\n    this.mfaToken = '';\n    this.assumedRole = null;\n    this.files = []; // Just in case\n  }\n\n  /** Handle an MFA login.\n   * Determine whether further action is necessary\n   */\n  handle_proceed_mfa() {\n    // Build our mfa params\n    const mfa: MFAInfo = {\n      SerialNumber: this.mfaSerial || null,\n      TokenCode: this.mfaToken\n    };\n\n    // Attempt to assume role based on if we've determined 2fa necessary\n    get_session_token(\n      this.accessToken,\n      this.secretToken,\n      AUTH_DURATION,\n      mfa\n    ).then(\n      (success) => {\n        // Keep them\n        this.assumedRole = success;\n        this.step = 3;\n      },\n      (failure) => {\n        this.handle_error(failure);\n      }\n    );\n  }\n\n  /** On mount, try to look up stored auth info */\n  mounted() {\n    // Load our session, if there is one\n    this.assumedRole = localSessionInformation.get_default(null);\n    if (this.assumedRole) {\n      this.step = 3;\n    }\n  }\n\n  /** Attempt to load.\n   * Basically just wraps fetch_files with error handling\n   */\n  async load_bucket(name: string) {\n    const s3 = new S3(this.assumedRole!.creds);\n    await s3\n      .listObjectsV2({\n        Bucket: name,\n        MaxKeys: 100\n      })\n      .promise()\n      .then((success) => {\n        this.files = success.Contents || [];\n      })\n      .catch((failure) => this.handle_error(failure));\n  }\n\n  /** Save the current credentials to local storage */\n  save_creds() {\n    localSessionInformation.set(this.assumedRole);\n  }\n\n  /** Callback to handle an AWS error.\n   * Sets shown error.\n   */\n  handle_error(error: AWSError): void {\n    const formattedError = transcribe_error(error);\n    // Toast whatever error we got\n    SnackbarModule.failure(formattedError);\n  }\n\n  /** Callback on got files */\n  got_files(files: Array<FileID>) {\n    this.$emit('got-files', files);\n  }\n}\n</script>\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/store/data_filters.ts": "/**\n * This module provides a cached, reusable method for filtering data from data_store.\n */\n\nimport {Trinary} from '@/enums/Trinary';\nimport {InspecDataModule} from '@/store/data_store';\nimport {\n  FileID,\n  SourcedContextualizedEvaluation,\n  SourcedContextualizedProfile\n} from '@/store/report_intake';\nimport Store from '@/store/store';\nimport {\n  ContextualizedControl,\n  ContextualizedProfile,\n  ControlStatus,\n  NistControl,\n  Severity\n} from 'inspecjs';\nimport _ from 'lodash';\nimport LRUCache from 'lru-cache';\nimport {\n  Action,\n  getModule,\n  Module,\n  Mutation,\n  VuexModule\n} from 'vuex-module-decorators';\n\nconst MAX_CACHE_ENTRIES = 20;\n\nexport declare type ExtendedControlStatus = ControlStatus | 'Waived';\n\n/** Contains common filters on data from the store. */\nexport interface Filter {\n  // General\n  /** Which file these objects came from. Undefined => any */\n  fromFile: FileID[];\n\n  // Control specific\n  /** What status the controls can have. Undefined => any */\n  status?: ExtendedControlStatus[];\n\n  /** What severity the controls can have. Undefined => any */\n  severity?: Severity[];\n\n  /** Whether or not to allow/include overlayed controls */\n  omit_overlayed_controls?: boolean;\n\n  /** Control IDs to search for */\n  ids?: string[];\n\n  /** Titles to search for */\n  titleSearchTerms?: string[];\n\n  /** Descriptions to search for */\n  descriptionSearchTerms?: string[];\n\n  /** Code to search for */\n  codeSearchTerms?: string[];\n\n  /** CCIs to search for */\n  nistIdFilter?: string[];\n\n  /** A search term string, case insensitive\n   * We look for this in\n   * - control ID\n   * - rule title\n   * - severity\n   * - status\n   * - finding details (from HDF)\n   * - code\n   */\n  searchTerm?: string;\n\n  /** The current state of the Nist Treemap. Used to further filter by nist categories etc. */\n  treeFilters?: TreeMapState;\n\n  /** A specific control id */\n  control_id?: string;\n}\n\nexport type TreeMapState = string[]; // Representing the current path spec, from root\n\n/**\n * Facillitates the search functionality\n * @param term The string to search with\n * @param contextControl The control to search for term in\n */\nfunction contains_term(\n  contextControl: ContextualizedControl,\n  term: string\n): boolean {\n  const asHDF = contextControl.root.hdf;\n  // Get our (non-null) searchable data\n  const searchables: string[] = [\n    asHDF.wraps.id,\n    asHDF.wraps.title,\n    asHDF.wraps.code,\n    asHDF.severity,\n    asHDF.status,\n    asHDF.finding_details\n  ].filter((s) => s !== null) as string[];\n\n  // See if any contain term\n  return searchables.some((s) => s.toLowerCase().includes(term));\n}\n\n@Module({\n  namespaced: true,\n  dynamic: true,\n  store: Store,\n  name: 'filteredData'\n})\nexport class FilteredData extends VuexModule {\n  selectedEvaluationIds: FileID[] = [];\n  selectedProfileIds: FileID[] = [];\n\n  @Mutation\n  SELECT_EVALUATIONS(files: FileID[]): void {\n    this.selectedEvaluationIds = [\n      ...new Set([...files, ...this.selectedEvaluationIds])\n    ];\n  }\n\n  @Mutation\n  SELECT_PROFILES(files: FileID[]): void {\n    this.selectedProfileIds = [\n      ...new Set([...files, ...this.selectedProfileIds])\n    ];\n  }\n\n  @Mutation\n  CLEAR_EVALUATION(removeId: FileID): void {\n    this.selectedEvaluationIds = this.selectedEvaluationIds.filter(\n      (ids) => ids !== removeId\n    );\n  }\n\n  @Mutation\n  CLEAR_PROFILE(removeId: FileID): void {\n    this.selectedProfileIds = this.selectedProfileIds.filter(\n      (ids) => ids !== removeId\n    );\n  }\n\n  @Mutation\n  CLEAR_ALL_EVALUATIONS(): void {\n    this.selectedEvaluationIds = [];\n  }\n\n  @Mutation\n  CLEAR_ALL_PROFILES(): void {\n    this.selectedProfileIds = [];\n  }\n\n  @Action\n  public toggle_all_evaluations(): void {\n    if (this.all_evaluations_selected === Trinary.On) {\n      this.CLEAR_ALL_EVALUATIONS();\n    } else {\n      this.SELECT_EVALUATIONS(\n        InspecDataModule.allEvaluationFiles.map((v) => v.uniqueId)\n      );\n    }\n  }\n\n  @Action\n  public toggle_all_profiles(): void {\n    if (this.all_profiles_selected === Trinary.On) {\n      this.CLEAR_ALL_PROFILES();\n    } else {\n      this.SELECT_PROFILES(\n        InspecDataModule.allProfileFiles.map((v) => v.uniqueId)\n      );\n    }\n  }\n\n  @Action\n  public select_exclusive_evaluation(fileID: FileID): void {\n    this.CLEAR_ALL_EVALUATIONS();\n    this.SELECT_EVALUATIONS([fileID]);\n  }\n\n  @Action\n  public select_exclusive_profile(fileID: FileID): void {\n    this.CLEAR_ALL_PROFILES();\n    this.SELECT_PROFILES([fileID]);\n  }\n\n  @Action\n  public toggle_evaluation(fileID: FileID): void {\n    if (this.selectedEvaluationIds.includes(fileID)) {\n      this.CLEAR_EVALUATION(fileID);\n    } else {\n      this.SELECT_EVALUATIONS([fileID]);\n    }\n  }\n\n  @Action\n  public toggle_profile(fileID: FileID): void {\n    if (this.selectedProfileIds.includes(fileID)) {\n      this.CLEAR_PROFILE(fileID);\n    } else {\n      this.SELECT_PROFILES([fileID]);\n    }\n  }\n\n  @Action\n  public clear_file(fileID: FileID): void {\n    this.CLEAR_EVALUATION(fileID);\n    this.CLEAR_PROFILE(fileID);\n  }\n\n  /**\n   * Parameterized getter.\n   * Get all evaluations from the specified file ids\n   */\n  get evaluations(): (\n    files: FileID[]\n  ) => readonly SourcedContextualizedEvaluation[] {\n    return (files: FileID[]) => {\n      return InspecDataModule.contextualExecutions.filter((e) =>\n        files.includes(e.from_file.uniqueId)\n      );\n    };\n  }\n\n  get profiles_for_evaluations(): (\n    files: FileID[]\n  ) => readonly ContextualizedProfile[] {\n    return (files: FileID[]) => {\n      // Filter to those that match our filter. In this case that just means come from the right file id\n      return this.evaluations(files).flatMap(\n        (evaluation) => evaluation.contains\n      );\n    };\n  }\n\n  /**\n   * Parameterized getter.\n   * Get all profiles from the specified file ids.\n   */\n  get profiles(): (files: FileID[]) => readonly SourcedContextualizedProfile[] {\n    return (files: FileID[]) => {\n      return InspecDataModule.contextualProfiles.filter((e) => {\n        return files.includes(e.from_file.uniqueId);\n      });\n    };\n  }\n\n  get selected_file_ids(): FileID[] {\n    return [...this.selectedEvaluationIds, ...this.selectedProfileIds];\n  }\n\n  // check to see if all profiles are selected\n  get all_profiles_selected(): Trinary {\n    switch (this.selectedProfileIds.length) {\n      case 0:\n        return Trinary.Off;\n      case InspecDataModule.allProfileFiles.length:\n        return Trinary.On;\n      default:\n        return Trinary.Mixed;\n    }\n  }\n\n  // check to see if all evaluations are selected\n  get all_evaluations_selected(): Trinary {\n    switch (this.selectedEvaluationIds.length) {\n      case 0:\n        return Trinary.Off;\n      case InspecDataModule.allEvaluationFiles.length:\n        return Trinary.On;\n      default:\n        return Trinary.Mixed;\n    }\n  }\n\n  /**\n   * Parameterized getter.\n   * Get all controls from all profiles from the specified file id.\n   * Utlizes the profiles getter to accelerate the file filter.\n   */\n  get controls(): (filter: Filter) => readonly ContextualizedControl[] {\n    /** Cache by filter */\n    const localCache: LRUCache<string, readonly ContextualizedControl[]> =\n      new LRUCache(MAX_CACHE_ENTRIES);\n\n    return (filter: Filter) => {\n      // Generate a hash for cache purposes.\n      // If the \"searchTerm\" string is not null, we don't cache - no need to pollute\n      const id: string = filter_cache_key(filter);\n\n      // Check if we have this cached:\n      const cached = localCache.get(id);\n      if (cached !== undefined) {\n        return cached;\n      }\n\n      // Get profiles from loaded Results\n      let profiles: readonly ContextualizedProfile[] =\n        this.profiles_for_evaluations(filter.fromFile);\n\n      // Get profiles from loaded Profiles\n      profiles = profiles.concat(this.profiles(filter.fromFile));\n\n      // And all the controls they contain\n      let controls: readonly ContextualizedControl[] = profiles.flatMap(\n        (profile) => profile.contains\n      );\n\n      // Filter by single control id\n      if (filter.control_id !== undefined) {\n        controls = controls.filter((c) => c.data.id === filter.control_id);\n      }\n\n      const controlFilters: Record<\n        string,\n        boolean | Array<string> | undefined\n      > = {\n        'root.hdf.severity': filter.severity,\n        'hdf.wraps.id': filter.ids,\n        'hdf.wraps.title': filter.titleSearchTerms,\n        'hdf.wraps.desc': filter.descriptionSearchTerms,\n        'hdf.raw_nist_tags': filter.nistIdFilter,\n        full_code: filter.codeSearchTerms,\n        'hdf.waived': filter.status?.includes('Waived'),\n        'root.hdf.status': _.filter(\n          filter.status,\n          (status) => status !== 'Waived'\n        )\n      };\n\n      controls = filterControlsBy(controls, controlFilters);\n\n      // Filter by overlay\n      if (filter.omit_overlayed_controls) {\n        controls = controls.filter(\n          (control) => control.extendedBy.length === 0\n        );\n      }\n\n      // Freeform search\n      if (filter.searchTerm !== undefined) {\n        const term = filter.searchTerm.toLowerCase();\n\n        // Filter controls to those that contain search term\n        controls = controls.filter((c) => contains_term(c, term));\n      }\n\n      // Filter by nist stuff\n      if (filter.treeFilters && filter.treeFilters.length > 0) {\n        // Construct a nist control to represent the filter\n        const control = new NistControl(filter.treeFilters);\n\n        controls = controls.filter((c) => {\n          // Get an hdf version so we have the fixed nist tags\n          return c.root.hdf.parsedNistTags.some((t) => control.contains(t));\n        });\n      }\n\n      // Freeze and save to cache\n      const r = Object.freeze(controls);\n      localCache.set(id, r);\n      return r;\n    };\n  }\n}\n\nexport const FilteredDataModule = getModule(FilteredData);\n\n/**\n * Generates a unique string to represent a filter.\n * Does some minor \"acceleration\" techniques such as\n * - annihilating empty search terms\n * - defaulting \"omit_overlayed_controls\"\n */\nexport function filter_cache_key(f: Filter) {\n  const newFilter: Filter = {\n    searchTerm: f.searchTerm?.trim() || '',\n    omit_overlayed_controls: f.omit_overlayed_controls || false,\n    ...f\n  };\n  return JSON.stringify(newFilter);\n}\n\nexport function filterControlsBy(\n  controls: readonly ContextualizedControl[],\n  filters: Record<string, boolean | Array<string> | undefined>\n): readonly ContextualizedControl[] {\n  const activeFilters: typeof filters = _.pickBy(\n    filters,\n    (value, _key) =>\n      (Array.isArray(value) && value.length > 0) ||\n      (typeof value === 'boolean' && value)\n  );\n  return controls.filter((control) => {\n    return Object.entries(activeFilters).every(([filter, value]) => {\n      const item: string | string[] | boolean = _.get(control, filter);\n      if (Array.isArray(value) && typeof item !== 'boolean') {\n        return value?.some((term) => {\n          return arrayOrStringIncludes(item, (compareValue) =>\n            compareValue.toLowerCase().includes(term.toLowerCase())\n          );\n        });\n      } else {\n        return item === value;\n      }\n    });\n  });\n}\n\n/** Iterate over a string or array of strings and call the string compare function provided on every element **/\nfunction arrayOrStringIncludes(\n  arrayOrString: string | string[],\n  comparator: (compareValue: string) => boolean\n) {\n  if (typeof arrayOrString === 'string') {\n    return comparator(arrayOrString);\n  } else {\n    return arrayOrString.some((value) => comparator(value));\n  }\n}\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/utilities/format_util.ts": "/**\n * Functions for formatting items to have unique keys. Principally used for vuex v-for key generation.\n */\n\nimport {isFromProfileFile} from '@/store/data_store';\nimport {\n  SourcedContextualizedEvaluation,\n  SourcedContextualizedProfile\n} from '@/store/report_intake';\nimport {ContextualizedControl} from 'inspecjs';\n\nexport function execution_unique_key(\n  exec: Readonly<SourcedContextualizedEvaluation>\n): string {\n  return `exec_${exec.from_file.uniqueId}`;\n}\n\n/**\n * Generates a unique key for the given profile\n * @param profile\n */\nexport function profile_unique_key(\n  profile: Readonly<SourcedContextualizedProfile>\n): string {\n  if (isFromProfileFile(profile)) {\n    return `profile_${profile.from_file.uniqueId}`;\n  } else {\n    return `${execution_unique_key(\n      profile.sourcedFrom as SourcedContextualizedEvaluation\n    )}-${profile.data.name}`;\n  }\n}\n\n/**\n * Generates a unique key for the given control\n * @param ctrl The control to generate the key for\n */\nexport function control_unique_key(\n  ctrl: Readonly<ContextualizedControl>\n): string {\n  return `${profile_unique_key(\n    ctrl.sourcedFrom as Readonly<SourcedContextualizedProfile>\n  )}-${ctrl.data.id}`;\n}\n\n",
  "/api/sources/raw?key=test:libs/inspecjs/src/context.ts": "/**\n * Provides general utilities for articulating associations beteen evaluations, profiles, and controls.\n * Especially useful for handling overlay/wrapper profiles.\n */\n\nimport {HDFControl, hdfWrapControl} from './compat_wrappers';\nimport {\n  AnyControl,\n  AnyEval,\n  AnyEvalControl,\n  AnyEvalProfile,\n  AnyProfile\n} from './fileparse';\n\n/**\n * Mixin type to express that this type wraps another data type to add additional fields,\n * without modifying the inner type.\n */\ninterface WrapsType<Data> {\n  data: Data;\n}\n\n/**\n * Mixin type to express that this type has some sort \"parent\".\n * Sort of an inverse to the Contains mixin.\n * E.g. A control is sourced from a profile, and an execution is from a file.\n */\ninterface Sourced<From> {\n  sourcedFrom: From;\n}\n\n/**\n * Mixin type to express that this type has some sort of directional dependency-graph with members of a (usually the same) type.\n * For instance, profiles overlay/are overlayed by profiles.\n * Controls override behavior/are overrideen by other controls\n */\ninterface Extendable<By> {\n  /**\n   * What is this data extended by?\n   * E.g. a profile that overlays this profile.\n   * Can be empty.\n   */\n  extendedBy: By[];\n\n  /**\n   * What data is this node extending?\n   * E.g. is this overlaying a profile? Another control?\n   * Can be empty.\n   */\n  extendsFrom: By[];\n}\n\n/**\n * Mixin type to express that this type is primarily a parent to some other data.\n * For instance, profiles are most directly a parent of controls .\n * What objects/resources does this item contain?\n */\ninterface Contains<Item> {\n  contains: Item;\n}\n\n// Create our three primary data types from the above mixins\n// Essentially this is just describing the parent/child relationships each type has\nexport interface ContextualizedEvaluation\n  extends WrapsType<AnyEval>,\n    Contains<ContextualizedProfile[]> {}\n\nexport interface ContextualizedProfile\n  extends WrapsType<AnyProfile>,\n    Sourced<ContextualizedEvaluation | null>,\n    Contains<ContextualizedControl[]>,\n    Extendable<ContextualizedProfile> {}\nexport interface ContextualizedControl\n  extends WrapsType<AnyControl>,\n    Sourced<ContextualizedProfile>,\n    Extendable<ContextualizedControl> {\n  /** The HDF version of this particular control */\n  hdf: HDFControl;\n\n  /** Drills down to this controls root CC. In general you should use this for all data operations */\n  root: ContextualizedControl;\n\n  /** Yields the full code of this control, by concatenating overlay code. */\n  full_code: string;\n}\n\nclass ContextualizedControlImp implements ContextualizedControl {\n  // Imp stuff\n  data: AnyControl;\n  sourcedFrom: ContextualizedProfile;\n  extendsFrom: ContextualizedControl[];\n  extendedBy: ContextualizedControl[];\n  hdf: HDFControl;\n\n  constructor(\n    data: AnyControl,\n    sourcedFrom: ContextualizedProfile,\n    extendedBy: ContextualizedControl[],\n    extendsFrom: ContextualizedControl[]\n  ) {\n    // Simple save\n    this.data = data;\n    this.sourcedFrom = sourcedFrom;\n    this.hdf = hdfWrapControl(data);\n    this.extendedBy = extendedBy;\n    this.extendsFrom = extendsFrom;\n  }\n\n  get root(): ContextualizedControl {\n    if (this.extendsFrom.length) {\n      return this.extendsFrom[0].root;\n    }\n    return this;\n  }\n\n  /** Returns whether this control is just a duplicate of base/root (but is not itself root) */\n  get is_redundant(): boolean {\n    return (\n      !this.data.code ||\n      this.data.code.trim() === '' ||\n      (this.extendsFrom.length > 0 && this.data.code === this.root.data.code)\n    );\n  }\n\n  get full_code(): string {\n    // If we extend from something, we behave slightly differently\n    if (this.extendsFrom.length) {\n      const ancestor = this.extendsFrom[0];\n      if (this.is_redundant) {\n        return ancestor.full_code;\n      } else {\n        return `\\\n=========================================================\n# Profile name: ${this.sourcedFrom.data.name}\n=========================================================\n\n${this.data.code}\n\n${this.extendsFrom[0].full_code}`.trim();\n      }\n    } else {\n      // We are the endpoint\n      return `\\\n=========================================================\n# Profile name: ${this.sourcedFrom.data.name}\n=========================================================\n\n${this.data.code}`.trim();\n    }\n  }\n}\n\nexport function contextualizeEvaluation(\n  evaluation: AnyEval\n): ContextualizedEvaluation {\n  // To begin, create basic context for profiles and evaluation\n  const evalContext: ContextualizedEvaluation = {\n    data: evaluation,\n    contains: []\n  };\n\n  for (const profile of evaluation.profiles) {\n    const evalProfileContext: ContextualizedProfile = {\n      data: profile,\n      sourcedFrom: evalContext,\n      extendedBy: [],\n      extendsFrom: [],\n      contains: []\n    };\n\n    // Add it to our parent\n    evalContext.contains.push(evalProfileContext);\n  }\n\n  // After our initial save of profiles, we go over them again to establish parentage/dependency\n  for (const profile of evalContext.contains) {\n    // We know these are from a report; label as such\n    const asExec = profile.data as AnyEvalProfile;\n\n    // If it has a parent profile then we link them by extendedby/extendsfrom\n    if (asExec.parent_profile !== undefined) {\n      // Look it up\n      const parent = evalContext.contains.find(\n        (p) => p.data.name === asExec.parent_profile\n      );\n\n      // Link it up\n      if (parent) {\n        parent.extendsFrom.push(profile);\n        profile.extendedBy.push(parent);\n      }\n    }\n  }\n\n  // Next step: Extract controls and connect them\n  // Extract the controls and set them as the \"contained\" data for each profile\n  // These ContextualizedControls are basically empty - just have data and from where they were sourced\n  const allControls: ContextualizedControl[] = [];\n  for (const profile of evalContext.contains) {\n    const pControls = profile.data.controls as AnyEvalControl[];\n    profile.contains = pControls.map((c) => {\n      return new ContextualizedControlImp(c, profile, [], []);\n    });\n    allControls.push(...profile.contains);\n  }\n\n  // Link each contextualized control\n  for (const cc of allControls) {\n    // Behaviour changes based on if we have well-formed or malformed profile dependency\n    if (cc.sourcedFrom.extendsFrom.length || cc.sourcedFrom.extendedBy.length) {\n      // Our profile is a baseline! No need to continue - children will make connections for us\n      // If we aren't extended from something we just drop. Our children will make connections for us\n      if (cc.sourcedFrom.extendsFrom.length === 0) {\n        continue;\n      }\n\n      // Get the profile(s) that this control's owning profile is extending\n      // For a wrapper profile, there might be many of these!\n      // We don't know which one it will be, so we iterate\n      for (const extendedProfile of cc.sourcedFrom.extendsFrom) {\n        // Hunt for its ancestor in the extended profile\n        const ancestor = extendedProfile.contains.find(\n          (c) => c.data.id === cc.data.id\n        );\n        // First one we find with a matching id we assume is the root (or at least, closer to root)\n        if (ancestor) {\n          ancestor.extendedBy.push(cc);\n          cc.extendsFrom.push(ancestor);\n          break; // Note that we're in a nested loop here\n        }\n      }\n      // If it's not found, then we just assume it does not exist!\n    } else {\n      // If we don't have a normal profile dependency layout, then we have to hunt ye-olde-fashioned-way\n      // Unfortunately, if theres more than 2 profiles there's ultimately no way to figure out which one was applied \"last\".\n      // This method leaves them as siblings. However, as a fallback method that is perhaps the best we can hope for\n      // First, hunt out all controls from this file that have the same id as cc\n      const sameId = allControls.filter((c) => c.data.id === cc.data.id);\n      // Find which of them, if any, is populated with results.\n      let sameIdPopulated = sameId.find(\n        (c) => c.hdf.segments && c.hdf.segments.length\n      );\n\n      // If found a populated base, use that. If not, we substitute in the first found element in sameId. This is arbitrary.\n      if (!sameIdPopulated) {\n        sameIdPopulated = sameId[0];\n      }\n\n      // If the object we end up with is \"us\", then just ignore\n      if (Object.is(cc, sameIdPopulated)) {\n        continue;\n      } else {\n        // Otherwise, bind\n        sameIdPopulated.extendedBy.push(cc);\n        cc.extendsFrom.push(sameIdPopulated);\n      }\n    }\n  }\n  return evalContext;\n}\n\n// Here we handle the independent profile (IE those in their own files, generated by inspec json).\n// These are slightly simpler because they do not actually include their overlays (even if they depend on them)\n// as a separate data structure.\n// As such, we can just do all the profile and controls from each in one fell swoop\nexport function contextualizeProfile(\n  profile: AnyProfile\n): ContextualizedProfile {\n  const profileContext: ContextualizedProfile = {\n    data: profile,\n    extendedBy: [],\n    extendsFrom: [],\n    contains: [],\n    sourcedFrom: null\n  };\n\n  // Now give it its controls\n  for (const c of profile.controls) {\n    const result = new ContextualizedControlImp(c, profileContext, [], []);\n    profileContext.contains.push(result);\n  }\n\n  return profileContext;\n}\n\n",
  "/api/sources/raw?key=test:libs/inspecjs/src/nist.ts": "import {ControlStatus} from './compat_wrappers';\nimport {ALL_NIST_CONTROL_NUMBERS, ALL_NIST_FAMILIES} from './raw_nist';\n\n// Regexes.\nconst NIST_FAMILY_RE = /^[A-Z]{2}$/;\n// Limit length of children to avoid potential DoS on malicious NIST Control strings\nconst NIST_CONTROL_RE = /^([A-Z]{2})-([0-9]+)(.{0,60})$/;\nconst SPEC_SPLITTER = /[\\s\\(\\)\\.]+/; // Includes all whitespace, periods, and parenthesis\nconst REV_RE = /^rev[\\s_.]+(\\d+)$/i; // Matches Rev_5 etc\ntype ParseNist = NistControl | NistRevision | null;\n\nexport interface CanonizationConfig {\n  max_specifiers: number;\n\n  // All are assumed false\n  pad_zeros?: boolean; // default false\n  allow_letters?: boolean; // default true\n  add_spaces?: boolean; // default true\n  add_parens?: boolean; // default true\n  add_periods?: boolean; // default true\n}\n\nfunction default_partial_config(c: CanonizationConfig): CanonizationConfig {\n  return {\n    pad_zeros: false,\n    allow_letters: true,\n    add_spaces: true,\n    add_parens: true,\n    add_periods: true,\n    ...c\n  };\n}\n\n/** Represents a single nist control, or group of controls if the sub specs are vague enoug. */\nexport class NistControl {\n  /** The sequence of sub-specifiers making up the \"parts\" of the nist tags\n   * E.g.  in \"SI-7 (14)(b)\", we would have [\"SI\", \"7\", \"14\", \"b\"]\n   *       in \"SI-4a.2.\", we would have [\"SI\", \"4\", \"a, \"2\"];\n   * First element is guaranteed to be a 2-letter family\n   * Note that we strip punctuation\n   */\n  subSpecifiers: string[]; // Guaranteed to be of length at least one on a \"real\" control\n\n  /** Holds the string from which this control was generated. */\n  rawText?: string;\n\n  /** Trivial constructor */\n  constructor(subSpecs: string[], rawRext?: string) {\n    this.subSpecifiers = subSpecs;\n    this.rawText = rawRext;\n  }\n\n  /** This function checks if the given control is contained by or equivalent to this control.\n   * It is purely a wrapper around compare_lineage\n   */\n  contains(other: NistControl): boolean {\n    return this.compare_lineage(other) !== -1;\n  }\n\n  /** This function compares this nist control to another nist control.\n   * If the other control is the same control as this one, returns 0.\n   *\n   * If the other control is a child of this control\n   * (IE it is the same base directives with further enhancements, e.g. `IA-4` -> `IA-4b.` or `AC-9a.` -> `AC-9a. (2)`)\n   * and returns how many further enhancements have been applied (IE what is the number of additional subdirectives.)\n   *\n   * If the other control is NOT a child of this control, return -1\n   */\n  compare_lineage(other: NistControl): number {\n    // Can't contain if we're more specific\n    if (this.subSpecifiers.length > other.subSpecifiers.length) {\n      return -1;\n    }\n\n    // After that we just need to iterate\n    for (let i = 0; i < this.subSpecifiers.length; i++) {\n      // If our subspec differentiate at any point, then we do not match\n      if (this.subSpecifiers[i] !== other.subSpecifiers[i]) {\n        return -1;\n      }\n    }\n\n    // We survived! The change in # sub specs is thus the # of changes to enhancements\n    return other.subSpecifiers.length - this.subSpecifiers.length;\n  }\n\n  /** Gives a numeric value indicating how these controls compare, lexicographically.\n   * See string.localCompare for the output format.\n   */\n  localCompare(other: NistControl): number {\n    // Convert into a chain of directives\n    const aChain = this.subSpecifiers;\n    const bChain = other.subSpecifiers;\n    for (let i = 0; i < aChain.length && i < bChain.length; i++) {\n      // Compare corresponding elements of the chain\n      const idA = aChain[i];\n      const idB = bChain[i];\n\n      // Return only if significant\n      const lc = idA.localeCompare(idB, 'en', {numeric: true});\n      if (lc) {\n        return lc;\n      }\n    }\n\n    // Fall back to length comparison. We want shorter first, so ascending's good\n    return aChain.length - bChain.length;\n  }\n\n  /**\n   * Quick accessor to the leading family letters for the nsit control\n   */\n  get family(): string | undefined {\n    if (this.subSpecifiers.length) {\n      return this.subSpecifiers[0];\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * Returns the \"canonical\" representation of this control, based on the provided parameters.\n   * This is, unfortunately, slightly expensive.\n   * Avoid repeating this if possible.\n   */\n  canonize(config: CanonizationConfig): string {\n    config = default_partial_config(config);\n    const ss = this.subSpecifiers;\n\n    // Build our string. Start with family\n    let s = this.family || '';\n    if (ss.length > 1) {\n      s += '-';\n    }\n\n    for (let i = 1; i < ss.length && i < config.max_specifiers; i++) {\n      let spec = ss[i];\n\n      // Handle numbers\n      if (!Number.isNaN(Number.parseInt(spec))) {\n        // If we need to, pad zeros\n        if (config.pad_zeros && spec.length < 2) {\n          spec = '0' + spec;\n        }\n\n        // If index past 1, wrap in parens\n        if (i > 1) {\n          if (config.add_parens) {\n            spec = `(${spec})`;\n          }\n\n          // If space, add space\n          if (config.add_spaces) {\n            spec = ' ' + spec;\n          }\n        }\n\n        // Append\n        s += spec;\n      } else if (config.allow_letters) {\n        // It's a letter. Add a .\n        if (config.add_spaces) {\n          s += ' ';\n        }\n        s += spec;\n        if (config.add_periods) {\n          s += '.';\n        }\n      }\n    }\n    return s;\n  }\n}\n\n/** Wrapper around a revision number. Currently has no additional functionality, but this may change. */\nexport class NistRevision {\n  revNum: number;\n  constructor(revNum: number) {\n    this.revNum = revNum;\n  }\n}\n\nexport function parse_nist(rawNist: string): ParseNist {\n  // Is it a revision? Get the match, continuing if none\n  const revMatch = rawNist.match(REV_RE);\n  if (revMatch) {\n    return new NistRevision(Number.parseInt(revMatch[1]));\n  }\n  // Is it just a family?\n  // Get the match, failing out if we can't\n  const famMatch = rawNist.match(NIST_FAMILY_RE);\n  if (famMatch) {\n    return new NistControl([famMatch[0]], famMatch[0]);\n  }\n\n  // Next try it as a full control\n  const fullMatch = rawNist.match(NIST_CONTROL_RE);\n  if (!fullMatch) {\n    return null;\n  }\n\n  // Parse sub-elements\n  const family = fullMatch[1];\n  const controlNum = fullMatch[2];\n  const subspecsRaw = (fullMatch[3] || '').trim();\n\n  // Init sub-specs\n  const subSpecs: string[] = [family, controlNum];\n\n  // Filter garbage from subspecsRaw\n  let subspecsSplit = subspecsRaw.split(SPEC_SPLITTER);\n  subspecsSplit = subspecsSplit.filter((s) => s !== '');\n  return new NistControl(subSpecs.concat(subspecsSplit), rawNist);\n}\n\n/** Simple discriminators */\nexport function is_control(\n  x: NistControl | NistRevision | null\n): x is NistControl {\n  if (x && (x as NistControl).subSpecifiers !== undefined) {\n    return true;\n  }\n  return false;\n}\n\n/** Simple discriminators */\nexport function is_revision(\n  x: NistControl | NistRevision | null\n): x is NistRevision {\n  if (x && (x as NistRevision).revNum !== undefined) {\n    return true;\n  }\n  return false;\n}\n\n/** All a control in a nist hash really needs is a status */\nexport interface CategoryItemRequirements {\n  status: ControlStatus;\n}\n\n// Represents the status of a group of controsl. Typically holds the value of the \"worst\" control amongst the group\n// Empty means no controls are in the given group\nexport type ControlGroupStatus = ControlStatus | 'Empty';\n\n/**\n * Computes the groups status having added control.\n * There's a natural precedence to statuses, at least in a list/group\n * For instance, we would not mark a group as Passed if it contained a Failed.\n * Clearly \"Empty\" is the lowest precedence, as adding any control would wipe it out.\n * Following we have \"From Profile\" since it is in some way the absence of status, but also lacks run context. We care more about literally anything else\n * Next, \"Not Applicable\" since it means that though we ran we don't care about the result\n * \"Not Reviewed\" implies that had the test run it would've mattered, but it was skipped deliberately\n * \"No Data\" is similarly a lack of result, but in this case unexpected, and thus worthy of more scrutiny\n * \"Passed\" means that a test passed! But \"Failed\" should override, since fails are really what we're looking for\n * Finally, \"Profile Errors\" mean something is broken and needs to be fixed, and thus overrides all\n *\n * Returns:\n * < 0  if a < b (by the above criteria)\n * 0    if a === b\n * > 0  if a > b\n */\nexport function compare_statuses(\n  a: ControlGroupStatus,\n  b: ControlGroupStatus\n): number {\n  const precedence: ControlGroupStatus[] = [\n    'Empty',\n    'From Profile',\n    'Not Applicable',\n    'Not Reviewed',\n    'Passed',\n    'Failed',\n    'Profile Error'\n  ];\n  const idA = precedence.indexOf(a);\n  const idB = precedence.indexOf(b);\n  return idA - idB;\n}\n\nexport function updateStatus(\n  group: ControlGroupStatus,\n  control: ControlStatus\n): ControlGroupStatus {\n  if (compare_statuses(group, control) > 0) {\n    // Our new control has shifted the status!\n    return control;\n  } else {\n    // Our existing group status was \"greater\"\n    return group;\n  }\n}\n\nexport interface NistHierarchyNode {\n  control: NistControl;\n  children: NistHierarchyNode[];\n}\nexport type NistHierarchy = NistHierarchyNode[];\n\nfunction _control_parent(c: NistControl): NistControl | null {\n  if (c.subSpecifiers.length) {\n    return new NistControl(\n      c.subSpecifiers.slice(0, c.subSpecifiers.length - 1)\n    );\n  } else {\n    return null; // Can't get any shorter\n  }\n}\n\nfunction _key_for(c: NistControl): string {\n  return c.subSpecifiers.join('-');\n}\n\nfunction _generate_full_nist_hierarchy(): NistHierarchy {\n  // Initialize our roots\n  const roots: NistHierarchy = ALL_NIST_FAMILIES.map((family) => {\n    return {\n      control: new NistControl([family], family),\n      children: []\n    };\n  });\n\n  // Init our map, which maps _key_for of controls to their corresponding hierarchy nodes\n  const map: {[key: string]: NistHierarchyNode} = {};\n\n  // Add roots to the map\n  roots.forEach((r) => {\n    map[_key_for(r.control)] = r;\n  });\n\n  // Iterate over all controls\n  ALL_NIST_CONTROL_NUMBERS.forEach((n) => {\n    const asControl = parse_nist(n) as NistControl | null; // We know there are no revs in our file\n    if (!asControl) {\n      throw new Error(`Invalid nist control constant ${n}`);\n    }\n\n    // If our node has already been created, replace the temporary control with the \"real\" one\n    const key = _key_for(asControl);\n    let asNode: NistHierarchyNode;\n    if (map[key]) {\n      asNode = map[key];\n      asNode.control = asControl;\n    } else {\n      //Make it fresh\n      asNode = {\n        control: asControl,\n        children: []\n      };\n\n      // Register in map\n      map[key] = asNode;\n    }\n\n    const parent = _control_parent(asControl);\n\n    // If parent is null, add to roots.\n    if (!parent) {\n      roots.push({\n        control: asControl,\n        children: []\n      });\n    } else {\n      // Valid parent; look it up and append us to it\n      const parentKey = _key_for(parent);\n      const parentNode = map[parentKey];\n\n      // If parent has been explored already, simply append this node to that\n      if (parentNode) {\n        parentNode.children.push(asNode);\n      } else {\n        // It's not? make a stub\n        map[parentKey] = {\n          control: parent,\n          children: [asNode] // \"Us\"\n        };\n      }\n    }\n  });\n\n  // Now roots are our final answers!\n  return roots;\n}\n\nexport const FULL_NIST_HIERARCHY: Readonly<NistHierarchy> =\n  _generate_full_nist_hierarchy();\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/store/data_store.ts": "/**\n * Tracks uploaded files, and their parsed contents\n */\n\nimport {\n  EvaluationFile,\n  FileID,\n  ProfileFile,\n  SourcedContextualizedEvaluation,\n  SourcedContextualizedProfile\n} from '@/store/report_intake';\nimport Store from '@/store/store';\nimport {\n  Action,\n  getModule,\n  Module,\n  Mutation,\n  VuexModule\n} from 'vuex-module-decorators';\nimport {FilteredDataModule} from './data_filters';\n\n/** We make some new variant types of the Contextual types, to include their files*/\nexport function isFromProfileFile(p: SourcedContextualizedProfile) {\n  return p.sourcedFrom === null;\n}\n\n@Module({\n  namespaced: true,\n  dynamic: true,\n  store: Store,\n  name: 'data'\n})\nexport class InspecData extends VuexModule {\n  /** State var containing all execution files that have been added */\n  executionFiles: EvaluationFile[] = [];\n\n  /** State var containing all profile files that have been added */\n  profileFiles: ProfileFile[] = [];\n\n  /** Return all of the files that we currently have. */\n  get allFiles(): (EvaluationFile | ProfileFile)[] {\n    const result: (EvaluationFile | ProfileFile)[] = [];\n    result.push(...this.executionFiles);\n    result.push(...this.profileFiles);\n    return result;\n  }\n\n  /* Return all evaluation files only */\n  get allEvaluationFiles(): EvaluationFile[] {\n    return this.executionFiles;\n  }\n\n  /* Return all profile files only */\n  get allProfileFiles(): ProfileFile[] {\n    return this.profileFiles;\n  }\n\n  /**\n   * Returns a readonly list of all executions currently held in the data store\n   * including associated context\n   */\n  get contextualExecutions(): readonly SourcedContextualizedEvaluation[] {\n    return this.executionFiles.map((file) => file.evaluation);\n  }\n\n  get loadedDatabaseIds(): string[] {\n    const ids: string[] = [];\n    this.allFiles.forEach((file) => {\n      if (file.database_id) {\n        ids.push(file.database_id.toString());\n      }\n    });\n    return ids;\n  }\n\n  /**\n   * Returns a readonly list of all profiles belonging to executions currently\n   * held in the data store\n   */\n  get contextualExecutionProfiles(): readonly SourcedContextualizedProfile[] {\n    return this.contextualExecutions.flatMap(\n      (evaluation) => evaluation.contains\n    ) as SourcedContextualizedProfile[];\n  }\n\n  /**\n   * Returns a readonly list of all profiles currently held in the data store\n   * including associated context\n   */\n  get contextualProfiles(): readonly SourcedContextualizedProfile[] {\n    return this.profileFiles.map((file) => file.profile);\n  }\n\n  get allProfiles(): readonly SourcedContextualizedProfile[] {\n    return this.contextualProfiles.concat(this.contextualExecutionProfiles);\n  }\n\n  /**\n   * Adds a profile file to the store.\n   * @param newProfile The profile to add\n   */\n  @Mutation\n  addProfile(newProfile: ProfileFile) {\n    this.profileFiles.push(newProfile);\n  }\n\n  /**\n   * Adds an execution file to the store.\n   * @param newExecution The execution to add\n   */\n  @Mutation\n  addExecution(newExecution: EvaluationFile) {\n    this.executionFiles.push(newExecution);\n  }\n\n  /**\n   * Unloads the file with the given id\n   */\n  @Action\n  removeFile(fileId: FileID) {\n    FilteredDataModule.clear_file(fileId);\n    this.context.commit('REMOVE_PROFILE', fileId);\n    this.context.commit('REMOVE_RESULT', fileId);\n  }\n\n  @Mutation\n  REMOVE_PROFILE(fileId: FileID) {\n    this.profileFiles = this.profileFiles.filter(\n      (pf) => pf.uniqueId !== fileId\n    );\n  }\n\n  @Mutation\n  REMOVE_RESULT(fileId: FileID) {\n    this.executionFiles = this.executionFiles.filter(\n      (ef) => ef.uniqueId !== fileId\n    );\n  }\n\n  /**\n   * Clear all stored data.\n   */\n  @Mutation\n  reset() {\n    this.profileFiles = [];\n    this.executionFiles = [];\n  }\n}\n\nexport const InspecDataModule = getModule(InspecData);\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/components/cards/treemap/Cell.vue": "<template>\n  <!-- We can use Vue transitions too! -->\n  <g>\n    <!-- Generate our children here. Only do so for parents, and if they aren't too deep -->\n    <g v-if=\"is_parent\">\n      <Cell\n        v-for=\"child in node.children\"\n        :key=\"child.data.key\"\n        :selected-control-id=\"selectedControlId\"\n        :depth=\"depth + 1\"\n        :node=\"child\"\n        :scales=\"scales\"\n        @select-node=\"select_node\"\n      />\n    </g>\n\n    <!-- The actual body of this square. Visible only if depth === 1 (ie a direct child of parent) or depth === 2 (one level deeper) -->\n    <rect\n      v-if=\"depth >= 1\"\n      :style=\"cell_style\"\n      :x=\"x\"\n      :y=\"y\"\n      :width=\"width\"\n      :height=\"height\"\n      :class=\"cell_classes\"\n      :rx=\"is_selected ? 20 : 0\"\n      @click=\"select_node(node)\"\n    />\n\n    <text\n      v-if=\"depth === 1\"\n      dominant-baseline=\"middle\"\n      text-anchor=\"middle\"\n      :x=\"x + width / 2\"\n      :y=\"y + height / 2\"\n      >{{ node.data.title }}</text\n    >\n  </g>\n</template>\n\n<script lang=\"ts\">\nimport {is_leaf, TreemapNode, TreemapNodeLeaf} from '@/utilities/treemap_util';\nimport * as d3 from 'd3';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\nimport {Prop} from 'vue-property-decorator';\n\nexport interface XYScale {\n  scale_x: d3.ScaleLinear<number, number>;\n  scale_y: d3.ScaleLinear<number, number>;\n}\n\n/**\n * Categories property must be of type Category\n * Emits \"select-node\" with payload of type d3.HierarchyRectangularNode<TreemapNode>\n */\n@Component({\n  name: 'Cell'\n})\nexport default class Cell extends Vue {\n  @Prop({type: String}) readonly selectedControlId!: string;\n  @Prop({type: Object, required: true})\n  readonly node!: d3.HierarchyRectangularNode<TreemapNode>;\n\n  @Prop({type: Number, default: 0}) readonly depth!: number;\n  @Prop({type: Object, default: 0}) readonly scales!: XYScale;\n\n  scale = 1.0;\n\n  /** Are we a control? Use treemap util type checker */\n  get is_control(): boolean {\n    return is_leaf(this.node.data);\n  }\n\n  /** Invert of above. Checks if this node has children, essentially */\n  get is_parent(): boolean {\n    return !this.is_control;\n  }\n\n  /** Are we selected? True if selectedControlId matches our id, and we are in selected hierarchy */\n  get is_selected(): boolean {\n    return (\n      this.is_control && // We are a control\n      (this.node.data as TreemapNodeLeaf).control.data.id ===\n        this.selectedControlId // Our control id matches\n    );\n  }\n\n  /** Compute the top-left x coord of this cell rect based on the provided scale_x prop */\n  get x(): number {\n    return this.scales.scale_x(this.node.x0);\n  }\n\n  /** Compute the top-left y coord of this cell rect based on the provided scale_y prop */\n  get y(): number {\n    return this.scales.scale_y(this.node.y0);\n  }\n\n  /**\n   * Compute the width of this rect based on scale, and base x position\n   */\n  get width(): number {\n    return this.scales.scale_x(this.node.x1) - this.x;\n  }\n\n  /**\n   * Compute the height of this rect based on scale, and base y position\n   */\n  get height(): number {\n    return this.scales.scale_y(this.node.y1) - this.y;\n  }\n\n  /** Returns a list of classes appropriate to this nodes Rect\n   * These are contextual based on type of data, and depth within the tree\n   */\n  get cell_classes(): string[] {\n    const s: string[] = [];\n    if (this.is_parent) {\n      s.push('parent');\n      if (!this.node.children || !this.node.children.length) {\n        s.push('empty');\n      }\n    } else {\n      s.push('leaf');\n    }\n\n    // Depth stuff\n    if (this.depth === 0) {\n      s.push('root');\n    } else if (this.depth === 1) {\n      s.push('top');\n    } else if (this.depth >= 1) {\n      s.push('nested');\n    }\n\n    return s;\n  }\n\n  get cell_style(): string {\n    if (this.node.data.color) {\n      return `fill: ${this.node.data.color.css()};`;\n    }\n    return 'fill-opacity: 0';\n  }\n\n  /**\n   * Callback fired when the user clicks a node. Passes up from cell to cell until it reaches Treemap\n   */\n  select_node(n: d3.HierarchyRectangularNode<TreemapNode>): void {\n    // Pass it up to root\n    this.$emit('select-node', n);\n  }\n}\n</script>\n\n<style scoped>\ntext {\n  pointer-events: none;\n}\n\n.theme--dark text {\n  fill: #f8f8f8;\n  font-size: large;\n}\n\n/* Basic settings for our chart. Things unclickable by default */\nrect {\n  stroke: #000000;\n  pointer-events: none;\n  fill-opacity: 0;\n}\n\n/* We want top to be clickable. */\nrect.top {\n  pointer-events: auto;\n  stroke-width: 2;\n}\n\n/* We want leaves */\nrect.leaf {\n  fill-opacity: 1;\n}\n\n/* Otherwise, don't want nested to draw strokes */\nrect.nested {\n  stroke-width: 1;\n}\n\nrect.nested.leaf {\n  stroke-width: 0;\n}\n\n/* Make tops transparent but also more thickly drawn when hovered */\nrect.top:hover {\n  stroke-width: 3;\n}\n</style>\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/components/generic/ApexLineChart.vue": "<template>\n  <div style=\"color: black\">\n    <vue-apex-charts\n      type=\"line\"\n      height=\"350\"\n      :options=\"chartOptions\"\n      :series=\"series\"\n    />\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport {ApexOptions} from 'apexcharts';\nimport Vue from 'vue';\nimport VueApexCharts from 'vue-apexcharts';\nimport Component from 'vue-class-component';\nimport {Prop} from 'vue-property-decorator';\nimport {Category} from './ApexPieChart.vue';\n\nexport interface SeriesItem {\n  name: string;\n  data: number[];\n}\n\n/**\n * Emits \"category-selected\" with payload of type Category whenever a category is selected.\n */\n@Component({\n  components: {\n    VueApexCharts\n  }\n})\nexport default class ApexLineChart extends Vue {\n  @Prop({required: true, type: Array}) readonly categories!: Category<string>[];\n  @Prop({required: true, type: Array}) readonly series!: number[];\n  @Prop({type: Number}) readonly upperRange!: number; //upper bound of y axis\n  @Prop({type: Boolean}) readonly sevChart!: boolean; //identifies chart as severity chart\n  @Prop({type: String}) readonly title!: string;\n  @Prop({type: String}) readonly yTitle!: string;\n\n  //gives apex charts the severity colors\n  sevColors: string[] = ['#FFEB3B', '#FF9800', '#FF5722', '#F44336'];\n\n  get label_colors(): string[] {\n    const colors = [];\n    for (let i = 0; i < this.categories.length; i++) {\n      colors.push('#FFFFFF');\n    }\n    return colors;\n  }\n\n  //creates differing number of ticks based on number of controls\n  get y_axis_tick(): number {\n    if (this.upperRange < 15) {\n      return this.upperRange;\n    } else if (this.upperRange < 50) {\n      return Math.floor(this.upperRange / 5);\n    } else {\n      return Math.floor(this.upperRange / 10);\n    }\n  }\n\n  get line_colors(): string[] | undefined {\n    if (this.sevChart) {\n      return this.sevColors;\n    }\n    return undefined;\n  }\n\n  // Generate the chart options based on _categories\n  get chartOptions(): ApexOptions {\n    return {\n      chart: {\n        height: 350,\n        type: 'line',\n        zoom: {\n          enabled: false\n        }\n        //background: '#000'\n      },\n      colors: this.line_colors,\n      dataLabels: {\n        enabled: false\n      },\n      stroke: {\n        width: 5,\n        curve: 'straight'\n      },\n      title: {\n        text: this.title,\n        align: 'left',\n        style: {\n          fontFamily: 'Arial Black',\n          fontSize: '14px',\n          color: '#FFFFFF'\n        }\n      },\n      legend: {\n        labels: {\n          useSeriesColors: true\n        }\n      },\n      xaxis: {\n        categories: this.categories,\n        labels: {\n          style: {\n            colors: this.label_colors\n          }\n        }\n      },\n      yaxis: {\n        min: 0,\n        max: this.upperRange,\n        tickAmount: this.y_axis_tick,\n        axisTicks: {\n          color: '#FF0000'\n        },\n        axisBorder: {\n          show: true,\n          color: '#FFFFFF',\n          offsetX: 0,\n          offsetY: 0\n        },\n        title: {\n          text: this.yTitle,\n          style: {\n            color: '#FFFFFF'\n          }\n        },\n        labels: {\n          style: {\n            colors: '#FFFFFF'\n          }\n        }\n      },\n      grid: {\n        borderColor: '#f1f1f1'\n      }\n    };\n  }\n}\n</script>\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/utilities/delta_util.ts": "/**\n * Provides utlities for comparing executions\n */\n\nimport {SourcedContextualizedEvaluation} from '@/store/report_intake';\nimport {ContextualizedControl, ContextualizedEvaluation} from 'inspecjs';\nimport {DateTime} from 'luxon';\n\nexport const NOT_SELECTED = 'not selected';\n\n// Unique ID is the unique ID of a file\n// Controls is a list of controls\ninterface ResultControls {\n  uniqueId: string;\n  controls: ContextualizedControl[];\n}\n\n/**\n * Represents a change in a property.\n * We assume that the \"old\" property is the name to use for both.\n * IE that they are the same property value.\n */\nexport class ControlChange {\n  name: string; // the key/title of these values\n  values: string[]; // values over controls sorted by time\n\n  /** Trivial constructor */\n  constructor(name: string, values: string[]) {\n    this.values = values;\n    this.name = name;\n  }\n\n  /** Checks if this actually changes anything.\n   * Returns true iff old !== new\n   */\n  get valid(): boolean {\n    let firstSelected = -1;\n    for (let i = 0; i < this.values.length; i++) {\n      if (this.values[i] !== NOT_SELECTED) {\n        firstSelected = i;\n        break;\n      }\n    }\n    if (firstSelected === -1) {\n      return false;\n    }\n    for (let i = firstSelected + 1; i < this.values.length; i++) {\n      if (\n        this.values[i] !== this.values[firstSelected] &&\n        this.values[i] !== NOT_SELECTED\n      ) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\n/**\n * Represents a group of changes all under one cnosistent named banner.\n */\nexport class ControlChangeGroup {\n  name: string;\n  changes: ControlChange[];\n\n  /** Trivial constructor */\n  constructor(name: string, changes: ControlChange[]) {\n    this.name = name;\n    this.changes = changes;\n  }\n\n  /** Checks if this has any changes at all. Simple shorthand */\n  get any(): boolean {\n    return this.changes.length > 0;\n  }\n\n  /** Removes any changes if they aren't actually changes */\n  clean() {\n    this.changes = this.changes.filter((c) => c.valid);\n  }\n}\n\n/**\n * Holds/computes the differences between two runs of the same control.\n */\nexport class ControlDelta {\n  controls: ContextualizedControl[] = [];\n  controlsandnull: (ContextualizedControl | null)[] = [];\n  numNull = 0;\n\n  constructor(controls: (ContextualizedControl | null)[]) {\n    this.controlsandnull = controls;\n    for (const value of controls) {\n      if (value !== null) {\n        this.controls.push(value);\n      } else {\n        this.numNull += 1;\n      }\n    }\n  }\n\n  /** Returns the changes in \"header\" elements of a control. E.g. name, status, etc. */\n  get headerChanges(): ControlChangeGroup {\n    // Init the list\n    const headerChanges: ControlChange[] = [];\n\n    // Change in... ID? Theoretically possible!\n    headerChanges.push(\n      new ControlChange(\n        'ID',\n        this.controlsandnull.map((c) => {\n          if (c === null) {\n            return NOT_SELECTED;\n          }\n          return c.data.id;\n        })\n      )\n    );\n\n    // And severity! Why not\n    headerChanges.push(\n      new ControlChange(\n        'Severity',\n        this.controlsandnull.map((c) => {\n          if (c === null) {\n            return NOT_SELECTED;\n          }\n          return c.hdf.severity;\n        })\n      )\n    );\n\n    // Change in nist tags!\n    headerChanges.push(\n      new ControlChange(\n        'NIST Tags',\n        this.controlsandnull.map((c) => {\n          if (c === null) {\n            return NOT_SELECTED;\n          }\n          return c.hdf.rawNistTags.join(', ');\n        })\n      )\n    );\n\n    // Make the group and clean it\n    const result = new ControlChangeGroup('Control Details', headerChanges);\n    result.clean();\n    return result;\n  }\n}\n\nexport function get_eval_start_time(\n  ev: ContextualizedEvaluation\n): string | null {\n  for (const prof of ev.contains) {\n    for (const ctrl of prof.contains) {\n      if (ctrl.hdf.segments!.length) {\n        return ctrl.hdf.segments![0].start_time;\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Grabs the \"top\" (IE non-overlayed/end of overlay chain) controls from the execution.\n *\n * @param exec The execution to grab controls from\n */\nfunction extract_top_level_controls(\n  exec: SourcedContextualizedEvaluation\n): ResultControls {\n  // Get all controls\n  const allControls = exec.contains.flatMap((p) => p.contains);\n\n  // Filter to controls that aren't overlayed further\n  const top = allControls.filter((control) => control.extendedBy.length === 0);\n  return {uniqueId: exec.from_file.uniqueId, controls: top};\n}\n\n/** An object of contextualized controls with the same V-ID */\nexport type ControlSeries = {[key: string]: ContextualizedControl};\n\n/** Matches ControlID keys to Arrays of Controls */\nexport type ControlSeriesLookup = {[key: string]: ControlSeries};\n\n/** Helps manage comparing change(s) between one or more profile executions */\nexport class ComparisonContext {\n  /** A list of old-new control pairings */\n  pairings: ControlSeriesLookup;\n\n  constructor(executions: readonly SourcedContextualizedEvaluation[]) {\n    // Get all of the \"top level\" controls from each execution, IE those that actually ran\n    // grouped by their files unique id.\n    const allControls = executions.map(extract_top_level_controls);\n    // Organize the controls by ID\n    // The structure this returns is as follows:\n    // {{\"V-XXX\": {\"unique_file_id_1\": control, \"unique_file_id_2\": control, ...}}}\n    const matched = allControls.reduce(\n      (acc: ControlSeriesLookup, evaluation: ResultControls) => {\n        evaluation.controls.forEach((control) => {\n          // Group initialization\n          if (!acc[control.data.id]) {\n            acc[control.data.id] = {};\n          }\n          // Grouping\n          acc[control.data.id][evaluation.uniqueId] = control;\n        });\n\n        return acc;\n      },\n      {}\n    );\n    // Store\n    this.pairings = matched;\n  }\n}\n\n/*\n  DateTime parsing in Chrome works very different than Safari and Firefox\n  Using luxon provides consistent timestamp information with a fallback to\n  using the native browser date parsing.\n\n  Chrome already supports parsing all of these formats natively, however it\n  is the only browser that does so.\n*/\nexport function parse_datetime(dateString: string): DateTime {\n  let result: DateTime;\n\n  result = DateTime.fromRFC2822(dateString);\n  if (result.isValid) {\n    return result;\n  }\n  result = DateTime.fromISO(dateString);\n  if (result.isValid) {\n    return result;\n  }\n  result = DateTime.fromHTTP(dateString);\n  if (result.isValid) {\n    return result;\n  }\n  result = DateTime.fromSQL(dateString);\n  if (result.isValid) {\n    return result;\n  }\n\n  return DateTime.fromJSDate(new Date(dateString));\n}\n\nexport function compare_times(\n  a: SourcedContextualizedEvaluation,\n  b: SourcedContextualizedEvaluation\n) {\n  const aDate = parse_datetime(get_eval_start_time(a) || '');\n  const bDate = parse_datetime(get_eval_start_time(b) || '');\n\n  return aDate.valueOf() - bDate.valueOf();\n}\n\n",
  "/api/sources/raw?key=test:apps/frontend/tests/unit/Compare.spec.ts": "import {FilteredDataModule} from '@/store/data_filters';\nimport {SearchModule} from '@/store/search';\nimport {StatusCountModule} from '@/store/status_counts';\nimport {ComparisonContext, ControlSeries} from '@/utilities/delta_util';\nimport Compare from '@/views/Compare.vue';\nimport {shallowMount, Wrapper} from '@vue/test-utils';\nimport 'jest';\nimport Vue from 'vue';\nimport Vuetify from 'vuetify';\nimport {fileCompliance, loadSample, removeAllFiles} from '../util/testingUtils';\n\nconst vuetify = new Vuetify();\n\nconst wrapper: Wrapper<Vue> = shallowMount(Compare, {\n  vuetify,\n  propsData: {}\n});\n\nexport interface SeriesItem {\n  name: string;\n  data: number[];\n}\n\nconst redHatControlCount = 247;\nconst nginxControlCount = 41;\nconst nginxDelta = 3;\n\ndescribe('Compare table data', () => {\n  loadSample('NGINX With Failing Tests');\n  it('correctly counts controls with 1 file', () => {\n    (wrapper.vm as Vue & {changedOnly: boolean}).changedOnly = false;\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(nginxControlCount);\n  });\n\n  it('does not recount same controls with 2 files', () => {\n    loadSample('NGINX With Failing Tests');\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(nginxControlCount);\n  });\n\n  it('does not recount same controls with 3 files', () => {\n    loadSample('NGINX With Failing Tests');\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(nginxControlCount);\n  });\n\n  it('does not show any changed between two of the same', () => {\n    (wrapper.vm as Vue & {changedOnly: boolean}).changedOnly = true;\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(0);\n  });\n\n  it('search works when nothing fits criteria', () => {\n    (wrapper.vm as Vue & {searchTerm: string}).searchTerm = 'failed';\n    SearchModule.parseSearch();\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(0);\n  });\n\n  it('search id works', () => {\n    (wrapper.vm as Vue & {changedOnly: boolean}).changedOnly = false;\n    (wrapper.vm as Vue & {searchTerm: string}).searchTerm = 'v-13613';\n    SearchModule.parseSearch();\n    setTimeout(() => {\n      expect(\n        (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n          .length\n      ).toBe(1);\n    }, 1000);\n  });\n\n  it('shows differing delta data when \"show only changed\"', () => {\n    (wrapper.vm as Vue & {searchTerm: string}).searchTerm = '';\n    (wrapper.vm as Vue & {changedOnly: boolean}).changedOnly = true;\n    loadSample('NGINX Clean Sample');\n    SearchModule.parseSearch();\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(nginxDelta);\n  });\n\n  it('search status works', () => {\n    (wrapper.vm as Vue & {changedOnly: boolean}).changedOnly = false;\n    (wrapper.vm as Vue & {searchTerm: string}).searchTerm = 'failed';\n    SearchModule.parseSearch();\n    setTimeout(() => {\n      expect(\n        (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n          .length\n      ).toBe(nginxDelta);\n    }, 1000);\n  });\n\n  it('counts every unique control', () => {\n    loadSample('Red Hat With Failing Tests');\n    (wrapper.vm as Vue & {searchTerm: string}).searchTerm = '';\n    (wrapper.vm as Vue & {changedOnly: boolean}).changedOnly = true;\n    SearchModule.parseSearch();\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(nginxControlCount + redHatControlCount);\n  });\n\n  it('shows all delta data of controls with multiple occurances when \"show only changed\"', () => {\n    loadSample('Red Hat Clean Sample');\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(nginxControlCount + redHatControlCount);\n  });\n\n  it('ComparisonContext counts status correctly', () => {\n    let failed = 0;\n    let passed = 0;\n    let na = 0;\n    let nr = 0;\n    let pe = 0;\n    const selectedData = FilteredDataModule.evaluations(\n      FilteredDataModule.selected_file_ids\n    );\n    const currDelta = new ComparisonContext(selectedData);\n    for (const pairing of Object.values(currDelta.pairings)) {\n      for (const ctrl of Object.values(pairing)) {\n        if (ctrl === null) {\n          continue;\n        } else if (ctrl.root.hdf.status === 'Passed') {\n          passed++;\n        } else if (ctrl.root.hdf.status === 'Failed') {\n          failed++;\n        } else if (ctrl.root.hdf.status === 'Not Applicable') {\n          na++;\n        } else if (ctrl.root.hdf.status === 'Not Reviewed') {\n          nr++;\n        } else if (ctrl.root.hdf.status === 'Profile Error') {\n          pe++;\n        }\n      }\n    }\n    const expected = {\n      Failed: StatusCountModule.hash({\n        omit_overlayed_controls: true,\n        fromFile: [...FilteredDataModule.selected_file_ids]\n      }).Failed,\n      Passed: StatusCountModule.hash({\n        omit_overlayed_controls: true,\n        fromFile: [...FilteredDataModule.selected_file_ids]\n      }).Passed,\n      'From Profile': 0,\n      'Profile Error': StatusCountModule.hash({\n        omit_overlayed_controls: true,\n        fromFile: [...FilteredDataModule.selected_file_ids]\n      })['Profile Error'],\n      'Not Reviewed': StatusCountModule.hash({\n        omit_overlayed_controls: true,\n        fromFile: [...FilteredDataModule.selected_file_ids]\n      })['Not Reviewed'],\n      'Not Applicable': StatusCountModule.hash({\n        omit_overlayed_controls: true,\n        fromFile: [...FilteredDataModule.selected_file_ids]\n      })['Not Applicable']\n    };\n    const actual = {\n      Failed: failed,\n      Passed: passed,\n      'From Profile': 0,\n      'Profile Error': pe,\n      'Not Reviewed': nr,\n      'Not Applicable': na\n    };\n    expect(actual).toEqual(expected);\n  });\n});\n\ndescribe('compare charts', () => {\n  it('sev chart gets correct data with 2 files', () => {\n    removeAllFiles();\n    loadSample('NGINX With Failing Tests');\n    loadSample('NGINX Clean Sample');\n    //the values in expected are the correct data\n    expect((wrapper.vm as Vue & {sev_series: number[][]}).sev_series).toEqual([\n      [0, 0],\n      [3, 0],\n      [0, 0],\n      [0, 0]\n    ]);\n  });\n\n  it('sev chart gets correct data with 2 files with differing profiles', () => {\n    removeAllFiles();\n    loadSample('NGINX With Failing Tests');\n    loadSample('Red Hat With Failing Tests');\n    //the values in expected are the correct data\n    expect((wrapper.vm as Vue & {sev_series: number[][]}).sev_series).toEqual([\n      [0, 6],\n      [3, 18],\n      [0, 3],\n      [0, 0]\n    ]);\n  });\n\n  it('sev chart gets correct data with 2 files with overlayed profiles', () => {\n    removeAllFiles();\n    loadSample('Triple Overlay Example');\n    loadSample('Acme Overlay Example');\n    //the values in expected are the correct data\n    expect((wrapper.vm as Vue & {sev_series: number[][]}).sev_series).toEqual([\n      [3, 0],\n      [51, 0],\n      [1, 0],\n      [0, 60]\n    ]);\n  });\n\n  it('compliance chart gets correct data with 2 files', () => {\n    removeAllFiles();\n    loadSample('NGINX With Failing Tests');\n    loadSample('NGINX Clean Sample');\n    expect(\n      new Set(\n        (\n          wrapper.vm as Vue & {\n            compliance_series: SeriesItem[];\n          }\n        ).compliance_series[0].data\n      )\n    ).toEqual(\n      new Set([\n        fileCompliance(FilteredDataModule.selected_file_ids[0]),\n        fileCompliance(FilteredDataModule.selected_file_ids[1])\n      ])\n    );\n  });\n\n  it('compliance chart gets correct data with 2 files with differing profiles', () => {\n    removeAllFiles();\n    loadSample('NGINX With Failing Tests');\n    loadSample('Red Hat With Failing Tests');\n    expect(\n      new Set(\n        (\n          wrapper.vm as Vue & {\n            compliance_series: SeriesItem[];\n          }\n        ).compliance_series[0].data\n      )\n    ).toEqual(\n      new Set([\n        fileCompliance(FilteredDataModule.selected_file_ids[0]),\n        fileCompliance(FilteredDataModule.selected_file_ids[1])\n      ])\n    );\n  });\n\n  it('compliance chart gets correct data with 2 files with overlayed profiles', () => {\n    removeAllFiles();\n    loadSample('Triple Overlay Example');\n    loadSample('Acme Overlay Example');\n    expect(\n      new Set(\n        (\n          wrapper.vm as Vue & {\n            compliance_series: SeriesItem[];\n          }\n        ).compliance_series[0].data\n      )\n    ).toEqual(\n      new Set([\n        fileCompliance(FilteredDataModule.selected_file_ids[0]),\n        fileCompliance(FilteredDataModule.selected_file_ids[1])\n      ])\n    );\n  });\n});\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/utilities/splunk_util.ts": "import {ConversionResult, convertFile, ExecJSON} from 'inspecjs';\nimport {ElementCompact, xml2js} from 'xml-js';\nimport {delay} from './async_util';\nimport {basic_auth, group_by, map_hash} from './helper_util';\n\nexport type JobID = string;\n\n// Interfaces\n/** The parent type to other interfaces, to save duplication */\ninterface AbsMetaInfo {\n  /** The file this came from */\n  filename: string;\n\n  /** The type of the file (NOT of this event!) */\n  filetype: 'evaluation' | 'profile';\n\n  /** The subtype of this specific event */\n  subtype: 'header' | 'profile' | 'control';\n\n  /** A randomly generated GUID capturing all of the events in this file */\n  guid: string;\n\n  /** When this event was parsed */\n  parse_time: string;\n\n  /** The schema version: */\n  hdf_splunk_schema: string;\n\n  /** The sha256 hash of the profile that is/contains this event */\n  profile_sha256: string;\n\n  /** The start time of the control in ISO format */\n  startTime: string;\n\n  /** The control ID, repeated for convenience in splunk searches */\n  control_id: string;\n}\n\n/** The meta information for an event with the \"evaluation\" subtype */\nexport interface ExecutionMetaInfo\n  extends Omit<AbsMetaInfo, 'control_id' | 'startTime' | 'profile_sha256'> {\n  subtype: 'header';\n}\n\n/** The meta information for an event with the \"profile\" subtype */\nexport interface ProfileMetaInfo\n  extends Omit<AbsMetaInfo, 'control_id' | 'startTime'> {\n  subtype: 'profile';\n}\n\n/** The meta information for an event with the \"control\" subtype */\nexport interface ControlMetaInfo extends AbsMetaInfo {\n  subtype: 'control';\n}\n\n/** This is what we expect to find in every parsed event representing an Evaluation\n * Note that Profiles will typically be initially empty\n */\nexport interface ExecutionPayload {\n  meta: ExecutionMetaInfo;\n  profiles: ProfilePayload[];\n}\n\n/** This is what we expect to find in every parsed event representing a Profile.\n * Note that controls will typically be initially empty\n */\nexport interface ProfilePayload {\n  meta: ProfileMetaInfo;\n  controls: ControlPayload[];\n}\n\n/** This is what we expect to find in every parsed event representing a Control */\nexport interface ControlPayload {\n  meta: ControlMetaInfo;\n}\n\n// Could be any!\nexport type UnknownPayload = ExecutionPayload | ProfilePayload | ControlPayload;\n\n/* Job states */\ntype CompleteJobStatus = 'succeeded' | 'failed';\ntype PendingJobStatus = 'pending'; // There are others, but we don't handle them for now\ntype JobStatus = CompleteJobStatus | PendingJobStatus;\ninterface JobState {\n  status: JobStatus;\n  jobId: JobID;\n}\n\n/** This info is used to negotiate splunk connections */\nexport class SplunkEndpoint {\n  /** The full host information, including port (typically 8089).\n   * EX: https://localhost:8089\n   */\n  host: string;\n\n  /** Username to use for authentication */\n  username: string;\n\n  /** Password to use for authentication */\n  password: string;\n\n  constructor(host: string, username: string, password: string) {\n    this.host = host;\n    this.username = username;\n    this.password = password;\n  }\n\n  /** Checks whether we're able to successfully get jobs,\n   * which indicates proper auth.\n   *\n   * Will error if we aren't\n   */\n\n  process_response(response: Response) {\n    if (!response.ok) {\n      throw process_error(response);\n    }\n    return response.text();\n  }\n\n  async check_auth(): Promise<void> {\n    return fetch(`${this.host}/services/search/jobs`, {\n      headers: {\n        Authorization: this.authString\n      },\n      method: 'GET'\n    }).then(\n      (response) => {\n        if (!response.ok) {\n          throw process_error(response);\n        }\n      },\n      (failure) => {\n        throw process_error(failure);\n      }\n    );\n  }\n\n  /** Provides a list of Evaluation meta headers from recent executions.\n   * We should eventually change this to allow more specific criteria\n   */\n  async fetch_execution_list(): Promise<ExecutionMetaInfo[]> {\n    // This search lists evaluation headers\n    const getExecutionsSearch =\n      'spath \"meta.subtype\" | search \"meta.subtype\"=header';\n\n    return this.hdf_event_search(getExecutionsSearch).then((events) => {\n      // Because we only searched for headers, we can assume these to be eval events\n      const evalEvents = events as ExecutionPayload[];\n\n      // Could perhaps just return e but I'd rather people didn't screw themselves\n      return evalEvents.map((e) => e.meta);\n    });\n  }\n\n  async get_execution_events(executionGuid: string): Promise<UnknownPayload[]> {\n    // This search, provided a guid, returns all headers for that guid\n    const specificEvaluation = `spath \"meta.guid\" | search \"meta.guid\"=${executionGuid}`;\n    return this.hdf_event_search(specificEvaluation);\n  }\n\n  async get_execution(executionGuid: string): Promise<ExecJSON.Execution> {\n    return this.get_execution_events(executionGuid)\n      .then((events) => consolidate_payloads(events))\n      .then((execs) => {\n        if (execs.length !== 1) {\n          throw SplunkErrorCode.InvalidGUID;\n        } else {\n          return execs[0];\n        }\n      })\n      .then((fullEvent) => {\n        // This is dumb and we should make the inspecjs layer more accepting of many file types\n        let result: ConversionResult;\n        try {\n          result = convertFile(JSON.stringify(fullEvent));\n        } catch (e) {\n          throw SplunkErrorCode.SchemaViolation;\n        }\n\n        // Determine what sort of file we (hopefully) have, then add it\n        if (result['1_0_ExecJson']) {\n          // Handle as exec\n          return result['1_0_ExecJson'];\n        } else {\n          throw SplunkErrorCode.SchemaViolation;\n        }\n      });\n  }\n\n  /** Creates a proper base64 encoded auth string, using this objects credentials. */\n  private get authString(): string {\n    return basic_auth(this.username, this.password);\n  }\n\n  /** Performs the entire process of search string -> results array\n   *  Performs no consolidation.\n   *  Assumes your search string is properly constrained to the hdf index\n   */\n  async hdf_event_search(searchString: string): Promise<UnknownPayload[]> {\n    return this.create_search(searchString)\n      .then((jobId) => this.pend_job(jobId, 500))\n      .then((jobState) => {\n        if (jobState.status === 'failed') {\n          throw SplunkErrorCode.SearchFailed;\n        }\n\n        return this.get_search_results(jobState.jobId);\n      })\n      .catch((error) => {\n        throw process_error(error);\n      });\n  }\n\n  /** Returns the job id */\n  private async create_search(searchString: string): Promise<JobID> {\n    return fetch(`${this.host}/services/search/jobs`, {\n      method: 'POST',\n      headers: new Headers({\n        Authorization: this.authString\n      }),\n      body: `search=search index=\"hdf\" | ${searchString}`\n    })\n      .then(this.process_response)\n      .then((text) => {\n        // Parse the xml\n        const xml = xml2js(text, {\n          compact: true\n        }) as ElementCompact;\n        return xml.response.sid._text as string;\n      });\n  }\n\n  /** Returns the current state of the job */\n  private async check_job(jobId: JobID): Promise<JobState> {\n    return fetch(`${this.host}/services/search/jobs/${jobId}`, {\n      method: 'GET',\n      headers: new Headers({\n        Authorization: this.authString\n      })\n    })\n      .then(this.process_response)\n      .then((text) => {\n        // Parse the xml\n        const xml = xml2js(text, {\n          compact: true\n        }) as ElementCompact;\n\n        // Get the keys, and find the one with name \"dispatchState\"\n        const keys = xml.entry.content['s:dict']['s:key'];\n        let state: string | undefined;\n        for (const k of keys) {\n          if (k._attributes.name === 'dispatchState') {\n            state = k._text;\n          }\n        }\n\n        // Check we found state\n        if (!state) {\n          // It probably failed if we can't find it lol\n          state = 'FAILED';\n        }\n\n        // Decide result based on state\n        let status: JobStatus;\n        if (state === 'DONE') {\n          status = 'succeeded';\n        } else if (state === 'FAILED') {\n          status = 'failed';\n        } else {\n          status = 'pending';\n        }\n\n        // Construct the state\n        return {\n          status,\n          jobId\n        };\n      });\n  }\n\n  /** Continually checks the job until resolution */\n  private async pend_job(jobId: JobID, interval: number): Promise<JobState> {\n    /* eslint-disable */\n        while (true) {\n            /* eslint-enable */\n      const state = await this.check_job(jobId);\n      if (state.status === 'pending') {\n        await delay(interval);\n      } else {\n        return state;\n      }\n    }\n  }\n\n  /** Gets the search results for a given job id, if it is done */\n  private async get_search_results(jobId: JobID): Promise<UnknownPayload[]> {\n    return fetch(\n      `${this.host}/services/search/jobs/${jobId}/results/?output_mode=json&count=0`,\n      {\n        headers: {\n          Authorization: this.authString\n        },\n        method: 'GET'\n      }\n    )\n      .then((response) => {\n        if (!response.ok) {\n          throw process_error(response);\n        }\n        return response.json();\n      })\n      .then((data) => {\n        // We basically can't, and really shouldn't, do typescript here. Output is 50% guaranteed to be wonk\n        // Get all the raws\n        const raws: Array<string> = data['results'].map(\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          (datum: any) => datum._raw\n        );\n\n        // Parse to json, and freeze\n        const parsed = [] as UnknownPayload[];\n        for (const v of raws) {\n          try {\n            parsed.push(JSON.parse(v) as UnknownPayload);\n          } catch (err) {\n            // eslint-disable-next-line no-console\n            console.warn(err);\n          }\n        }\n\n        return parsed;\n      });\n  }\n}\n\n/** Given: A list of all payloads from a search,\n * Produce: A list of Evaluation payloads containing all data properly reconstructed, recursively, into a \"normal\"\n * HDF heirarchy.\n *\n * TODO: Provide a mechanism for also returning orphaned items\n */\nexport function consolidate_payloads(\n  payloads: UnknownPayload[]\n): ExecutionPayload[] {\n  // Group by exec id\n  const grouped = group_by(payloads, (pl) => pl.meta.guid);\n\n  const built = map_hash(grouped, consolidate_file_payloads);\n\n  return Object.values(built);\n}\n\n/** Given: A list of all payloads from a search with the same GUID\n * Produce: A single EvaluationPayload containing all of these payloads reconstructed into the expected HDF heirarchy\n */\nfunction consolidate_file_payloads(\n  filePayloads: UnknownPayload[]\n): ExecutionPayload {\n  // In the end we wish to produce a single evaluation EventPayload which in fact contains all data for the guid\n  // Group by subtype\n  const subtypes = group_by(filePayloads, (event) => event.meta.subtype);\n  const execEvents = (subtypes['header'] || []) as ExecutionPayload[];\n  const profileEvents = (subtypes['profile'] || []) as ProfilePayload[];\n  const controlEvents = (subtypes['control'] || []) as ControlPayload[];\n\n  // Verify we only have one exec event\n  if (execEvents.length !== 1) {\n    throw new Error(\n      `Incorrect # of Evaluation events. Expected 1, got ${execEvents.length}`\n    );\n  }\n\n  // Pull it out\n  const exec = execEvents[0];\n\n  // Put all the profiles into the exec\n  exec.profiles.push(...profileEvents);\n\n  // Group controls, and then put them into the profiles\n  const shaGroupedControls = group_by(\n    controlEvents,\n    (ctrl) => ctrl.meta.profile_sha256\n  );\n  for (const profile of profileEvents) {\n    // Get the corresponding controls, and put them into the profile\n    const sha = profile.meta.profile_sha256;\n    const corrControls = shaGroupedControls[sha] || [];\n    profile.controls.push(...corrControls);\n  }\n\n  // Spit it back out\n  return exec;\n}\n\nexport enum SplunkErrorCode {\n  BadNetwork, // Server could not be reached, either due to bad address or bad CORS\n  BadUrl, // URL poorly formed\n  PageNotFound, // Server gave error 404\n  BadAuth, // Authorization credentials are no good\n  SearchFailed, // For whatever reason, the splunk search failed\n  ConsolidationFailed, // Something went wrong during event consolidation phase\n  SchemaViolation, // The data we got out isn't valid HDF. Hope to not see this too often\n  InvalidGUID, // If the provided GUID did not match to exactly one header\n  UnknownError // No clue!\n}\n\n/** Converts Responses and Errorcodes into purely just errorcodes */\nexport function process_error(\n  r: Response | SplunkErrorCode | TypeError\n): SplunkErrorCode {\n  if (r instanceof TypeError) {\n    if (r.message.includes('NetworkError')) {\n      return SplunkErrorCode.BadNetwork;\n    } else if (r.message.includes('not a valid URL')) {\n      return SplunkErrorCode.BadUrl;\n    }\n  } else if (r instanceof Response) {\n    // Based on the network code, guess\n    const response = r;\n    switch (response.status) {\n      case 401: // Bad username/password\n        return SplunkErrorCode.BadAuth;\n      case 404: // URL got borked\n        return SplunkErrorCode.PageNotFound;\n      default:\n        return SplunkErrorCode.UnknownError;\n    }\n  } else if (typeof r === typeof SplunkErrorCode.UnknownError) {\n    // It's already an error code - pass along\n    return r;\n  }\n  // idk lol\n  return SplunkErrorCode.UnknownError;\n}\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/utilities/treemap_util.ts": "/**\n * Tools used for generating the treemaps consumed by, of course, the Treemap card and associated components.\n */\n\nimport {ColorHack} from '@/store/color_hack';\nimport Chroma from 'chroma-js';\nimport * as d3 from 'd3';\nimport {\n  ContextualizedControl,\n  FULL_NIST_HIERARCHY,\n  NistControl,\n  NistHierarchyNode\n} from 'inspecjs';\nimport {control_unique_key} from './format_util';\n\n// How deep into nist trees we allow\nconst depthMax = 2;\n\n/** A simple wrapper type representing what any node's data might be in our treemap */\ninterface AbsTreemapNode {\n  title: string;\n  subtitle?: string;\n  hovertext?: string;\n  key: string;\n  color?: Chroma.Color;\n  parent: TreemapNodeParent | null; // The parent of this node.\n  nist_control: NistControl; // The nist control which this node is associated with. Not necessarily unique (e.g. leaves)\n}\nexport interface TreemapNodeParent extends AbsTreemapNode {\n  children: TreemapNode[]; // Maps the next sub-specifier to children\n}\n\nexport interface TreemapNodeLeaf extends AbsTreemapNode {\n  control: ContextualizedControl;\n}\n\nexport function is_leaf(n: TreemapNode): n is TreemapNodeLeaf {\n  return (n as TreemapNodeLeaf).control !== undefined;\n}\n\nexport function is_parent(n: TreemapNode): n is TreemapNodeParent {\n  return (n as TreemapNodeParent).children !== undefined;\n}\n\n/** The type of our treemap nodes, prior to rendering */\nexport type TreemapNode = TreemapNodeLeaf | TreemapNodeParent;\nexport type D3TreemapNode = d3.HierarchyNode<TreemapNode>;\n\n/**\n * Converts a list of controls to treemap leaves.\n * Actually a one-to-many mapping since we must make a unique leaf for each nist control on each control!\n * @param controls The controls to build into a nist node map\n */\nfunction controls_to_nist_node_data(\n  contextualizedControls: Readonly<ContextualizedControl[]>,\n  colors: ColorHack\n): TreemapNodeLeaf[] {\n  return contextualizedControls.flatMap((cc) => {\n    // Get the status color\n    const color = Chroma.hex(colors.colorForStatus(cc.root.hdf.status));\n    // Now make leaves for each nist control\n    return cc.root.hdf.parsedNistTags.map((nc) => {\n      return {\n        title: cc.data.id,\n        subtitle: cc.data.title || undefined,\n        hovertext: cc.data.desc || undefined,\n        key: control_unique_key(cc) + nc.rawText,\n        control: cc,\n        nist_control: nc,\n        color,\n        parent: null // We set this later\n      };\n    });\n  });\n}\n\n/** Builds a scaffolding for the nist items using the given root.\n * Also constructs a lookup table of control nodes.\n * Only goes maxDepth deep.\n */\nfunction recursive_nist_map(\n  parent: TreemapNodeParent | null,\n  node: Readonly<NistHierarchyNode>,\n  controlLookup: {[key: string]: TreemapNodeParent},\n  maxDepth: number\n): TreemapNodeParent {\n  // Init child list\n  const children: TreemapNode[] = [];\n\n  // Make our final value\n  const ret: TreemapNodeParent = {\n    key: node.control.rawText || '',\n    title: node.control.rawText || '',\n    nist_control: node.control,\n    parent,\n    children\n  };\n\n  // Fill our children\n  if (node.control.subSpecifiers.length < maxDepth) {\n    node.children.forEach((child) => {\n      // Assign it, recursively computing the rest\n      children.push(recursive_nist_map(ret, child, controlLookup, maxDepth));\n    });\n  }\n\n  // Save to lookup\n  controlLookup[lookup_key_for(node.control, maxDepth)] = ret;\n  return ret;\n}\n\n/** Colorizes a treemap based on each nodes children. */\nfunction colorize_tree_map(root: TreemapNodeParent) {\n  // First colorize children, recursively\n  root.children.forEach((child) => {\n    if (is_parent(child)) {\n      colorize_tree_map(child);\n    }\n  });\n\n  // Now all children should have valid colors\n  // We decide this node's color as a composite of all underlying node colors\n  const childColors = root.children\n    .map((c) => c.color)\n    .filter((c): c is Chroma.Color => !!c);\n  // If we have any, then set our color\n  if (childColors.length) {\n    // Set the color\n    const avgColor = Chroma.average(childColors);\n    root.color = avgColor;\n  }\n}\n\n/** Generates a lookup key for the given control */\nfunction lookup_key_for(x: NistControl, maxDepth: number): string {\n  if (maxDepth) {\n    return x.subSpecifiers.slice(0, maxDepth).join('-');\n  } else {\n    return x.subSpecifiers.join('-');\n  }\n}\n\n/** Populates a treemap using the given lookup table */\nfunction populate_tree_map(\n  lookup: {[key: string]: TreemapNodeParent},\n  leaves: TreemapNodeLeaf[],\n  maxDepth: number\n) {\n  // Populate it\n  leaves.forEach((leaf) => {\n    const parent = lookup[lookup_key_for(leaf.nist_control, maxDepth)];\n    if (parent) {\n      // We found a node that will accept it (matches its control)\n      // We can do this as because we know we constructed these to only have empty children\n      parent.children.push(leaf);\n      leaf.parent = parent;\n    } else {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `Warning: unable to assign control ${leaf.nist_control.rawText} to valid treemap leaf`\n      );\n    }\n  });\n}\n\n/**\n * Assembles the provided leaves into a nist map.\n * Colorizes nodes as appropriate, and assigns parentage\n */\nfunction build_populated_nist_map(data: TreemapNodeLeaf[]): TreemapNodeParent {\n  // Build our scaffold\n  const lookup: {[key: string]: TreemapNodeParent} = {};\n  const rootChildren: TreemapNodeParent[] = [];\n  const root: TreemapNodeParent = {\n    key: 'tree_root',\n    title: 'NIST-853 Controls',\n    children: rootChildren,\n    parent: null,\n    nist_control: new NistControl([], 'NIST-853')\n  };\n\n  // Fill out children, recursively\n  FULL_NIST_HIERARCHY.forEach((n) => {\n    const child = recursive_nist_map(root, n, lookup, depthMax);\n    rootChildren.push(child);\n  });\n\n  // Populate them with leaves\n  populate_tree_map(lookup, data, depthMax);\n\n  // Colorize it\n  colorize_tree_map(root);\n\n  // Done\n  return root;\n}\n\n/**\n * Generates a tree map from the given nist hash, using the size of each category to inversely scale it with controls.\n * Thus each category has a fixed weight!\n * Categories/Families are further sorted by name, and the\n *\n * @param data The nist hash to turn into a tree map\n */\nfunction node_data_to_tree_map(\n  data: Readonly<TreemapNodeParent>\n): D3TreemapNode {\n  return d3\n    .hierarchy<TreemapNode>(data, (d: TreemapNode) => {\n      if (is_parent(d)) {\n        return d.children;\n      }\n      return null;\n    })\n    .sort((a, b) => a.data.title.localeCompare(b.data.title))\n    .sum((root) => {\n      if (is_parent(root)) {\n        if (root.children.length === 0) {\n          return 1;\n        }\n      } else if (root.parent !== null) {\n        return 1.0 / root.parent!.children.length;\n      }\n      return 0;\n    });\n}\n\n/** Does all the steps */\nexport function build_nist_tree_map(\n  data: Readonly<ContextualizedControl[]>,\n  colors: ColorHack\n): D3TreemapNode {\n  const leaves = controls_to_nist_node_data(data, colors);\n  const b = build_populated_nist_map(leaves);\n  return node_data_to_tree_map(b);\n}\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/components/cards/controltable/ControlRowDetails.vue": "<template>\n  <v-row no-gutters dense class=\"pb-1\">\n    <v-col cols=\"12\" class=\"font-weight-bold\">\n      <v-card>\n        <v-tabs v-model=\"localTab\" fixed-tabs show-arrows @change=\"tab_change\">\n          <!-- Declare our tabs -->\n          <v-tab href=\"#tab-test\"> Test </v-tab>\n          <v-tab href=\"#tab-details\"> Details </v-tab>\n          <v-tab href=\"#tab-code\"> Code </v-tab>\n\n          <v-tab-item value=\"tab-test\">\n            <div class=\"pa-4\">\n              <div v-if=\"caveat\">\n                Caveat: {{ caveat }}\n                <v-divider />\n                <br />\n              </div>\n              <!-- eslint-disable-next-line vue/no-v-html -->\n              <div v-html=\"sanitize_html(main_desc)\" />\n            </div>\n            <ControlRowCol\n              v-for=\"(result, index) in control.root.hdf.segments\"\n              :key=\"'col' + index\"\n              :class=\"zebra(index)\"\n              :result=\"result\"\n              :status-code=\"result.status\"\n            />\n          </v-tab-item>\n\n          <v-tab-item value=\"tab-details\">\n            <v-container fluid>\n              <!-- Create a row for each detail -->\n              <template v-for=\"(detail, index) in details\">\n                <v-row :key=\"'tab' + index\" :class=\"zebra(index)\">\n                  <v-col cols=\"12\" :class=\"detail.class\">\n                    <h3>{{ detail.name }}:</h3>\n                    <!-- eslint-disable vue/no-v-html -->\n                    <h4 class=\"mono\" v-html=\"sanitize_html(detail.value)\" />\n                    <!-- eslint-enable vue/no-v-html -->\n                  </v-col>\n                  <v-divider />\n                </v-row>\n              </template>\n            </v-container>\n          </v-tab-item>\n\n          <v-tab-item value=\"tab-code\">\n            <v-container fluid>\n              <v-row>\n                <v-col cols=\"12\">\n                  <prism language=\"ruby\">{{ control.full_code }}</prism>\n                </v-col>\n              </v-row>\n            </v-container>\n          </v-tab-item>\n        </v-tabs>\n      </v-card>\n    </v-col>\n  </v-row>\n</template>\n\n<script lang=\"ts\">\nimport ControlRowCol from '@/components/cards/controltable/ControlRowCol.vue';\nimport HtmlSanitizeMixin from '@/mixins/HtmlSanitizeMixin';\nimport {ContextualizedControl} from 'inspecjs';\nimport _ from 'lodash';\n//TODO: add line numbers\nimport 'prismjs';\nimport 'prismjs/components/prism-makefile.js';\nimport 'prismjs/components/prism-ruby.js';\nimport 'prismjs/themes/prism-tomorrow.css';\nimport Component, {mixins} from 'vue-class-component';\n//@ts-ignore\nimport Prism from 'vue-prism-component';\nimport {Prop, Watch} from 'vue-property-decorator';\n\ninterface Detail {\n  name: string;\n  value: string;\n  class?: string;\n}\n\n@Component({\n  components: {\n    ControlRowCol,\n    Prism\n  }\n})\nexport default class ControlRowDetails extends mixins(HtmlSanitizeMixin) {\n  @Prop({type: String, default: 'tab-test'}) readonly tab!: string;\n  @Prop({type: Object, required: true})\n  readonly control!: ContextualizedControl;\n\n  localTab = this.tab;\n\n  @Watch('tab')\n  onTabChanged(newTab?: string, _oldVal?: string) {\n    if (newTab) {\n      this.localTab = newTab;\n    }\n  }\n\n  get cciControlString(): string | null {\n    const cci = this.control.hdf.wraps.tags.cci;\n    if (!cci) {\n      return null;\n    } else if (Array.isArray(cci)) {\n      return cci.join(', ');\n    } else {\n      return cci;\n    }\n  }\n\n  get main_desc(): string {\n    if (this.control.data.desc) {\n      return this.control.data.desc.trim();\n    } else {\n      return 'No description';\n    }\n  }\n\n  tab_change(tab: string) {\n    this.$emit('update:tab', tab);\n  }\n\n  /** Shown above the description */\n  get header(): string {\n    const msgSplit = this.control.root.hdf.finding_details.split(':');\n    if (msgSplit.length === 1) {\n      return msgSplit[0] + '.';\n    } else {\n      return msgSplit[0] + ':';\n    }\n  }\n\n  get caveat(): string | undefined {\n    return this.control.hdf.descriptions.caveat;\n  }\n\n  get details(): Detail[] {\n    const c = this.control;\n    const detailsMap = new Map();\n\n    detailsMap.set('Control', c.data.id);\n    detailsMap.set('Title', c.data.title);\n    detailsMap.set('Caveat', c.hdf.descriptions.caveat);\n    detailsMap.set('Desc', c.data.desc);\n    detailsMap.set('Rationale', c.hdf.descriptions.rationale);\n    detailsMap.set('Severity', c.root.hdf.severity);\n    detailsMap.set('Impact', c.data.impact);\n    detailsMap.set('Nist controls', c.hdf.rawNistTags.join(', '));\n    detailsMap.set('CCI controls', this.cciControlString);\n    detailsMap.set('Check', c.hdf.descriptions.check || c.data.tags.check);\n    detailsMap.set('Fix', c.hdf.descriptions.fix || c.data.tags.fix);\n    detailsMap.set('CWE ID', _.get(c, 'hdf.wraps.tags.cweid'));\n\n    for (const prop in c.hdf.descriptions) {\n      if (!detailsMap.has(_.capitalize(prop))) {\n        detailsMap.set(_.capitalize(prop), c.hdf.descriptions[prop]);\n      }\n    }\n    return Array.from(detailsMap, ([name, value]) => ({name, value})).filter(\n      (v) => v.value\n    );\n  }\n\n  //for zebra background\n  zebra(ix: number): string {\n    if (ix % 2 === 0) {\n      return 'zebra-table';\n    }\n    return 'non-zebra-table';\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n@import '@/sass/control-row-format.scss';\n\n.clickable {\n  cursor: pointer;\n}\n\n.v-application {\n  code.language-ruby {\n    border: none;\n    box-shadow: none;\n  }\n}\n\npre {\n  white-space: pre-wrap; /* Since CSS 2.1 */\n  white-space: -moz-pre-wrap; /* Mozilla, since 1999 */\n  white-space: -pre-wrap; /* Opera 4-6 */\n  white-space: -o-pre-wrap; /* Opera 7 */\n  word-wrap: break-word; /* Internet Explorer 5.5+ */\n}\n.theme--dark .zebra-table {\n  background-color: var(--v-secondary-lighten2);\n  max-width: 99.9%;\n  margin: auto;\n}\n\n.theme--dark .non-zebra-table {\n  max-width: 99.9%;\n  margin: auto;\n}\n\n.code-card {\n  height: inherit;\n  margin: inherit;\n  white-space: auto;\n}\n.wset {\n  min-width: 125px;\n  justify-content: center;\n}\n\n.right {\n  margin-left: -1px;\n}\n</style>\n\n",
  "/api/sources/raw?key=test:apps/backend/src/evaluations/evaluations.service.spec.ts": "import {NotFoundException} from '@nestjs/common';\nimport {SequelizeModule} from '@nestjs/sequelize';\nimport {Test} from '@nestjs/testing';\nimport {\n  CREATE_EVALUATION_DTO_WITHOUT_FILENAME,\n  CREATE_EVALUATION_DTO_WITHOUT_TAGS,\n  EVALUATION_WITH_TAGS_1,\n  UPDATE_EVALUATION,\n  UPDATE_EVALUATION_DATA_ONLY,\n  UPDATE_EVALUATION_FILENAME_ONLY\n} from '../../test/constants/evaluations-test.constant';\nimport {GROUP_1} from '../../test/constants/groups-test.constant';\nimport {CREATE_USER_DTO_TEST_OBJ} from '../../test/constants/users-test.constant';\nimport {DatabaseModule} from '../database/database.module';\nimport {DatabaseService} from '../database/database.service';\nimport {EvaluationTagsModule} from '../evaluation-tags/evaluation-tags.module';\nimport {EvaluationTagsService} from '../evaluation-tags/evaluation-tags.service';\nimport {GroupEvaluation} from '../group-evaluations/group-evaluation.model';\nimport {GroupUser} from '../group-users/group-user.model';\nimport {Group} from '../groups/group.model';\nimport {GroupsService} from '../groups/groups.service';\nimport {UserDto} from '../users/dto/user.dto';\nimport {UsersModule} from '../users/users.module';\nimport {UsersService} from '../users/users.service';\nimport {EvaluationDto} from './dto/evaluation.dto';\nimport {Evaluation} from './evaluation.model';\nimport {EvaluationsService} from './evaluations.service';\n\ndescribe('EvaluationsService', () => {\n  let evaluationsService: EvaluationsService;\n  let evaluationTagsService: EvaluationTagsService;\n  let databaseService: DatabaseService;\n  let usersService: UsersService;\n  let user: UserDto;\n  let groupsService: GroupsService;\n\n  beforeAll(async () => {\n    const module = await Test.createTestingModule({\n      imports: [\n        DatabaseModule,\n        SequelizeModule.forFeature([\n          Evaluation,\n          GroupUser,\n          Group,\n          GroupEvaluation\n        ]),\n        EvaluationTagsModule,\n        UsersModule\n      ],\n      providers: [\n        EvaluationsService,\n        DatabaseService,\n        UsersService,\n        GroupsService\n      ]\n    }).compile();\n\n    evaluationsService = module.get<EvaluationsService>(EvaluationsService);\n    evaluationTagsService = module.get<EvaluationTagsService>(\n      EvaluationTagsService\n    );\n    databaseService = module.get<DatabaseService>(DatabaseService);\n    usersService = module.get<UsersService>(UsersService);\n    groupsService = module.get<GroupsService>(GroupsService);\n  });\n\n  beforeEach(async () => {\n    await databaseService.cleanAll();\n    user = new UserDto(await usersService.create(CREATE_USER_DTO_TEST_OBJ));\n  });\n\n  describe('findAll', () => {\n    it('should find all evaluations', async () => {\n      let evaluationsDtoArray = await evaluationsService.findAll();\n      expect(evaluationsDtoArray).toEqual([]);\n\n      await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n      await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n      evaluationsDtoArray = await evaluationsService.findAll();\n      expect(evaluationsDtoArray.length).toEqual(2);\n    });\n\n    it('should include the evaluation user', async () => {\n      await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n\n      const evaluations = await evaluationsService.findAll();\n      expect(new UserDto(evaluations[0].user)).toEqual(user);\n    });\n\n    it('should include the evaluation group and group users', async () => {\n      const group = await groupsService.create(GROUP_1);\n      const owner = await usersService.findById(user.id);\n      const evaluation = await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n\n      let evaluations = await evaluationsService.findAll();\n      expect(evaluations[0].groups[0]).not.toBeDefined();\n\n      await groupsService.addEvaluationToGroup(group, evaluation);\n      await groupsService.addUserToGroup(group, owner, 'owner');\n\n      evaluations = await evaluationsService.findAll();\n      const foundGroup = evaluations[0].groups[0];\n      expect(foundGroup).toBeDefined();\n      expect(foundGroup.id).toEqual(group.id);\n      expect(foundGroup.users.length).toEqual(1);\n      expect(foundGroup.users[0].id).toEqual(owner.id);\n      expect(foundGroup.users[0].GroupUser.role).toEqual('owner');\n    });\n  });\n\n  describe('findById', () => {\n    it('should find evaluations by id', async () => {\n      expect.assertions(1);\n      const evaluation = await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n      const foundEvaluation = await evaluationsService.findById(evaluation.id);\n      expect(new EvaluationDto(evaluation)).toEqual(\n        new EvaluationDto(foundEvaluation)\n      );\n    });\n\n    it('should throw an error if an evaluation does not exist', async () => {\n      expect.assertions(1);\n      await expect(evaluationsService.findById('-1')).rejects.toThrow(\n        NotFoundException\n      );\n    });\n  });\n\n  describe('create', () => {\n    it('should create a new evaluation with evaluation tags', async () => {\n      const evaluation = await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n      expect(evaluation.id).toBeDefined();\n      expect(evaluation.updatedAt).toBeDefined();\n      expect(evaluation.createdAt).toBeDefined();\n      expect(evaluation.data).toEqual({});\n      expect(evaluation.filename).toEqual(EVALUATION_WITH_TAGS_1.filename);\n      expect(evaluation.evaluationTags[0].evaluationId).toBeDefined();\n      expect(evaluation.evaluationTags[0].updatedAt).toBeDefined();\n      expect(evaluation.evaluationTags[0].createdAt).toBeDefined();\n\n      if (EVALUATION_WITH_TAGS_1.evaluationTags === undefined) {\n        throw new TypeError(\n          'Evaluation fixture does not have any associated tags.'\n        );\n      }\n\n      expect(evaluation.evaluationTags?.[0].value).toEqual(\n        EVALUATION_WITH_TAGS_1.evaluationTags[0].value\n      );\n    });\n\n    it('should create a new evaluation without evaluation tags', async () => {\n      const evaluation = await evaluationsService.create({\n        ...CREATE_EVALUATION_DTO_WITHOUT_TAGS,\n        data: {},\n        userId: user.id\n      });\n      expect(evaluation.id).toBeDefined();\n      expect(evaluation.updatedAt).toBeDefined();\n      expect(evaluation.createdAt).toBeDefined();\n      expect(evaluation.data).toEqual({});\n      expect(evaluation.filename).toEqual(\n        CREATE_EVALUATION_DTO_WITHOUT_TAGS.filename\n      );\n      expect(evaluation.evaluationTags).not.toBeDefined();\n      expect((await evaluationTagsService.findAll()).length).toBe(0);\n    });\n\n    it('should throw an error when missing the filename field', async () => {\n      expect.assertions(1);\n      await expect(\n        evaluationsService.create({\n          ...CREATE_EVALUATION_DTO_WITHOUT_FILENAME,\n          data: {},\n          userId: user.id\n        })\n      ).rejects.toThrow(\n        'notNull Violation: Evaluation.filename cannot be null'\n      );\n    });\n  });\n\n  describe('update', () => {\n    it('should throw an error if an evaluation does not exist', async () => {\n      expect.assertions(1);\n      await expect(\n        evaluationsService.update('-1', UPDATE_EVALUATION)\n      ).rejects.toThrow(NotFoundException);\n    });\n\n    it('should update all fields of an evaluation', async () => {\n      const evaluation = await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n      const updatedEvaluation = await evaluationsService.update(\n        evaluation.id,\n        UPDATE_EVALUATION\n      );\n      expect(updatedEvaluation.id).toEqual(evaluation.id);\n      expect(updatedEvaluation.createdAt).toEqual(evaluation.createdAt);\n      expect(updatedEvaluation.updatedAt).not.toEqual(evaluation.updatedAt);\n      expect(updatedEvaluation.data).not.toEqual(evaluation.data);\n      expect(updatedEvaluation.filename).not.toEqual(evaluation.filename);\n    });\n\n    it('should only update data if provided', async () => {\n      const evaluation = await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n      const updatedEvaluation = await evaluationsService.update(\n        evaluation.id,\n        UPDATE_EVALUATION_DATA_ONLY\n      );\n      expect(updatedEvaluation.id).toEqual(evaluation.id);\n      expect(updatedEvaluation.createdAt).toEqual(evaluation.createdAt);\n      expect(updatedEvaluation.updatedAt).not.toEqual(evaluation.updatedAt);\n      expect(updatedEvaluation.evaluationTags.length).toEqual(\n        evaluation.evaluationTags.length\n      );\n      expect(updatedEvaluation.data).not.toEqual(evaluation.data);\n      expect(updatedEvaluation.filename).toEqual(evaluation.filename);\n    });\n\n    it('should only update filename if provided', async () => {\n      const evaluation = await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n\n      const updatedEvaluation = await evaluationsService.update(\n        evaluation.id,\n        UPDATE_EVALUATION_FILENAME_ONLY\n      );\n      expect(updatedEvaluation.id).toEqual(evaluation.id);\n      expect(updatedEvaluation.createdAt).toEqual(evaluation.createdAt);\n      expect(updatedEvaluation.updatedAt).not.toEqual(evaluation.updatedAt);\n      expect(updatedEvaluation.evaluationTags.length).toEqual(\n        evaluation.evaluationTags.length\n      );\n      expect(updatedEvaluation.data).toEqual(evaluation.data);\n      expect(updatedEvaluation.filename).not.toEqual(evaluation.filename);\n    });\n  });\n\n  describe('remove', () => {\n    it('should remove an evaluation and its evaluation tags given an id', async () => {\n      const evaluation = await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n      const removedEvaluation = await evaluationsService.remove(evaluation.id);\n      const foundEvaluationTags = await evaluationTagsService.findAll();\n      expect(foundEvaluationTags.length).toEqual(0);\n      expect(new EvaluationDto(removedEvaluation)).toEqual(\n        new EvaluationDto(evaluation)\n      );\n\n      await expect(\n        evaluationsService.findById(removedEvaluation.id)\n      ).rejects.toThrow(NotFoundException);\n    });\n\n    it('should throw an error when the evaluation does not exist', async () => {\n      expect.assertions(1);\n      await expect(evaluationsService.findById('-1')).rejects.toThrow(\n        NotFoundException\n      );\n    });\n  });\n\n  afterAll(async () => {\n    await databaseService.cleanAll();\n    await databaseService.closeConnection();\n  });\n});\n\n",
  "/api/sources/raw?key=test:apps/backend/src/config/config.service.spec.ts": "import * as dotenv from 'dotenv';\nimport mock from 'mock-fs';\nimport {\n  DATABASE_URL_MOCK_ENV,\n  ENV_MOCK_FILE,\n  SIMPLE_ENV_MOCK_FILE\n} from '../../test/constants/env-test.constant';\nimport {ConfigService} from './config.service';\n\n/* If you run the test without --silent , you need to add console.log() before you mock out the\nfile system in the beforeAll() or it'll throw an error (this is a documented bug which can be\nfound at https://github.com/tschaub/mock-fs/issues/234).\nIf you run the test with --silent (which we do by default), you don't need the log statement. */\ndescribe('Config Service', () => {\n  beforeAll(async () => {\n    // eslint-disable-next-line no-console\n    console.log();\n    // Used as an empty file system\n    mock({\n      // No files created (.env file does not exist yet)\n    });\n  });\n\n  describe('Tests the get function when .env file does not exist', () => {\n    it('should return undefined because env variable does not exist', () => {\n      const configService = new ConfigService();\n      expect(configService.get('DATABASE_NAME')).toBe(undefined);\n    });\n\n    it('should print to the console about how it was unable to read .env file', () => {\n      const consoleSpy = jest.spyOn(console, 'log');\n      // Used to make sure logs are outputted\n      new ConfigService();\n      expect(consoleSpy).toHaveBeenCalledWith(\n        'Unable to read configuration file `.env`!'\n      );\n      expect(consoleSpy).toHaveBeenCalledWith(\n        'Falling back to environment or undefined values!'\n      );\n    });\n  });\n\n  describe('Tests the get function when .env file does exist', () => {\n    beforeAll(() => {\n      // Mock .env file\n      mock({\n        '.env': ENV_MOCK_FILE\n      });\n    });\n\n    it('should return the correct database name', () => {\n      const configService = new ConfigService();\n      expect(configService.get('PORT')).toEqual('8000');\n      expect(configService.get('DATABASE_HOST')).toEqual('localhost');\n      expect(configService.get('DATABASE_PORT')).toEqual('5432');\n      expect(configService.get('DATABASE_USERNAME')).toEqual('postgres');\n      expect(configService.get('DATABASE_PASSWORD')).toEqual('postgres');\n      expect(configService.get('DATABASE_NAME')).toEqual(\n        'heimdallts_jest_testing_service_db'\n      );\n      expect(configService.get('JWT_SECRET')).toEqual('abc123');\n      expect(configService.get('NODE_ENV')).toEqual('test');\n    });\n\n    it('should return undefined because env variable does not exist', () => {\n      const configService = new ConfigService();\n      expect(configService.get('INVALID_VARIABLE')).toBe(undefined);\n    });\n  });\n\n  describe('Tests the get function when environment file is sourced externally', () => {\n    beforeAll(() => {\n      // Mock .env file\n      mock({\n        '.env-loaded-externally': SIMPLE_ENV_MOCK_FILE\n      });\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      dotenv.config({path: '.env-loaded-externally'});\n    });\n\n    it('should return the correct database port', () => {\n      const configService = new ConfigService();\n      expect(configService.get('PORT')).toEqual('8001');\n    });\n\n    it('should return undefined because env variable does not exist', () => {\n      const configService = new ConfigService();\n      expect(configService.get('INVALID_VARIABLE')).toBe(undefined);\n    });\n  });\n\n  describe('When using DATABASE_URL', () => {\n    beforeAll(() => {\n      mock({\n        '.env': DATABASE_URL_MOCK_ENV\n      });\n    });\n\n    it('should correctly parse DATABASE_URL into its components', () => {\n      const configService = new ConfigService();\n      expect(configService.get('DATABASE_HOST')).toEqual(\n        'ec2-00-000-11-123.compute-1.amazonaws.com'\n      );\n      expect(configService.get('DATABASE_PORT')).toEqual('5432');\n      expect(configService.get('DATABASE_USERNAME')).toEqual(\n        'abcdefghijk123456'\n      );\n      expect(configService.get('DATABASE_PASSWORD')).toEqual(\n        '000011112222333344455556666777778889999aaaabbbbccccddddeeeffff'\n      );\n      expect(configService.get('DATABASE_NAME')).toEqual('database01');\n    });\n  });\n\n  describe('Tests for thrown errors', () => {\n    it('should throw an EACCES error', () => {\n      expect.assertions(1);\n      mock({\n        '.env': mock.file({\n          content: 'DATABASE_NAME=heimdallts_jest_testing_service_db',\n          mode: 0o000 // Set file system permissions to none\n        })\n      });\n      expect(() => new ConfigService()).toThrowError(\n        \"EACCES: permission denied, open '.env'\"\n      );\n    });\n\n    it('should throw an error in the get function', () => {\n      mock({\n        '.env': ENV_MOCK_FILE\n      });\n      const configService = new ConfigService();\n      jest.spyOn(configService, 'get').mockImplementationOnce(() => {\n        throw new Error('');\n      });\n      expect(() => configService.get('DATABASE_NAME')).toThrowError();\n    });\n  });\n\n  describe('Set', () => {\n    it('should set a key value', () => {\n      const configService = new ConfigService();\n      configService.set('test', 'value');\n      expect(configService.get('test')).toBe('value');\n    });\n  });\n\n  afterAll(() => {\n    // Restore the fs binding to the real file system\n    mock.restore();\n  });\n});\n\n",
  "/api/sources/raw?key=test:apps/backend/src/pipes/password-complexity.pipe.spec.ts": "import {ArgumentMetadata, BadRequestException} from '@nestjs/common';\nimport {\n  CREATE_USER_DTO_TEST_OBJ,\n  CREATE_USER_DTO_TEST_OBJ_WITH_MISSING_PASSWORD_FIELD,\n  UPDATE_USER_DTO_TEST_OBJ,\n  UPDATE_USER_DTO_TEST_WITHOUT_PASSWORD,\n  UPDATE_USER_DTO_WITHOUT_PASSWORD_FIELDS\n} from '../../test/constants/users-test.constant';\nimport {PasswordComplexityPipe} from './password-complexity.pipe';\n\ndescribe('PasswordComplexityPipe', () => {\n  let passwordComplexityPipe: PasswordComplexityPipe;\n  let metaData: ArgumentMetadata;\n\n  beforeEach(() => {\n    passwordComplexityPipe = new PasswordComplexityPipe();\n  });\n\n  it('should make sure that the passwords-complexity pipe is defined', () => {\n    expect(passwordComplexityPipe).toBeDefined();\n  });\n\n  describe('Helper Function Tests', () => {\n    describe('hasClasses', () => {\n      it('should fail because the password length is less than 15 characters and it has all character classes', () => {\n        expect(passwordComplexityPipe.hasClasses('$7aB')).toBeFalsy();\n      });\n\n      it('should fail because the password does not contain a special character', () => {\n        expect(\n          passwordComplexityPipe.hasClasses('Testpasswordwithoutspecialchar7')\n        ).toBeFalsy();\n      });\n\n      it('should fail because the password does not contain a number', () => {\n        expect(\n          passwordComplexityPipe.hasClasses('Testpasswordwithoutnumber$')\n        ).toBeFalsy();\n      });\n\n      it('should fail because the password does not contain an uppercase letter', () => {\n        expect(\n          passwordComplexityPipe.hasClasses('testpasswordwithoutuppercase7$')\n        ).toBeFalsy();\n      });\n\n      it('should fail because the password does not contain a lowercase letter', () => {\n        expect(\n          passwordComplexityPipe.hasClasses('TESTPASSWORDWITHOUTLOWERCASE7$')\n        ).toBeFalsy();\n      });\n\n      it('should pass because the password has all character classes and is at least 15 characters', () => {\n        expect(\n          passwordComplexityPipe.hasClasses('Atestpassword7$')\n        ).toBeTruthy();\n      });\n    });\n\n    describe('noRepeats', () => {\n      it('should fail because there is more than 3 consecutive repeating lowercase characters in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('aaaa')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 lowercase characters back-to-back in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('test')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 consecutive repeating uppercase characters in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('AAAA')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 uppercase characters back-to-back in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('TEST')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 consecutive repeating numbers in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('7777')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 numbers back-to-back in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('1078')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 consecutive repeating numbers in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('$$$$')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 special characters back-to-back in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('!@#$')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 consecutive white spaces in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('spa    ce')).toBeFalsy();\n      });\n\n      it('should pass because the password meets all the minimum requirements', () => {\n        expect(passwordComplexityPipe.noRepeats('aaaBBB111$$$')).toBeTruthy();\n      });\n    });\n  });\n\n  /* Tests the complexity of a user's password and that when it meets the requirements of:\n    15 characters or longer, at least 1 uppercase letter, lowercase letter, number, special character,\n    the password meets the requirements of not containing more than three consecutive repeating\n    characters, and it contains no more than four repeating characters from the same character class,\n    the same dto object will be returned*/\n  describe('Test Valid Password', () => {\n    it('should return the same CreateUserDto', () => {\n      expect(\n        passwordComplexityPipe.transform(CREATE_USER_DTO_TEST_OBJ, metaData)\n      ).toEqual(CREATE_USER_DTO_TEST_OBJ);\n    });\n\n    it('should return the same UpdateUserDto', () => {\n      expect(\n        passwordComplexityPipe.transform(UPDATE_USER_DTO_TEST_OBJ, metaData)\n      ).toEqual(UPDATE_USER_DTO_TEST_OBJ);\n    });\n\n    it('should return UpdateUserDto if password fields are null', () => {\n      expect(\n        passwordComplexityPipe.transform(\n          UPDATE_USER_DTO_WITHOUT_PASSWORD_FIELDS,\n          metaData\n        )\n      ).toEqual(UPDATE_USER_DTO_WITHOUT_PASSWORD_FIELDS);\n    });\n  });\n\n  /* Tests that when a password does not meet all the minimum requirements,\n    a BadRequestException is thrown */\n  describe('Test Invalid Password', () => {\n    it('should throw a BadRequestException for CreateUserDto', () => {\n      expect(() =>\n        passwordComplexityPipe.transform(\n          CREATE_USER_DTO_TEST_OBJ_WITH_MISSING_PASSWORD_FIELD,\n          metaData\n        )\n      ).toThrowError(BadRequestException);\n      expect(() =>\n        passwordComplexityPipe.transform(\n          CREATE_USER_DTO_TEST_OBJ_WITH_MISSING_PASSWORD_FIELD,\n          metaData\n        )\n      ).toThrowError(\n        'Password does not meet complexity requirements. Passwords are a minimum of 15' +\n          ' characters in length. Passwords must contain at least one special character, number, upper-case letter, and' +\n          ' lower-case letter. Passwords cannot contain more than three consecutive repeating characters.' +\n          ' Passwords cannot contain more than four repeating characters from the same character class.'\n      );\n    });\n\n    it('should throw a BadRequestException for UpdateUserDto', () => {\n      expect(() =>\n        passwordComplexityPipe.transform(\n          UPDATE_USER_DTO_TEST_WITHOUT_PASSWORD,\n          metaData\n        )\n      ).toThrowError(BadRequestException);\n      expect(() =>\n        passwordComplexityPipe.transform(\n          UPDATE_USER_DTO_TEST_WITHOUT_PASSWORD,\n          metaData\n        )\n      ).toThrowError(\n        'Password does not meet complexity requirements. Passwords are a minimum of 15' +\n          ' characters in length. Passwords must contain at least one special character, number, upper-case letter, and' +\n          ' lower-case letter. Passwords cannot contain more than three consecutive repeating characters.' +\n          ' Passwords cannot contain more than four repeating characters from the same character class.'\n      );\n    });\n  });\n});\n\n",
  "/api/sources/raw?key=test:apps/backend/src/pipes/passwords-match.pipe.spec.ts": "import {ArgumentMetadata, BadRequestException} from '@nestjs/common';\nimport {\n  CREATE_USER_DTO_TEST_OBJ,\n  CREATE_USER_DTO_TEST_OBJ_WITH_UNMATCHING_PASSWORDS,\n  UPDATE_USER_DTO_TEST_OBJ,\n  UPDATE_USER_DTO_WITHOUT_PASSWORD_FIELDS\n} from '../../test/constants/users-test.constant';\nimport {PasswordsMatchPipe} from './passwords-match.pipe';\n\ndescribe('PasswordsMatchPipe', () => {\n  let passwordsMatchPipe: PasswordsMatchPipe;\n  let metaData: ArgumentMetadata;\n\n  beforeEach(() => {\n    passwordsMatchPipe = new PasswordsMatchPipe();\n  });\n\n  it('should make sure that the passwords-match pipe is defined', () => {\n    expect(passwordsMatchPipe).toBeDefined();\n  });\n\n  /* Tests that when password and passwordConfirmation match,\n   the same CreateUserDto obj that is passed to the pipeline, is returned */\n  describe('Test Matching Passwords', () => {\n    it('should return the same CreateUserDto', () => {\n      expect(\n        passwordsMatchPipe.transform(CREATE_USER_DTO_TEST_OBJ, metaData)\n      ).toEqual(CREATE_USER_DTO_TEST_OBJ);\n    });\n\n    it('should return the same UpdateUserDto', () => {\n      expect(\n        passwordsMatchPipe.transform(UPDATE_USER_DTO_TEST_OBJ, metaData)\n      ).toEqual(UPDATE_USER_DTO_TEST_OBJ);\n    });\n\n    it('should return UpdateUserDto if password fields are null', () => {\n      expect(\n        passwordsMatchPipe.transform(\n          UPDATE_USER_DTO_WITHOUT_PASSWORD_FIELDS,\n          metaData\n        )\n      ).toEqual(UPDATE_USER_DTO_WITHOUT_PASSWORD_FIELDS);\n    });\n  });\n\n  /* Tests that when password and passwordConfirmation don't match,\n    a BadRequestException is thrown */\n  describe('Test Mismatching Passwords', () => {\n    it('should throw a Bad Request Exception', () => {\n      expect(() =>\n        passwordsMatchPipe.transform(\n          CREATE_USER_DTO_TEST_OBJ_WITH_UNMATCHING_PASSWORDS,\n          metaData\n        )\n      ).toThrowError(BadRequestException);\n      expect(() =>\n        passwordsMatchPipe.transform(\n          CREATE_USER_DTO_TEST_OBJ_WITH_UNMATCHING_PASSWORDS,\n          metaData\n        )\n      ).toThrowError('Passwords do not match');\n    });\n  });\n});\n\n",
  "/api/rules/show?key=typescript:S3776": {
    "rule": {
      "key": "typescript:S3776",
      "repo": "typescript",
      "name": "Cognitive Complexity of functions should not be too high",
      "createdAt": "2021-08-13T16:14:42+0000",
      "htmlDesc": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>",
      "mdDesc": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>",
      "severity": "CRITICAL",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "brain-overload"
      ],
      "lang": "ts",
      "langName": "TypeScript",
      "params": [
        {
          "key": "threshold",
          "htmlDesc": "The maximum authorized complexity.",
          "defaultValue": 15,
          "type": "INTEGER"
        }
      ],
      "defaultDebtRemFnType": "LINEAR_OFFSET",
      "defaultDebtRemFnCoeff": "1min",
      "defaultDebtRemFnOffset": "5min",
      "effortToFixDescription": "per complexity point over the threshold",
      "debtOverloaded": false,
      "debtRemFnType": "LINEAR_OFFSET",
      "debtRemFnCoeff": "1min",
      "debtRemFnOffset": "5min",
      "type": "CODE_SMELL",
      "defaultRemFnType": "LINEAR_OFFSET",
      "defaultRemFnGapMultiplier": "1min",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "LINEAR_OFFSET",
      "remFnGapMultiplier": "1min",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "gapDescription": "per complexity point over the threshold",
      "scope": "MAIN",
      "isExternal": false
    },
    "actives": []
  },
  "/api/rules/show?key=typescript:S3317": {
    "rule": {
      "key": "typescript:S3317",
      "repo": "typescript",
      "name": "Default export names and file names should match",
      "createdAt": "2021-08-13T16:14:42+0000",
      "htmlDesc": "<p>By convention, a file that exports only one class, function, or constant should be named for that class, function or constant. Anything else may\nconfuse maintainers.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n// file path: myclass.js  -- Noncompliant\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n// file path: MyClass.js\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Exceptions</h2>\n<p>Case, underscores ( <code>_</code> ) and dashes (<code>-</code>) are ignored from the name comparison.</p>",
      "mdDesc": "<p>By convention, a file that exports only one class, function, or constant should be named for that class, function or constant. Anything else may\nconfuse maintainers.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n// file path: myclass.js  -- Noncompliant\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n// file path: MyClass.js\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Exceptions</h2>\n<p>Case, underscores ( <code>_</code> ) and dashes (<code>-</code>) are ignored from the name comparison.</p>",
      "severity": "MINOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "confusing",
        "convention",
        "es2015"
      ],
      "lang": "ts",
      "langName": "TypeScript",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "CODE_SMELL",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    "actives": []
  },
  "/api/rules/show?key=typescript:S1117": {
    "rule": {
      "key": "typescript:S1117",
      "repo": "typescript",
      "name": "Variables should not be shadowed",
      "createdAt": "2021-08-13T16:14:42+0000",
      "htmlDesc": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>",
      "mdDesc": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "pitfall",
        "suspicious"
      ],
      "lang": "ts",
      "langName": "TypeScript",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "CODE_SMELL",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    "actives": []
  },
  "/api/rules/show?key=typescript:S3358": {
    "rule": {
      "key": "typescript:S3358",
      "repo": "typescript",
      "name": "Ternary operators should not be nested",
      "createdAt": "2021-08-13T16:14:42+0000",
      "htmlDesc": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>",
      "mdDesc": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "confusing"
      ],
      "lang": "ts",
      "langName": "TypeScript",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "CODE_SMELL",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    "actives": []
  },
  "/api/rules/show?key=typescript:S4325": {
    "rule": {
      "key": "typescript:S4325",
      "repo": "typescript",
      "name": "Redundant casts and non-null assertions should be avoided",
      "createdAt": "2021-08-13T16:14:42+0000",
      "htmlDesc": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>",
      "mdDesc": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>",
      "severity": "MINOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "redundant"
      ],
      "lang": "ts",
      "langName": "TypeScript",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "1min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "1min",
      "type": "CODE_SMELL",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "1min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "1min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    "actives": []
  },
  "/api/rules/show?key=typescript:S4138": {
    "rule": {
      "key": "typescript:S4138",
      "repo": "typescript",
      "name": "\"for of\" should be used with Iterables",
      "createdAt": "2021-08-13T16:14:42+0000",
      "htmlDesc": "<p>If you have an iterable, such as an array, set, or list, your best option for looping through its values is the <code>for of</code> syntax. Use a\ncounter, and …​ well you’ll get the right behavior, but your code just isn’t as clean or clear.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nconst arr = [4, 3, 2, 1];\n\nfor (let i = 0; i &lt; arr.length; i++) {  // Noncompliant\n  console.log(arr[i]);\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nconst arr = [4, 3, 2, 1];\n\nfor (let value of arr) {\n  console.log(value);\n}\n</pre>",
      "mdDesc": "<p>If you have an iterable, such as an array, set, or list, your best option for looping through its values is the <code>for of</code> syntax. Use a\ncounter, and …​ well you’ll get the right behavior, but your code just isn’t as clean or clear.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nconst arr = [4, 3, 2, 1];\n\nfor (let i = 0; i &lt; arr.length; i++) {  // Noncompliant\n  console.log(arr[i]);\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nconst arr = [4, 3, 2, 1];\n\nfor (let value of arr) {\n  console.log(value);\n}\n</pre>",
      "severity": "MINOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "clumsy"
      ],
      "lang": "ts",
      "langName": "TypeScript",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "CODE_SMELL",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    "actives": []
  },
  "/api/rules/show?key=typescript:S4144": {
    "rule": {
      "key": "typescript:S4144",
      "repo": "typescript",
      "name": "Functions should not have identical implementations",
      "createdAt": "2021-08-13T16:14:42+0000",
      "htmlDesc": "<p>When two functions have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but\nmay be confusing to maintainers. In the latter case, the code should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {  // Noncompliant\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {\n  return calculateCode();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Functions with fewer than 3 lines are ignored.</p>",
      "mdDesc": "<p>When two functions have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but\nmay be confusing to maintainers. In the latter case, the code should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {  // Noncompliant\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {\n  return calculateCode();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Functions with fewer than 3 lines are ignored.</p>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "confusing",
        "duplicate",
        "suspicious"
      ],
      "lang": "ts",
      "langName": "TypeScript",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "15min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "15min",
      "type": "CODE_SMELL",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "15min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "15min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    "actives": []
  },
  "/api/rules/show?key=typescript:S1135": {
    "rule": {
      "key": "typescript:S1135",
      "repo": "typescript",
      "name": "Track uses of \"TODO\" tags",
      "createdAt": "2021-08-13T16:14:42+0000",
      "htmlDesc": "<p><code>TODO</code> tags are commonly used to mark places where some more code is required, but which the developer wants to implement later.</p>\n<p>Sometimes the developer will not have the time or will simply forget to get back to that tag.</p>\n<p>This rule is meant to track those tags and to ensure that they do not go unnoticed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction doSomething() {\n  // TODO\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/546.html\">MITRE, CWE-546</a> - Suspicious Comment </li>\n</ul>",
      "mdDesc": "<p><code>TODO</code> tags are commonly used to mark places where some more code is required, but which the developer wants to implement later.</p>\n<p>Sometimes the developer will not have the time or will simply forget to get back to that tag.</p>\n<p>This rule is meant to track those tags and to ensure that they do not go unnoticed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction doSomething() {\n  // TODO\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/546.html\">MITRE, CWE-546</a> - Suspicious Comment </li>\n</ul>",
      "severity": "INFO",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "cwe"
      ],
      "lang": "ts",
      "langName": "TypeScript",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "0min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "0min",
      "type": "CODE_SMELL",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "0min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "0min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    "actives": []
  },
  "/api/rules/show?key=typescript:S1848": {
    "rule": {
      "key": "typescript:S1848",
      "repo": "typescript",
      "name": "Objects should not be created to be dropped immediately without being used",
      "createdAt": "2021-08-13T16:14:42+0000",
      "htmlDesc": "<p>There is no good reason to create a new object to not do anything with it. Most of the time, this is due to a missing piece of code and so could\nlead to an unexpected behavior in production.</p>\n<p>If it was done on purpose because the constructor has side-effects, then that side-effect code should be moved into a separate method and called\ndirectly.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nnew MyConstructor(); // Non-Compliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar something = new MyConstructor();  // Compliant\n</pre>\n<h2>Exceptions</h2>\n<p>Immediately dropped new objects inside <code>try</code>-statements are ignored.</p>\n<pre>\ntry {\n  new MyConstructor();\n} catch (e) {\n  /* ... */\n}\n</pre>",
      "mdDesc": "<p>There is no good reason to create a new object to not do anything with it. Most of the time, this is due to a missing piece of code and so could\nlead to an unexpected behavior in production.</p>\n<p>If it was done on purpose because the constructor has side-effects, then that side-effect code should be moved into a separate method and called\ndirectly.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nnew MyConstructor(); // Non-Compliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar something = new MyConstructor();  // Compliant\n</pre>\n<h2>Exceptions</h2>\n<p>Immediately dropped new objects inside <code>try</code>-statements are ignored.</p>\n<pre>\ntry {\n  new MyConstructor();\n} catch (e) {\n  /* ... */\n}\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "ts",
      "langName": "TypeScript",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    "actives": []
  },
  "/api/issues/search?componentKeys=test&types=CODE_SMELL,BUG,VULNERABILITY&p=1": {
    "total": 68,
    "p": 1,
    "ps": 100,
    "paging": {
      "pageIndex": 1,
      "pageSize": 100,
      "total": 68
    },
    "effortTotal": 475,
    "issues": [
      {
        "key": "AXtAUPqUi8r-LMdMzpgJ",
        "rule": "typescript:S3776",
        "severity": "CRITICAL",
        "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
        "project": "test",
        "line": 353,
        "hash": "c8784c25364adaf775f446d53048aaad",
        "textRange": {
          "startLine": 353,
          "endLine": 353,
          "startOffset": 6,
          "endOffset": 11
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 363,
                  "endLine": 363,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 363,
                  "endLine": 363,
                  "startOffset": 36,
                  "endOffset": 38
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 366,
                  "endLine": 366,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 369,
                  "endLine": 369,
                  "startOffset": 11,
                  "endOffset": 13
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 370,
                  "endLine": 370,
                  "startOffset": 38,
                  "endOffset": 40
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 374,
                  "endLine": 374,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 377,
                  "endLine": 377,
                  "startOffset": 11,
                  "endOffset": 13
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 378,
                  "endLine": 378,
                  "startOffset": 40,
                  "endOffset": 42
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 382,
                  "endLine": 382,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 385,
                  "endLine": 385,
                  "startOffset": 11,
                  "endOffset": 13
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 385,
                  "endLine": 385,
                  "startOffset": 44,
                  "endOffset": 46
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 387,
                  "endLine": 387,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 390,
                  "endLine": 390,
                  "startOffset": 11,
                  "endOffset": 13
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 399,
                  "endLine": 399,
                  "startOffset": 6,
                  "endOffset": 10
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 391,
                  "endLine": 391,
                  "startOffset": 39,
                  "endOffset": 41
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 396,
                  "endLine": 396,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 404,
                  "endLine": 404,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                "textRange": {
                  "startLine": 410,
                  "endLine": 410,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Refactor this function to reduce its Cognitive Complexity from 23 to the 15 allowed.",
        "effort": "13min",
        "debt": "13min",
        "author": "rbclark@mitre.org",
        "tags": [
          "brain-overload"
        ],
        "creationDate": "2021-08-05T18:34:07+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "\n  /** Return items sorted and filters out viewed controls */\n  get items(): ListElt[] {\n    // Controls ascending/descending\n    let factor = 1;\n    // Whether or not we need to sort",
        "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
      },
      {
        "key": "AXtAUPhHi8r-LMdMzpf2",
        "rule": "typescript:S3317",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/components/global/upload_tabs/aws/AuthStepBasic.vue",
        "project": "test",
        "flows": [],
        "status": "OPEN",
        "message": "Rename this file to \"S3Reader\"",
        "effort": "5min",
        "debt": "5min",
        "author": "rbclark@mitre.org",
        "tags": [
          "confusing",
          "convention",
          "es2015"
        ],
        "creationDate": "2021-08-05T18:34:07+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "",
        "summary": "<p>By convention, a file that exports only one class, function, or constant should be named for that class, function or constant. Anything else may\nconfuse maintainers.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n// file path: myclass.js  -- Noncompliant\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n// file path: MyClass.js\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Exceptions</h2>\n<p>Case, underscores ( <code>_</code> ) and dashes (<code>-</code>) are ignored from the name comparison.</p>"
      },
      {
        "key": "AXtAUPnEi8r-LMdMzpf3",
        "rule": "typescript:S3317",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/components/global/upload_tabs/aws/AuthStepMFA.vue",
        "project": "test",
        "flows": [],
        "status": "OPEN",
        "message": "Rename this file to \"S3Reader\"",
        "effort": "5min",
        "debt": "5min",
        "author": "rbclark@mitre.org",
        "tags": [
          "confusing",
          "convention",
          "es2015"
        ],
        "creationDate": "2021-08-05T18:34:07+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "",
        "summary": "<p>By convention, a file that exports only one class, function, or constant should be named for that class, function or constant. Anything else may\nconfuse maintainers.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n// file path: myclass.js  -- Noncompliant\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n// file path: MyClass.js\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Exceptions</h2>\n<p>Case, underscores ( <code>_</code> ) and dashes (<code>-</code>) are ignored from the name comparison.</p>"
      },
      {
        "key": "AXtAUPy-i8r-LMdMzphZ",
        "rule": "typescript:S3776",
        "severity": "CRITICAL",
        "component": "test:libs/hdf-converters/src/base-converter.ts",
        "project": "test",
        "line": 195,
        "hash": "e3a2905493498652453fa20fca99f9b9",
        "textRange": {
          "startLine": 195,
          "endLine": 195,
          "startOffset": 2,
          "endOffset": 13
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 199,
                  "endLine": 199,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 202,
                  "endLine": 202,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 215,
                  "endLine": 215,
                  "startOffset": 6,
                  "endOffset": 10
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 211,
                  "endLine": 211,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 220,
                  "endLine": 220,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 245,
                  "endLine": 245,
                  "startOffset": 8,
                  "endOffset": 12
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 222,
                  "endLine": 222,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 238,
                  "endLine": 238,
                  "startOffset": 10,
                  "endOffset": 14
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 231,
                  "endLine": 231,
                  "startOffset": 10,
                  "endOffset": 12
                },
                "msg": "+4 (incl. 3 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 234,
                  "endLine": 234,
                  "startOffset": 10,
                  "endOffset": 12
                },
                "msg": "+4 (incl. 3 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 239,
                  "endLine": 239,
                  "startOffset": 10,
                  "endOffset": 12
                },
                "msg": "+4 (incl. 3 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/hdf-converters/src/base-converter.ts",
                "textRange": {
                  "startLine": 241,
                  "endLine": 241,
                  "startOffset": 12,
                  "endOffset": 16
                },
                "msg": "+1"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Refactor this function to reduce its Cognitive Complexity from 25 to the 15 allowed.",
        "effort": "15min",
        "debt": "15min",
        "author": "rbclark@mitre.org",
        "tags": [
          "brain-overload"
        ],
        "creationDate": "2021-08-05T16:58:31+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "  }\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  handleArray<T extends object>(\n    file: Record<string, unknown>,\n    v: Array<T & ILookupPath>\n  ): Array<T> {",
        "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzph5",
        "rule": "typescript:S3776",
        "severity": "CRITICAL",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 228,
        "hash": "5fd6dcc3adfc524cd3dd083080299a0c",
        "textRange": {
          "startLine": 228,
          "endLine": 228,
          "startOffset": 9,
          "endOffset": 18
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 286,
                  "endLine": 286,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 287,
                  "endLine": 287,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 288,
                  "endLine": 288,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 291,
                  "endLine": 291,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 292,
                  "endLine": 292,
                  "startOffset": 4,
                  "endOffset": 9
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 292,
                  "endLine": 292,
                  "startOffset": 35,
                  "endOffset": 37
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 295,
                  "endLine": 295,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 296,
                  "endLine": 296,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 297,
                  "endLine": 297,
                  "startOffset": 50,
                  "endOffset": 51
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 298,
                  "endLine": 298,
                  "startOffset": 50,
                  "endOffset": 51
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 299,
                  "endLine": 299,
                  "startOffset": 50,
                  "endOffset": 51
                },
                "msg": "+4 (incl. 3 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 303,
                  "endLine": 303,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 303,
                  "endLine": 303,
                  "startOffset": 21,
                  "endOffset": 23
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 230,
                  "endLine": 230,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 237,
                  "endLine": 237,
                  "startOffset": 8,
                  "endOffset": 11
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 241,
                  "endLine": 241,
                  "startOffset": 14,
                  "endOffset": 19
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 247,
                  "endLine": 247,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 253,
                  "endLine": 253,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 258,
                  "endLine": 258,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 262,
                  "endLine": 262,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 269,
                  "endLine": 269,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 269,
                  "endLine": 269,
                  "startOffset": 52,
                  "endOffset": 54
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 275,
                  "endLine": 275,
                  "startOffset": 69,
                  "endOffset": 70
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                "textRange": {
                  "startLine": 279,
                  "endLine": 279,
                  "startOffset": 12,
                  "endOffset": 14
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Refactor this function to reduce its Cognitive Complexity from 44 to the 15 allowed.",
        "effort": "34min",
        "debt": "34min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "brain-overload"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "}\n\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);",
        "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzph9",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 238,
        "hash": "c18b29c89a7108ee069bbe31d8a88c35",
        "textRange": {
          "startLine": 238,
          "endLine": 238,
          "startOffset": 18,
          "endOffset": 21
        },
        "flows": [],
        "status": "OPEN",
        "message": "'typ' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        const l = typs.length;\n        for (let i = 0; i < l; i++) {\n            const typ = typs[i];\n            try {\n                return transform(val, typ, getProps);\n            } catch (_) {}",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzpiC",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 268,
        "hash": "00fba73079d5d65a34ef9c6a86abaae5",
        "textRange": {
          "startLine": 268,
          "endLine": 268,
          "startOffset": 75,
          "endOffset": 83
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {\n        if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n            return invalidValue(\"object\", val);\n        }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzpiD",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 273,
        "hash": "f55f8faca787b16a5de85276cda27696",
        "textRange": {
          "startLine": 273,
          "endLine": 273,
          "startOffset": 50,
          "endOffset": 53
        },
        "flows": [],
        "status": "OPEN",
        "message": "'key' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        }\n        const result: any = {};\n        Object.getOwnPropertyNames(props).forEach(key => {\n            const prop = props[key];\n            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;\n            result[prop.key] = transform(v, prop.typ, getProps, prop.key);",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzpiE",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 278,
        "hash": "85cdf91827cdae6313afff45d00a55bf",
        "textRange": {
          "startLine": 278,
          "endLine": 278,
          "startOffset": 48,
          "endOffset": 51
        },
        "flows": [],
        "status": "OPEN",
        "message": "'key' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "            result[prop.key] = transform(v, prop.typ, getProps, prop.key);\n        });\n        Object.getOwnPropertyNames(val).forEach(key => {\n            if (!Object.prototype.hasOwnProperty.call(props, key)) {\n                result[key] = transform(val[key], additional, getProps, key);\n            }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzpiF",
        "rule": "typescript:S3358",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 298,
        "hash": "312531a9243571ab2555c04a21adee70",
        "textRange": {
          "startLine": 298,
          "endLine": 300,
          "startOffset": 14,
          "endOffset": 36
        },
        "flows": [],
        "status": "OPEN",
        "message": "Extract this nested ternary operation into an independent statement.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "confusing"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    if (typeof typ === \"object\") {\n        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);",
        "summary": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>"
      },
      {
        "key": "AXtAUP0Ii8r-LMdMzpiG",
        "rule": "typescript:S3358",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 299,
        "hash": "8a63580931669d2f7b7d79bda6f68a08",
        "textRange": {
          "startLine": 299,
          "endLine": 300,
          "startOffset": 14,
          "endOffset": 36
        },
        "flows": [],
        "status": "OPEN",
        "message": "Extract this nested ternary operation into an independent statement.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "confusing"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);",
        "summary": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzphr",
        "rule": "typescript:S3776",
        "severity": "CRITICAL",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 90,
        "hash": "5fd6dcc3adfc524cd3dd083080299a0c",
        "textRange": {
          "startLine": 90,
          "endLine": 90,
          "startOffset": 9,
          "endOffset": 18
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 148,
                  "endLine": 148,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 149,
                  "endLine": 149,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 150,
                  "endLine": 150,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 153,
                  "endLine": 153,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 154,
                  "endLine": 154,
                  "startOffset": 4,
                  "endOffset": 9
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 154,
                  "endLine": 154,
                  "startOffset": 35,
                  "endOffset": 37
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 157,
                  "endLine": 157,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 158,
                  "endLine": 158,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 159,
                  "endLine": 159,
                  "startOffset": 50,
                  "endOffset": 51
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 160,
                  "endLine": 160,
                  "startOffset": 50,
                  "endOffset": 51
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 161,
                  "endLine": 161,
                  "startOffset": 50,
                  "endOffset": 51
                },
                "msg": "+4 (incl. 3 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 165,
                  "endLine": 165,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 165,
                  "endLine": 165,
                  "startOffset": 21,
                  "endOffset": 23
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 92,
                  "endLine": 92,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 99,
                  "endLine": 99,
                  "startOffset": 8,
                  "endOffset": 11
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 103,
                  "endLine": 103,
                  "startOffset": 14,
                  "endOffset": 19
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 109,
                  "endLine": 109,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 115,
                  "endLine": 115,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 120,
                  "endLine": 120,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 124,
                  "endLine": 124,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 131,
                  "endLine": 131,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 131,
                  "endLine": 131,
                  "startOffset": 52,
                  "endOffset": 54
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 137,
                  "endLine": 137,
                  "startOffset": 69,
                  "endOffset": 70
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                "textRange": {
                  "startLine": 141,
                  "endLine": 141,
                  "startOffset": 12,
                  "endOffset": 14
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Refactor this function to reduce its Cognitive Complexity from 44 to the 15 allowed.",
        "effort": "34min",
        "debt": "34min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "brain-overload"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "}\n\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);",
        "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzph0",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 130,
        "hash": "00fba73079d5d65a34ef9c6a86abaae5",
        "textRange": {
          "startLine": 130,
          "endLine": 130,
          "startOffset": 75,
          "endOffset": 83
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {\n        if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n            return invalidValue(\"object\", val);\n        }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzph1",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 135,
        "hash": "f55f8faca787b16a5de85276cda27696",
        "textRange": {
          "startLine": 135,
          "endLine": 135,
          "startOffset": 50,
          "endOffset": 53
        },
        "flows": [],
        "status": "OPEN",
        "message": "'key' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        }\n        const result: any = {};\n        Object.getOwnPropertyNames(props).forEach(key => {\n            const prop = props[key];\n            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;\n            result[prop.key] = transform(v, prop.typ, getProps, prop.key);",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzph2",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 140,
        "hash": "85cdf91827cdae6313afff45d00a55bf",
        "textRange": {
          "startLine": 140,
          "endLine": 140,
          "startOffset": 48,
          "endOffset": 51
        },
        "flows": [],
        "status": "OPEN",
        "message": "'key' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "            result[prop.key] = transform(v, prop.typ, getProps, prop.key);\n        });\n        Object.getOwnPropertyNames(val).forEach(key => {\n            if (!Object.prototype.hasOwnProperty.call(props, key)) {\n                result[key] = transform(val[key], additional, getProps, key);\n            }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzph3",
        "rule": "typescript:S3358",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 160,
        "hash": "312531a9243571ab2555c04a21adee70",
        "textRange": {
          "startLine": 160,
          "endLine": 162,
          "startOffset": 14,
          "endOffset": 36
        },
        "flows": [],
        "status": "OPEN",
        "message": "Extract this nested ternary operation into an independent statement.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "confusing"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    if (typeof typ === \"object\") {\n        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);",
        "summary": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzph4",
        "rule": "typescript:S3358",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 161,
        "hash": "8a63580931669d2f7b7d79bda6f68a08",
        "textRange": {
          "startLine": 161,
          "endLine": 162,
          "startOffset": 14,
          "endOffset": 36
        },
        "flows": [],
        "status": "OPEN",
        "message": "Extract this nested ternary operation into an independent statement.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "confusing"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);",
        "summary": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphd",
        "rule": "typescript:S3776",
        "severity": "CRITICAL",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 147,
        "hash": "5fd6dcc3adfc524cd3dd083080299a0c",
        "textRange": {
          "startLine": 147,
          "endLine": 147,
          "startOffset": 9,
          "endOffset": 18
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 205,
                  "endLine": 205,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 206,
                  "endLine": 206,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 207,
                  "endLine": 207,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 210,
                  "endLine": 210,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 211,
                  "endLine": 211,
                  "startOffset": 4,
                  "endOffset": 9
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 211,
                  "endLine": 211,
                  "startOffset": 35,
                  "endOffset": 37
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 214,
                  "endLine": 214,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 215,
                  "endLine": 215,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 216,
                  "endLine": 216,
                  "startOffset": 50,
                  "endOffset": 51
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 217,
                  "endLine": 217,
                  "startOffset": 50,
                  "endOffset": 51
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 218,
                  "endLine": 218,
                  "startOffset": 50,
                  "endOffset": 51
                },
                "msg": "+4 (incl. 3 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 222,
                  "endLine": 222,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 222,
                  "endLine": 222,
                  "startOffset": 21,
                  "endOffset": 23
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 149,
                  "endLine": 149,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 156,
                  "endLine": 156,
                  "startOffset": 8,
                  "endOffset": 11
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 160,
                  "endLine": 160,
                  "startOffset": 14,
                  "endOffset": 19
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 166,
                  "endLine": 166,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 172,
                  "endLine": 172,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 177,
                  "endLine": 177,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 181,
                  "endLine": 181,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 188,
                  "endLine": 188,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 188,
                  "endLine": 188,
                  "startOffset": 52,
                  "endOffset": 54
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 194,
                  "endLine": 194,
                  "startOffset": 69,
                  "endOffset": 70
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                "textRange": {
                  "startLine": 198,
                  "endLine": 198,
                  "startOffset": 12,
                  "endOffset": 14
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Refactor this function to reduce its Cognitive Complexity from 44 to the 15 allowed.",
        "effort": "34min",
        "debt": "34min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "brain-overload"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "}\n\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);",
        "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphh",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 157,
        "hash": "c18b29c89a7108ee069bbe31d8a88c35",
        "textRange": {
          "startLine": 157,
          "endLine": 157,
          "startOffset": 18,
          "endOffset": 21
        },
        "flows": [],
        "status": "OPEN",
        "message": "'typ' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        const l = typs.length;\n        for (let i = 0; i < l; i++) {\n            const typ = typs[i];\n            try {\n                return transform(val, typ, getProps);\n            } catch (_) {}",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphm",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 187,
        "hash": "00fba73079d5d65a34ef9c6a86abaae5",
        "textRange": {
          "startLine": 187,
          "endLine": 187,
          "startOffset": 75,
          "endOffset": 83
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {\n        if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n            return invalidValue(\"object\", val);\n        }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphn",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 192,
        "hash": "f55f8faca787b16a5de85276cda27696",
        "textRange": {
          "startLine": 192,
          "endLine": 192,
          "startOffset": 50,
          "endOffset": 53
        },
        "flows": [],
        "status": "OPEN",
        "message": "'key' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        }\n        const result: any = {};\n        Object.getOwnPropertyNames(props).forEach(key => {\n            const prop = props[key];\n            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;\n            result[prop.key] = transform(v, prop.typ, getProps, prop.key);",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzpho",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 197,
        "hash": "85cdf91827cdae6313afff45d00a55bf",
        "textRange": {
          "startLine": 197,
          "endLine": 197,
          "startOffset": 48,
          "endOffset": 51
        },
        "flows": [],
        "status": "OPEN",
        "message": "'key' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "            result[prop.key] = transform(v, prop.typ, getProps, prop.key);\n        });\n        Object.getOwnPropertyNames(val).forEach(key => {\n            if (!Object.prototype.hasOwnProperty.call(props, key)) {\n                result[key] = transform(val[key], additional, getProps, key);\n            }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphp",
        "rule": "typescript:S3358",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 217,
        "hash": "312531a9243571ab2555c04a21adee70",
        "textRange": {
          "startLine": 217,
          "endLine": 219,
          "startOffset": 14,
          "endOffset": 36
        },
        "flows": [],
        "status": "OPEN",
        "message": "Extract this nested ternary operation into an independent statement.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "confusing"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    if (typeof typ === \"object\") {\n        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);",
        "summary": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphq",
        "rule": "typescript:S3358",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 218,
        "hash": "8a63580931669d2f7b7d79bda6f68a08",
        "textRange": {
          "startLine": 218,
          "endLine": 219,
          "startOffset": 14,
          "endOffset": 36
        },
        "flows": [],
        "status": "OPEN",
        "message": "Extract this nested ternary operation into an independent statement.",
        "effort": "5min",
        "debt": "5min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "confusing"
        ],
        "creationDate": "2021-08-02T17:29:14+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);",
        "summary": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPqri8r-LMdMzpgL",
        "rule": "typescript:S3776",
        "severity": "CRITICAL",
        "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
        "project": "test",
        "line": 71,
        "hash": "033d83583fb5666efff076b608fc30c3",
        "textRange": {
          "startLine": 71,
          "endLine": 71,
          "startOffset": 6,
          "endOffset": 19
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                "textRange": {
                  "startLine": 78,
                  "endLine": 78,
                  "startOffset": 6,
                  "endOffset": 9
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                "textRange": {
                  "startLine": 80,
                  "endLine": 80,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                "textRange": {
                  "startLine": 99,
                  "endLine": 99,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                "textRange": {
                  "startLine": 105,
                  "endLine": 105,
                  "startOffset": 10,
                  "endOffset": 14
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                "textRange": {
                  "startLine": 100,
                  "endLine": 100,
                  "startOffset": 10,
                  "endOffset": 12
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                "textRange": {
                  "startLine": 102,
                  "endLine": 102,
                  "startOffset": 12,
                  "endOffset": 16
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                "textRange": {
                  "startLine": 100,
                  "endLine": 100,
                  "startOffset": 31,
                  "endOffset": 33
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                "textRange": {
                  "startLine": 109,
                  "endLine": 109,
                  "startOffset": 6,
                  "endOffset": 11
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                "textRange": {
                  "startLine": 88,
                  "endLine": 88,
                  "startOffset": 10,
                  "endOffset": 12
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                "textRange": {
                  "startLine": 95,
                  "endLine": 95,
                  "startOffset": 12,
                  "endOffset": 16
                },
                "msg": "+1"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Refactor this function to reduce its Cognitive Complexity from 16 to the 15 allowed.",
        "effort": "6min",
        "debt": "6min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "brain-overload"
        ],
        "creationDate": "2021-06-30T16:09:04+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "\n  /** The currently selected treemap node. Wrapped to avoid initialization woes */\n  get selected_node(): d3.HierarchyRectangularNode<TreemapNode> {\n    // Get typed versions of the curr state\n    // Set curr to root\n    let curr = this.treemap_layout;",
        "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
      },
      {
        "key": "AXtAUPnSi8r-LMdMzpf4",
        "rule": "typescript:S4325",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/components/global/upload_tabs/aws/FileList.vue",
        "project": "test",
        "line": 79,
        "hash": "8a88aeebc2f9b4b0ecc10da38885032e",
        "textRange": {
          "startLine": 79,
          "endLine": 79,
          "startOffset": 41,
          "endOffset": 50
        },
        "flows": [],
        "status": "OPEN",
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "effort": "1min",
        "debt": "1min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "redundant"
        ],
        "creationDate": "2021-06-30T16:09:04+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "\n    // Fetch it from s3, and promise to submit it to be loaded afterwards\n    await fetch_s3_file(this.auth.creds, file.Key!, this.formBucketName).then(\n      (content) => {\n        InspecIntakeModule.loadText({\n          text: content,",
        "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPnsi8r-LMdMzpf6",
        "rule": "typescript:S4325",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/components/global/upload_tabs/aws/S3Reader.vue",
        "project": "test",
        "line": 184,
        "hash": "9a4009784ecd065c4fe9baa831240022",
        "textRange": {
          "startLine": 184,
          "endLine": 184,
          "startOffset": 22,
          "endOffset": 39
        },
        "flows": [],
        "status": "OPEN",
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "effort": "1min",
        "debt": "1min",
        "author": "66632401+sesheikholeslam@users.noreply.github.com",
        "tags": [
          "redundant"
        ],
        "creationDate": "2021-06-30T16:09:04+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "   */\n  async load_bucket(name: string) {\n    const s3 = new S3(this.assumedRole!.creds);\n    await s3\n      .listObjectsV2({\n        Bucket: name,",
        "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPr3i8r-LMdMzpgO",
        "rule": "typescript:S4325",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/store/data_filters.ts",
        "project": "test",
        "line": 96,
        "hash": "13967f9141b7884039ec8d6481313af7",
        "textRange": {
          "startLine": 96,
          "endLine": 103,
          "startOffset": 32,
          "endOffset": 41
        },
        "flows": [],
        "status": "OPEN",
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "effort": "1min",
        "debt": "1min",
        "author": "sheikholeslam@mitre.org",
        "tags": [
          "redundant"
        ],
        "creationDate": "2021-06-23T16:08:32+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "  const asHDF = contextControl.root.hdf;\n  // Get our (non-null) searchable data\n  const searchables: string[] = [\n    asHDF.wraps.id,\n    asHDF.wraps.title,\n    asHDF.wraps.code,\n    asHDF.severity,\n    asHDF.status,\n    asHDF.finding_details\n  ].filter((s) => s !== null) as string[];\n\n  // See if any contain term\n  return searchables.some((s) => s.toLowerCase().includes(term));",
        "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPs3i8r-LMdMzpgS",
        "rule": "typescript:S4325",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/utilities/format_util.ts",
        "project": "test",
        "line": 29,
        "hash": "0c2f340c5bacde239d24920b8a453c6b",
        "textRange": {
          "startLine": 29,
          "endLine": 29,
          "startOffset": 6,
          "endOffset": 60
        },
        "flows": [],
        "status": "OPEN",
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "effort": "1min",
        "debt": "1min",
        "author": "sheikholeslam@mitre.org",
        "tags": [
          "redundant"
        ],
        "creationDate": "2021-06-23T14:32:15+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "  } else {\n    return `${execution_unique_key(\n      profile.sourcedFrom as SourcedContextualizedEvaluation\n    )}-${profile.data.name}`;\n  }\n}",
        "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
      },
      {
        "key": "AXtAUP0Vi8r-LMdMzpiH",
        "rule": "typescript:S3776",
        "severity": "CRITICAL",
        "component": "test:libs/inspecjs/src/context.ts",
        "project": "test",
        "line": 153,
        "hash": "bd47be4985f547192f96954033d9e458",
        "textRange": {
          "startLine": 153,
          "endLine": 153,
          "startOffset": 16,
          "endOffset": 39
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 162,
                  "endLine": 162,
                  "startOffset": 2,
                  "endOffset": 5
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 176,
                  "endLine": 176,
                  "startOffset": 2,
                  "endOffset": 5
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 181,
                  "endLine": 181,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 188,
                  "endLine": 188,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 199,
                  "endLine": 199,
                  "startOffset": 2,
                  "endOffset": 5
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 208,
                  "endLine": 208,
                  "startOffset": 2,
                  "endOffset": 5
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 210,
                  "endLine": 210,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 233,
                  "endLine": 233,
                  "startOffset": 6,
                  "endOffset": 10
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 210,
                  "endLine": 210,
                  "startOffset": 42,
                  "endOffset": 44
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 213,
                  "endLine": 213,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 220,
                  "endLine": 220,
                  "startOffset": 6,
                  "endOffset": 9
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 226,
                  "endLine": 226,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+4 (incl. 3 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 245,
                  "endLine": 245,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 250,
                  "endLine": 250,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 252,
                  "endLine": 252,
                  "startOffset": 8,
                  "endOffset": 12
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/context.ts",
                "textRange": {
                  "startLine": 241,
                  "endLine": 241,
                  "startOffset": 30,
                  "endOffset": 32
                },
                "msg": "+1"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Refactor this function to reduce its Cognitive Complexity from 31 to the 15 allowed.",
        "effort": "21min",
        "debt": "21min",
        "author": "sheikholeslam@mitre.org",
        "tags": [
          "brain-overload"
        ],
        "creationDate": "2021-06-23T14:32:15+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "}\n\nexport function contextualizeEvaluation(\n  evaluation: AnyEval\n): ContextualizedEvaluation {\n  // To begin, create basic context for profiles and evaluation",
        "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzpiB",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 257,
        "hash": "ec0d349e10fedfa2b54a27dd6cf235ca",
        "textRange": {
          "startLine": 257,
          "endLine": 257,
          "startOffset": 27,
          "endOffset": 35
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "sheikholeslam@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-06-23T14:32:15+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformDate(val: any): any {\n        if (val === null) {\n            return null;\n        }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzphz",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 119,
        "hash": "ec0d349e10fedfa2b54a27dd6cf235ca",
        "textRange": {
          "startLine": 119,
          "endLine": 119,
          "startOffset": 27,
          "endOffset": 35
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "sheikholeslam@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-06-23T14:32:15+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformDate(val: any): any {\n        if (val === null) {\n            return null;\n        }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphl",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 176,
        "hash": "ec0d349e10fedfa2b54a27dd6cf235ca",
        "textRange": {
          "startLine": 176,
          "endLine": 176,
          "startOffset": 27,
          "endOffset": 35
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "sheikholeslam@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-06-23T14:32:15+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformDate(val: any): any {\n        if (val === null) {\n            return null;\n        }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzphv",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 100,
        "hash": "c18b29c89a7108ee069bbe31d8a88c35",
        "textRange": {
          "startLine": 100,
          "endLine": 100,
          "startOffset": 18,
          "endOffset": 21
        },
        "flows": [],
        "status": "OPEN",
        "message": "'typ' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "sheikholeslam@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2021-06-22T15:34:30+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        const l = typs.length;\n        for (let i = 0; i < l; i++) {\n            const typ = typs[i];\n            try {\n                return transform(val, typ, getProps);\n            } catch (_) {}",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzdi8r-LMdMzphc",
        "rule": "typescript:S3776",
        "severity": "CRITICAL",
        "component": "test:libs/inspecjs/src/nist.ts",
        "project": "test",
        "line": 126,
        "hash": "99d4f34dee5a16b69df60f274112f848",
        "textRange": {
          "startLine": 126,
          "endLine": 126,
          "startOffset": 2,
          "endOffset": 10
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 131,
                  "endLine": 131,
                  "startOffset": 24,
                  "endOffset": 26
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 132,
                  "endLine": 132,
                  "startOffset": 4,
                  "endOffset": 6
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 136,
                  "endLine": 136,
                  "startOffset": 4,
                  "endOffset": 7
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 136,
                  "endLine": 136,
                  "startOffset": 34,
                  "endOffset": 36
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 140,
                  "endLine": 140,
                  "startOffset": 6,
                  "endOffset": 8
                },
                "msg": "+2 (incl. 1 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 142,
                  "endLine": 142,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 142,
                  "endLine": 142,
                  "startOffset": 29,
                  "endOffset": 31
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 147,
                  "endLine": 147,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 148,
                  "endLine": 148,
                  "startOffset": 10,
                  "endOffset": 12
                },
                "msg": "+4 (incl. 3 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 153,
                  "endLine": 153,
                  "startOffset": 10,
                  "endOffset": 12
                },
                "msg": "+4 (incl. 3 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 160,
                  "endLine": 160,
                  "startOffset": 13,
                  "endOffset": 15
                },
                "msg": "+1"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 162,
                  "endLine": 162,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          },
          {
            "locations": [
              {
                "component": "test:libs/inspecjs/src/nist.ts",
                "textRange": {
                  "startLine": 166,
                  "endLine": 166,
                  "startOffset": 8,
                  "endOffset": 10
                },
                "msg": "+3 (incl. 2 for nesting)"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Refactor this function to reduce its Cognitive Complexity from 28 to the 15 allowed.",
        "effort": "18min",
        "debt": "18min",
        "author": "sheikholeslam@mitre.org",
        "tags": [
          "brain-overload"
        ],
        "creationDate": "2021-06-22T15:34:30+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "   * Avoid repeating this if possible.\n   */\n  canonize(config: CanonizationConfig): string {\n    config = default_partial_config(config);\n    const ss = this.subSpecifiers;\n",
        "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
      },
      {
        "key": "AXtAUPrqi8r-LMdMzpgN",
        "rule": "typescript:S4325",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/store/data_store.ts",
        "project": "test",
        "line": 81,
        "hash": "3899fef5cfc73d590869dd79cb4cc7e9",
        "textRange": {
          "startLine": 81,
          "endLine": 83,
          "startOffset": 11,
          "endOffset": 39
        },
        "flows": [],
        "status": "OPEN",
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "effort": "1min",
        "debt": "1min",
        "author": "66680985+camdenmoors@users.noreply.github.com",
        "tags": [
          "redundant"
        ],
        "creationDate": "2021-04-06T20:31:54+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "   */\n  get contextualExecutionProfiles(): readonly SourcedContextualizedProfile[] {\n    return this.contextualExecutions.flatMap(\n      (evaluation) => evaluation.contains\n    ) as SourcedContextualizedProfile[];\n  }\n\n  /**",
        "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPqii8r-LMdMzpgK",
        "rule": "typescript:S4325",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/components/cards/treemap/Cell.vue",
        "project": "test",
        "line": 84,
        "hash": "132666a69b184b8b50ac1bf8e461a4d6",
        "textRange": {
          "startLine": 84,
          "endLine": 84,
          "startOffset": 7,
          "endOffset": 40
        },
        "flows": [],
        "status": "OPEN",
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "effort": "1min",
        "debt": "1min",
        "author": "rbclark@mitre.org",
        "tags": [
          "redundant"
        ],
        "creationDate": "2020-10-14T22:38:18+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    return (\n      this.is_control && // We are a control\n      (this.node.data as TreemapNodeLeaf).control.data.id ===\n        this.selectedControlId // Our control id matches\n    );\n  }",
        "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPnSi8r-LMdMzpf5",
        "rule": "typescript:S4325",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/components/global/upload_tabs/aws/FileList.vue",
        "project": "test",
        "line": 83,
        "hash": "74f2f0146720ebd242fef2ef1727b1cd",
        "textRange": {
          "startLine": 83,
          "endLine": 83,
          "startOffset": 20,
          "endOffset": 29
        },
        "flows": [],
        "status": "OPEN",
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "effort": "1min",
        "debt": "1min",
        "author": "rbclark@mitre.org",
        "tags": [
          "redundant"
        ],
        "creationDate": "2020-09-22T22:33:07+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        InspecIntakeModule.loadText({\n          text: content,\n          filename: file.Key!\n        }).then((uniqueId) => this.$emit('got-files', [uniqueId]));\n      }\n    );",
        "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPrPi8r-LMdMzpgM",
        "rule": "typescript:S4138",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/components/generic/ApexLineChart.vue",
        "project": "test",
        "line": 46,
        "hash": "9acd2d681bf613b90597cfd8bcf316e8",
        "textRange": {
          "startLine": 46,
          "endLine": 48,
          "startOffset": 4,
          "endOffset": 5
        },
        "flows": [],
        "status": "OPEN",
        "message": "Expected a `for-of` loop instead of a `for` loop with this simple iteration.",
        "effort": "5min",
        "debt": "5min",
        "author": "51336847+cjdoherty@users.noreply.github.com",
        "tags": [
          "clumsy"
        ],
        "creationDate": "2020-08-26T14:02:11+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "  get label_colors(): string[] {\n    const colors = [];\n    for (let i = 0; i < this.categories.length; i++) {\n      colors.push('#FFFFFF');\n    }\n    return colors;\n  }\n",
        "summary": "<p>If you have an iterable, such as an array, set, or list, your best option for looping through its values is the <code>for of</code> syntax. Use a\ncounter, and …​ well you’ll get the right behavior, but your code just isn’t as clean or clear.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nconst arr = [4, 3, 2, 1];\n\nfor (let i = 0; i &lt; arr.length; i++) {  // Noncompliant\n  console.log(arr[i]);\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nconst arr = [4, 3, 2, 1];\n\nfor (let value of arr) {\n  console.log(value);\n}\n</pre>"
      },
      {
        "key": "AXtAUPsri8r-LMdMzpgQ",
        "rule": "typescript:S4325",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/utilities/delta_util.ts",
        "project": "test",
        "line": 158,
        "hash": "1ff214edad50c0e11919635e4a4da1fe",
        "textRange": {
          "startLine": 158,
          "endLine": 158,
          "startOffset": 10,
          "endOffset": 28
        },
        "flows": [],
        "status": "OPEN",
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "effort": "1min",
        "debt": "1min",
        "author": "51336847+cjdoherty@users.noreply.github.com",
        "tags": [
          "redundant"
        ],
        "creationDate": "2020-08-26T14:02:11+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "  for (const prof of ev.contains) {\n    for (const ctrl of prof.contains) {\n      if (ctrl.hdf.segments!.length) {\n        return ctrl.hdf.segments![0].start_time;\n      }\n    }",
        "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPssi8r-LMdMzpgR",
        "rule": "typescript:S4325",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/utilities/delta_util.ts",
        "project": "test",
        "line": 159,
        "hash": "a35b4c61d3b8c13f7961feca7a6ec00c",
        "textRange": {
          "startLine": 159,
          "endLine": 159,
          "startOffset": 15,
          "endOffset": 33
        },
        "flows": [],
        "status": "OPEN",
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "effort": "1min",
        "debt": "1min",
        "author": "51336847+cjdoherty@users.noreply.github.com",
        "tags": [
          "redundant"
        ],
        "creationDate": "2020-08-26T14:02:11+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    for (const ctrl of prof.contains) {\n      if (ctrl.hdf.segments!.length) {\n        return ctrl.hdf.segments![0].start_time;\n      }\n    }\n  }",
        "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPt6i8r-LMdMzpgU",
        "rule": "typescript:S4144",
        "severity": "MAJOR",
        "component": "test:apps/frontend/tests/unit/Compare.spec.ts",
        "project": "test",
        "line": 46,
        "hash": "a68d822d383917a99ac357fd376a830d",
        "textRange": {
          "startLine": 46,
          "endLine": 46,
          "startOffset": 55,
          "endOffset": 57
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:apps/frontend/tests/unit/Compare.spec.ts",
                "textRange": {
                  "startLine": 38,
                  "endLine": 38,
                  "startOffset": 55,
                  "endOffset": 57
                },
                "msg": "Original implementation"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Update this function so that its implementation is not identical to the one on line 38.",
        "effort": "15min",
        "debt": "15min",
        "author": "51336847+cjdoherty@users.noreply.github.com",
        "tags": [
          "confusing",
          "duplicate",
          "suspicious"
        ],
        "creationDate": "2020-08-26T14:02:11+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "  });\n\n  it('does not recount same controls with 3 files', () => {\n    loadSample('NGINX With Failing Tests');\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets",
        "summary": "<p>When two functions have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but\nmay be confusing to maintainers. In the latter case, the code should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {  // Noncompliant\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {\n  return calculateCode();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Functions with fewer than 3 lines are ignored.</p>"
      },
      {
        "key": "AXtAUPtAi8r-LMdMzpgT",
        "rule": "typescript:S1135",
        "severity": "INFO",
        "component": "test:apps/frontend/src/utilities/splunk_util.ts",
        "project": "test",
        "line": 341,
        "hash": "4ad01e433047b4d0b74d3a3bd46ae007",
        "textRange": {
          "startLine": 341,
          "endLine": 341,
          "startOffset": 3,
          "endOffset": 7
        },
        "flows": [],
        "status": "OPEN",
        "message": "Complete the task associated to this \"TODO\" comment.",
        "effort": "0min",
        "debt": "0min",
        "author": "51966679+mitriol@users.noreply.github.com",
        "tags": [
          "cwe"
        ],
        "creationDate": "2020-08-26T14:01:58+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": " * HDF heirarchy.\n *\n * TODO: Provide a mechanism for also returning orphaned items\n */\nexport function consolidate_payloads(\n  payloads: UnknownPayload[]",
        "summary": "<p><code>TODO</code> tags are commonly used to mark places where some more code is required, but which the developer wants to implement later.</p>\n<p>Sometimes the developer will not have the time or will simply forget to get back to that tag.</p>\n<p>This rule is meant to track those tags and to ensure that they do not go unnoticed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction doSomething() {\n  // TODO\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/546.html\">MITRE, CWE-546</a> - Suspicious Comment </li>\n</ul>"
      },
      {
        "key": "AXtAUPsYi8r-LMdMzpgP",
        "rule": "typescript:S4325",
        "severity": "MINOR",
        "component": "test:apps/frontend/src/utilities/treemap_util.ts",
        "project": "test",
        "line": 222,
        "hash": "9a78ca4b58afc6956625e79056466a00",
        "textRange": {
          "startLine": 222,
          "endLine": 222,
          "startOffset": 21,
          "endOffset": 33
        },
        "flows": [],
        "status": "OPEN",
        "message": "This assertion is unnecessary since it does not change the type of the expression.",
        "effort": "1min",
        "debt": "1min",
        "author": "51966679+mitriol@users.noreply.github.com",
        "tags": [
          "redundant"
        ],
        "creationDate": "2020-08-26T14:01:23+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        }\n      } else if (root.parent !== null) {\n        return 1.0 / root.parent!.children.length;\n      }\n      return 0;\n    });",
        "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
      },
      {
        "key": "AXtAUPp3i8r-LMdMzpgG",
        "rule": "typescript:S1135",
        "severity": "INFO",
        "component": "test:apps/frontend/src/components/cards/controltable/ControlRowDetails.vue",
        "project": "test",
        "line": 67,
        "hash": "b3b8610f2f997ad05a0cc9fcc8d5aa17",
        "textRange": {
          "startLine": 67,
          "endLine": 67,
          "startOffset": 2,
          "endOffset": 6
        },
        "flows": [],
        "status": "OPEN",
        "message": "Complete the task associated to this \"TODO\" comment.",
        "effort": "0min",
        "debt": "0min",
        "author": "lippold@gmail.com",
        "tags": [
          "cwe"
        ],
        "creationDate": "2020-08-26T14:01:02+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "import {ContextualizedControl} from 'inspecjs';\nimport _ from 'lodash';\n//TODO: add line numbers\nimport 'prismjs';\nimport 'prismjs/components/prism-makefile.js';\nimport 'prismjs/components/prism-ruby.js';",
        "summary": "<p><code>TODO</code> tags are commonly used to mark places where some more code is required, but which the developer wants to implement later.</p>\n<p>Sometimes the developer will not have the time or will simply forget to get back to that tag.</p>\n<p>This rule is meant to track those tags and to ensure that they do not go unnoticed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction doSomething() {\n  // TODO\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/546.html\">MITRE, CWE-546</a> - Suspicious Comment </li>\n</ul>"
      },
      {
        "key": "AXtAUPuhi8r-LMdMzpgV",
        "rule": "typescript:S4144",
        "severity": "MAJOR",
        "component": "test:apps/backend/src/evaluations/evaluations.service.spec.ts",
        "project": "test",
        "line": 293,
        "hash": "4fb693e4f6656b1e3dbad68b47593776",
        "textRange": {
          "startLine": 293,
          "endLine": 293,
          "startOffset": 76,
          "endOffset": 78
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:apps/backend/src/evaluations/evaluations.service.spec.ts",
                "textRange": {
                  "startLine": 141,
                  "endLine": 141,
                  "startOffset": 73,
                  "endOffset": 75
                },
                "msg": "Original implementation"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Update this function so that its implementation is not identical to the one on line 141.",
        "effort": "15min",
        "debt": "15min",
        "author": "kfagan@mitre.org",
        "tags": [
          "confusing",
          "duplicate",
          "suspicious"
        ],
        "creationDate": "2020-08-19T20:43:00+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    });\n\n    it('should throw an error when the evaluation does not exist', async () => {\n      expect.assertions(1);\n      await expect(evaluationsService.findById('-1')).rejects.toThrow(\n        NotFoundException",
        "summary": "<p>When two functions have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but\nmay be confusing to maintainers. In the latter case, the code should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {  // Noncompliant\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {\n  return calculateCode();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Functions with fewer than 3 lines are ignored.</p>"
      },
      {
        "key": "AXtAUPwji8r-LMdMzpga",
        "rule": "typescript:S1848",
        "severity": "MAJOR",
        "component": "test:apps/backend/src/config/config.service.spec.ts",
        "project": "test",
        "line": 33,
        "hash": "3cf63da6002c83ff5e01af3ea9a377fe",
        "textRange": {
          "startLine": 33,
          "endLine": 33,
          "startOffset": 6,
          "endOffset": 23
        },
        "flows": [],
        "status": "OPEN",
        "message": "Either remove this useless object instantiation of \"ConfigService\" or use it.",
        "effort": "5min",
        "debt": "5min",
        "author": "60075714+samuelsunvold@users.noreply.github.com",
        "tags": [],
        "creationDate": "2020-07-01T16:16:10+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "BUG",
        "scope": "MAIN",
        "snip": "      const consoleSpy = jest.spyOn(console, 'log');\n      // Used to make sure logs are outputted\n      new ConfigService();\n      expect(consoleSpy).toHaveBeenCalledWith(\n        'Unable to read configuration file `.env`!'\n      );",
        "summary": "<p>There is no good reason to create a new object to not do anything with it. Most of the time, this is due to a missing piece of code and so could\nlead to an unexpected behavior in production.</p>\n<p>If it was done on purpose because the constructor has side-effects, then that side-effect code should be moved into a separate method and called\ndirectly.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nnew MyConstructor(); // Non-Compliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar something = new MyConstructor();  // Compliant\n</pre>\n<h2>Exceptions</h2>\n<p>Immediately dropped new objects inside <code>try</code>-statements are ignored.</p>\n<pre>\ntry {\n  new MyConstructor();\n} catch (e) {\n  /* ... */\n}\n</pre>"
      },
      {
        "key": "AXtAUPwFi8r-LMdMzpgY",
        "rule": "typescript:S4144",
        "severity": "MAJOR",
        "component": "test:apps/backend/src/pipes/password-complexity.pipe.spec.ts",
        "project": "test",
        "line": 141,
        "hash": "7bdcb56ce070e980805d0246390b76f1",
        "textRange": {
          "startLine": 141,
          "endLine": 141,
          "startOffset": 16,
          "endOffset": 18
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:apps/backend/src/pipes/password-complexity.pipe.spec.ts",
                "textRange": {
                  "startLine": 135,
                  "endLine": 135,
                  "startOffset": 16,
                  "endOffset": 18
                },
                "msg": "Original implementation"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Update this function so that its implementation is not identical to the one on line 135.",
        "effort": "15min",
        "debt": "15min",
        "author": "kfagan@mitre.org",
        "tags": [
          "confusing",
          "duplicate",
          "suspicious"
        ],
        "creationDate": "2020-07-01T13:38:16+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        )\n      ).toThrowError(BadRequestException);\n      expect(() =>\n        passwordComplexityPipe.transform(\n          CREATE_USER_DTO_TEST_OBJ_WITH_MISSING_PASSWORD_FIELD,\n          metaData",
        "summary": "<p>When two functions have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but\nmay be confusing to maintainers. In the latter case, the code should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {  // Noncompliant\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {\n  return calculateCode();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Functions with fewer than 3 lines are ignored.</p>"
      },
      {
        "key": "AXtAUPwFi8r-LMdMzpgZ",
        "rule": "typescript:S4144",
        "severity": "MAJOR",
        "component": "test:apps/backend/src/pipes/password-complexity.pipe.spec.ts",
        "project": "test",
        "line": 161,
        "hash": "7bdcb56ce070e980805d0246390b76f1",
        "textRange": {
          "startLine": 161,
          "endLine": 161,
          "startOffset": 16,
          "endOffset": 18
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:apps/backend/src/pipes/password-complexity.pipe.spec.ts",
                "textRange": {
                  "startLine": 155,
                  "endLine": 155,
                  "startOffset": 16,
                  "endOffset": 18
                },
                "msg": "Original implementation"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Update this function so that its implementation is not identical to the one on line 155.",
        "effort": "15min",
        "debt": "15min",
        "author": "kfagan@mitre.org",
        "tags": [
          "confusing",
          "duplicate",
          "suspicious"
        ],
        "creationDate": "2020-07-01T13:38:16+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        )\n      ).toThrowError(BadRequestException);\n      expect(() =>\n        passwordComplexityPipe.transform(\n          UPDATE_USER_DTO_TEST_WITHOUT_PASSWORD,\n          metaData",
        "summary": "<p>When two functions have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but\nmay be confusing to maintainers. In the latter case, the code should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {  // Noncompliant\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {\n  return calculateCode();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Functions with fewer than 3 lines are ignored.</p>"
      },
      {
        "key": "AXtAUPv_i8r-LMdMzpgX",
        "rule": "typescript:S4144",
        "severity": "MAJOR",
        "component": "test:apps/backend/src/pipes/passwords-match.pipe.spec.ts",
        "project": "test",
        "line": 57,
        "hash": "7bdcb56ce070e980805d0246390b76f1",
        "textRange": {
          "startLine": 57,
          "endLine": 57,
          "startOffset": 16,
          "endOffset": 18
        },
        "flows": [
          {
            "locations": [
              {
                "component": "test:apps/backend/src/pipes/passwords-match.pipe.spec.ts",
                "textRange": {
                  "startLine": 51,
                  "endLine": 51,
                  "startOffset": 16,
                  "endOffset": 18
                },
                "msg": "Original implementation"
              }
            ]
          }
        ],
        "status": "OPEN",
        "message": "Update this function so that its implementation is not identical to the one on line 51.",
        "effort": "15min",
        "debt": "15min",
        "author": "kfagan@mitre.org",
        "tags": [
          "confusing",
          "duplicate",
          "suspicious"
        ],
        "creationDate": "2020-07-01T13:38:16+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "        )\n      ).toThrowError(BadRequestException);\n      expect(() =>\n        passwordsMatchPipe.transform(\n          CREATE_USER_DTO_TEST_OBJ_WITH_UNMATCHING_PASSWORDS,\n          metaData",
        "summary": "<p>When two functions have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but\nmay be confusing to maintainers. In the latter case, the code should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {  // Noncompliant\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {\n  return calculateCode();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Functions with fewer than 3 lines are ignored.</p>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzph6",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 229,
        "hash": "b981ea8d10d148243a1b3b9ee8a0c3a4",
        "textRange": {
          "startLine": 229,
          "endLine": 229,
          "startOffset": 32,
          "endOffset": 43
        },
        "flows": [],
        "status": "OPEN",
        "message": "'typ' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzph7",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 229,
        "hash": "b981ea8d10d148243a1b3b9ee8a0c3a4",
        "textRange": {
          "startLine": 229,
          "endLine": 229,
          "startOffset": 45,
          "endOffset": 53
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzph8",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 234,
        "hash": "c0531a3bd0eb2b95bf1124e7638d6e3d",
        "textRange": {
          "startLine": 234,
          "endLine": 234,
          "startOffset": 41,
          "endOffset": 49
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformUnion(typs: any[], val: any): any {\n        // val must validate against one typ in typs\n        const l = typs.length;\n        for (let i = 0; i < l; i++) {",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzph-",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 246,
        "hash": "f326b05dbcd91d3c9c8640bc74bcce26",
        "textRange": {
          "startLine": 246,
          "endLine": 246,
          "startOffset": 44,
          "endOffset": 52
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformEnum(cases: string[], val: any): any {\n        if (cases.indexOf(val) !== -1) return val;\n        return invalidValue(cases, val);\n    }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzph_",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 251,
        "hash": "1c3e797b8d85c13b868b149ec110baa3",
        "textRange": {
          "startLine": 251,
          "endLine": 251,
          "startOffset": 28,
          "endOffset": 36
        },
        "flows": [],
        "status": "OPEN",
        "message": "'typ' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUP0Hi8r-LMdMzpiA",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "project": "test",
        "line": 251,
        "hash": "1c3e797b8d85c13b868b149ec110baa3",
        "textRange": {
          "startLine": 251,
          "endLine": 251,
          "startOffset": 38,
          "endOffset": 46
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzphs",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 91,
        "hash": "b981ea8d10d148243a1b3b9ee8a0c3a4",
        "textRange": {
          "startLine": 91,
          "endLine": 91,
          "startOffset": 32,
          "endOffset": 43
        },
        "flows": [],
        "status": "OPEN",
        "message": "'typ' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzpht",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 91,
        "hash": "b981ea8d10d148243a1b3b9ee8a0c3a4",
        "textRange": {
          "startLine": 91,
          "endLine": 91,
          "startOffset": 45,
          "endOffset": 53
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzphu",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 96,
        "hash": "c0531a3bd0eb2b95bf1124e7638d6e3d",
        "textRange": {
          "startLine": 96,
          "endLine": 96,
          "startOffset": 41,
          "endOffset": 49
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformUnion(typs: any[], val: any): any {\n        // val must validate against one typ in typs\n        const l = typs.length;\n        for (let i = 0; i < l; i++) {",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzphw",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 108,
        "hash": "f326b05dbcd91d3c9c8640bc74bcce26",
        "textRange": {
          "startLine": 108,
          "endLine": 108,
          "startOffset": 44,
          "endOffset": 52
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformEnum(cases: string[], val: any): any {\n        if (cases.indexOf(val) !== -1) return val;\n        return invalidValue(cases, val);\n    }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzphx",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 113,
        "hash": "1c3e797b8d85c13b868b149ec110baa3",
        "textRange": {
          "startLine": 113,
          "endLine": 113,
          "startOffset": 28,
          "endOffset": 36
        },
        "flows": [],
        "status": "OPEN",
        "message": "'typ' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPz9i8r-LMdMzphy",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "project": "test",
        "line": 113,
        "hash": "1c3e797b8d85c13b868b149ec110baa3",
        "textRange": {
          "startLine": 113,
          "endLine": 113,
          "startOffset": 38,
          "endOffset": 46
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphe",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 148,
        "hash": "b981ea8d10d148243a1b3b9ee8a0c3a4",
        "textRange": {
          "startLine": 148,
          "endLine": 148,
          "startOffset": 32,
          "endOffset": 43
        },
        "flows": [],
        "status": "OPEN",
        "message": "'typ' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphf",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 148,
        "hash": "b981ea8d10d148243a1b3b9ee8a0c3a4",
        "textRange": {
          "startLine": 148,
          "endLine": 148,
          "startOffset": 45,
          "endOffset": 53
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphg",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 153,
        "hash": "c0531a3bd0eb2b95bf1124e7638d6e3d",
        "textRange": {
          "startLine": 153,
          "endLine": 153,
          "startOffset": 41,
          "endOffset": 49
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformUnion(typs: any[], val: any): any {\n        // val must validate against one typ in typs\n        const l = typs.length;\n        for (let i = 0; i < l; i++) {",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphi",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 165,
        "hash": "f326b05dbcd91d3c9c8640bc74bcce26",
        "textRange": {
          "startLine": 165,
          "endLine": 165,
          "startOffset": 44,
          "endOffset": 52
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformEnum(cases: string[], val: any): any {\n        if (cases.indexOf(val) !== -1) return val;\n        return invalidValue(cases, val);\n    }",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphj",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 170,
        "hash": "1c3e797b8d85c13b868b149ec110baa3",
        "textRange": {
          "startLine": 170,
          "endLine": 170,
          "startOffset": 28,
          "endOffset": 36
        },
        "flows": [],
        "status": "OPEN",
        "message": "'typ' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      },
      {
        "key": "AXtAUPzsi8r-LMdMzphk",
        "rule": "typescript:S1117",
        "severity": "MAJOR",
        "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "project": "test",
        "line": 170,
        "hash": "1c3e797b8d85c13b868b149ec110baa3",
        "textRange": {
          "startLine": 170,
          "endLine": 170,
          "startOffset": 38,
          "endOffset": 46
        },
        "flows": [],
        "status": "OPEN",
        "message": "'val' is already declared in the upper scope.",
        "effort": "5min",
        "debt": "5min",
        "author": "jchenry@mitre.org",
        "tags": [
          "pitfall",
          "suspicious"
        ],
        "creationDate": "2019-07-25T22:13:43+0000",
        "updateDate": "2021-08-13T16:18:45+0000",
        "type": "CODE_SMELL",
        "scope": "MAIN",
        "snip": "    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));",
        "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
      }
    ],
    "components": [
      {
        "key": "test:apps/frontend/src/components/cards/controltable/ControlRowDetails.vue",
        "enabled": true,
        "qualifier": "FIL",
        "name": "ControlRowDetails.vue",
        "longName": "apps/frontend/src/components/cards/controltable/ControlRowDetails.vue",
        "path": "apps/frontend/src/components/cards/controltable/ControlRowDetails.vue"
      },
      {
        "key": "test:apps/backend/src/pipes/passwords-match.pipe.spec.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "passwords-match.pipe.spec.ts",
        "longName": "apps/backend/src/pipes/passwords-match.pipe.spec.ts",
        "path": "apps/backend/src/pipes/passwords-match.pipe.spec.ts"
      },
      {
        "key": "test:apps/backend/src/pipes/password-complexity.pipe.spec.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "password-complexity.pipe.spec.ts",
        "longName": "apps/backend/src/pipes/password-complexity.pipe.spec.ts",
        "path": "apps/backend/src/pipes/password-complexity.pipe.spec.ts"
      },
      {
        "key": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
        "enabled": true,
        "qualifier": "FIL",
        "name": "ControlTable.vue",
        "longName": "apps/frontend/src/components/cards/controltable/ControlTable.vue",
        "path": "apps/frontend/src/components/cards/controltable/ControlTable.vue"
      },
      {
        "key": "test:libs/hdf-converters/src/base-converter.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "base-converter.ts",
        "longName": "libs/hdf-converters/src/base-converter.ts",
        "path": "libs/hdf-converters/src/base-converter.ts"
      },
      {
        "key": "test:apps/frontend/src/utilities/treemap_util.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "treemap_util.ts",
        "longName": "apps/frontend/src/utilities/treemap_util.ts",
        "path": "apps/frontend/src/utilities/treemap_util.ts"
      },
      {
        "key": "test:apps/frontend/src/store/data_store.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "data_store.ts",
        "longName": "apps/frontend/src/store/data_store.ts",
        "path": "apps/frontend/src/store/data_store.ts"
      },
      {
        "key": "test:apps/frontend/src/store/data_filters.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "data_filters.ts",
        "longName": "apps/frontend/src/store/data_filters.ts",
        "path": "apps/frontend/src/store/data_filters.ts"
      },
      {
        "key": "test:apps/backend/src/evaluations/evaluations.service.spec.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "evaluations.service.spec.ts",
        "longName": "apps/backend/src/evaluations/evaluations.service.spec.ts",
        "path": "apps/backend/src/evaluations/evaluations.service.spec.ts"
      },
      {
        "key": "test:apps/frontend/src/components/global/upload_tabs/aws/S3Reader.vue",
        "enabled": true,
        "qualifier": "FIL",
        "name": "S3Reader.vue",
        "longName": "apps/frontend/src/components/global/upload_tabs/aws/S3Reader.vue",
        "path": "apps/frontend/src/components/global/upload_tabs/aws/S3Reader.vue"
      },
      {
        "key": "test:apps/frontend/src/components/global/upload_tabs/aws/FileList.vue",
        "enabled": true,
        "qualifier": "FIL",
        "name": "FileList.vue",
        "longName": "apps/frontend/src/components/global/upload_tabs/aws/FileList.vue",
        "path": "apps/frontend/src/components/global/upload_tabs/aws/FileList.vue"
      },
      {
        "key": "test:apps/frontend/src/components/global/upload_tabs/aws/AuthStepMFA.vue",
        "enabled": true,
        "qualifier": "FIL",
        "name": "AuthStepMFA.vue",
        "longName": "apps/frontend/src/components/global/upload_tabs/aws/AuthStepMFA.vue",
        "path": "apps/frontend/src/components/global/upload_tabs/aws/AuthStepMFA.vue"
      },
      {
        "key": "test:apps/frontend/src/components/global/upload_tabs/aws/AuthStepBasic.vue",
        "enabled": true,
        "qualifier": "FIL",
        "name": "AuthStepBasic.vue",
        "longName": "apps/frontend/src/components/global/upload_tabs/aws/AuthStepBasic.vue",
        "path": "apps/frontend/src/components/global/upload_tabs/aws/AuthStepBasic.vue"
      },
      {
        "key": "test:apps/frontend/src/utilities/delta_util.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "delta_util.ts",
        "longName": "apps/frontend/src/utilities/delta_util.ts",
        "path": "apps/frontend/src/utilities/delta_util.ts"
      },
      {
        "key": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
        "enabled": true,
        "qualifier": "FIL",
        "name": "Treemap.vue",
        "longName": "apps/frontend/src/components/cards/treemap/Treemap.vue",
        "path": "apps/frontend/src/components/cards/treemap/Treemap.vue"
      },
      {
        "key": "test:apps/frontend/tests/unit/Compare.spec.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "Compare.spec.ts",
        "longName": "apps/frontend/tests/unit/Compare.spec.ts",
        "path": "apps/frontend/tests/unit/Compare.spec.ts"
      },
      {
        "key": "test:apps/frontend/src/utilities/format_util.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "format_util.ts",
        "longName": "apps/frontend/src/utilities/format_util.ts",
        "path": "apps/frontend/src/utilities/format_util.ts"
      },
      {
        "key": "test:apps/frontend/src/utilities/splunk_util.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "splunk_util.ts",
        "longName": "apps/frontend/src/utilities/splunk_util.ts",
        "path": "apps/frontend/src/utilities/splunk_util.ts"
      },
      {
        "key": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "exec-jsonmin.ts",
        "longName": "libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
        "path": "libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts"
      },
      {
        "key": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "exec-json.ts",
        "longName": "libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
        "path": "libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts"
      },
      {
        "key": "test:apps/frontend/src/components/cards/treemap/Cell.vue",
        "enabled": true,
        "qualifier": "FIL",
        "name": "Cell.vue",
        "longName": "apps/frontend/src/components/cards/treemap/Cell.vue",
        "path": "apps/frontend/src/components/cards/treemap/Cell.vue"
      },
      {
        "key": "test:libs/inspecjs/src/context.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "context.ts",
        "longName": "libs/inspecjs/src/context.ts",
        "path": "libs/inspecjs/src/context.ts"
      },
      {
        "key": "test:apps/frontend/src/components/generic/ApexLineChart.vue",
        "enabled": true,
        "qualifier": "FIL",
        "name": "ApexLineChart.vue",
        "longName": "apps/frontend/src/components/generic/ApexLineChart.vue",
        "path": "apps/frontend/src/components/generic/ApexLineChart.vue"
      },
      {
        "key": "test:libs/inspecjs/src/nist.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "nist.ts",
        "longName": "libs/inspecjs/src/nist.ts",
        "path": "libs/inspecjs/src/nist.ts"
      },
      {
        "key": "test",
        "enabled": true,
        "qualifier": "TRK",
        "name": "test",
        "longName": "test"
      },
      {
        "key": "test:apps/backend/src/config/config.service.spec.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "config.service.spec.ts",
        "longName": "apps/backend/src/config/config.service.spec.ts",
        "path": "apps/backend/src/config/config.service.spec.ts"
      },
      {
        "key": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "enabled": true,
        "qualifier": "FIL",
        "name": "profile-json.ts",
        "longName": "libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
        "path": "libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts"
      }
    ],
    "facets": []
  },
  "/api/sources/raw?key=test:apps/frontend/src/components/cards/controltable/ControlTable.vue": "<template>\n  <v-container fluid class=\"font-weight-bold\">\n    <div\n      ref=\"controlTableTitle\"\n      :class=\"\n        $vuetify.breakpoint.smAndDown\n          ? 'control-table-title'\n          : 'pinned-header control-table-title'\n      \"\n      :style=\"controlTableTitleStyle\"\n    >\n      <!-- Toolbar -->\n      <v-row v-resize=\"onResize\">\n        <v-row>\n          <v-col cols=\"12\" md=\"3\" class=\"pb-0\">\n            <v-card-title class=\"pb-0\">Results View Data</v-card-title>\n          </v-col>\n          <v-spacer />\n          <v-col cols=\"3\" md=\"auto\" class=\"text-right pl-6 pb-0\">\n            <v-switch\n              v-model=\"displayUnviewedControls\"\n              label=\"Show Only Unviewed\"\n            />\n          </v-col>\n          <v-col cols=\"3\" md=\"auto\" class=\"text-right pb-0\">\n            <v-switch v-model=\"syncTabs\" label=\"Sync Tabs\" />\n          </v-col>\n          <v-col cols=\"3\" md=\"auto\" class=\"text-right pb-0\">\n            <v-switch\n              v-model=\"singleExpand\"\n              label=\"Single Expand\"\n              @change=\"handleToggleSingleExpand\"\n            />\n          </v-col>\n          <v-col cols=\"3\" md=\"auto\" class=\"text-right pb-0\">\n            <v-switch v-model=\"expandAll\" label=\"Expand All\" class=\"mr-5\" />\n          </v-col>\n        </v-row>\n      </v-row>\n\n      <!-- Header. This should mirror the structure of ControlRowHeader -->\n      <ResponsiveRowSwitch>\n        <template #status>\n          <ColumnHeader\n            text=\"Status\"\n            :sort=\"sortStatus\"\n            @input=\"set_sort('status', $event)\"\n          />\n        </template>\n\n        <template #set>\n          <ColumnHeader\n            text=\"Result Set\"\n            :sort=\"sortSet\"\n            @input=\"set_sort('set', $event)\"\n          />\n        </template>\n\n        <template #id>\n          <ColumnHeader\n            text=\"ID\"\n            :sort=\"sortId\"\n            @input=\"set_sort('id', $event)\"\n          />\n        </template>\n\n        <template #severity>\n          <ColumnHeader\n            :text=\"showImpact ? 'Impact' : 'Severity'\"\n            :sort=\"sortSeverity\"\n            @input=\"set_sort('severity', $event)\"\n          />\n        </template>\n\n        <template #title>\n          <ColumnHeader text=\"Title\" sort=\"disabled\" />\n        </template>\n\n        <template #tags>\n          <ColumnHeader text=\"800-53 Controls & CCIs\" sort=\"disabled\" />\n        </template>\n\n        <template #runTime>\n          <ColumnHeader\n            text=\"Run Time\"\n            :sort=\"sortRunTime\"\n            @input=\"set_sort('runTime', $event)\"\n          />\n        </template>\n\n        <template #viewed class=\"my-2 px-1\">\n          <ColumnHeader\n            text=\"Controls Viewed\"\n            sort=\"disabled\"\n            :viewed-header=\"true\"\n            :number-of-viewed-controls=\"viewedControlIds.length\"\n            :number-of-all-controls=\"raw_items.length\"\n          />\n        </template>\n      </ResponsiveRowSwitch>\n    </div>\n\n    <!-- Body -->\n    <v-lazy\n      v-for=\"item in items\"\n      :key=\"item.key\"\n      min-height=\"50\"\n      transition=\"fade-transition\"\n    >\n      <div :id=\"striptoChars(item.key)\">\n        <ControlRowHeader\n          :class=\"$vuetify.breakpoint.smAndDown ? '' : 'pinned-header'\"\n          :style=\"controlRowPinOffset\"\n          :control=\"item.control\"\n          :expanded=\"expanded.includes(item.key)\"\n          :show-impact=\"showImpact\"\n          :viewed-controls=\"viewedControlIds\"\n          @toggle=\"toggle(item.key)\"\n          @control-viewed=\"toggleControlViewed\"\n        />\n        <ControlRowDetails\n          v-if=\"expanded.includes(item.key)\"\n          :control=\"item.control\"\n          :tab=\"syncTabs ? syncTab : undefined\"\n          @update:tab=\"updateTab\"\n        />\n      </div>\n    </v-lazy>\n  </v-container>\n</template>\n\n<script lang=\"ts\">\nimport ControlRowDetails from '@/components/cards/controltable/ControlRowDetails.vue';\nimport ControlRowHeader, {\n  getControlRunTime\n} from '@/components/cards/controltable/ControlRowHeader.vue';\nimport ResponsiveRowSwitch from '@/components/cards/controltable/ResponsiveRowSwitch.vue';\nimport ColumnHeader, {Sort} from '@/components/generic/ColumnHeader.vue';\nimport {Filter, FilteredDataModule} from '@/store/data_filters';\nimport {HeightsModule} from '@/store/heights';\nimport {control_unique_key} from '@/utilities/format_util';\nimport {ContextualizedControl} from 'inspecjs';\nimport _ from 'lodash';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\nimport {Prop, Ref} from 'vue-property-decorator';\n\n// Tracks the visibility of an HDF control\ninterface ListElt {\n  // A unique id to be used as a key.\n  key: string;\n\n  filename: string;\n\n  // Computed values for status and severity \"value\", for sorting\n  status_val: number;\n  severity_val: number;\n\n  control: ContextualizedControl;\n}\n\n@Component({\n  components: {\n    ControlRowHeader,\n    ControlRowDetails,\n    ColumnHeader,\n    ResponsiveRowSwitch\n  }\n})\nexport default class ControlTable extends Vue {\n  @Ref('controlTableTitle') readonly controlTableTitle!: Element;\n  @Prop({type: Object, required: true}) readonly filter!: Filter;\n  @Prop({type: Boolean, required: true}) readonly showImpact!: boolean;\n\n  // Whether to allow multiple expansions\n  singleExpand = true;\n\n  // If the currently selected tab should sync\n  syncTabs = false;\n  syncTab = 'tab-test';\n\n  // List of currently expanded options. If unique id is in here, it is expanded\n  expanded: Array<string> = [];\n\n  // Sorts\n  sortId: Sort = 'none';\n  sortStatus: Sort = 'none';\n  sortSet: Sort = 'none';\n  sortSeverity: Sort = 'none';\n  sortRunTime: Sort = 'none';\n\n  // Used for viewed/unviewed controls.\n  viewedControlIds: string[] = [];\n  displayUnviewedControls = true;\n\n  toggleControlViewed(control: ContextualizedControl) {\n    const alreadyViewed = this.viewedControlIds.indexOf(control.data.id);\n    // If the control hasn't been marked as viewed yet, mark it as viewed.\n    if (alreadyViewed === -1) {\n      this.viewedControlIds.push(control.data.id);\n    }\n    // Else, remove it from the view controls array.\n    else {\n      this.viewedControlIds.splice(alreadyViewed, 1);\n    }\n  }\n\n  mounted() {\n    this.onResize();\n  }\n\n  onResize() {\n    // Allow the page to settle before checking the controlTableHeader height\n    // (this is what $nextTick is supposed to do but it's firing too quickly)\n    setTimeout(() => {\n      HeightsModule.setControlTableHeaderHeight(\n        this.controlTableTitle?.clientHeight\n      );\n    }, 2000);\n  }\n\n  /** Callback to handle setting a new sort */\n  set_sort(column: string, newSort: Sort) {\n    this.sortId = 'none';\n    this.sortSet = 'none';\n    this.sortStatus = 'none';\n    this.sortSeverity = 'none';\n    this.sortRunTime = 'none';\n    switch (column) {\n      case 'id':\n        this.sortId = newSort;\n        break;\n      case 'status':\n        this.sortStatus = newSort;\n        break;\n      case 'set':\n        this.sortSet = newSort;\n        break;\n      case 'severity':\n        this.sortSeverity = newSort;\n        break;\n      case 'runTime':\n        this.sortRunTime = newSort;\n        break;\n    }\n  }\n\n  get expandAll() {\n    return this.expanded.length === this.items.length;\n  }\n\n  set expandAll(value: boolean) {\n    if (value) {\n      this.singleExpand = false;\n      this.expanded = this.items.map((items) => items.key);\n    } else {\n      this.expanded = [];\n    }\n  }\n\n  get controlTableTitleStyle() {\n    return {top: `${HeightsModule.topbarHeight}px`};\n  }\n\n  get controlRowPinOffset() {\n    // There is ~10px of padding being added which makes the ControlRowHeader look out of place\n    return {top: `${this.topOfPage - 10}px`};\n  }\n\n  // The top of the page, relative to the topbar and the title bar\n  get topOfPage() {\n    return HeightsModule.topbarHeight + HeightsModule.controlTableHeaderHeight;\n  }\n\n  /** Closes all open controls when single-expand is re-enabled */\n  async handleToggleSingleExpand(singleExpand: boolean): Promise<void> {\n    if (singleExpand) {\n      this.expandAll = false;\n    }\n  }\n\n  async updateTab(tab: string) {\n    this.syncTab = tab;\n  }\n\n  /** Toggles the given expansion of a control details panel */\n  toggle(key: string) {\n    if (this.singleExpand) {\n      // Check if key already there\n      const had = this.expanded.includes(key);\n\n      // Clear\n      this.expanded = [];\n\n      // If key is new, add it\n      if (!had) {\n        this.expanded.push(key);\n        this.jump_to_key(key);\n      }\n    } else {\n      // Add or remove it from the set, as appropriate. Shortcut this by only adding if delete fails\n      const i = this.expanded.indexOf(key);\n      if (i < 0) {\n        this.expanded.push(key);\n        this.jump_to_key(key);\n      } else {\n        this.expanded.splice(i, 1);\n      }\n    }\n  }\n\n  jump_to_key(key: string) {\n    if (!this.$vuetify.breakpoint.smAndDown) {\n      this.$nextTick(() => {\n        this.$vuetify.goTo(`#${this.striptoChars(key)}`, {\n          offset: this.topOfPage,\n          duration: 300\n        });\n      });\n    }\n  }\n\n  striptoChars(key: string) {\n    return key.replace(/[^a-z0-9]/gi, '');\n  }\n\n  /** Return items as key, value pairs */\n  get raw_items(): ListElt[] {\n    return FilteredDataModule.controls(this.filter).map((d) => {\n      const key = control_unique_key(d);\n\n      // File, hdf wrapper\n      return {\n        key,\n        control: d,\n        status_val: [\n          'Passed',\n          'Not Applicable',\n          'No Data',\n          'Not Reviewed',\n          'Profile Error',\n          'Failed'\n        ].indexOf(d.root.hdf.status),\n        severity_val: ['none', 'low', 'medium', 'high', 'critical'].indexOf(\n          d.root.hdf.severity\n        ),\n        filename: _.get(d, 'sourcedFrom.sourcedFrom.from_file.filename')\n      };\n    });\n  }\n\n  /** Return items sorted and filters out viewed controls */\n  get items(): ListElt[] {\n    // Controls ascending/descending\n    let factor = 1;\n    // Whether or not we need to sort\n    let sort = true;\n    // Our comparator function\n    let cmp: (a: ListElt, b: ListElt) => number;\n\n    let items = this.raw_items;\n\n    if (this.sortId === 'ascending' || this.sortId === 'descending') {\n      cmp = (a: ListElt, b: ListElt) =>\n        a.control.data.id.localeCompare(b.control.data.id);\n      if (this.sortId === 'ascending') {\n        factor = -1;\n      }\n    } else if (\n      this.sortStatus === 'ascending' ||\n      this.sortStatus === 'descending'\n    ) {\n      cmp = (a: ListElt, b: ListElt) => a.status_val - b.status_val;\n      if (this.sortStatus === 'ascending') {\n        factor = -1;\n      }\n    } else if (\n      this.sortSeverity === 'ascending' ||\n      this.sortSeverity === 'descending'\n    ) {\n      cmp = (a: ListElt, b: ListElt) => a.severity_val - b.severity_val;\n      if (this.sortSeverity === 'ascending') {\n        factor = -1;\n      }\n    } else if (this.sortSet === 'ascending' || this.sortSet === 'descending') {\n      cmp = (a: ListElt, b: ListElt) => a.filename.localeCompare(b.filename);\n      if (this.sortSet === 'ascending') {\n        factor = -1;\n      }\n    } else if (\n      this.sortRunTime === 'ascending' ||\n      this.sortRunTime === 'descending'\n    ) {\n      cmp = (a: ListElt, b: ListElt) =>\n        getControlRunTime(b.control) - getControlRunTime(a.control);\n      if (this.sortRunTime === 'ascending') {\n        factor = -1;\n      }\n    } else {\n      sort = false;\n    }\n\n    // Displays only unviewed controls.\n    if (this.displayUnviewedControls) {\n      items = items.filter(\n        (val) => !this.viewedControlIds.includes(val.control.data.id)\n      );\n    }\n\n    if (sort === true) {\n      items = items.sort((a, b) => cmp(a, b) * factor);\n    }\n\n    return items;\n  }\n}\n</script>\n\n<style scoped>\n.pinned-header {\n  position: sticky;\n  z-index: 2;\n  padding-top: 2px;\n  padding-bottom: 2px;\n}\n\n.control-table-title {\n  background-color: var(--v-secondary-lighten1);\n  z-index: 10;\n}\n</style>\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/components/global/upload_tabs/aws/AuthStepBasic.vue": "<template>\n  <v-stepper-content step=\"1\">\n    <v-form v-model=\"valid\">\n      <v-text-field\n        :value=\"accessToken\"\n        label=\"User Account Access Token\"\n        lazy-validation=\"lazy\"\n        :rules=\"[reqRule]\"\n        @input=\"change_access_token\"\n      />\n      <v-text-field\n        :value=\"secretToken\"\n        label=\"User Account Secret Token\"\n        type=\"password\"\n        :rules=\"[reqRule]\"\n        @input=\"change_secret_token\"\n      />\n    </v-form>\n    <v-btn\n      color=\"primary\"\n      :disabled=\"!valid\"\n      class=\"my-2 mr-3\"\n      @click=\"$emit('auth-basic')\"\n    >\n      Basic Login\n    </v-btn>\n    <v-btn\n      color=\"green\"\n      :disabled=\"!valid\"\n      class=\"my-2 mr-3\"\n      @click=\"$emit('goto-mfa')\"\n    >\n      MFA Login\n    </v-btn>\n  </v-stepper-content>\n</template>\n\n<script lang=\"ts\">\nimport FileList from '@/components/global/upload_tabs/aws/FileList.vue';\nimport {LocalStorageVal} from '@/utilities/helper_util';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\nimport {Prop} from 'vue-property-decorator';\n\n/** Localstorage keys */\nconst localAccessToken = new LocalStorageVal<string>('aws_s3_access_token');\nconst localSecretToken = new LocalStorageVal<string>('aws_s3_secret_token');\n\n/**\n * File reader component for taking in inspec JSON data.\n * Uploads data to the store with unique IDs asynchronously as soon as data is entered.\n * Emits \"got-files\" with a list of the unique_ids of the loaded files.\n */\n@Component({\n  components: {\n    FileList\n  }\n})\nexport default class S3Reader extends Vue {\n  @Prop({type: String}) readonly accessToken!: string;\n  @Prop({type: String}) readonly secretToken!: string;\n\n  /** Models if currently displayed form is valid.\n   * Shouldn't be used to interpret literally anything else as valid - just checks fields filled\n   */\n  valid = false;\n\n  /** Form required field rules. Maybe eventually expand to other stuff */\n  reqRule = (v: string | null | undefined) =>\n    (v || '').trim().length > 0 || 'Field is Required';\n\n  // Callback for change in access token\n  change_access_token(token: string) {\n    localAccessToken.set(token);\n    this.$emit('update:accessToken', token);\n  }\n\n  // Callback for change in secret token\n  change_secret_token(token: string) {\n    localSecretToken.set(token);\n    this.$emit('update:secretToken', token);\n  }\n\n  /** On mount, try to look up stored auth info */\n  mounted() {\n    // Load our credentials\n    this.change_access_token(localAccessToken.get_default(''));\n    this.change_secret_token(localSecretToken.get_default(''));\n  }\n}\n</script>\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/components/global/upload_tabs/aws/AuthStepMFA.vue": "<template>\n  <v-stepper-content step=\"2\">\n    <v-form v-model=\"valid\">\n      <v-text-field\n        :value=\"mfaToken\"\n        label=\"MFA Token\"\n        :rules=\"[reqRule, mfaRule]\"\n        @input=\"change_mfa_token\"\n        @keyup.enter=\"proceed\"\n      />\n      <v-text-field\n        :value=\"mfaSerial\"\n        label=\"MFA Device ARN (Optional)\"\n        hint=\"Defaults to virtual IAM device\"\n        @input=\"changeMFASerial\"\n        @keyup.enter=\"proceed\"\n      />\n      <v-btn\n        color=\"primary\"\n        :disabled=\"!valid\"\n        class=\"my-2 mr-2\"\n        @click=\"$emit('auth-mfa')\"\n      >\n        Login\n      </v-btn>\n      <v-btn color=\"red\" class=\"my-2 ml-2\" @click=\"proceed\"> Cancel </v-btn>\n    </v-form>\n  </v-stepper-content>\n</template>\n\n<script lang=\"ts\">\nimport {LocalStorageVal} from '@/utilities/helper_util';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\nimport {PropSync} from 'vue-property-decorator';\n\n/** Localstorage keys */\nconst localMFASerial = new LocalStorageVal<string>('aws_s3_mfa_serial');\n\n/**\n * File reader component for taking in inspec JSON data.\n * Uploads data to the store with unique IDs asynchronously as soon as data is entered.\n * Emits \"got-files\" with a list of the unique_ids of the loaded files.\n */\n@Component\nexport default class S3Reader extends Vue {\n  @PropSync('mfaToken', {type: String}) token!: string;\n  @PropSync('mfaSerial', {type: String}) serial!: string;\n  /** Models if currently displayed form is valid.\n   * Shouldn't be used to interpret literally anything else as valid - just checks fields filled\n   */\n  valid = false;\n\n  /** Form required field rules. Maybe eventually expand to other stuff */\n  reqRule = (v: string | null | undefined) =>\n    (v || '').trim().length > 0 || 'Field is Required';\n\n  mfaRule = (v: string | null | undefined) =>\n    (v || '').trim().match('^\\\\d{6}$') !== null ||\n    'Field must be the 6 number code from a valid authenticator device';\n\n  /** On mount, try to look up stored auth info */\n  mounted() {\n    this.changeMFASerial(localMFASerial.get_default(''));\n  }\n\n  /** Handles changes to mfa serial */\n  change_mfa_token(newValue: string) {\n    this.token = newValue;\n  }\n\n  /** Handles changes to mfa token */\n  changeMFASerial(newValue: string) {\n    localMFASerial.set(newValue);\n    this.serial = newValue;\n  }\n\n  /** When button is pressed or enter is pressed */\n  proceed() {\n    this.$emit('exit-mfa');\n  }\n}\n</script>\n\n",
  "/api/sources/raw?key=test:libs/hdf-converters/src/base-converter.ts": "import {createHash} from 'crypto';\nimport * as htmlparser from 'htmlparser2';\nimport {ExecJSON} from 'inspecjs';\nimport _ from 'lodash';\n\nexport interface ILookupPath {\n  path?: string;\n  transformer?: (value: unknown) => unknown;\n  arrayTransformer?: (value: unknown[], file: unknown) => unknown[];\n  key?: string;\n}\n\nexport type ObjectEntries<T> = {[K in keyof T]: readonly [K, T[K]]}[keyof T];\n/* eslint-disable @typescript-eslint/ban-types */\nexport type MappedTransform<T, U extends ILookupPath> = {\n  [K in keyof T]: Exclude<T[K], undefined | null> extends Array<any>\n    ? MappedTransform<T[K], U>\n    : T[K] extends Function\n    ? T[K]\n    : T[K] extends object\n    ? MappedTransform<\n        T[K] &\n          (U & {\n            arrayTransformer?: (\n              value: unknown[],\n              file: Record<string, unknown>\n            ) => T[K][];\n          }),\n        U\n      >\n    : T[K] | (U & {transformer?: (value: unknown) => T[K]});\n};\nexport type MappedReform<T, U> = {\n  [K in keyof T]: Exclude<T[K], undefined | null> extends Array<any>\n    ? MappedReform<T[K], U>\n    : T[K] extends object\n    ? MappedReform<T[K] & U, U>\n    : Exclude<T[K], U>;\n};\n/* eslint-enable @typescript-eslint/ban-types */\n\n// Hashing Function\nexport function generateHash(data: string, algorithm = 'sha256'): string {\n  const hash = createHash(algorithm);\n  return hash.update(data).digest('hex');\n}\n\nexport function parseHtml(input: unknown): string {\n  const textData: string[] = [];\n  const myParser = new htmlparser.Parser({\n    ontext(text: string) {\n      textData.push(text);\n    }\n  });\n  if (typeof input === 'string') {\n    myParser.write(input);\n  }\n  return textData.join('');\n}\nexport function impactMapping(\n  mapping: Map<string, number>\n): (severity: unknown) => number {\n  return (severity: unknown): number => {\n    if (typeof severity === 'string' || typeof severity === 'number') {\n      return mapping.get(severity.toString().toLowerCase()) || 0;\n    } else {\n      return 0;\n    }\n  };\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction collapseDuplicates<T extends object>(\n  array: Array<T>,\n  key: string,\n  collapseResults: boolean\n): Array<T> {\n  const seen = new Map<string, number>();\n  const newArray: T[] = [];\n  let counter = 0;\n  array.forEach((item: T) => {\n    const propertyValue = _.get(item, key);\n    if (typeof propertyValue === 'string') {\n      const index = seen.get(propertyValue) || 0;\n      if (!seen.has(propertyValue)) {\n        newArray.push(item);\n        seen.set(propertyValue, counter);\n        counter++;\n      } else {\n        const oldResult = _.get(\n          newArray[index],\n          'results'\n        ) as ExecJSON.ControlResult[];\n        const descriptions = oldResult.map((element) =>\n          _.get(element, 'code_desc')\n        );\n        if (collapseResults) {\n          if (\n            descriptions.indexOf(\n              _.get(item, 'results[0].code_desc') as string\n            ) === -1\n          ) {\n            _.set(\n              newArray[index],\n              'results',\n              oldResult.concat(\n                _.get(item, 'results') as ExecJSON.ControlResult[]\n              )\n            );\n          }\n        } else {\n          _.set(\n            newArray[index],\n            'results',\n            oldResult.concat(_.get(item, 'results') as ExecJSON.ControlResult[])\n          );\n        }\n      }\n    }\n  });\n  return newArray;\n}\nexport class BaseConverter {\n  data: Record<string, unknown>;\n  mappings?: MappedTransform<ExecJSON.Execution, ILookupPath>;\n  collapseResults: boolean;\n\n  constructor(data: Record<string, unknown>, collapseResults = false) {\n    this.data = data;\n    this.collapseResults = collapseResults;\n  }\n  setMappings(\n    mappings: MappedTransform<ExecJSON.Execution, ILookupPath>\n  ): void {\n    this.mappings = mappings;\n  }\n  toHdf(): ExecJSON.Execution {\n    if (this.mappings === undefined) {\n      throw new Error('Mappings must be provided');\n    } else {\n      const v = this.convertInternal(this.data, this.mappings);\n      v.profiles.forEach((element) => {\n        element.sha256 = generateHash(JSON.stringify(element));\n      });\n      return v;\n    }\n  }\n\n  objectMap<T, V>(obj: T, fn: (v: ObjectEntries<T>) => V): {[K in keyof T]: V} {\n    return Object.fromEntries(\n      Object.entries(obj).map(([k, v]) => [k, fn(v)])\n    ) as Record<keyof T, V>;\n  }\n  convertInternal<T>(\n    file: Record<string, unknown>,\n    fields: T\n  ): MappedReform<T, ILookupPath> {\n    const result = this.objectMap(fields, (v: ObjectEntries<T>) =>\n      this.evaluate(file, v)\n    );\n    return result as MappedReform<T, ILookupPath>;\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  evaluate<T extends object>(\n    file: Record<string, unknown>,\n    v: Array<T> | T\n  ): T | Array<T> | MappedReform<T, ILookupPath> {\n    const transformer = _.get(v, 'transformer');\n    if (Array.isArray(v)) {\n      return this.handleArray(file, v);\n    } else if (\n      typeof v === 'string' ||\n      typeof v === 'number' ||\n      typeof v === 'boolean' ||\n      v === null\n    ) {\n      return v;\n    } else if (_.has(v, 'path')) {\n      if (typeof transformer === 'function') {\n        return transformer(this.handlePath(file, _.get(v, 'path') as string));\n      }\n      const pathVal = this.handlePath(file, _.get(v, 'path') as string);\n      if (Array.isArray(pathVal)) {\n        return pathVal as T[];\n      }\n      return pathVal as T;\n    }\n    if (typeof transformer === 'function') {\n      return transformer(file);\n    } else {\n      return this.convertInternal(file, v);\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  handleArray<T extends object>(\n    file: Record<string, unknown>,\n    v: Array<T & ILookupPath>\n  ): Array<T> {\n    if (v.length === 0) {\n      return [];\n    }\n    if (v[0].path === undefined) {\n      const arrayTransformer = v[0].arrayTransformer;\n      v = v.map((element) => {\n        return _.omit(element, ['arrayTransformer']) as T & ILookupPath;\n      });\n      let output: Array<T> = [];\n      v.forEach((element) => {\n        output.push(this.evaluate(file, element) as T);\n      });\n      if (arrayTransformer !== undefined) {\n        output = arrayTransformer(output, this.data) as T[];\n      }\n      return output;\n    } else {\n      const path = v[0].path;\n      const key = v[0].key;\n      const arrayTransformer = v[0].arrayTransformer;\n      const transformer = v[0].transformer;\n      if (this.hasPath(file, path)) {\n        const pathVal = this.handlePath(file, path);\n        if (Array.isArray(pathVal)) {\n          v = pathVal.map((element: Record<string, unknown>) => {\n            return _.omit(this.convertInternal(element, v[0]), [\n              'path',\n              'transformer',\n              'arrayTransformer',\n              'key'\n            ]) as T;\n          });\n          if (key !== undefined) {\n            v = collapseDuplicates(v, key, this.collapseResults);\n          }\n          if (arrayTransformer !== undefined) {\n            v = arrayTransformer(v, this.data) as T[];\n          }\n          return v;\n        } else {\n          if (transformer !== undefined) {\n            return [transformer(this.handlePath(file, path)) as T];\n          } else {\n            return [this.handlePath(file, path) as T];\n          }\n        }\n      } else {\n        return [];\n      }\n    }\n  }\n  handlePath(file: Record<string, unknown>, path: string): unknown {\n    if (path.startsWith('$.')) {\n      return _.get(this.data, path.slice(2)) || '';\n    } else {\n      return _.get(file, path) || '';\n    }\n  }\n  hasPath(file: Record<string, unknown>, path: string): boolean {\n    if (path.startsWith('$.')) {\n      return _.has(this.data, path.slice(2));\n    } else {\n      return _.has(file, path);\n    }\n  }\n}\n\n",
  "/api/sources/raw?key=test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts": "// To parse this data:\n//\n//   import { Convert, ExecJSON } from \"./file\";\n//\n//   const execJSON = Convert.toExecJSON(json);\n//\n// These functions will throw an error if the JSON doesn't\n// match the expected interface, even if the JSON is valid.\n\nexport interface ExecJSON {\n    platform:   Platform;\n    profiles:   ExecJSONProfile[];\n    statistics: Statistics;\n    version:    string;\n}\n\nexport interface Platform {\n    /**\n     * The name of the platform this was run on.\n     */\n    name: string;\n    /**\n     * The version of the platform this was run on.\n     */\n    release:    string;\n    target_id?: null | string;\n}\n\nexport interface ExecJSONProfile {\n    attributes:       { [key: string]: any }[];\n    controls:         ExecJSONControl[];\n    copyright?:       null | string;\n    copyright_email?: null | string;\n    depends?:         Dependency[] | null;\n    description?:     null | string;\n    groups:           ControlGroup[];\n    inspec_version?:  null | string;\n    license?:         null | string;\n    maintainer?:      null | string;\n    name:             string;\n    parent_profile?:  null | string;\n    sha256:           string;\n    skip_message?:    null | string;\n    status?:          null | string;\n    status_message?:  null | string;\n    summary?:         null | string;\n    supports:         SupportedPlatform[];\n    title?:           null | string;\n    version?:         null | string;\n}\n\nexport interface ExecJSONControl {\n    /**\n     * The raw source code of the control. Note that if this is an overlay control, it does not\n     * include the underlying source code\n     */\n    code?:         null | string;\n    desc?:         null | string;\n    descriptions?: ControlDescription[] | null;\n    /**\n     * The ID of this control\n     */\n    id:     string;\n    impact: number;\n    refs:   Reference[];\n    /**\n     * A list of all results of the controls describe blocks.\n     *\n     * For instance, if in the controls code we had the following:\n     * describe sshd_config do\n     * its('Port') { should cmp 22 }\n     * end\n     * The result of this block as a ControlResult would be appended to the results list.\n     */\n    results:         ControlResult[];\n    source_location: SourceLocation;\n    tags:            { [key: string]: any };\n    title?:          null | string;\n    waiver_data?:    null | WaiverData;\n}\n\nexport interface ControlDescription {\n    data:  string;\n    label: string;\n}\n\nexport interface Reference {\n    ref?: { [key: string]: any }[] | string;\n    url?: string;\n    uri?: string;\n}\n\nexport interface ControlResult {\n    backtrace?:    string[] | null;\n    code_desc:     string;\n    exception?:    null | string;\n    message?:      null | string;\n    resource?:     null | string;\n    run_time?:     number | null;\n    skip_message?: null | string;\n    start_time:    string;\n    status?:       ControlResultStatus | null;\n}\n\nexport enum ControlResultStatus {\n    Error = \"error\",\n    Failed = \"failed\",\n    Passed = \"passed\",\n    Skipped = \"skipped\",\n}\n\nexport interface SourceLocation {\n    /**\n     * The line at which this statement is located in the file\n     */\n    line?: number | null;\n    /**\n     * Path to the file that this statement originates from\n     */\n    ref?: null | string;\n}\n\nexport interface WaiverData {\n    expiration_date?:       null | string;\n    justification?:         null | string;\n    message?:               null | string;\n    run?:                   boolean | null;\n    skipped_due_to_waiver?: boolean | null | string;\n}\n\nexport interface Dependency {\n    branch?:         null | string;\n    compliance?:     null | string;\n    git?:            null | string;\n    name?:           null | string;\n    path?:           null | string;\n    status?:         null | string;\n    status_message?: null | string;\n    supermarket?:    null | string;\n    url?:            null | string;\n}\n\nexport interface ControlGroup {\n    /**\n     * The control IDs in this group\n     */\n    controls: string[];\n    /**\n     * The unique identifier of the group\n     */\n    id: string;\n    /**\n     * The name of the group\n     */\n    title?: null | string;\n}\n\nexport interface SupportedPlatform {\n    \"os-family\"?:       null | string;\n    \"os-name\"?:         null | string;\n    platform?:          null | string;\n    \"platform-family\"?: null | string;\n    \"platform-name\"?:   null | string;\n    release?:           null | string;\n}\n\nexport interface Statistics {\n    controls?: null | StatisticHash;\n    /**\n     * How long (in seconds) this inspec exec ran for.\n     */\n    duration?: number | null;\n}\n\n/**\n * Breakdowns of control statistics by result\n */\nexport interface StatisticHash {\n    failed?:  null | StatisticBlock;\n    passed?:  null | StatisticBlock;\n    skipped?: null | StatisticBlock;\n}\n\nexport interface StatisticBlock {\n    /**\n     * Total number of controls (in this category) for this inspec execution.\n     */\n    total: number;\n}\n\n// Converts JSON strings to/from your types\n// and asserts the results of JSON.parse at runtime\nexport class Convert {\n    public static toExecJSON(json: string): ExecJSON {\n        return cast(JSON.parse(json), r(\"ExecJSON\"));\n    }\n\n    public static execJSONToJson(value: ExecJSON): string {\n        return JSON.stringify(uncast(value, r(\"ExecJSON\")), null, 2);\n    }\n}\n\nfunction invalidValue(typ: any, val: any, key: any = ''): never {\n    if (key) {\n        throw Error(`Invalid value for key \"${key}\". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);\n    }\n    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );\n}\n\nfunction jsonToJSProps(typ: any): any {\n    if (typ.jsonToJS === undefined) {\n        const map: any = {};\n        typ.props.forEach((p: any) => map[p.json] = { key: p.js, typ: p.typ });\n        typ.jsonToJS = map;\n    }\n    return typ.jsonToJS;\n}\n\nfunction jsToJSONProps(typ: any): any {\n    if (typ.jsToJSON === undefined) {\n        const map: any = {};\n        typ.props.forEach((p: any) => map[p.js] = { key: p.json, typ: p.typ });\n        typ.jsToJSON = map;\n    }\n    return typ.jsToJSON;\n}\n\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }\n\n    function transformUnion(typs: any[], val: any): any {\n        // val must validate against one typ in typs\n        const l = typs.length;\n        for (let i = 0; i < l; i++) {\n            const typ = typs[i];\n            try {\n                return transform(val, typ, getProps);\n            } catch (_) {}\n        }\n        return invalidValue(typs, val);\n    }\n\n    function transformEnum(cases: string[], val: any): any {\n        if (cases.indexOf(val) !== -1) return val;\n        return invalidValue(cases, val);\n    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));\n    }\n\n    function transformDate(val: any): any {\n        if (val === null) {\n            return null;\n        }\n        const d = new Date(val);\n        if (isNaN(d.valueOf())) {\n            return invalidValue(\"Date\", val);\n        }\n        return d;\n    }\n\n    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {\n        if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n            return invalidValue(\"object\", val);\n        }\n        const result: any = {};\n        Object.getOwnPropertyNames(props).forEach(key => {\n            const prop = props[key];\n            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;\n            result[prop.key] = transform(v, prop.typ, getProps, prop.key);\n        });\n        Object.getOwnPropertyNames(val).forEach(key => {\n            if (!Object.prototype.hasOwnProperty.call(props, key)) {\n                result[key] = transform(val[key], additional, getProps, key);\n            }\n        });\n        return result;\n    }\n\n    if (typ === \"any\") return val;\n    if (typ === null) {\n        if (val === null) return val;\n        return invalidValue(typ, val);\n    }\n    if (typ === false) return invalidValue(typ, val);\n    while (typeof typ === \"object\" && typ.ref !== undefined) {\n        typ = typeMap[typ.ref];\n    }\n    if (Array.isArray(typ)) return transformEnum(typ, val);\n    if (typeof typ === \"object\") {\n        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);\n    return transformPrimitive(typ, val);\n}\n\nfunction cast<T>(val: any, typ: any): T {\n    return transform(val, typ, jsonToJSProps);\n}\n\nfunction uncast<T>(val: T, typ: any): any {\n    return transform(val, typ, jsToJSONProps);\n}\n\nfunction a(typ: any) {\n    return { arrayItems: typ };\n}\n\nfunction u(...typs: any[]) {\n    return { unionMembers: typs };\n}\n\nfunction o(props: any[], additional: any) {\n    return { props, additional };\n}\n\nfunction m(additional: any) {\n    return { props: [], additional };\n}\n\nfunction r(name: string) {\n    return { ref: name };\n}\n\nconst typeMap: any = {\n    \"ExecJSON\": o([\n        { json: \"platform\", js: \"platform\", typ: r(\"Platform\") },\n        { json: \"profiles\", js: \"profiles\", typ: a(r(\"ExecJSONProfile\")) },\n        { json: \"statistics\", js: \"statistics\", typ: r(\"Statistics\") },\n        { json: \"version\", js: \"version\", typ: \"\" },\n    ], \"any\"),\n    \"Platform\": o([\n        { json: \"name\", js: \"name\", typ: \"\" },\n        { json: \"release\", js: \"release\", typ: \"\" },\n        { json: \"target_id\", js: \"target_id\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"ExecJSONProfile\": o([\n        { json: \"attributes\", js: \"attributes\", typ: a(m(\"any\")) },\n        { json: \"controls\", js: \"controls\", typ: a(r(\"ExecJSONControl\")) },\n        { json: \"copyright\", js: \"copyright\", typ: u(undefined, u(null, \"\")) },\n        { json: \"copyright_email\", js: \"copyright_email\", typ: u(undefined, u(null, \"\")) },\n        { json: \"depends\", js: \"depends\", typ: u(undefined, u(a(r(\"Dependency\")), null)) },\n        { json: \"description\", js: \"description\", typ: u(undefined, u(null, \"\")) },\n        { json: \"groups\", js: \"groups\", typ: a(r(\"ControlGroup\")) },\n        { json: \"inspec_version\", js: \"inspec_version\", typ: u(undefined, u(null, \"\")) },\n        { json: \"license\", js: \"license\", typ: u(undefined, u(null, \"\")) },\n        { json: \"maintainer\", js: \"maintainer\", typ: u(undefined, u(null, \"\")) },\n        { json: \"name\", js: \"name\", typ: \"\" },\n        { json: \"parent_profile\", js: \"parent_profile\", typ: u(undefined, u(null, \"\")) },\n        { json: \"sha256\", js: \"sha256\", typ: \"\" },\n        { json: \"skip_message\", js: \"skip_message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"status\", js: \"status\", typ: u(undefined, u(null, \"\")) },\n        { json: \"status_message\", js: \"status_message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"summary\", js: \"summary\", typ: u(undefined, u(null, \"\")) },\n        { json: \"supports\", js: \"supports\", typ: a(r(\"SupportedPlatform\")) },\n        { json: \"title\", js: \"title\", typ: u(undefined, u(null, \"\")) },\n        { json: \"version\", js: \"version\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"ExecJSONControl\": o([\n        { json: \"code\", js: \"code\", typ: u(undefined, u(null, \"\")) },\n        { json: \"desc\", js: \"desc\", typ: u(undefined, u(null, \"\")) },\n        { json: \"descriptions\", js: \"descriptions\", typ: u(undefined, u(a(r(\"ControlDescription\")), null)) },\n        { json: \"id\", js: \"id\", typ: \"\" },\n        { json: \"impact\", js: \"impact\", typ: 3.14 },\n        { json: \"refs\", js: \"refs\", typ: a(r(\"Reference\")) },\n        { json: \"results\", js: \"results\", typ: a(r(\"ControlResult\")) },\n        { json: \"source_location\", js: \"source_location\", typ: r(\"SourceLocation\") },\n        { json: \"tags\", js: \"tags\", typ: m(\"any\") },\n        { json: \"title\", js: \"title\", typ: u(undefined, u(null, \"\")) },\n        { json: \"waiver_data\", js: \"waiver_data\", typ: u(undefined, u(null, r(\"WaiverData\"))) },\n    ], \"any\"),\n    \"ControlDescription\": o([\n        { json: \"data\", js: \"data\", typ: \"\" },\n        { json: \"label\", js: \"label\", typ: \"\" },\n    ], \"any\"),\n    \"Reference\": o([\n        { json: \"ref\", js: \"ref\", typ: u(undefined, u(a(m(\"any\")), \"\")) },\n        { json: \"url\", js: \"url\", typ: u(undefined, \"\") },\n        { json: \"uri\", js: \"uri\", typ: u(undefined, \"\") },\n    ], \"any\"),\n    \"ControlResult\": o([\n        { json: \"backtrace\", js: \"backtrace\", typ: u(undefined, u(a(\"\"), null)) },\n        { json: \"code_desc\", js: \"code_desc\", typ: \"\" },\n        { json: \"exception\", js: \"exception\", typ: u(undefined, u(null, \"\")) },\n        { json: \"message\", js: \"message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"resource\", js: \"resource\", typ: u(undefined, u(null, \"\")) },\n        { json: \"run_time\", js: \"run_time\", typ: u(undefined, u(3.14, null)) },\n        { json: \"skip_message\", js: \"skip_message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"start_time\", js: \"start_time\", typ: \"\" },\n        { json: \"status\", js: \"status\", typ: u(undefined, u(r(\"ControlResultStatus\"), null)) },\n    ], \"any\"),\n    \"SourceLocation\": o([\n        { json: \"line\", js: \"line\", typ: u(undefined, u(3.14, null)) },\n        { json: \"ref\", js: \"ref\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"WaiverData\": o([\n        { json: \"expiration_date\", js: \"expiration_date\", typ: u(undefined, u(null, \"\")) },\n        { json: \"justification\", js: \"justification\", typ: u(undefined, u(null, \"\")) },\n        { json: \"message\", js: \"message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"run\", js: \"run\", typ: u(undefined, u(true, null)) },\n        { json: \"skipped_due_to_waiver\", js: \"skipped_due_to_waiver\", typ: u(undefined, u(true, null, \"\")) },\n    ], \"any\"),\n    \"Dependency\": o([\n        { json: \"branch\", js: \"branch\", typ: u(undefined, u(null, \"\")) },\n        { json: \"compliance\", js: \"compliance\", typ: u(undefined, u(null, \"\")) },\n        { json: \"git\", js: \"git\", typ: u(undefined, u(null, \"\")) },\n        { json: \"name\", js: \"name\", typ: u(undefined, u(null, \"\")) },\n        { json: \"path\", js: \"path\", typ: u(undefined, u(null, \"\")) },\n        { json: \"status\", js: \"status\", typ: u(undefined, u(null, \"\")) },\n        { json: \"status_message\", js: \"status_message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"supermarket\", js: \"supermarket\", typ: u(undefined, u(null, \"\")) },\n        { json: \"url\", js: \"url\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"ControlGroup\": o([\n        { json: \"controls\", js: \"controls\", typ: a(\"\") },\n        { json: \"id\", js: \"id\", typ: \"\" },\n        { json: \"title\", js: \"title\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"SupportedPlatform\": o([\n        { json: \"os-family\", js: \"os-family\", typ: u(undefined, u(null, \"\")) },\n        { json: \"os-name\", js: \"os-name\", typ: u(undefined, u(null, \"\")) },\n        { json: \"platform\", js: \"platform\", typ: u(undefined, u(null, \"\")) },\n        { json: \"platform-family\", js: \"platform-family\", typ: u(undefined, u(null, \"\")) },\n        { json: \"platform-name\", js: \"platform-name\", typ: u(undefined, u(null, \"\")) },\n        { json: \"release\", js: \"release\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"Statistics\": o([\n        { json: \"controls\", js: \"controls\", typ: u(undefined, u(null, r(\"StatisticHash\"))) },\n        { json: \"duration\", js: \"duration\", typ: u(undefined, u(3.14, null)) },\n    ], \"any\"),\n    \"StatisticHash\": o([\n        { json: \"failed\", js: \"failed\", typ: u(undefined, u(null, r(\"StatisticBlock\"))) },\n        { json: \"passed\", js: \"passed\", typ: u(undefined, u(null, r(\"StatisticBlock\"))) },\n        { json: \"skipped\", js: \"skipped\", typ: u(undefined, u(null, r(\"StatisticBlock\"))) },\n    ], \"any\"),\n    \"StatisticBlock\": o([\n        { json: \"total\", js: \"total\", typ: 3.14 },\n    ], \"any\"),\n    \"ControlResultStatus\": [\n        \"error\",\n        \"failed\",\n        \"passed\",\n        \"skipped\",\n    ],\n};\n\n",
  "/api/sources/raw?key=test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts": "// To parse this data:\n//\n//   import { Convert, ExecJsonmin } from \"./file\";\n//\n//   const execJsonmin = Convert.toExecJsonmin(json);\n//\n// These functions will throw an error if the JSON doesn't\n// match the expected interface, even if the JSON is valid.\n\nexport interface ExecJsonmin {\n    controls:   ExecJSONMINControl[];\n    statistics: Statistics;\n    version:    string;\n}\n\nexport interface ExecJSONMINControl {\n    backtrace?:     string[] | null;\n    code_desc:      string;\n    exception?:     null | string;\n    id:             string;\n    message?:       null | string;\n    profile_id?:    null | string;\n    profile_sha256: string;\n    resource?:      null | string;\n    skip_message?:  null | string;\n    status:         string;\n}\n\nexport interface Statistics {\n    controls?: null | StatisticHash;\n    /**\n     * How long (in seconds) this inspec exec ran for.\n     */\n    duration: number;\n}\n\n/**\n * Breakdowns of control statistics by result\n */\nexport interface StatisticHash {\n    failed?:  null | StatisticBlock;\n    passed?:  null | StatisticBlock;\n    skipped?: null | StatisticBlock;\n}\n\nexport interface StatisticBlock {\n    /**\n     * Total number of controls (in this category) for this inspec execution.\n     */\n    total: number;\n}\n\n// Converts JSON strings to/from your types\n// and asserts the results of JSON.parse at runtime\nexport class Convert {\n    public static toExecJsonmin(json: string): ExecJsonmin {\n        return cast(JSON.parse(json), r(\"ExecJsonmin\"));\n    }\n\n    public static execJsonminToJson(value: ExecJsonmin): string {\n        return JSON.stringify(uncast(value, r(\"ExecJsonmin\")), null, 2);\n    }\n}\n\nfunction invalidValue(typ: any, val: any, key: any = ''): never {\n    if (key) {\n        throw Error(`Invalid value for key \"${key}\". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);\n    }\n    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );\n}\n\nfunction jsonToJSProps(typ: any): any {\n    if (typ.jsonToJS === undefined) {\n        const map: any = {};\n        typ.props.forEach((p: any) => map[p.json] = { key: p.js, typ: p.typ });\n        typ.jsonToJS = map;\n    }\n    return typ.jsonToJS;\n}\n\nfunction jsToJSONProps(typ: any): any {\n    if (typ.jsToJSON === undefined) {\n        const map: any = {};\n        typ.props.forEach((p: any) => map[p.js] = { key: p.json, typ: p.typ });\n        typ.jsToJSON = map;\n    }\n    return typ.jsToJSON;\n}\n\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }\n\n    function transformUnion(typs: any[], val: any): any {\n        // val must validate against one typ in typs\n        const l = typs.length;\n        for (let i = 0; i < l; i++) {\n            const typ = typs[i];\n            try {\n                return transform(val, typ, getProps);\n            } catch (_) {}\n        }\n        return invalidValue(typs, val);\n    }\n\n    function transformEnum(cases: string[], val: any): any {\n        if (cases.indexOf(val) !== -1) return val;\n        return invalidValue(cases, val);\n    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));\n    }\n\n    function transformDate(val: any): any {\n        if (val === null) {\n            return null;\n        }\n        const d = new Date(val);\n        if (isNaN(d.valueOf())) {\n            return invalidValue(\"Date\", val);\n        }\n        return d;\n    }\n\n    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {\n        if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n            return invalidValue(\"object\", val);\n        }\n        const result: any = {};\n        Object.getOwnPropertyNames(props).forEach(key => {\n            const prop = props[key];\n            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;\n            result[prop.key] = transform(v, prop.typ, getProps, prop.key);\n        });\n        Object.getOwnPropertyNames(val).forEach(key => {\n            if (!Object.prototype.hasOwnProperty.call(props, key)) {\n                result[key] = transform(val[key], additional, getProps, key);\n            }\n        });\n        return result;\n    }\n\n    if (typ === \"any\") return val;\n    if (typ === null) {\n        if (val === null) return val;\n        return invalidValue(typ, val);\n    }\n    if (typ === false) return invalidValue(typ, val);\n    while (typeof typ === \"object\" && typ.ref !== undefined) {\n        typ = typeMap[typ.ref];\n    }\n    if (Array.isArray(typ)) return transformEnum(typ, val);\n    if (typeof typ === \"object\") {\n        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);\n    return transformPrimitive(typ, val);\n}\n\nfunction cast<T>(val: any, typ: any): T {\n    return transform(val, typ, jsonToJSProps);\n}\n\nfunction uncast<T>(val: T, typ: any): any {\n    return transform(val, typ, jsToJSONProps);\n}\n\nfunction a(typ: any) {\n    return { arrayItems: typ };\n}\n\nfunction u(...typs: any[]) {\n    return { unionMembers: typs };\n}\n\nfunction o(props: any[], additional: any) {\n    return { props, additional };\n}\n\nfunction m(additional: any) {\n    return { props: [], additional };\n}\n\nfunction r(name: string) {\n    return { ref: name };\n}\n\nconst typeMap: any = {\n    \"ExecJsonmin\": o([\n        { json: \"controls\", js: \"controls\", typ: a(r(\"ExecJSONMINControl\")) },\n        { json: \"statistics\", js: \"statistics\", typ: r(\"Statistics\") },\n        { json: \"version\", js: \"version\", typ: \"\" },\n    ], \"any\"),\n    \"ExecJSONMINControl\": o([\n        { json: \"backtrace\", js: \"backtrace\", typ: u(undefined, u(a(\"\"), null)) },\n        { json: \"code_desc\", js: \"code_desc\", typ: \"\" },\n        { json: \"exception\", js: \"exception\", typ: u(undefined, u(null, \"\")) },\n        { json: \"id\", js: \"id\", typ: \"\" },\n        { json: \"message\", js: \"message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"profile_id\", js: \"profile_id\", typ: u(undefined, u(null, \"\")) },\n        { json: \"profile_sha256\", js: \"profile_sha256\", typ: \"\" },\n        { json: \"resource\", js: \"resource\", typ: u(undefined, u(null, \"\")) },\n        { json: \"skip_message\", js: \"skip_message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"status\", js: \"status\", typ: \"\" },\n    ], \"any\"),\n    \"Statistics\": o([\n        { json: \"controls\", js: \"controls\", typ: u(undefined, u(null, r(\"StatisticHash\"))) },\n        { json: \"duration\", js: \"duration\", typ: 3.14 },\n    ], \"any\"),\n    \"StatisticHash\": o([\n        { json: \"failed\", js: \"failed\", typ: u(undefined, u(null, r(\"StatisticBlock\"))) },\n        { json: \"passed\", js: \"passed\", typ: u(undefined, u(null, r(\"StatisticBlock\"))) },\n        { json: \"skipped\", js: \"skipped\", typ: u(undefined, u(null, r(\"StatisticBlock\"))) },\n    ], \"any\"),\n    \"StatisticBlock\": o([\n        { json: \"total\", js: \"total\", typ: 3.14 },\n    ], \"any\"),\n};\n\n",
  "/api/sources/raw?key=test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts": "// To parse this data:\n//\n//   import { Convert, ProfileJSON } from \"./file\";\n//\n//   const profileJSON = Convert.toProfileJSON(json);\n//\n// These functions will throw an error if the JSON doesn't\n// match the expected interface, even if the JSON is valid.\n\nexport interface ProfileJSON {\n    controls:         ProfileJSONControl[];\n    copyright?:       null | string;\n    copyright_email?: null | string;\n    depends?:         Dependency[] | null;\n    generator?:       null | Generator;\n    groups:           ControlGroup[];\n    inputs?:          { [key: string]: any }[] | null;\n    maintainer?:      null | string;\n    name:             string;\n    sha256:           string;\n    status?:          null | string;\n    supports:         SupportedPlatform[];\n    title?:           null | string;\n    version?:         null | string;\n}\n\nexport interface ProfileJSONControl {\n    /**\n     * The raw source code of the control. Note that if this is an overlay control, it does not\n     * include the underlying source code\n     */\n    code:          string;\n    desc?:         null | string;\n    descriptions?: { [key: string]: any } | null;\n    /**\n     * The ID of this control\n     */\n    id:               string;\n    impact:           number;\n    refs?:            Reference[] | null;\n    source_location?: null | SourceLocation;\n    tags:             { [key: string]: any };\n    title?:           null | string;\n}\n\nexport interface Reference {\n    ref?: { [key: string]: any }[] | string;\n    url?: string;\n    uri?: string;\n}\n\nexport interface SourceLocation {\n    /**\n     * The line at which this statement is located in the file\n     */\n    line?: number | null;\n    /**\n     * Path to the file that this statement originates from\n     */\n    ref?: null | string;\n}\n\nexport interface Dependency {\n    branch?:         null | string;\n    compliance?:     null | string;\n    git?:            null | string;\n    name?:           null | string;\n    path?:           null | string;\n    status?:         null | string;\n    status_message?: null | string;\n    supermarket?:    null | string;\n    url?:            null | string;\n}\n\nexport interface Generator {\n    /**\n     * The name of the software that generated this report.\n     */\n    name: string;\n    /**\n     * The version of the software that generated this report.\n     */\n    version: string;\n}\n\nexport interface ControlGroup {\n    /**\n     * The control IDs in this group\n     */\n    controls: string[];\n    /**\n     * The unique identifier of the group\n     */\n    id: string;\n    /**\n     * The name of the group\n     */\n    title?: null | string;\n}\n\nexport interface SupportedPlatform {\n    \"os-family\"?:       null | string;\n    \"os-name\"?:         null | string;\n    platform?:          null | string;\n    \"platform-family\"?: null | string;\n    \"platform-name\"?:   null | string;\n    release?:           null | string;\n}\n\n// Converts JSON strings to/from your types\n// and asserts the results of JSON.parse at runtime\nexport class Convert {\n    public static toProfileJSON(json: string): ProfileJSON {\n        return cast(JSON.parse(json), r(\"ProfileJSON\"));\n    }\n\n    public static profileJSONToJson(value: ProfileJSON): string {\n        return JSON.stringify(uncast(value, r(\"ProfileJSON\")), null, 2);\n    }\n}\n\nfunction invalidValue(typ: any, val: any, key: any = ''): never {\n    if (key) {\n        throw Error(`Invalid value for key \"${key}\". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);\n    }\n    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );\n}\n\nfunction jsonToJSProps(typ: any): any {\n    if (typ.jsonToJS === undefined) {\n        const map: any = {};\n        typ.props.forEach((p: any) => map[p.json] = { key: p.js, typ: p.typ });\n        typ.jsonToJS = map;\n    }\n    return typ.jsonToJS;\n}\n\nfunction jsToJSONProps(typ: any): any {\n    if (typ.jsToJSON === undefined) {\n        const map: any = {};\n        typ.props.forEach((p: any) => map[p.js] = { key: p.json, typ: p.typ });\n        typ.jsToJSON = map;\n    }\n    return typ.jsToJSON;\n}\n\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }\n\n    function transformUnion(typs: any[], val: any): any {\n        // val must validate against one typ in typs\n        const l = typs.length;\n        for (let i = 0; i < l; i++) {\n            const typ = typs[i];\n            try {\n                return transform(val, typ, getProps);\n            } catch (_) {}\n        }\n        return invalidValue(typs, val);\n    }\n\n    function transformEnum(cases: string[], val: any): any {\n        if (cases.indexOf(val) !== -1) return val;\n        return invalidValue(cases, val);\n    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));\n    }\n\n    function transformDate(val: any): any {\n        if (val === null) {\n            return null;\n        }\n        const d = new Date(val);\n        if (isNaN(d.valueOf())) {\n            return invalidValue(\"Date\", val);\n        }\n        return d;\n    }\n\n    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {\n        if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n            return invalidValue(\"object\", val);\n        }\n        const result: any = {};\n        Object.getOwnPropertyNames(props).forEach(key => {\n            const prop = props[key];\n            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;\n            result[prop.key] = transform(v, prop.typ, getProps, prop.key);\n        });\n        Object.getOwnPropertyNames(val).forEach(key => {\n            if (!Object.prototype.hasOwnProperty.call(props, key)) {\n                result[key] = transform(val[key], additional, getProps, key);\n            }\n        });\n        return result;\n    }\n\n    if (typ === \"any\") return val;\n    if (typ === null) {\n        if (val === null) return val;\n        return invalidValue(typ, val);\n    }\n    if (typ === false) return invalidValue(typ, val);\n    while (typeof typ === \"object\" && typ.ref !== undefined) {\n        typ = typeMap[typ.ref];\n    }\n    if (Array.isArray(typ)) return transformEnum(typ, val);\n    if (typeof typ === \"object\") {\n        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);\n    return transformPrimitive(typ, val);\n}\n\nfunction cast<T>(val: any, typ: any): T {\n    return transform(val, typ, jsonToJSProps);\n}\n\nfunction uncast<T>(val: T, typ: any): any {\n    return transform(val, typ, jsToJSONProps);\n}\n\nfunction a(typ: any) {\n    return { arrayItems: typ };\n}\n\nfunction u(...typs: any[]) {\n    return { unionMembers: typs };\n}\n\nfunction o(props: any[], additional: any) {\n    return { props, additional };\n}\n\nfunction m(additional: any) {\n    return { props: [], additional };\n}\n\nfunction r(name: string) {\n    return { ref: name };\n}\n\nconst typeMap: any = {\n    \"ProfileJSON\": o([\n        { json: \"controls\", js: \"controls\", typ: a(r(\"ProfileJSONControl\")) },\n        { json: \"copyright\", js: \"copyright\", typ: u(undefined, u(null, \"\")) },\n        { json: \"copyright_email\", js: \"copyright_email\", typ: u(undefined, u(null, \"\")) },\n        { json: \"depends\", js: \"depends\", typ: u(undefined, u(a(r(\"Dependency\")), null)) },\n        { json: \"generator\", js: \"generator\", typ: u(undefined, u(null, r(\"Generator\"))) },\n        { json: \"groups\", js: \"groups\", typ: a(r(\"ControlGroup\")) },\n        { json: \"inputs\", js: \"inputs\", typ: u(undefined, u(a(m(\"any\")), null)) },\n        { json: \"maintainer\", js: \"maintainer\", typ: u(undefined, u(null, \"\")) },\n        { json: \"name\", js: \"name\", typ: \"\" },\n        { json: \"sha256\", js: \"sha256\", typ: \"\" },\n        { json: \"status\", js: \"status\", typ: u(undefined, u(null, \"\")) },\n        { json: \"supports\", js: \"supports\", typ: a(r(\"SupportedPlatform\")) },\n        { json: \"title\", js: \"title\", typ: u(undefined, u(null, \"\")) },\n        { json: \"version\", js: \"version\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"ProfileJSONControl\": o([\n        { json: \"code\", js: \"code\", typ: \"\" },\n        { json: \"desc\", js: \"desc\", typ: u(undefined, u(null, \"\")) },\n        { json: \"descriptions\", js: \"descriptions\", typ: u(undefined, u(m(\"any\"), null)) },\n        { json: \"id\", js: \"id\", typ: \"\" },\n        { json: \"impact\", js: \"impact\", typ: 3.14 },\n        { json: \"refs\", js: \"refs\", typ: u(undefined, u(a(r(\"Reference\")), null)) },\n        { json: \"source_location\", js: \"source_location\", typ: u(undefined, u(null, r(\"SourceLocation\"))) },\n        { json: \"tags\", js: \"tags\", typ: m(\"any\") },\n        { json: \"title\", js: \"title\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"Reference\": o([\n        { json: \"ref\", js: \"ref\", typ: u(undefined, u(a(m(\"any\")), \"\")) },\n        { json: \"url\", js: \"url\", typ: u(undefined, \"\") },\n        { json: \"uri\", js: \"uri\", typ: u(undefined, \"\") },\n    ], \"any\"),\n    \"SourceLocation\": o([\n        { json: \"line\", js: \"line\", typ: u(undefined, u(3.14, null)) },\n        { json: \"ref\", js: \"ref\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"Dependency\": o([\n        { json: \"branch\", js: \"branch\", typ: u(undefined, u(null, \"\")) },\n        { json: \"compliance\", js: \"compliance\", typ: u(undefined, u(null, \"\")) },\n        { json: \"git\", js: \"git\", typ: u(undefined, u(null, \"\")) },\n        { json: \"name\", js: \"name\", typ: u(undefined, u(null, \"\")) },\n        { json: \"path\", js: \"path\", typ: u(undefined, u(null, \"\")) },\n        { json: \"status\", js: \"status\", typ: u(undefined, u(null, \"\")) },\n        { json: \"status_message\", js: \"status_message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"supermarket\", js: \"supermarket\", typ: u(undefined, u(null, \"\")) },\n        { json: \"url\", js: \"url\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"Generator\": o([\n        { json: \"name\", js: \"name\", typ: \"\" },\n        { json: \"version\", js: \"version\", typ: \"\" },\n    ], \"any\"),\n    \"ControlGroup\": o([\n        { json: \"controls\", js: \"controls\", typ: a(\"\") },\n        { json: \"id\", js: \"id\", typ: \"\" },\n        { json: \"title\", js: \"title\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"SupportedPlatform\": o([\n        { json: \"os-family\", js: \"os-family\", typ: u(undefined, u(null, \"\")) },\n        { json: \"os-name\", js: \"os-name\", typ: u(undefined, u(null, \"\")) },\n        { json: \"platform\", js: \"platform\", typ: u(undefined, u(null, \"\")) },\n        { json: \"platform-family\", js: \"platform-family\", typ: u(undefined, u(null, \"\")) },\n        { json: \"platform-name\", js: \"platform-name\", typ: u(undefined, u(null, \"\")) },\n        { json: \"release\", js: \"release\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n};\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/components/cards/treemap/Treemap.vue": "<template>\n  <v-container ref=\"treemapContainer\" fluid>\n    <v-row dense>\n      <v-col :cols=\"4\">\n        NIST SP 800-53 Security and Privacy Control Coverage\n      </v-col>\n      <v-col :cols=\"8\">\n        <v-btn :disabled=\"!allow_up\" block x-small @click=\"up\">\n          <v-icon v-if=\"allow_up\"> mdi-arrow-left </v-icon>\n          {{ 'NIST-SP-800-53 -> ' + value.join(' -> ') }}\n        </v-btn>\n      </v-col>\n    </v-row>\n    <v-row>\n      <v-col v-resize=\"on_resize\" :cols=\"12\">\n        <svg id=\"chartBody\" :width=\"width\" :height=\"height\">\n          <g\n            style=\"shape-rendering: crispEdges\"\n            preserveAspectRatio=\"xMidYMid meet\"\n          >\n            <!-- The body -->\n            <Cell\n              :selected_control_id=\"selected_control\"\n              :node=\"selected_node\"\n              :scales=\"scales\"\n              :depth=\"0\"\n              @select-node=\"select_node\"\n            />\n          </g>\n        </svg>\n      </v-col>\n    </v-row>\n  </v-container>\n</template>\n\n<script lang=\"ts\">\nimport Cell, {XYScale} from '@/components/cards/treemap/Cell.vue';\nimport {ColorHackModule} from '@/store/color_hack';\nimport {Filter, FilteredDataModule, TreeMapState} from '@/store/data_filters';\nimport {compare_arrays} from '@/utilities/helper_util';\nimport {\n  build_nist_tree_map,\n  is_leaf,\n  is_parent,\n  TreemapNode\n} from '@/utilities/treemap_util';\nimport * as d3 from 'd3';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\nimport {Prop, PropSync, Ref} from 'vue-property-decorator';\n\n// Respects a v-model of type TreeMapState\n@Component({\n  components: {\n    Cell\n  }\n})\nexport default class Treemap extends Vue {\n  @Ref('treemapContainer') readonly treemapContainer!: Element;\n  @Prop({type: Array, required: true}) readonly value!: TreeMapState;\n  @Prop({type: Object, required: true}) readonly filter!: Filter;\n  @PropSync('selected_control', {type: String}) syncedSelectedControl!:\n    | string\n    | null;\n\n  /** The svg internal coordinate space */\n  width = 1600;\n  height = 530;\n\n  /** The currently selected treemap node. Wrapped to avoid initialization woes */\n  get selected_node(): d3.HierarchyRectangularNode<TreemapNode> {\n    // Get typed versions of the curr state\n    // Set curr to root\n    let curr = this.treemap_layout;\n    let depth = 0;\n\n    try {\n      for (; depth < this.value.length; depth++) {\n        // If the current has no children, then just bail here\n        if (curr.children === undefined) {\n          throw Error('no children to go into');\n        }\n\n        // Fetch the next path spec\n        const nextSpecifiers = this.value.slice(0, depth + 1);\n\n        const newCurr = curr.children.find((child) => {\n          if (is_parent(child.data)) {\n            const ssA = child.data.nist_control.subSpecifiers;\n            return (\n              compare_arrays(ssA, nextSpecifiers, (a, b) =>\n                a.localeCompare(b)\n              ) === 0\n            );\n          } else {\n            return false; // We cannot go into a leaf (OR CAN WE? MUST DECIDE, AT SOME POINT)\n          }\n        });\n        if (newCurr) {\n          if (newCurr.children && newCurr.children.length) {\n            curr = newCurr;\n          } else {\n            throw Error('empty');\n          }\n        } else {\n          throw Error('truncate');\n        }\n      }\n    } catch (someTraversalError) {\n      // Slice to last successful depth. Slice is non inclusive so this works\n      this.set_path(this.value.slice(0, depth));\n    }\n\n    // Return as deep as we travelled\n    return curr;\n  }\n\n  /** Get our viewbox */\n  get view_box(): string {\n    return `0 0 ${this.width} ${this.height}`;\n  }\n\n  /** Get our scales */\n  get scales(): XYScale {\n    return {\n      scale_x: d3\n        .scaleLinear()\n        .domain([this.selected_node.x0, this.selected_node.x1])\n        .range([0, this.width]),\n      scale_y: d3\n        .scaleLinear()\n        .domain([this.selected_node.y0, this.selected_node.y1])\n        .range([0, this.height])\n    };\n  }\n\n  /** Generates a d3 heirarchy structure, with appropriate bounds to our width\n   *  detailing all of the controls in the nist hash */\n  get treemap_layout(): d3.HierarchyRectangularNode<TreemapNode> {\n    // Get the current filtered data\n    const controls = FilteredDataModule.controls(this.filter);\n\n    // Build the map\n    const hierarchy = build_nist_tree_map(controls, ColorHackModule);\n    return d3\n      .treemap<TreemapNode>()\n      .size([this.width, this.height])\n      .round(false)\n      .paddingInner(0)(hierarchy);\n  }\n\n  // Callbacks for our tree\n  select_node(n: d3.HierarchyRectangularNode<TreemapNode>): void {\n    // If it is a leaf, then select it\n    if (is_leaf(n.data)) {\n      const id = n.data.control.data.id;\n      this.syncedSelectedControl =\n        id !== this.syncedSelectedControl ? id : null;\n    } else {\n      // Otherwise, dive away. Set course for the leading title\n      const cntrl = n.data.nist_control;\n      if (cntrl) {\n        this.set_path(cntrl.subSpecifiers);\n      }\n    }\n  }\n\n  /** Submits an event to go up one node */\n  up(): void {\n    if (this.value.length) {\n      // Slice and dice, baybee\n      this.set_path(this.value.slice(0, this.value.length - 1));\n\n      // Also clear selected\n      this.syncedSelectedControl = null;\n    }\n  }\n\n  /** Typed method to wrap changes in the depth */\n  set_path(pathSpec: TreeMapState) {\n    this.$emit('input', pathSpec);\n  }\n\n  /** Controls whether we should allow up */\n  get allow_up(): boolean {\n    return this.value.length > 0;\n  }\n\n  /** Called on resize */\n  on_resize() {\n    this.width = this.treemapContainer.clientWidth;\n  }\n}\n</script>\n\n<style scoped>\ntext {\n  pointer-events: none;\n  font-weight: bold;\n  font-size: 1.1em;\n  fill: 'primary';\n}\n\nrect {\n  fill: none;\n}\n</style>\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/components/global/upload_tabs/aws/FileList.vue": "<template>\n  <v-stepper-content step=\"3\">\n    <div class=\"d-flex flex-column\">\n      <div class=\"d-flex justify-space-between\">\n        <v-text-field\n          v-model=\"formBucketName\"\n          label=\"Bucket name\"\n          @keyup.enter=\"load\"\n        />\n        <v-btn\n          title=\"Load\"\n          :disabled=\"formBucketName.length < 1\"\n          class=\"fill-height pa-0\"\n          @click=\"load\"\n        >\n          <v-icon>mdi-cloud-download</v-icon>\n        </v-btn>\n      </div>\n\n      <v-list :two-line=\"true\">\n        <v-list-item v-if=\"files.length === 0\"\n          >No items found! Try different terms?</v-list-item\n        >\n        <v-list-item v-for=\"(val, index) in files\" :key=\"val.Key\">\n          <v-list-item-content>\n            <!-- Title: The item key -->\n            <v-list-item-title>{{ val.Key }}</v-list-item-title>\n            <!-- Subtitle: Date of creation -->\n            <v-list-item-subtitle>\n              {{ val.LastModified }}\n            </v-list-item-subtitle>\n          </v-list-item-content>\n          <!-- Action: Click to add -->\n          <v-list-item-action>\n            <v-btn icon @click=\"load_file(index)\">\n              <v-icon>mdi-plus-circle</v-icon>\n            </v-btn>\n          </v-list-item-action>\n        </v-list-item>\n      </v-list>\n      <v-btn color=\"red\" class=\"my-2 mr-3\" @click=\"$emit('exit-list')\">\n        Cancel\n      </v-btn>\n    </div>\n  </v-stepper-content>\n</template>\n\n<script lang=\"ts\">\nimport {InspecIntakeModule} from '@/store/report_intake';\nimport {Auth, fetch_s3_file} from '@/utilities/aws_util';\nimport {LocalStorageVal} from '@/utilities/helper_util';\nimport S3 from 'aws-sdk/clients/s3';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\nimport {Prop} from 'vue-property-decorator';\n\n// Caches the bucket name\nconst localBucketName = new LocalStorageVal<string>('aws_bucket_name');\n\n@Component({\n  components: {}\n})\nexport default class FileList extends Vue {\n  @Prop({type: Object}) readonly auth!: Auth;\n  @Prop({type: Array}) readonly files!: S3.Object[];\n\n  /** The name written in the form */\n  formBucketName = '';\n\n  /** On mount, try to look up stored auth info */\n  /** Callback for when user selects a file.\n   * Loads it into our system.\n   */\n  async load_file(index: number): Promise<void> {\n    // Get it out of the list\n    const file = this.files[index];\n\n    // Fetch it from s3, and promise to submit it to be loaded afterwards\n    await fetch_s3_file(this.auth.creds, file.Key!, this.formBucketName).then(\n      (content) => {\n        InspecIntakeModule.loadText({\n          text: content,\n          filename: file.Key!\n        }).then((uniqueId) => this.$emit('got-files', [uniqueId]));\n      }\n    );\n  }\n\n  /** Recalls the last entered bucket name.  */\n  mounted() {\n    this.formBucketName = localBucketName.get_default('');\n  }\n\n  /** Handles when load button clicked */\n  load() {\n    localBucketName.set(this.formBucketName);\n    this.$emit('load-bucket', this.formBucketName);\n  }\n}\n</script>\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/components/global/upload_tabs/aws/S3Reader.vue": "<template>\n  <v-stepper v-model=\"step\" vertical class=\"elevation-0\">\n    <v-stepper-step :complete=\"!!assumedRole\" step=\"1\">\n      Account Credentials\n    </v-stepper-step>\n\n    <AuthStepBasic\n      :access-token.sync=\"accessToken\"\n      :secret-token.sync=\"secretToken\"\n      @auth-basic=\"handle_basic\"\n      @goto-mfa=\"handle_goto_mfa\"\n    />\n\n    <v-stepper-step :complete=\"!!assumedRole && assumedRole.from_mfa\" step=\"2\">\n      MFA Authorization\n    </v-stepper-step>\n\n    <AuthStepMFA\n      :mfa-token.sync=\"mfaToken\"\n      :mfa-serial.sync=\"mfaSerial\"\n      @auth-mfa=\"handle_proceed_mfa\"\n      @exit-mfa=\"handle_cancel_mfa\"\n    />\n\n    <v-stepper-step step=\"3\"> Browse Bucket </v-stepper-step>\n\n    <FileList\n      :auth=\"assumedRole\"\n      :files=\"files\"\n      @exit-list=\"handle_cancel_mfa\"\n      @got-files=\"got_files\"\n      @load-bucket=\"load_bucket\"\n    />\n  </v-stepper>\n</template>\n\n<script lang=\"ts\">\nimport AuthStepBasic from '@/components/global/upload_tabs/aws/AuthStepBasic.vue';\nimport AuthStepMFA from '@/components/global/upload_tabs/aws/AuthStepMFA.vue';\nimport FileList from '@/components/global/upload_tabs/aws/FileList.vue';\nimport {FileID} from '@/store/report_intake';\nimport {SnackbarModule} from '@/store/snackbar';\nimport {\n  Auth,\n  AUTH_DURATION,\n  get_session_token,\n  MFAInfo,\n  transcribe_error\n} from '@/utilities/aws_util';\nimport {LocalStorageVal} from '@/utilities/helper_util';\nimport S3 from 'aws-sdk/clients/s3';\nimport {AWSError} from 'aws-sdk/lib/error';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\n\n/** The cached session info */\nconst localSessionInformation = new LocalStorageVal<Auth | null>(\n  'aws_session_info'\n);\n\n/**\n * Uploads data to the store with unique IDs asynchronously as soon as data is entered.\n * Emits \"got-files\" with a list of the unique_ids of the loaded files.\n */\n@Component({\n  components: {\n    AuthStepBasic,\n    AuthStepMFA,\n    FileList\n  }\n})\nexport default class S3Reader extends Vue {\n  /** Form required field rules. Maybe eventually expand to other stuff */\n  reqRule = (v: string | null | undefined) =>\n    (v || '').trim().length > 0 || 'Field is Required';\n\n  /** Passed from step 1 to step 2 (MFA) if necessary */\n  /** State of all globally relevant fields */\n  accessToken = '';\n  secretToken = '';\n  mfaSerial = '';\n  mfaToken = '';\n\n  /** Our session information, generated by AWS STS */\n  assumedRole: Auth | null = null;\n\n  /** Current step */\n  step = 1;\n\n  /** Currently loaded file list from bucket */\n  files: S3.Object[] = [];\n\n  /**\n   * Handle a basic login.\n   * Gets a session token\n   */\n  handle_basic() {\n    // Attempt to assume role based on if we've determined 2fa necessary\n    get_session_token(this.accessToken, this.secretToken, AUTH_DURATION).then(\n      // Success of get session token - now need to determine if MFA necessary\n      (success) => {\n        this.assumedRole = success;\n        this.step = 3;\n      },\n\n      // Failure of initial get session token: want to set error normally\n      (failure) => {\n        this.handle_error(failure);\n      }\n    );\n  }\n\n  /** If the user tries to login by going to MFA, first check that the account is valid */\n  handle_goto_mfa() {\n    // Attempt to assume role based on if we've determined 2fa necessary\n    // Don't need the duration to be very long\n    get_session_token(this.accessToken, this.secretToken, 10).then(\n      // Success of get session token - now need to determine if MFA necessary\n      () => {\n        this.step = 2;\n      },\n\n      // Failure of initial get session token: want to set error normally\n      (failure) => {\n        this.handle_error(failure);\n      }\n    );\n  }\n\n  handle_cancel_mfa() {\n    this.step = 1;\n    this.mfaToken = '';\n    this.assumedRole = null; // Just in case\n  }\n\n  handle_exit_list() {\n    this.step = 1;\n    this.mfaToken = '';\n    this.assumedRole = null;\n    this.files = []; // Just in case\n  }\n\n  /** Handle an MFA login.\n   * Determine whether further action is necessary\n   */\n  handle_proceed_mfa() {\n    // Build our mfa params\n    const mfa: MFAInfo = {\n      SerialNumber: this.mfaSerial || null,\n      TokenCode: this.mfaToken\n    };\n\n    // Attempt to assume role based on if we've determined 2fa necessary\n    get_session_token(\n      this.accessToken,\n      this.secretToken,\n      AUTH_DURATION,\n      mfa\n    ).then(\n      (success) => {\n        // Keep them\n        this.assumedRole = success;\n        this.step = 3;\n      },\n      (failure) => {\n        this.handle_error(failure);\n      }\n    );\n  }\n\n  /** On mount, try to look up stored auth info */\n  mounted() {\n    // Load our session, if there is one\n    this.assumedRole = localSessionInformation.get_default(null);\n    if (this.assumedRole) {\n      this.step = 3;\n    }\n  }\n\n  /** Attempt to load.\n   * Basically just wraps fetch_files with error handling\n   */\n  async load_bucket(name: string) {\n    const s3 = new S3(this.assumedRole!.creds);\n    await s3\n      .listObjectsV2({\n        Bucket: name,\n        MaxKeys: 100\n      })\n      .promise()\n      .then((success) => {\n        this.files = success.Contents || [];\n      })\n      .catch((failure) => this.handle_error(failure));\n  }\n\n  /** Save the current credentials to local storage */\n  save_creds() {\n    localSessionInformation.set(this.assumedRole);\n  }\n\n  /** Callback to handle an AWS error.\n   * Sets shown error.\n   */\n  handle_error(error: AWSError): void {\n    const formattedError = transcribe_error(error);\n    // Toast whatever error we got\n    SnackbarModule.failure(formattedError);\n  }\n\n  /** Callback on got files */\n  got_files(files: Array<FileID>) {\n    this.$emit('got-files', files);\n  }\n}\n</script>\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/store/data_filters.ts": "/**\n * This module provides a cached, reusable method for filtering data from data_store.\n */\n\nimport {Trinary} from '@/enums/Trinary';\nimport {InspecDataModule} from '@/store/data_store';\nimport {\n  FileID,\n  SourcedContextualizedEvaluation,\n  SourcedContextualizedProfile\n} from '@/store/report_intake';\nimport Store from '@/store/store';\nimport {\n  ContextualizedControl,\n  ContextualizedProfile,\n  ControlStatus,\n  NistControl,\n  Severity\n} from 'inspecjs';\nimport _ from 'lodash';\nimport LRUCache from 'lru-cache';\nimport {\n  Action,\n  getModule,\n  Module,\n  Mutation,\n  VuexModule\n} from 'vuex-module-decorators';\n\nconst MAX_CACHE_ENTRIES = 20;\n\nexport declare type ExtendedControlStatus = ControlStatus | 'Waived';\n\n/** Contains common filters on data from the store. */\nexport interface Filter {\n  // General\n  /** Which file these objects came from. Undefined => any */\n  fromFile: FileID[];\n\n  // Control specific\n  /** What status the controls can have. Undefined => any */\n  status?: ExtendedControlStatus[];\n\n  /** What severity the controls can have. Undefined => any */\n  severity?: Severity[];\n\n  /** Whether or not to allow/include overlayed controls */\n  omit_overlayed_controls?: boolean;\n\n  /** Control IDs to search for */\n  ids?: string[];\n\n  /** Titles to search for */\n  titleSearchTerms?: string[];\n\n  /** Descriptions to search for */\n  descriptionSearchTerms?: string[];\n\n  /** Code to search for */\n  codeSearchTerms?: string[];\n\n  /** CCIs to search for */\n  nistIdFilter?: string[];\n\n  /** A search term string, case insensitive\n   * We look for this in\n   * - control ID\n   * - rule title\n   * - severity\n   * - status\n   * - finding details (from HDF)\n   * - code\n   */\n  searchTerm?: string;\n\n  /** The current state of the Nist Treemap. Used to further filter by nist categories etc. */\n  treeFilters?: TreeMapState;\n\n  /** A specific control id */\n  control_id?: string;\n}\n\nexport type TreeMapState = string[]; // Representing the current path spec, from root\n\n/**\n * Facillitates the search functionality\n * @param term The string to search with\n * @param contextControl The control to search for term in\n */\nfunction contains_term(\n  contextControl: ContextualizedControl,\n  term: string\n): boolean {\n  const asHDF = contextControl.root.hdf;\n  // Get our (non-null) searchable data\n  const searchables: string[] = [\n    asHDF.wraps.id,\n    asHDF.wraps.title,\n    asHDF.wraps.code,\n    asHDF.severity,\n    asHDF.status,\n    asHDF.finding_details\n  ].filter((s) => s !== null) as string[];\n\n  // See if any contain term\n  return searchables.some((s) => s.toLowerCase().includes(term));\n}\n\n@Module({\n  namespaced: true,\n  dynamic: true,\n  store: Store,\n  name: 'filteredData'\n})\nexport class FilteredData extends VuexModule {\n  selectedEvaluationIds: FileID[] = [];\n  selectedProfileIds: FileID[] = [];\n\n  @Mutation\n  SELECT_EVALUATIONS(files: FileID[]): void {\n    this.selectedEvaluationIds = [\n      ...new Set([...files, ...this.selectedEvaluationIds])\n    ];\n  }\n\n  @Mutation\n  SELECT_PROFILES(files: FileID[]): void {\n    this.selectedProfileIds = [\n      ...new Set([...files, ...this.selectedProfileIds])\n    ];\n  }\n\n  @Mutation\n  CLEAR_EVALUATION(removeId: FileID): void {\n    this.selectedEvaluationIds = this.selectedEvaluationIds.filter(\n      (ids) => ids !== removeId\n    );\n  }\n\n  @Mutation\n  CLEAR_PROFILE(removeId: FileID): void {\n    this.selectedProfileIds = this.selectedProfileIds.filter(\n      (ids) => ids !== removeId\n    );\n  }\n\n  @Mutation\n  CLEAR_ALL_EVALUATIONS(): void {\n    this.selectedEvaluationIds = [];\n  }\n\n  @Mutation\n  CLEAR_ALL_PROFILES(): void {\n    this.selectedProfileIds = [];\n  }\n\n  @Action\n  public toggle_all_evaluations(): void {\n    if (this.all_evaluations_selected === Trinary.On) {\n      this.CLEAR_ALL_EVALUATIONS();\n    } else {\n      this.SELECT_EVALUATIONS(\n        InspecDataModule.allEvaluationFiles.map((v) => v.uniqueId)\n      );\n    }\n  }\n\n  @Action\n  public toggle_all_profiles(): void {\n    if (this.all_profiles_selected === Trinary.On) {\n      this.CLEAR_ALL_PROFILES();\n    } else {\n      this.SELECT_PROFILES(\n        InspecDataModule.allProfileFiles.map((v) => v.uniqueId)\n      );\n    }\n  }\n\n  @Action\n  public select_exclusive_evaluation(fileID: FileID): void {\n    this.CLEAR_ALL_EVALUATIONS();\n    this.SELECT_EVALUATIONS([fileID]);\n  }\n\n  @Action\n  public select_exclusive_profile(fileID: FileID): void {\n    this.CLEAR_ALL_PROFILES();\n    this.SELECT_PROFILES([fileID]);\n  }\n\n  @Action\n  public toggle_evaluation(fileID: FileID): void {\n    if (this.selectedEvaluationIds.includes(fileID)) {\n      this.CLEAR_EVALUATION(fileID);\n    } else {\n      this.SELECT_EVALUATIONS([fileID]);\n    }\n  }\n\n  @Action\n  public toggle_profile(fileID: FileID): void {\n    if (this.selectedProfileIds.includes(fileID)) {\n      this.CLEAR_PROFILE(fileID);\n    } else {\n      this.SELECT_PROFILES([fileID]);\n    }\n  }\n\n  @Action\n  public clear_file(fileID: FileID): void {\n    this.CLEAR_EVALUATION(fileID);\n    this.CLEAR_PROFILE(fileID);\n  }\n\n  /**\n   * Parameterized getter.\n   * Get all evaluations from the specified file ids\n   */\n  get evaluations(): (\n    files: FileID[]\n  ) => readonly SourcedContextualizedEvaluation[] {\n    return (files: FileID[]) => {\n      return InspecDataModule.contextualExecutions.filter((e) =>\n        files.includes(e.from_file.uniqueId)\n      );\n    };\n  }\n\n  get profiles_for_evaluations(): (\n    files: FileID[]\n  ) => readonly ContextualizedProfile[] {\n    return (files: FileID[]) => {\n      // Filter to those that match our filter. In this case that just means come from the right file id\n      return this.evaluations(files).flatMap(\n        (evaluation) => evaluation.contains\n      );\n    };\n  }\n\n  /**\n   * Parameterized getter.\n   * Get all profiles from the specified file ids.\n   */\n  get profiles(): (files: FileID[]) => readonly SourcedContextualizedProfile[] {\n    return (files: FileID[]) => {\n      return InspecDataModule.contextualProfiles.filter((e) => {\n        return files.includes(e.from_file.uniqueId);\n      });\n    };\n  }\n\n  get selected_file_ids(): FileID[] {\n    return [...this.selectedEvaluationIds, ...this.selectedProfileIds];\n  }\n\n  // check to see if all profiles are selected\n  get all_profiles_selected(): Trinary {\n    switch (this.selectedProfileIds.length) {\n      case 0:\n        return Trinary.Off;\n      case InspecDataModule.allProfileFiles.length:\n        return Trinary.On;\n      default:\n        return Trinary.Mixed;\n    }\n  }\n\n  // check to see if all evaluations are selected\n  get all_evaluations_selected(): Trinary {\n    switch (this.selectedEvaluationIds.length) {\n      case 0:\n        return Trinary.Off;\n      case InspecDataModule.allEvaluationFiles.length:\n        return Trinary.On;\n      default:\n        return Trinary.Mixed;\n    }\n  }\n\n  /**\n   * Parameterized getter.\n   * Get all controls from all profiles from the specified file id.\n   * Utlizes the profiles getter to accelerate the file filter.\n   */\n  get controls(): (filter: Filter) => readonly ContextualizedControl[] {\n    /** Cache by filter */\n    const localCache: LRUCache<string, readonly ContextualizedControl[]> =\n      new LRUCache(MAX_CACHE_ENTRIES);\n\n    return (filter: Filter) => {\n      // Generate a hash for cache purposes.\n      // If the \"searchTerm\" string is not null, we don't cache - no need to pollute\n      const id: string = filter_cache_key(filter);\n\n      // Check if we have this cached:\n      const cached = localCache.get(id);\n      if (cached !== undefined) {\n        return cached;\n      }\n\n      // Get profiles from loaded Results\n      let profiles: readonly ContextualizedProfile[] =\n        this.profiles_for_evaluations(filter.fromFile);\n\n      // Get profiles from loaded Profiles\n      profiles = profiles.concat(this.profiles(filter.fromFile));\n\n      // And all the controls they contain\n      let controls: readonly ContextualizedControl[] = profiles.flatMap(\n        (profile) => profile.contains\n      );\n\n      // Filter by single control id\n      if (filter.control_id !== undefined) {\n        controls = controls.filter((c) => c.data.id === filter.control_id);\n      }\n\n      const controlFilters: Record<\n        string,\n        boolean | Array<string> | undefined\n      > = {\n        'root.hdf.severity': filter.severity,\n        'hdf.wraps.id': filter.ids,\n        'hdf.wraps.title': filter.titleSearchTerms,\n        'hdf.wraps.desc': filter.descriptionSearchTerms,\n        'hdf.raw_nist_tags': filter.nistIdFilter,\n        full_code: filter.codeSearchTerms,\n        'hdf.waived': filter.status?.includes('Waived'),\n        'root.hdf.status': _.filter(\n          filter.status,\n          (status) => status !== 'Waived'\n        )\n      };\n\n      controls = filterControlsBy(controls, controlFilters);\n\n      // Filter by overlay\n      if (filter.omit_overlayed_controls) {\n        controls = controls.filter(\n          (control) => control.extendedBy.length === 0\n        );\n      }\n\n      // Freeform search\n      if (filter.searchTerm !== undefined) {\n        const term = filter.searchTerm.toLowerCase();\n\n        // Filter controls to those that contain search term\n        controls = controls.filter((c) => contains_term(c, term));\n      }\n\n      // Filter by nist stuff\n      if (filter.treeFilters && filter.treeFilters.length > 0) {\n        // Construct a nist control to represent the filter\n        const control = new NistControl(filter.treeFilters);\n\n        controls = controls.filter((c) => {\n          // Get an hdf version so we have the fixed nist tags\n          return c.root.hdf.parsedNistTags.some((t) => control.contains(t));\n        });\n      }\n\n      // Freeze and save to cache\n      const r = Object.freeze(controls);\n      localCache.set(id, r);\n      return r;\n    };\n  }\n}\n\nexport const FilteredDataModule = getModule(FilteredData);\n\n/**\n * Generates a unique string to represent a filter.\n * Does some minor \"acceleration\" techniques such as\n * - annihilating empty search terms\n * - defaulting \"omit_overlayed_controls\"\n */\nexport function filter_cache_key(f: Filter) {\n  const newFilter: Filter = {\n    searchTerm: f.searchTerm?.trim() || '',\n    omit_overlayed_controls: f.omit_overlayed_controls || false,\n    ...f\n  };\n  return JSON.stringify(newFilter);\n}\n\nexport function filterControlsBy(\n  controls: readonly ContextualizedControl[],\n  filters: Record<string, boolean | Array<string> | undefined>\n): readonly ContextualizedControl[] {\n  const activeFilters: typeof filters = _.pickBy(\n    filters,\n    (value, _key) =>\n      (Array.isArray(value) && value.length > 0) ||\n      (typeof value === 'boolean' && value)\n  );\n  return controls.filter((control) => {\n    return Object.entries(activeFilters).every(([filter, value]) => {\n      const item: string | string[] | boolean = _.get(control, filter);\n      if (Array.isArray(value) && typeof item !== 'boolean') {\n        return value?.some((term) => {\n          return arrayOrStringIncludes(item, (compareValue) =>\n            compareValue.toLowerCase().includes(term.toLowerCase())\n          );\n        });\n      } else {\n        return item === value;\n      }\n    });\n  });\n}\n\n/** Iterate over a string or array of strings and call the string compare function provided on every element **/\nfunction arrayOrStringIncludes(\n  arrayOrString: string | string[],\n  comparator: (compareValue: string) => boolean\n) {\n  if (typeof arrayOrString === 'string') {\n    return comparator(arrayOrString);\n  } else {\n    return arrayOrString.some((value) => comparator(value));\n  }\n}\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/utilities/format_util.ts": "/**\n * Functions for formatting items to have unique keys. Principally used for vuex v-for key generation.\n */\n\nimport {isFromProfileFile} from '@/store/data_store';\nimport {\n  SourcedContextualizedEvaluation,\n  SourcedContextualizedProfile\n} from '@/store/report_intake';\nimport {ContextualizedControl} from 'inspecjs';\n\nexport function execution_unique_key(\n  exec: Readonly<SourcedContextualizedEvaluation>\n): string {\n  return `exec_${exec.from_file.uniqueId}`;\n}\n\n/**\n * Generates a unique key for the given profile\n * @param profile\n */\nexport function profile_unique_key(\n  profile: Readonly<SourcedContextualizedProfile>\n): string {\n  if (isFromProfileFile(profile)) {\n    return `profile_${profile.from_file.uniqueId}`;\n  } else {\n    return `${execution_unique_key(\n      profile.sourcedFrom as SourcedContextualizedEvaluation\n    )}-${profile.data.name}`;\n  }\n}\n\n/**\n * Generates a unique key for the given control\n * @param ctrl The control to generate the key for\n */\nexport function control_unique_key(\n  ctrl: Readonly<ContextualizedControl>\n): string {\n  return `${profile_unique_key(\n    ctrl.sourcedFrom as Readonly<SourcedContextualizedProfile>\n  )}-${ctrl.data.id}`;\n}\n\n",
  "/api/sources/raw?key=test:libs/inspecjs/src/context.ts": "/**\n * Provides general utilities for articulating associations beteen evaluations, profiles, and controls.\n * Especially useful for handling overlay/wrapper profiles.\n */\n\nimport {HDFControl, hdfWrapControl} from './compat_wrappers';\nimport {\n  AnyControl,\n  AnyEval,\n  AnyEvalControl,\n  AnyEvalProfile,\n  AnyProfile\n} from './fileparse';\n\n/**\n * Mixin type to express that this type wraps another data type to add additional fields,\n * without modifying the inner type.\n */\ninterface WrapsType<Data> {\n  data: Data;\n}\n\n/**\n * Mixin type to express that this type has some sort \"parent\".\n * Sort of an inverse to the Contains mixin.\n * E.g. A control is sourced from a profile, and an execution is from a file.\n */\ninterface Sourced<From> {\n  sourcedFrom: From;\n}\n\n/**\n * Mixin type to express that this type has some sort of directional dependency-graph with members of a (usually the same) type.\n * For instance, profiles overlay/are overlayed by profiles.\n * Controls override behavior/are overrideen by other controls\n */\ninterface Extendable<By> {\n  /**\n   * What is this data extended by?\n   * E.g. a profile that overlays this profile.\n   * Can be empty.\n   */\n  extendedBy: By[];\n\n  /**\n   * What data is this node extending?\n   * E.g. is this overlaying a profile? Another control?\n   * Can be empty.\n   */\n  extendsFrom: By[];\n}\n\n/**\n * Mixin type to express that this type is primarily a parent to some other data.\n * For instance, profiles are most directly a parent of controls .\n * What objects/resources does this item contain?\n */\ninterface Contains<Item> {\n  contains: Item;\n}\n\n// Create our three primary data types from the above mixins\n// Essentially this is just describing the parent/child relationships each type has\nexport interface ContextualizedEvaluation\n  extends WrapsType<AnyEval>,\n    Contains<ContextualizedProfile[]> {}\n\nexport interface ContextualizedProfile\n  extends WrapsType<AnyProfile>,\n    Sourced<ContextualizedEvaluation | null>,\n    Contains<ContextualizedControl[]>,\n    Extendable<ContextualizedProfile> {}\nexport interface ContextualizedControl\n  extends WrapsType<AnyControl>,\n    Sourced<ContextualizedProfile>,\n    Extendable<ContextualizedControl> {\n  /** The HDF version of this particular control */\n  hdf: HDFControl;\n\n  /** Drills down to this controls root CC. In general you should use this for all data operations */\n  root: ContextualizedControl;\n\n  /** Yields the full code of this control, by concatenating overlay code. */\n  full_code: string;\n}\n\nclass ContextualizedControlImp implements ContextualizedControl {\n  // Imp stuff\n  data: AnyControl;\n  sourcedFrom: ContextualizedProfile;\n  extendsFrom: ContextualizedControl[];\n  extendedBy: ContextualizedControl[];\n  hdf: HDFControl;\n\n  constructor(\n    data: AnyControl,\n    sourcedFrom: ContextualizedProfile,\n    extendedBy: ContextualizedControl[],\n    extendsFrom: ContextualizedControl[]\n  ) {\n    // Simple save\n    this.data = data;\n    this.sourcedFrom = sourcedFrom;\n    this.hdf = hdfWrapControl(data);\n    this.extendedBy = extendedBy;\n    this.extendsFrom = extendsFrom;\n  }\n\n  get root(): ContextualizedControl {\n    if (this.extendsFrom.length) {\n      return this.extendsFrom[0].root;\n    }\n    return this;\n  }\n\n  /** Returns whether this control is just a duplicate of base/root (but is not itself root) */\n  get is_redundant(): boolean {\n    return (\n      !this.data.code ||\n      this.data.code.trim() === '' ||\n      (this.extendsFrom.length > 0 && this.data.code === this.root.data.code)\n    );\n  }\n\n  get full_code(): string {\n    // If we extend from something, we behave slightly differently\n    if (this.extendsFrom.length) {\n      const ancestor = this.extendsFrom[0];\n      if (this.is_redundant) {\n        return ancestor.full_code;\n      } else {\n        return `\\\n=========================================================\n# Profile name: ${this.sourcedFrom.data.name}\n=========================================================\n\n${this.data.code}\n\n${this.extendsFrom[0].full_code}`.trim();\n      }\n    } else {\n      // We are the endpoint\n      return `\\\n=========================================================\n# Profile name: ${this.sourcedFrom.data.name}\n=========================================================\n\n${this.data.code}`.trim();\n    }\n  }\n}\n\nexport function contextualizeEvaluation(\n  evaluation: AnyEval\n): ContextualizedEvaluation {\n  // To begin, create basic context for profiles and evaluation\n  const evalContext: ContextualizedEvaluation = {\n    data: evaluation,\n    contains: []\n  };\n\n  for (const profile of evaluation.profiles) {\n    const evalProfileContext: ContextualizedProfile = {\n      data: profile,\n      sourcedFrom: evalContext,\n      extendedBy: [],\n      extendsFrom: [],\n      contains: []\n    };\n\n    // Add it to our parent\n    evalContext.contains.push(evalProfileContext);\n  }\n\n  // After our initial save of profiles, we go over them again to establish parentage/dependency\n  for (const profile of evalContext.contains) {\n    // We know these are from a report; label as such\n    const asExec = profile.data as AnyEvalProfile;\n\n    // If it has a parent profile then we link them by extendedby/extendsfrom\n    if (asExec.parent_profile !== undefined) {\n      // Look it up\n      const parent = evalContext.contains.find(\n        (p) => p.data.name === asExec.parent_profile\n      );\n\n      // Link it up\n      if (parent) {\n        parent.extendsFrom.push(profile);\n        profile.extendedBy.push(parent);\n      }\n    }\n  }\n\n  // Next step: Extract controls and connect them\n  // Extract the controls and set them as the \"contained\" data for each profile\n  // These ContextualizedControls are basically empty - just have data and from where they were sourced\n  const allControls: ContextualizedControl[] = [];\n  for (const profile of evalContext.contains) {\n    const pControls = profile.data.controls as AnyEvalControl[];\n    profile.contains = pControls.map((c) => {\n      return new ContextualizedControlImp(c, profile, [], []);\n    });\n    allControls.push(...profile.contains);\n  }\n\n  // Link each contextualized control\n  for (const cc of allControls) {\n    // Behaviour changes based on if we have well-formed or malformed profile dependency\n    if (cc.sourcedFrom.extendsFrom.length || cc.sourcedFrom.extendedBy.length) {\n      // Our profile is a baseline! No need to continue - children will make connections for us\n      // If we aren't extended from something we just drop. Our children will make connections for us\n      if (cc.sourcedFrom.extendsFrom.length === 0) {\n        continue;\n      }\n\n      // Get the profile(s) that this control's owning profile is extending\n      // For a wrapper profile, there might be many of these!\n      // We don't know which one it will be, so we iterate\n      for (const extendedProfile of cc.sourcedFrom.extendsFrom) {\n        // Hunt for its ancestor in the extended profile\n        const ancestor = extendedProfile.contains.find(\n          (c) => c.data.id === cc.data.id\n        );\n        // First one we find with a matching id we assume is the root (or at least, closer to root)\n        if (ancestor) {\n          ancestor.extendedBy.push(cc);\n          cc.extendsFrom.push(ancestor);\n          break; // Note that we're in a nested loop here\n        }\n      }\n      // If it's not found, then we just assume it does not exist!\n    } else {\n      // If we don't have a normal profile dependency layout, then we have to hunt ye-olde-fashioned-way\n      // Unfortunately, if theres more than 2 profiles there's ultimately no way to figure out which one was applied \"last\".\n      // This method leaves them as siblings. However, as a fallback method that is perhaps the best we can hope for\n      // First, hunt out all controls from this file that have the same id as cc\n      const sameId = allControls.filter((c) => c.data.id === cc.data.id);\n      // Find which of them, if any, is populated with results.\n      let sameIdPopulated = sameId.find(\n        (c) => c.hdf.segments && c.hdf.segments.length\n      );\n\n      // If found a populated base, use that. If not, we substitute in the first found element in sameId. This is arbitrary.\n      if (!sameIdPopulated) {\n        sameIdPopulated = sameId[0];\n      }\n\n      // If the object we end up with is \"us\", then just ignore\n      if (Object.is(cc, sameIdPopulated)) {\n        continue;\n      } else {\n        // Otherwise, bind\n        sameIdPopulated.extendedBy.push(cc);\n        cc.extendsFrom.push(sameIdPopulated);\n      }\n    }\n  }\n  return evalContext;\n}\n\n// Here we handle the independent profile (IE those in their own files, generated by inspec json).\n// These are slightly simpler because they do not actually include their overlays (even if they depend on them)\n// as a separate data structure.\n// As such, we can just do all the profile and controls from each in one fell swoop\nexport function contextualizeProfile(\n  profile: AnyProfile\n): ContextualizedProfile {\n  const profileContext: ContextualizedProfile = {\n    data: profile,\n    extendedBy: [],\n    extendsFrom: [],\n    contains: [],\n    sourcedFrom: null\n  };\n\n  // Now give it its controls\n  for (const c of profile.controls) {\n    const result = new ContextualizedControlImp(c, profileContext, [], []);\n    profileContext.contains.push(result);\n  }\n\n  return profileContext;\n}\n\n",
  "/api/sources/raw?key=test:libs/inspecjs/src/nist.ts": "import {ControlStatus} from './compat_wrappers';\nimport {ALL_NIST_CONTROL_NUMBERS, ALL_NIST_FAMILIES} from './raw_nist';\n\n// Regexes.\nconst NIST_FAMILY_RE = /^[A-Z]{2}$/;\n// Limit length of children to avoid potential DoS on malicious NIST Control strings\nconst NIST_CONTROL_RE = /^([A-Z]{2})-([0-9]+)(.{0,60})$/;\nconst SPEC_SPLITTER = /[\\s\\(\\)\\.]+/; // Includes all whitespace, periods, and parenthesis\nconst REV_RE = /^rev[\\s_.]+(\\d+)$/i; // Matches Rev_5 etc\ntype ParseNist = NistControl | NistRevision | null;\n\nexport interface CanonizationConfig {\n  max_specifiers: number;\n\n  // All are assumed false\n  pad_zeros?: boolean; // default false\n  allow_letters?: boolean; // default true\n  add_spaces?: boolean; // default true\n  add_parens?: boolean; // default true\n  add_periods?: boolean; // default true\n}\n\nfunction default_partial_config(c: CanonizationConfig): CanonizationConfig {\n  return {\n    pad_zeros: false,\n    allow_letters: true,\n    add_spaces: true,\n    add_parens: true,\n    add_periods: true,\n    ...c\n  };\n}\n\n/** Represents a single nist control, or group of controls if the sub specs are vague enoug. */\nexport class NistControl {\n  /** The sequence of sub-specifiers making up the \"parts\" of the nist tags\n   * E.g.  in \"SI-7 (14)(b)\", we would have [\"SI\", \"7\", \"14\", \"b\"]\n   *       in \"SI-4a.2.\", we would have [\"SI\", \"4\", \"a, \"2\"];\n   * First element is guaranteed to be a 2-letter family\n   * Note that we strip punctuation\n   */\n  subSpecifiers: string[]; // Guaranteed to be of length at least one on a \"real\" control\n\n  /** Holds the string from which this control was generated. */\n  rawText?: string;\n\n  /** Trivial constructor */\n  constructor(subSpecs: string[], rawRext?: string) {\n    this.subSpecifiers = subSpecs;\n    this.rawText = rawRext;\n  }\n\n  /** This function checks if the given control is contained by or equivalent to this control.\n   * It is purely a wrapper around compare_lineage\n   */\n  contains(other: NistControl): boolean {\n    return this.compare_lineage(other) !== -1;\n  }\n\n  /** This function compares this nist control to another nist control.\n   * If the other control is the same control as this one, returns 0.\n   *\n   * If the other control is a child of this control\n   * (IE it is the same base directives with further enhancements, e.g. `IA-4` -> `IA-4b.` or `AC-9a.` -> `AC-9a. (2)`)\n   * and returns how many further enhancements have been applied (IE what is the number of additional subdirectives.)\n   *\n   * If the other control is NOT a child of this control, return -1\n   */\n  compare_lineage(other: NistControl): number {\n    // Can't contain if we're more specific\n    if (this.subSpecifiers.length > other.subSpecifiers.length) {\n      return -1;\n    }\n\n    // After that we just need to iterate\n    for (let i = 0; i < this.subSpecifiers.length; i++) {\n      // If our subspec differentiate at any point, then we do not match\n      if (this.subSpecifiers[i] !== other.subSpecifiers[i]) {\n        return -1;\n      }\n    }\n\n    // We survived! The change in # sub specs is thus the # of changes to enhancements\n    return other.subSpecifiers.length - this.subSpecifiers.length;\n  }\n\n  /** Gives a numeric value indicating how these controls compare, lexicographically.\n   * See string.localCompare for the output format.\n   */\n  localCompare(other: NistControl): number {\n    // Convert into a chain of directives\n    const aChain = this.subSpecifiers;\n    const bChain = other.subSpecifiers;\n    for (let i = 0; i < aChain.length && i < bChain.length; i++) {\n      // Compare corresponding elements of the chain\n      const idA = aChain[i];\n      const idB = bChain[i];\n\n      // Return only if significant\n      const lc = idA.localeCompare(idB, 'en', {numeric: true});\n      if (lc) {\n        return lc;\n      }\n    }\n\n    // Fall back to length comparison. We want shorter first, so ascending's good\n    return aChain.length - bChain.length;\n  }\n\n  /**\n   * Quick accessor to the leading family letters for the nsit control\n   */\n  get family(): string | undefined {\n    if (this.subSpecifiers.length) {\n      return this.subSpecifiers[0];\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * Returns the \"canonical\" representation of this control, based on the provided parameters.\n   * This is, unfortunately, slightly expensive.\n   * Avoid repeating this if possible.\n   */\n  canonize(config: CanonizationConfig): string {\n    config = default_partial_config(config);\n    const ss = this.subSpecifiers;\n\n    // Build our string. Start with family\n    let s = this.family || '';\n    if (ss.length > 1) {\n      s += '-';\n    }\n\n    for (let i = 1; i < ss.length && i < config.max_specifiers; i++) {\n      let spec = ss[i];\n\n      // Handle numbers\n      if (!Number.isNaN(Number.parseInt(spec))) {\n        // If we need to, pad zeros\n        if (config.pad_zeros && spec.length < 2) {\n          spec = '0' + spec;\n        }\n\n        // If index past 1, wrap in parens\n        if (i > 1) {\n          if (config.add_parens) {\n            spec = `(${spec})`;\n          }\n\n          // If space, add space\n          if (config.add_spaces) {\n            spec = ' ' + spec;\n          }\n        }\n\n        // Append\n        s += spec;\n      } else if (config.allow_letters) {\n        // It's a letter. Add a .\n        if (config.add_spaces) {\n          s += ' ';\n        }\n        s += spec;\n        if (config.add_periods) {\n          s += '.';\n        }\n      }\n    }\n    return s;\n  }\n}\n\n/** Wrapper around a revision number. Currently has no additional functionality, but this may change. */\nexport class NistRevision {\n  revNum: number;\n  constructor(revNum: number) {\n    this.revNum = revNum;\n  }\n}\n\nexport function parse_nist(rawNist: string): ParseNist {\n  // Is it a revision? Get the match, continuing if none\n  const revMatch = rawNist.match(REV_RE);\n  if (revMatch) {\n    return new NistRevision(Number.parseInt(revMatch[1]));\n  }\n  // Is it just a family?\n  // Get the match, failing out if we can't\n  const famMatch = rawNist.match(NIST_FAMILY_RE);\n  if (famMatch) {\n    return new NistControl([famMatch[0]], famMatch[0]);\n  }\n\n  // Next try it as a full control\n  const fullMatch = rawNist.match(NIST_CONTROL_RE);\n  if (!fullMatch) {\n    return null;\n  }\n\n  // Parse sub-elements\n  const family = fullMatch[1];\n  const controlNum = fullMatch[2];\n  const subspecsRaw = (fullMatch[3] || '').trim();\n\n  // Init sub-specs\n  const subSpecs: string[] = [family, controlNum];\n\n  // Filter garbage from subspecsRaw\n  let subspecsSplit = subspecsRaw.split(SPEC_SPLITTER);\n  subspecsSplit = subspecsSplit.filter((s) => s !== '');\n  return new NistControl(subSpecs.concat(subspecsSplit), rawNist);\n}\n\n/** Simple discriminators */\nexport function is_control(\n  x: NistControl | NistRevision | null\n): x is NistControl {\n  if (x && (x as NistControl).subSpecifiers !== undefined) {\n    return true;\n  }\n  return false;\n}\n\n/** Simple discriminators */\nexport function is_revision(\n  x: NistControl | NistRevision | null\n): x is NistRevision {\n  if (x && (x as NistRevision).revNum !== undefined) {\n    return true;\n  }\n  return false;\n}\n\n/** All a control in a nist hash really needs is a status */\nexport interface CategoryItemRequirements {\n  status: ControlStatus;\n}\n\n// Represents the status of a group of controsl. Typically holds the value of the \"worst\" control amongst the group\n// Empty means no controls are in the given group\nexport type ControlGroupStatus = ControlStatus | 'Empty';\n\n/**\n * Computes the groups status having added control.\n * There's a natural precedence to statuses, at least in a list/group\n * For instance, we would not mark a group as Passed if it contained a Failed.\n * Clearly \"Empty\" is the lowest precedence, as adding any control would wipe it out.\n * Following we have \"From Profile\" since it is in some way the absence of status, but also lacks run context. We care more about literally anything else\n * Next, \"Not Applicable\" since it means that though we ran we don't care about the result\n * \"Not Reviewed\" implies that had the test run it would've mattered, but it was skipped deliberately\n * \"No Data\" is similarly a lack of result, but in this case unexpected, and thus worthy of more scrutiny\n * \"Passed\" means that a test passed! But \"Failed\" should override, since fails are really what we're looking for\n * Finally, \"Profile Errors\" mean something is broken and needs to be fixed, and thus overrides all\n *\n * Returns:\n * < 0  if a < b (by the above criteria)\n * 0    if a === b\n * > 0  if a > b\n */\nexport function compare_statuses(\n  a: ControlGroupStatus,\n  b: ControlGroupStatus\n): number {\n  const precedence: ControlGroupStatus[] = [\n    'Empty',\n    'From Profile',\n    'Not Applicable',\n    'Not Reviewed',\n    'Passed',\n    'Failed',\n    'Profile Error'\n  ];\n  const idA = precedence.indexOf(a);\n  const idB = precedence.indexOf(b);\n  return idA - idB;\n}\n\nexport function updateStatus(\n  group: ControlGroupStatus,\n  control: ControlStatus\n): ControlGroupStatus {\n  if (compare_statuses(group, control) > 0) {\n    // Our new control has shifted the status!\n    return control;\n  } else {\n    // Our existing group status was \"greater\"\n    return group;\n  }\n}\n\nexport interface NistHierarchyNode {\n  control: NistControl;\n  children: NistHierarchyNode[];\n}\nexport type NistHierarchy = NistHierarchyNode[];\n\nfunction _control_parent(c: NistControl): NistControl | null {\n  if (c.subSpecifiers.length) {\n    return new NistControl(\n      c.subSpecifiers.slice(0, c.subSpecifiers.length - 1)\n    );\n  } else {\n    return null; // Can't get any shorter\n  }\n}\n\nfunction _key_for(c: NistControl): string {\n  return c.subSpecifiers.join('-');\n}\n\nfunction _generate_full_nist_hierarchy(): NistHierarchy {\n  // Initialize our roots\n  const roots: NistHierarchy = ALL_NIST_FAMILIES.map((family) => {\n    return {\n      control: new NistControl([family], family),\n      children: []\n    };\n  });\n\n  // Init our map, which maps _key_for of controls to their corresponding hierarchy nodes\n  const map: {[key: string]: NistHierarchyNode} = {};\n\n  // Add roots to the map\n  roots.forEach((r) => {\n    map[_key_for(r.control)] = r;\n  });\n\n  // Iterate over all controls\n  ALL_NIST_CONTROL_NUMBERS.forEach((n) => {\n    const asControl = parse_nist(n) as NistControl | null; // We know there are no revs in our file\n    if (!asControl) {\n      throw new Error(`Invalid nist control constant ${n}`);\n    }\n\n    // If our node has already been created, replace the temporary control with the \"real\" one\n    const key = _key_for(asControl);\n    let asNode: NistHierarchyNode;\n    if (map[key]) {\n      asNode = map[key];\n      asNode.control = asControl;\n    } else {\n      //Make it fresh\n      asNode = {\n        control: asControl,\n        children: []\n      };\n\n      // Register in map\n      map[key] = asNode;\n    }\n\n    const parent = _control_parent(asControl);\n\n    // If parent is null, add to roots.\n    if (!parent) {\n      roots.push({\n        control: asControl,\n        children: []\n      });\n    } else {\n      // Valid parent; look it up and append us to it\n      const parentKey = _key_for(parent);\n      const parentNode = map[parentKey];\n\n      // If parent has been explored already, simply append this node to that\n      if (parentNode) {\n        parentNode.children.push(asNode);\n      } else {\n        // It's not? make a stub\n        map[parentKey] = {\n          control: parent,\n          children: [asNode] // \"Us\"\n        };\n      }\n    }\n  });\n\n  // Now roots are our final answers!\n  return roots;\n}\n\nexport const FULL_NIST_HIERARCHY: Readonly<NistHierarchy> =\n  _generate_full_nist_hierarchy();\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/store/data_store.ts": "/**\n * Tracks uploaded files, and their parsed contents\n */\n\nimport {\n  EvaluationFile,\n  FileID,\n  ProfileFile,\n  SourcedContextualizedEvaluation,\n  SourcedContextualizedProfile\n} from '@/store/report_intake';\nimport Store from '@/store/store';\nimport {\n  Action,\n  getModule,\n  Module,\n  Mutation,\n  VuexModule\n} from 'vuex-module-decorators';\nimport {FilteredDataModule} from './data_filters';\n\n/** We make some new variant types of the Contextual types, to include their files*/\nexport function isFromProfileFile(p: SourcedContextualizedProfile) {\n  return p.sourcedFrom === null;\n}\n\n@Module({\n  namespaced: true,\n  dynamic: true,\n  store: Store,\n  name: 'data'\n})\nexport class InspecData extends VuexModule {\n  /** State var containing all execution files that have been added */\n  executionFiles: EvaluationFile[] = [];\n\n  /** State var containing all profile files that have been added */\n  profileFiles: ProfileFile[] = [];\n\n  /** Return all of the files that we currently have. */\n  get allFiles(): (EvaluationFile | ProfileFile)[] {\n    const result: (EvaluationFile | ProfileFile)[] = [];\n    result.push(...this.executionFiles);\n    result.push(...this.profileFiles);\n    return result;\n  }\n\n  /* Return all evaluation files only */\n  get allEvaluationFiles(): EvaluationFile[] {\n    return this.executionFiles;\n  }\n\n  /* Return all profile files only */\n  get allProfileFiles(): ProfileFile[] {\n    return this.profileFiles;\n  }\n\n  /**\n   * Returns a readonly list of all executions currently held in the data store\n   * including associated context\n   */\n  get contextualExecutions(): readonly SourcedContextualizedEvaluation[] {\n    return this.executionFiles.map((file) => file.evaluation);\n  }\n\n  get loadedDatabaseIds(): string[] {\n    const ids: string[] = [];\n    this.allFiles.forEach((file) => {\n      if (file.database_id) {\n        ids.push(file.database_id.toString());\n      }\n    });\n    return ids;\n  }\n\n  /**\n   * Returns a readonly list of all profiles belonging to executions currently\n   * held in the data store\n   */\n  get contextualExecutionProfiles(): readonly SourcedContextualizedProfile[] {\n    return this.contextualExecutions.flatMap(\n      (evaluation) => evaluation.contains\n    ) as SourcedContextualizedProfile[];\n  }\n\n  /**\n   * Returns a readonly list of all profiles currently held in the data store\n   * including associated context\n   */\n  get contextualProfiles(): readonly SourcedContextualizedProfile[] {\n    return this.profileFiles.map((file) => file.profile);\n  }\n\n  get allProfiles(): readonly SourcedContextualizedProfile[] {\n    return this.contextualProfiles.concat(this.contextualExecutionProfiles);\n  }\n\n  /**\n   * Adds a profile file to the store.\n   * @param newProfile The profile to add\n   */\n  @Mutation\n  addProfile(newProfile: ProfileFile) {\n    this.profileFiles.push(newProfile);\n  }\n\n  /**\n   * Adds an execution file to the store.\n   * @param newExecution The execution to add\n   */\n  @Mutation\n  addExecution(newExecution: EvaluationFile) {\n    this.executionFiles.push(newExecution);\n  }\n\n  /**\n   * Unloads the file with the given id\n   */\n  @Action\n  removeFile(fileId: FileID) {\n    FilteredDataModule.clear_file(fileId);\n    this.context.commit('REMOVE_PROFILE', fileId);\n    this.context.commit('REMOVE_RESULT', fileId);\n  }\n\n  @Mutation\n  REMOVE_PROFILE(fileId: FileID) {\n    this.profileFiles = this.profileFiles.filter(\n      (pf) => pf.uniqueId !== fileId\n    );\n  }\n\n  @Mutation\n  REMOVE_RESULT(fileId: FileID) {\n    this.executionFiles = this.executionFiles.filter(\n      (ef) => ef.uniqueId !== fileId\n    );\n  }\n\n  /**\n   * Clear all stored data.\n   */\n  @Mutation\n  reset() {\n    this.profileFiles = [];\n    this.executionFiles = [];\n  }\n}\n\nexport const InspecDataModule = getModule(InspecData);\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/components/cards/treemap/Cell.vue": "<template>\n  <!-- We can use Vue transitions too! -->\n  <g>\n    <!-- Generate our children here. Only do so for parents, and if they aren't too deep -->\n    <g v-if=\"is_parent\">\n      <Cell\n        v-for=\"child in node.children\"\n        :key=\"child.data.key\"\n        :selected-control-id=\"selectedControlId\"\n        :depth=\"depth + 1\"\n        :node=\"child\"\n        :scales=\"scales\"\n        @select-node=\"select_node\"\n      />\n    </g>\n\n    <!-- The actual body of this square. Visible only if depth === 1 (ie a direct child of parent) or depth === 2 (one level deeper) -->\n    <rect\n      v-if=\"depth >= 1\"\n      :style=\"cell_style\"\n      :x=\"x\"\n      :y=\"y\"\n      :width=\"width\"\n      :height=\"height\"\n      :class=\"cell_classes\"\n      :rx=\"is_selected ? 20 : 0\"\n      @click=\"select_node(node)\"\n    />\n\n    <text\n      v-if=\"depth === 1\"\n      dominant-baseline=\"middle\"\n      text-anchor=\"middle\"\n      :x=\"x + width / 2\"\n      :y=\"y + height / 2\"\n      >{{ node.data.title }}</text\n    >\n  </g>\n</template>\n\n<script lang=\"ts\">\nimport {is_leaf, TreemapNode, TreemapNodeLeaf} from '@/utilities/treemap_util';\nimport * as d3 from 'd3';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\nimport {Prop} from 'vue-property-decorator';\n\nexport interface XYScale {\n  scale_x: d3.ScaleLinear<number, number>;\n  scale_y: d3.ScaleLinear<number, number>;\n}\n\n/**\n * Categories property must be of type Category\n * Emits \"select-node\" with payload of type d3.HierarchyRectangularNode<TreemapNode>\n */\n@Component({\n  name: 'Cell'\n})\nexport default class Cell extends Vue {\n  @Prop({type: String}) readonly selectedControlId!: string;\n  @Prop({type: Object, required: true})\n  readonly node!: d3.HierarchyRectangularNode<TreemapNode>;\n\n  @Prop({type: Number, default: 0}) readonly depth!: number;\n  @Prop({type: Object, default: 0}) readonly scales!: XYScale;\n\n  scale = 1.0;\n\n  /** Are we a control? Use treemap util type checker */\n  get is_control(): boolean {\n    return is_leaf(this.node.data);\n  }\n\n  /** Invert of above. Checks if this node has children, essentially */\n  get is_parent(): boolean {\n    return !this.is_control;\n  }\n\n  /** Are we selected? True if selectedControlId matches our id, and we are in selected hierarchy */\n  get is_selected(): boolean {\n    return (\n      this.is_control && // We are a control\n      (this.node.data as TreemapNodeLeaf).control.data.id ===\n        this.selectedControlId // Our control id matches\n    );\n  }\n\n  /** Compute the top-left x coord of this cell rect based on the provided scale_x prop */\n  get x(): number {\n    return this.scales.scale_x(this.node.x0);\n  }\n\n  /** Compute the top-left y coord of this cell rect based on the provided scale_y prop */\n  get y(): number {\n    return this.scales.scale_y(this.node.y0);\n  }\n\n  /**\n   * Compute the width of this rect based on scale, and base x position\n   */\n  get width(): number {\n    return this.scales.scale_x(this.node.x1) - this.x;\n  }\n\n  /**\n   * Compute the height of this rect based on scale, and base y position\n   */\n  get height(): number {\n    return this.scales.scale_y(this.node.y1) - this.y;\n  }\n\n  /** Returns a list of classes appropriate to this nodes Rect\n   * These are contextual based on type of data, and depth within the tree\n   */\n  get cell_classes(): string[] {\n    const s: string[] = [];\n    if (this.is_parent) {\n      s.push('parent');\n      if (!this.node.children || !this.node.children.length) {\n        s.push('empty');\n      }\n    } else {\n      s.push('leaf');\n    }\n\n    // Depth stuff\n    if (this.depth === 0) {\n      s.push('root');\n    } else if (this.depth === 1) {\n      s.push('top');\n    } else if (this.depth >= 1) {\n      s.push('nested');\n    }\n\n    return s;\n  }\n\n  get cell_style(): string {\n    if (this.node.data.color) {\n      return `fill: ${this.node.data.color.css()};`;\n    }\n    return 'fill-opacity: 0';\n  }\n\n  /**\n   * Callback fired when the user clicks a node. Passes up from cell to cell until it reaches Treemap\n   */\n  select_node(n: d3.HierarchyRectangularNode<TreemapNode>): void {\n    // Pass it up to root\n    this.$emit('select-node', n);\n  }\n}\n</script>\n\n<style scoped>\ntext {\n  pointer-events: none;\n}\n\n.theme--dark text {\n  fill: #f8f8f8;\n  font-size: large;\n}\n\n/* Basic settings for our chart. Things unclickable by default */\nrect {\n  stroke: #000000;\n  pointer-events: none;\n  fill-opacity: 0;\n}\n\n/* We want top to be clickable. */\nrect.top {\n  pointer-events: auto;\n  stroke-width: 2;\n}\n\n/* We want leaves */\nrect.leaf {\n  fill-opacity: 1;\n}\n\n/* Otherwise, don't want nested to draw strokes */\nrect.nested {\n  stroke-width: 1;\n}\n\nrect.nested.leaf {\n  stroke-width: 0;\n}\n\n/* Make tops transparent but also more thickly drawn when hovered */\nrect.top:hover {\n  stroke-width: 3;\n}\n</style>\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/components/generic/ApexLineChart.vue": "<template>\n  <div style=\"color: black\">\n    <vue-apex-charts\n      type=\"line\"\n      height=\"350\"\n      :options=\"chartOptions\"\n      :series=\"series\"\n    />\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport {ApexOptions} from 'apexcharts';\nimport Vue from 'vue';\nimport VueApexCharts from 'vue-apexcharts';\nimport Component from 'vue-class-component';\nimport {Prop} from 'vue-property-decorator';\nimport {Category} from './ApexPieChart.vue';\n\nexport interface SeriesItem {\n  name: string;\n  data: number[];\n}\n\n/**\n * Emits \"category-selected\" with payload of type Category whenever a category is selected.\n */\n@Component({\n  components: {\n    VueApexCharts\n  }\n})\nexport default class ApexLineChart extends Vue {\n  @Prop({required: true, type: Array}) readonly categories!: Category<string>[];\n  @Prop({required: true, type: Array}) readonly series!: number[];\n  @Prop({type: Number}) readonly upperRange!: number; //upper bound of y axis\n  @Prop({type: Boolean}) readonly sevChart!: boolean; //identifies chart as severity chart\n  @Prop({type: String}) readonly title!: string;\n  @Prop({type: String}) readonly yTitle!: string;\n\n  //gives apex charts the severity colors\n  sevColors: string[] = ['#FFEB3B', '#FF9800', '#FF5722', '#F44336'];\n\n  get label_colors(): string[] {\n    const colors = [];\n    for (let i = 0; i < this.categories.length; i++) {\n      colors.push('#FFFFFF');\n    }\n    return colors;\n  }\n\n  //creates differing number of ticks based on number of controls\n  get y_axis_tick(): number {\n    if (this.upperRange < 15) {\n      return this.upperRange;\n    } else if (this.upperRange < 50) {\n      return Math.floor(this.upperRange / 5);\n    } else {\n      return Math.floor(this.upperRange / 10);\n    }\n  }\n\n  get line_colors(): string[] | undefined {\n    if (this.sevChart) {\n      return this.sevColors;\n    }\n    return undefined;\n  }\n\n  // Generate the chart options based on _categories\n  get chartOptions(): ApexOptions {\n    return {\n      chart: {\n        height: 350,\n        type: 'line',\n        zoom: {\n          enabled: false\n        }\n        //background: '#000'\n      },\n      colors: this.line_colors,\n      dataLabels: {\n        enabled: false\n      },\n      stroke: {\n        width: 5,\n        curve: 'straight'\n      },\n      title: {\n        text: this.title,\n        align: 'left',\n        style: {\n          fontFamily: 'Arial Black',\n          fontSize: '14px',\n          color: '#FFFFFF'\n        }\n      },\n      legend: {\n        labels: {\n          useSeriesColors: true\n        }\n      },\n      xaxis: {\n        categories: this.categories,\n        labels: {\n          style: {\n            colors: this.label_colors\n          }\n        }\n      },\n      yaxis: {\n        min: 0,\n        max: this.upperRange,\n        tickAmount: this.y_axis_tick,\n        axisTicks: {\n          color: '#FF0000'\n        },\n        axisBorder: {\n          show: true,\n          color: '#FFFFFF',\n          offsetX: 0,\n          offsetY: 0\n        },\n        title: {\n          text: this.yTitle,\n          style: {\n            color: '#FFFFFF'\n          }\n        },\n        labels: {\n          style: {\n            colors: '#FFFFFF'\n          }\n        }\n      },\n      grid: {\n        borderColor: '#f1f1f1'\n      }\n    };\n  }\n}\n</script>\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/utilities/delta_util.ts": "/**\n * Provides utlities for comparing executions\n */\n\nimport {SourcedContextualizedEvaluation} from '@/store/report_intake';\nimport {ContextualizedControl, ContextualizedEvaluation} from 'inspecjs';\nimport {DateTime} from 'luxon';\n\nexport const NOT_SELECTED = 'not selected';\n\n// Unique ID is the unique ID of a file\n// Controls is a list of controls\ninterface ResultControls {\n  uniqueId: string;\n  controls: ContextualizedControl[];\n}\n\n/**\n * Represents a change in a property.\n * We assume that the \"old\" property is the name to use for both.\n * IE that they are the same property value.\n */\nexport class ControlChange {\n  name: string; // the key/title of these values\n  values: string[]; // values over controls sorted by time\n\n  /** Trivial constructor */\n  constructor(name: string, values: string[]) {\n    this.values = values;\n    this.name = name;\n  }\n\n  /** Checks if this actually changes anything.\n   * Returns true iff old !== new\n   */\n  get valid(): boolean {\n    let firstSelected = -1;\n    for (let i = 0; i < this.values.length; i++) {\n      if (this.values[i] !== NOT_SELECTED) {\n        firstSelected = i;\n        break;\n      }\n    }\n    if (firstSelected === -1) {\n      return false;\n    }\n    for (let i = firstSelected + 1; i < this.values.length; i++) {\n      if (\n        this.values[i] !== this.values[firstSelected] &&\n        this.values[i] !== NOT_SELECTED\n      ) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\n/**\n * Represents a group of changes all under one cnosistent named banner.\n */\nexport class ControlChangeGroup {\n  name: string;\n  changes: ControlChange[];\n\n  /** Trivial constructor */\n  constructor(name: string, changes: ControlChange[]) {\n    this.name = name;\n    this.changes = changes;\n  }\n\n  /** Checks if this has any changes at all. Simple shorthand */\n  get any(): boolean {\n    return this.changes.length > 0;\n  }\n\n  /** Removes any changes if they aren't actually changes */\n  clean() {\n    this.changes = this.changes.filter((c) => c.valid);\n  }\n}\n\n/**\n * Holds/computes the differences between two runs of the same control.\n */\nexport class ControlDelta {\n  controls: ContextualizedControl[] = [];\n  controlsandnull: (ContextualizedControl | null)[] = [];\n  numNull = 0;\n\n  constructor(controls: (ContextualizedControl | null)[]) {\n    this.controlsandnull = controls;\n    for (const value of controls) {\n      if (value !== null) {\n        this.controls.push(value);\n      } else {\n        this.numNull += 1;\n      }\n    }\n  }\n\n  /** Returns the changes in \"header\" elements of a control. E.g. name, status, etc. */\n  get headerChanges(): ControlChangeGroup {\n    // Init the list\n    const headerChanges: ControlChange[] = [];\n\n    // Change in... ID? Theoretically possible!\n    headerChanges.push(\n      new ControlChange(\n        'ID',\n        this.controlsandnull.map((c) => {\n          if (c === null) {\n            return NOT_SELECTED;\n          }\n          return c.data.id;\n        })\n      )\n    );\n\n    // And severity! Why not\n    headerChanges.push(\n      new ControlChange(\n        'Severity',\n        this.controlsandnull.map((c) => {\n          if (c === null) {\n            return NOT_SELECTED;\n          }\n          return c.hdf.severity;\n        })\n      )\n    );\n\n    // Change in nist tags!\n    headerChanges.push(\n      new ControlChange(\n        'NIST Tags',\n        this.controlsandnull.map((c) => {\n          if (c === null) {\n            return NOT_SELECTED;\n          }\n          return c.hdf.rawNistTags.join(', ');\n        })\n      )\n    );\n\n    // Make the group and clean it\n    const result = new ControlChangeGroup('Control Details', headerChanges);\n    result.clean();\n    return result;\n  }\n}\n\nexport function get_eval_start_time(\n  ev: ContextualizedEvaluation\n): string | null {\n  for (const prof of ev.contains) {\n    for (const ctrl of prof.contains) {\n      if (ctrl.hdf.segments!.length) {\n        return ctrl.hdf.segments![0].start_time;\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Grabs the \"top\" (IE non-overlayed/end of overlay chain) controls from the execution.\n *\n * @param exec The execution to grab controls from\n */\nfunction extract_top_level_controls(\n  exec: SourcedContextualizedEvaluation\n): ResultControls {\n  // Get all controls\n  const allControls = exec.contains.flatMap((p) => p.contains);\n\n  // Filter to controls that aren't overlayed further\n  const top = allControls.filter((control) => control.extendedBy.length === 0);\n  return {uniqueId: exec.from_file.uniqueId, controls: top};\n}\n\n/** An object of contextualized controls with the same V-ID */\nexport type ControlSeries = {[key: string]: ContextualizedControl};\n\n/** Matches ControlID keys to Arrays of Controls */\nexport type ControlSeriesLookup = {[key: string]: ControlSeries};\n\n/** Helps manage comparing change(s) between one or more profile executions */\nexport class ComparisonContext {\n  /** A list of old-new control pairings */\n  pairings: ControlSeriesLookup;\n\n  constructor(executions: readonly SourcedContextualizedEvaluation[]) {\n    // Get all of the \"top level\" controls from each execution, IE those that actually ran\n    // grouped by their files unique id.\n    const allControls = executions.map(extract_top_level_controls);\n    // Organize the controls by ID\n    // The structure this returns is as follows:\n    // {{\"V-XXX\": {\"unique_file_id_1\": control, \"unique_file_id_2\": control, ...}}}\n    const matched = allControls.reduce(\n      (acc: ControlSeriesLookup, evaluation: ResultControls) => {\n        evaluation.controls.forEach((control) => {\n          // Group initialization\n          if (!acc[control.data.id]) {\n            acc[control.data.id] = {};\n          }\n          // Grouping\n          acc[control.data.id][evaluation.uniqueId] = control;\n        });\n\n        return acc;\n      },\n      {}\n    );\n    // Store\n    this.pairings = matched;\n  }\n}\n\n/*\n  DateTime parsing in Chrome works very different than Safari and Firefox\n  Using luxon provides consistent timestamp information with a fallback to\n  using the native browser date parsing.\n\n  Chrome already supports parsing all of these formats natively, however it\n  is the only browser that does so.\n*/\nexport function parse_datetime(dateString: string): DateTime {\n  let result: DateTime;\n\n  result = DateTime.fromRFC2822(dateString);\n  if (result.isValid) {\n    return result;\n  }\n  result = DateTime.fromISO(dateString);\n  if (result.isValid) {\n    return result;\n  }\n  result = DateTime.fromHTTP(dateString);\n  if (result.isValid) {\n    return result;\n  }\n  result = DateTime.fromSQL(dateString);\n  if (result.isValid) {\n    return result;\n  }\n\n  return DateTime.fromJSDate(new Date(dateString));\n}\n\nexport function compare_times(\n  a: SourcedContextualizedEvaluation,\n  b: SourcedContextualizedEvaluation\n) {\n  const aDate = parse_datetime(get_eval_start_time(a) || '');\n  const bDate = parse_datetime(get_eval_start_time(b) || '');\n\n  return aDate.valueOf() - bDate.valueOf();\n}\n\n",
  "/api/sources/raw?key=test:apps/frontend/tests/unit/Compare.spec.ts": "import {FilteredDataModule} from '@/store/data_filters';\nimport {SearchModule} from '@/store/search';\nimport {StatusCountModule} from '@/store/status_counts';\nimport {ComparisonContext, ControlSeries} from '@/utilities/delta_util';\nimport Compare from '@/views/Compare.vue';\nimport {shallowMount, Wrapper} from '@vue/test-utils';\nimport 'jest';\nimport Vue from 'vue';\nimport Vuetify from 'vuetify';\nimport {fileCompliance, loadSample, removeAllFiles} from '../util/testingUtils';\n\nconst vuetify = new Vuetify();\n\nconst wrapper: Wrapper<Vue> = shallowMount(Compare, {\n  vuetify,\n  propsData: {}\n});\n\nexport interface SeriesItem {\n  name: string;\n  data: number[];\n}\n\nconst redHatControlCount = 247;\nconst nginxControlCount = 41;\nconst nginxDelta = 3;\n\ndescribe('Compare table data', () => {\n  loadSample('NGINX With Failing Tests');\n  it('correctly counts controls with 1 file', () => {\n    (wrapper.vm as Vue & {changedOnly: boolean}).changedOnly = false;\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(nginxControlCount);\n  });\n\n  it('does not recount same controls with 2 files', () => {\n    loadSample('NGINX With Failing Tests');\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(nginxControlCount);\n  });\n\n  it('does not recount same controls with 3 files', () => {\n    loadSample('NGINX With Failing Tests');\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(nginxControlCount);\n  });\n\n  it('does not show any changed between two of the same', () => {\n    (wrapper.vm as Vue & {changedOnly: boolean}).changedOnly = true;\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(0);\n  });\n\n  it('search works when nothing fits criteria', () => {\n    (wrapper.vm as Vue & {searchTerm: string}).searchTerm = 'failed';\n    SearchModule.parseSearch();\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(0);\n  });\n\n  it('search id works', () => {\n    (wrapper.vm as Vue & {changedOnly: boolean}).changedOnly = false;\n    (wrapper.vm as Vue & {searchTerm: string}).searchTerm = 'v-13613';\n    SearchModule.parseSearch();\n    setTimeout(() => {\n      expect(\n        (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n          .length\n      ).toBe(1);\n    }, 1000);\n  });\n\n  it('shows differing delta data when \"show only changed\"', () => {\n    (wrapper.vm as Vue & {searchTerm: string}).searchTerm = '';\n    (wrapper.vm as Vue & {changedOnly: boolean}).changedOnly = true;\n    loadSample('NGINX Clean Sample');\n    SearchModule.parseSearch();\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(nginxDelta);\n  });\n\n  it('search status works', () => {\n    (wrapper.vm as Vue & {changedOnly: boolean}).changedOnly = false;\n    (wrapper.vm as Vue & {searchTerm: string}).searchTerm = 'failed';\n    SearchModule.parseSearch();\n    setTimeout(() => {\n      expect(\n        (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n          .length\n      ).toBe(nginxDelta);\n    }, 1000);\n  });\n\n  it('counts every unique control', () => {\n    loadSample('Red Hat With Failing Tests');\n    (wrapper.vm as Vue & {searchTerm: string}).searchTerm = '';\n    (wrapper.vm as Vue & {changedOnly: boolean}).changedOnly = true;\n    SearchModule.parseSearch();\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(nginxControlCount + redHatControlCount);\n  });\n\n  it('shows all delta data of controls with multiple occurances when \"show only changed\"', () => {\n    loadSample('Red Hat Clean Sample');\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(nginxControlCount + redHatControlCount);\n  });\n\n  it('ComparisonContext counts status correctly', () => {\n    let failed = 0;\n    let passed = 0;\n    let na = 0;\n    let nr = 0;\n    let pe = 0;\n    const selectedData = FilteredDataModule.evaluations(\n      FilteredDataModule.selected_file_ids\n    );\n    const currDelta = new ComparisonContext(selectedData);\n    for (const pairing of Object.values(currDelta.pairings)) {\n      for (const ctrl of Object.values(pairing)) {\n        if (ctrl === null) {\n          continue;\n        } else if (ctrl.root.hdf.status === 'Passed') {\n          passed++;\n        } else if (ctrl.root.hdf.status === 'Failed') {\n          failed++;\n        } else if (ctrl.root.hdf.status === 'Not Applicable') {\n          na++;\n        } else if (ctrl.root.hdf.status === 'Not Reviewed') {\n          nr++;\n        } else if (ctrl.root.hdf.status === 'Profile Error') {\n          pe++;\n        }\n      }\n    }\n    const expected = {\n      Failed: StatusCountModule.hash({\n        omit_overlayed_controls: true,\n        fromFile: [...FilteredDataModule.selected_file_ids]\n      }).Failed,\n      Passed: StatusCountModule.hash({\n        omit_overlayed_controls: true,\n        fromFile: [...FilteredDataModule.selected_file_ids]\n      }).Passed,\n      'From Profile': 0,\n      'Profile Error': StatusCountModule.hash({\n        omit_overlayed_controls: true,\n        fromFile: [...FilteredDataModule.selected_file_ids]\n      })['Profile Error'],\n      'Not Reviewed': StatusCountModule.hash({\n        omit_overlayed_controls: true,\n        fromFile: [...FilteredDataModule.selected_file_ids]\n      })['Not Reviewed'],\n      'Not Applicable': StatusCountModule.hash({\n        omit_overlayed_controls: true,\n        fromFile: [...FilteredDataModule.selected_file_ids]\n      })['Not Applicable']\n    };\n    const actual = {\n      Failed: failed,\n      Passed: passed,\n      'From Profile': 0,\n      'Profile Error': pe,\n      'Not Reviewed': nr,\n      'Not Applicable': na\n    };\n    expect(actual).toEqual(expected);\n  });\n});\n\ndescribe('compare charts', () => {\n  it('sev chart gets correct data with 2 files', () => {\n    removeAllFiles();\n    loadSample('NGINX With Failing Tests');\n    loadSample('NGINX Clean Sample');\n    //the values in expected are the correct data\n    expect((wrapper.vm as Vue & {sev_series: number[][]}).sev_series).toEqual([\n      [0, 0],\n      [3, 0],\n      [0, 0],\n      [0, 0]\n    ]);\n  });\n\n  it('sev chart gets correct data with 2 files with differing profiles', () => {\n    removeAllFiles();\n    loadSample('NGINX With Failing Tests');\n    loadSample('Red Hat With Failing Tests');\n    //the values in expected are the correct data\n    expect((wrapper.vm as Vue & {sev_series: number[][]}).sev_series).toEqual([\n      [0, 6],\n      [3, 18],\n      [0, 3],\n      [0, 0]\n    ]);\n  });\n\n  it('sev chart gets correct data with 2 files with overlayed profiles', () => {\n    removeAllFiles();\n    loadSample('Triple Overlay Example');\n    loadSample('Acme Overlay Example');\n    //the values in expected are the correct data\n    expect((wrapper.vm as Vue & {sev_series: number[][]}).sev_series).toEqual([\n      [3, 0],\n      [51, 0],\n      [1, 0],\n      [0, 60]\n    ]);\n  });\n\n  it('compliance chart gets correct data with 2 files', () => {\n    removeAllFiles();\n    loadSample('NGINX With Failing Tests');\n    loadSample('NGINX Clean Sample');\n    expect(\n      new Set(\n        (\n          wrapper.vm as Vue & {\n            compliance_series: SeriesItem[];\n          }\n        ).compliance_series[0].data\n      )\n    ).toEqual(\n      new Set([\n        fileCompliance(FilteredDataModule.selected_file_ids[0]),\n        fileCompliance(FilteredDataModule.selected_file_ids[1])\n      ])\n    );\n  });\n\n  it('compliance chart gets correct data with 2 files with differing profiles', () => {\n    removeAllFiles();\n    loadSample('NGINX With Failing Tests');\n    loadSample('Red Hat With Failing Tests');\n    expect(\n      new Set(\n        (\n          wrapper.vm as Vue & {\n            compliance_series: SeriesItem[];\n          }\n        ).compliance_series[0].data\n      )\n    ).toEqual(\n      new Set([\n        fileCompliance(FilteredDataModule.selected_file_ids[0]),\n        fileCompliance(FilteredDataModule.selected_file_ids[1])\n      ])\n    );\n  });\n\n  it('compliance chart gets correct data with 2 files with overlayed profiles', () => {\n    removeAllFiles();\n    loadSample('Triple Overlay Example');\n    loadSample('Acme Overlay Example');\n    expect(\n      new Set(\n        (\n          wrapper.vm as Vue & {\n            compliance_series: SeriesItem[];\n          }\n        ).compliance_series[0].data\n      )\n    ).toEqual(\n      new Set([\n        fileCompliance(FilteredDataModule.selected_file_ids[0]),\n        fileCompliance(FilteredDataModule.selected_file_ids[1])\n      ])\n    );\n  });\n});\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/utilities/splunk_util.ts": "import {ConversionResult, convertFile, ExecJSON} from 'inspecjs';\nimport {ElementCompact, xml2js} from 'xml-js';\nimport {delay} from './async_util';\nimport {basic_auth, group_by, map_hash} from './helper_util';\n\nexport type JobID = string;\n\n// Interfaces\n/** The parent type to other interfaces, to save duplication */\ninterface AbsMetaInfo {\n  /** The file this came from */\n  filename: string;\n\n  /** The type of the file (NOT of this event!) */\n  filetype: 'evaluation' | 'profile';\n\n  /** The subtype of this specific event */\n  subtype: 'header' | 'profile' | 'control';\n\n  /** A randomly generated GUID capturing all of the events in this file */\n  guid: string;\n\n  /** When this event was parsed */\n  parse_time: string;\n\n  /** The schema version: */\n  hdf_splunk_schema: string;\n\n  /** The sha256 hash of the profile that is/contains this event */\n  profile_sha256: string;\n\n  /** The start time of the control in ISO format */\n  startTime: string;\n\n  /** The control ID, repeated for convenience in splunk searches */\n  control_id: string;\n}\n\n/** The meta information for an event with the \"evaluation\" subtype */\nexport interface ExecutionMetaInfo\n  extends Omit<AbsMetaInfo, 'control_id' | 'startTime' | 'profile_sha256'> {\n  subtype: 'header';\n}\n\n/** The meta information for an event with the \"profile\" subtype */\nexport interface ProfileMetaInfo\n  extends Omit<AbsMetaInfo, 'control_id' | 'startTime'> {\n  subtype: 'profile';\n}\n\n/** The meta information for an event with the \"control\" subtype */\nexport interface ControlMetaInfo extends AbsMetaInfo {\n  subtype: 'control';\n}\n\n/** This is what we expect to find in every parsed event representing an Evaluation\n * Note that Profiles will typically be initially empty\n */\nexport interface ExecutionPayload {\n  meta: ExecutionMetaInfo;\n  profiles: ProfilePayload[];\n}\n\n/** This is what we expect to find in every parsed event representing a Profile.\n * Note that controls will typically be initially empty\n */\nexport interface ProfilePayload {\n  meta: ProfileMetaInfo;\n  controls: ControlPayload[];\n}\n\n/** This is what we expect to find in every parsed event representing a Control */\nexport interface ControlPayload {\n  meta: ControlMetaInfo;\n}\n\n// Could be any!\nexport type UnknownPayload = ExecutionPayload | ProfilePayload | ControlPayload;\n\n/* Job states */\ntype CompleteJobStatus = 'succeeded' | 'failed';\ntype PendingJobStatus = 'pending'; // There are others, but we don't handle them for now\ntype JobStatus = CompleteJobStatus | PendingJobStatus;\ninterface JobState {\n  status: JobStatus;\n  jobId: JobID;\n}\n\n/** This info is used to negotiate splunk connections */\nexport class SplunkEndpoint {\n  /** The full host information, including port (typically 8089).\n   * EX: https://localhost:8089\n   */\n  host: string;\n\n  /** Username to use for authentication */\n  username: string;\n\n  /** Password to use for authentication */\n  password: string;\n\n  constructor(host: string, username: string, password: string) {\n    this.host = host;\n    this.username = username;\n    this.password = password;\n  }\n\n  /** Checks whether we're able to successfully get jobs,\n   * which indicates proper auth.\n   *\n   * Will error if we aren't\n   */\n\n  process_response(response: Response) {\n    if (!response.ok) {\n      throw process_error(response);\n    }\n    return response.text();\n  }\n\n  async check_auth(): Promise<void> {\n    return fetch(`${this.host}/services/search/jobs`, {\n      headers: {\n        Authorization: this.authString\n      },\n      method: 'GET'\n    }).then(\n      (response) => {\n        if (!response.ok) {\n          throw process_error(response);\n        }\n      },\n      (failure) => {\n        throw process_error(failure);\n      }\n    );\n  }\n\n  /** Provides a list of Evaluation meta headers from recent executions.\n   * We should eventually change this to allow more specific criteria\n   */\n  async fetch_execution_list(): Promise<ExecutionMetaInfo[]> {\n    // This search lists evaluation headers\n    const getExecutionsSearch =\n      'spath \"meta.subtype\" | search \"meta.subtype\"=header';\n\n    return this.hdf_event_search(getExecutionsSearch).then((events) => {\n      // Because we only searched for headers, we can assume these to be eval events\n      const evalEvents = events as ExecutionPayload[];\n\n      // Could perhaps just return e but I'd rather people didn't screw themselves\n      return evalEvents.map((e) => e.meta);\n    });\n  }\n\n  async get_execution_events(executionGuid: string): Promise<UnknownPayload[]> {\n    // This search, provided a guid, returns all headers for that guid\n    const specificEvaluation = `spath \"meta.guid\" | search \"meta.guid\"=${executionGuid}`;\n    return this.hdf_event_search(specificEvaluation);\n  }\n\n  async get_execution(executionGuid: string): Promise<ExecJSON.Execution> {\n    return this.get_execution_events(executionGuid)\n      .then((events) => consolidate_payloads(events))\n      .then((execs) => {\n        if (execs.length !== 1) {\n          throw SplunkErrorCode.InvalidGUID;\n        } else {\n          return execs[0];\n        }\n      })\n      .then((fullEvent) => {\n        // This is dumb and we should make the inspecjs layer more accepting of many file types\n        let result: ConversionResult;\n        try {\n          result = convertFile(JSON.stringify(fullEvent));\n        } catch (e) {\n          throw SplunkErrorCode.SchemaViolation;\n        }\n\n        // Determine what sort of file we (hopefully) have, then add it\n        if (result['1_0_ExecJson']) {\n          // Handle as exec\n          return result['1_0_ExecJson'];\n        } else {\n          throw SplunkErrorCode.SchemaViolation;\n        }\n      });\n  }\n\n  /** Creates a proper base64 encoded auth string, using this objects credentials. */\n  private get authString(): string {\n    return basic_auth(this.username, this.password);\n  }\n\n  /** Performs the entire process of search string -> results array\n   *  Performs no consolidation.\n   *  Assumes your search string is properly constrained to the hdf index\n   */\n  async hdf_event_search(searchString: string): Promise<UnknownPayload[]> {\n    return this.create_search(searchString)\n      .then((jobId) => this.pend_job(jobId, 500))\n      .then((jobState) => {\n        if (jobState.status === 'failed') {\n          throw SplunkErrorCode.SearchFailed;\n        }\n\n        return this.get_search_results(jobState.jobId);\n      })\n      .catch((error) => {\n        throw process_error(error);\n      });\n  }\n\n  /** Returns the job id */\n  private async create_search(searchString: string): Promise<JobID> {\n    return fetch(`${this.host}/services/search/jobs`, {\n      method: 'POST',\n      headers: new Headers({\n        Authorization: this.authString\n      }),\n      body: `search=search index=\"hdf\" | ${searchString}`\n    })\n      .then(this.process_response)\n      .then((text) => {\n        // Parse the xml\n        const xml = xml2js(text, {\n          compact: true\n        }) as ElementCompact;\n        return xml.response.sid._text as string;\n      });\n  }\n\n  /** Returns the current state of the job */\n  private async check_job(jobId: JobID): Promise<JobState> {\n    return fetch(`${this.host}/services/search/jobs/${jobId}`, {\n      method: 'GET',\n      headers: new Headers({\n        Authorization: this.authString\n      })\n    })\n      .then(this.process_response)\n      .then((text) => {\n        // Parse the xml\n        const xml = xml2js(text, {\n          compact: true\n        }) as ElementCompact;\n\n        // Get the keys, and find the one with name \"dispatchState\"\n        const keys = xml.entry.content['s:dict']['s:key'];\n        let state: string | undefined;\n        for (const k of keys) {\n          if (k._attributes.name === 'dispatchState') {\n            state = k._text;\n          }\n        }\n\n        // Check we found state\n        if (!state) {\n          // It probably failed if we can't find it lol\n          state = 'FAILED';\n        }\n\n        // Decide result based on state\n        let status: JobStatus;\n        if (state === 'DONE') {\n          status = 'succeeded';\n        } else if (state === 'FAILED') {\n          status = 'failed';\n        } else {\n          status = 'pending';\n        }\n\n        // Construct the state\n        return {\n          status,\n          jobId\n        };\n      });\n  }\n\n  /** Continually checks the job until resolution */\n  private async pend_job(jobId: JobID, interval: number): Promise<JobState> {\n    /* eslint-disable */\n        while (true) {\n            /* eslint-enable */\n      const state = await this.check_job(jobId);\n      if (state.status === 'pending') {\n        await delay(interval);\n      } else {\n        return state;\n      }\n    }\n  }\n\n  /** Gets the search results for a given job id, if it is done */\n  private async get_search_results(jobId: JobID): Promise<UnknownPayload[]> {\n    return fetch(\n      `${this.host}/services/search/jobs/${jobId}/results/?output_mode=json&count=0`,\n      {\n        headers: {\n          Authorization: this.authString\n        },\n        method: 'GET'\n      }\n    )\n      .then((response) => {\n        if (!response.ok) {\n          throw process_error(response);\n        }\n        return response.json();\n      })\n      .then((data) => {\n        // We basically can't, and really shouldn't, do typescript here. Output is 50% guaranteed to be wonk\n        // Get all the raws\n        const raws: Array<string> = data['results'].map(\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          (datum: any) => datum._raw\n        );\n\n        // Parse to json, and freeze\n        const parsed = [] as UnknownPayload[];\n        for (const v of raws) {\n          try {\n            parsed.push(JSON.parse(v) as UnknownPayload);\n          } catch (err) {\n            // eslint-disable-next-line no-console\n            console.warn(err);\n          }\n        }\n\n        return parsed;\n      });\n  }\n}\n\n/** Given: A list of all payloads from a search,\n * Produce: A list of Evaluation payloads containing all data properly reconstructed, recursively, into a \"normal\"\n * HDF heirarchy.\n *\n * TODO: Provide a mechanism for also returning orphaned items\n */\nexport function consolidate_payloads(\n  payloads: UnknownPayload[]\n): ExecutionPayload[] {\n  // Group by exec id\n  const grouped = group_by(payloads, (pl) => pl.meta.guid);\n\n  const built = map_hash(grouped, consolidate_file_payloads);\n\n  return Object.values(built);\n}\n\n/** Given: A list of all payloads from a search with the same GUID\n * Produce: A single EvaluationPayload containing all of these payloads reconstructed into the expected HDF heirarchy\n */\nfunction consolidate_file_payloads(\n  filePayloads: UnknownPayload[]\n): ExecutionPayload {\n  // In the end we wish to produce a single evaluation EventPayload which in fact contains all data for the guid\n  // Group by subtype\n  const subtypes = group_by(filePayloads, (event) => event.meta.subtype);\n  const execEvents = (subtypes['header'] || []) as ExecutionPayload[];\n  const profileEvents = (subtypes['profile'] || []) as ProfilePayload[];\n  const controlEvents = (subtypes['control'] || []) as ControlPayload[];\n\n  // Verify we only have one exec event\n  if (execEvents.length !== 1) {\n    throw new Error(\n      `Incorrect # of Evaluation events. Expected 1, got ${execEvents.length}`\n    );\n  }\n\n  // Pull it out\n  const exec = execEvents[0];\n\n  // Put all the profiles into the exec\n  exec.profiles.push(...profileEvents);\n\n  // Group controls, and then put them into the profiles\n  const shaGroupedControls = group_by(\n    controlEvents,\n    (ctrl) => ctrl.meta.profile_sha256\n  );\n  for (const profile of profileEvents) {\n    // Get the corresponding controls, and put them into the profile\n    const sha = profile.meta.profile_sha256;\n    const corrControls = shaGroupedControls[sha] || [];\n    profile.controls.push(...corrControls);\n  }\n\n  // Spit it back out\n  return exec;\n}\n\nexport enum SplunkErrorCode {\n  BadNetwork, // Server could not be reached, either due to bad address or bad CORS\n  BadUrl, // URL poorly formed\n  PageNotFound, // Server gave error 404\n  BadAuth, // Authorization credentials are no good\n  SearchFailed, // For whatever reason, the splunk search failed\n  ConsolidationFailed, // Something went wrong during event consolidation phase\n  SchemaViolation, // The data we got out isn't valid HDF. Hope to not see this too often\n  InvalidGUID, // If the provided GUID did not match to exactly one header\n  UnknownError // No clue!\n}\n\n/** Converts Responses and Errorcodes into purely just errorcodes */\nexport function process_error(\n  r: Response | SplunkErrorCode | TypeError\n): SplunkErrorCode {\n  if (r instanceof TypeError) {\n    if (r.message.includes('NetworkError')) {\n      return SplunkErrorCode.BadNetwork;\n    } else if (r.message.includes('not a valid URL')) {\n      return SplunkErrorCode.BadUrl;\n    }\n  } else if (r instanceof Response) {\n    // Based on the network code, guess\n    const response = r;\n    switch (response.status) {\n      case 401: // Bad username/password\n        return SplunkErrorCode.BadAuth;\n      case 404: // URL got borked\n        return SplunkErrorCode.PageNotFound;\n      default:\n        return SplunkErrorCode.UnknownError;\n    }\n  } else if (typeof r === typeof SplunkErrorCode.UnknownError) {\n    // It's already an error code - pass along\n    return r;\n  }\n  // idk lol\n  return SplunkErrorCode.UnknownError;\n}\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/utilities/treemap_util.ts": "/**\n * Tools used for generating the treemaps consumed by, of course, the Treemap card and associated components.\n */\n\nimport {ColorHack} from '@/store/color_hack';\nimport Chroma from 'chroma-js';\nimport * as d3 from 'd3';\nimport {\n  ContextualizedControl,\n  FULL_NIST_HIERARCHY,\n  NistControl,\n  NistHierarchyNode\n} from 'inspecjs';\nimport {control_unique_key} from './format_util';\n\n// How deep into nist trees we allow\nconst depthMax = 2;\n\n/** A simple wrapper type representing what any node's data might be in our treemap */\ninterface AbsTreemapNode {\n  title: string;\n  subtitle?: string;\n  hovertext?: string;\n  key: string;\n  color?: Chroma.Color;\n  parent: TreemapNodeParent | null; // The parent of this node.\n  nist_control: NistControl; // The nist control which this node is associated with. Not necessarily unique (e.g. leaves)\n}\nexport interface TreemapNodeParent extends AbsTreemapNode {\n  children: TreemapNode[]; // Maps the next sub-specifier to children\n}\n\nexport interface TreemapNodeLeaf extends AbsTreemapNode {\n  control: ContextualizedControl;\n}\n\nexport function is_leaf(n: TreemapNode): n is TreemapNodeLeaf {\n  return (n as TreemapNodeLeaf).control !== undefined;\n}\n\nexport function is_parent(n: TreemapNode): n is TreemapNodeParent {\n  return (n as TreemapNodeParent).children !== undefined;\n}\n\n/** The type of our treemap nodes, prior to rendering */\nexport type TreemapNode = TreemapNodeLeaf | TreemapNodeParent;\nexport type D3TreemapNode = d3.HierarchyNode<TreemapNode>;\n\n/**\n * Converts a list of controls to treemap leaves.\n * Actually a one-to-many mapping since we must make a unique leaf for each nist control on each control!\n * @param controls The controls to build into a nist node map\n */\nfunction controls_to_nist_node_data(\n  contextualizedControls: Readonly<ContextualizedControl[]>,\n  colors: ColorHack\n): TreemapNodeLeaf[] {\n  return contextualizedControls.flatMap((cc) => {\n    // Get the status color\n    const color = Chroma.hex(colors.colorForStatus(cc.root.hdf.status));\n    // Now make leaves for each nist control\n    return cc.root.hdf.parsedNistTags.map((nc) => {\n      return {\n        title: cc.data.id,\n        subtitle: cc.data.title || undefined,\n        hovertext: cc.data.desc || undefined,\n        key: control_unique_key(cc) + nc.rawText,\n        control: cc,\n        nist_control: nc,\n        color,\n        parent: null // We set this later\n      };\n    });\n  });\n}\n\n/** Builds a scaffolding for the nist items using the given root.\n * Also constructs a lookup table of control nodes.\n * Only goes maxDepth deep.\n */\nfunction recursive_nist_map(\n  parent: TreemapNodeParent | null,\n  node: Readonly<NistHierarchyNode>,\n  controlLookup: {[key: string]: TreemapNodeParent},\n  maxDepth: number\n): TreemapNodeParent {\n  // Init child list\n  const children: TreemapNode[] = [];\n\n  // Make our final value\n  const ret: TreemapNodeParent = {\n    key: node.control.rawText || '',\n    title: node.control.rawText || '',\n    nist_control: node.control,\n    parent,\n    children\n  };\n\n  // Fill our children\n  if (node.control.subSpecifiers.length < maxDepth) {\n    node.children.forEach((child) => {\n      // Assign it, recursively computing the rest\n      children.push(recursive_nist_map(ret, child, controlLookup, maxDepth));\n    });\n  }\n\n  // Save to lookup\n  controlLookup[lookup_key_for(node.control, maxDepth)] = ret;\n  return ret;\n}\n\n/** Colorizes a treemap based on each nodes children. */\nfunction colorize_tree_map(root: TreemapNodeParent) {\n  // First colorize children, recursively\n  root.children.forEach((child) => {\n    if (is_parent(child)) {\n      colorize_tree_map(child);\n    }\n  });\n\n  // Now all children should have valid colors\n  // We decide this node's color as a composite of all underlying node colors\n  const childColors = root.children\n    .map((c) => c.color)\n    .filter((c): c is Chroma.Color => !!c);\n  // If we have any, then set our color\n  if (childColors.length) {\n    // Set the color\n    const avgColor = Chroma.average(childColors);\n    root.color = avgColor;\n  }\n}\n\n/** Generates a lookup key for the given control */\nfunction lookup_key_for(x: NistControl, maxDepth: number): string {\n  if (maxDepth) {\n    return x.subSpecifiers.slice(0, maxDepth).join('-');\n  } else {\n    return x.subSpecifiers.join('-');\n  }\n}\n\n/** Populates a treemap using the given lookup table */\nfunction populate_tree_map(\n  lookup: {[key: string]: TreemapNodeParent},\n  leaves: TreemapNodeLeaf[],\n  maxDepth: number\n) {\n  // Populate it\n  leaves.forEach((leaf) => {\n    const parent = lookup[lookup_key_for(leaf.nist_control, maxDepth)];\n    if (parent) {\n      // We found a node that will accept it (matches its control)\n      // We can do this as because we know we constructed these to only have empty children\n      parent.children.push(leaf);\n      leaf.parent = parent;\n    } else {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `Warning: unable to assign control ${leaf.nist_control.rawText} to valid treemap leaf`\n      );\n    }\n  });\n}\n\n/**\n * Assembles the provided leaves into a nist map.\n * Colorizes nodes as appropriate, and assigns parentage\n */\nfunction build_populated_nist_map(data: TreemapNodeLeaf[]): TreemapNodeParent {\n  // Build our scaffold\n  const lookup: {[key: string]: TreemapNodeParent} = {};\n  const rootChildren: TreemapNodeParent[] = [];\n  const root: TreemapNodeParent = {\n    key: 'tree_root',\n    title: 'NIST-853 Controls',\n    children: rootChildren,\n    parent: null,\n    nist_control: new NistControl([], 'NIST-853')\n  };\n\n  // Fill out children, recursively\n  FULL_NIST_HIERARCHY.forEach((n) => {\n    const child = recursive_nist_map(root, n, lookup, depthMax);\n    rootChildren.push(child);\n  });\n\n  // Populate them with leaves\n  populate_tree_map(lookup, data, depthMax);\n\n  // Colorize it\n  colorize_tree_map(root);\n\n  // Done\n  return root;\n}\n\n/**\n * Generates a tree map from the given nist hash, using the size of each category to inversely scale it with controls.\n * Thus each category has a fixed weight!\n * Categories/Families are further sorted by name, and the\n *\n * @param data The nist hash to turn into a tree map\n */\nfunction node_data_to_tree_map(\n  data: Readonly<TreemapNodeParent>\n): D3TreemapNode {\n  return d3\n    .hierarchy<TreemapNode>(data, (d: TreemapNode) => {\n      if (is_parent(d)) {\n        return d.children;\n      }\n      return null;\n    })\n    .sort((a, b) => a.data.title.localeCompare(b.data.title))\n    .sum((root) => {\n      if (is_parent(root)) {\n        if (root.children.length === 0) {\n          return 1;\n        }\n      } else if (root.parent !== null) {\n        return 1.0 / root.parent!.children.length;\n      }\n      return 0;\n    });\n}\n\n/** Does all the steps */\nexport function build_nist_tree_map(\n  data: Readonly<ContextualizedControl[]>,\n  colors: ColorHack\n): D3TreemapNode {\n  const leaves = controls_to_nist_node_data(data, colors);\n  const b = build_populated_nist_map(leaves);\n  return node_data_to_tree_map(b);\n}\n\n",
  "/api/sources/raw?key=test:apps/frontend/src/components/cards/controltable/ControlRowDetails.vue": "<template>\n  <v-row no-gutters dense class=\"pb-1\">\n    <v-col cols=\"12\" class=\"font-weight-bold\">\n      <v-card>\n        <v-tabs v-model=\"localTab\" fixed-tabs show-arrows @change=\"tab_change\">\n          <!-- Declare our tabs -->\n          <v-tab href=\"#tab-test\"> Test </v-tab>\n          <v-tab href=\"#tab-details\"> Details </v-tab>\n          <v-tab href=\"#tab-code\"> Code </v-tab>\n\n          <v-tab-item value=\"tab-test\">\n            <div class=\"pa-4\">\n              <div v-if=\"caveat\">\n                Caveat: {{ caveat }}\n                <v-divider />\n                <br />\n              </div>\n              <!-- eslint-disable-next-line vue/no-v-html -->\n              <div v-html=\"sanitize_html(main_desc)\" />\n            </div>\n            <ControlRowCol\n              v-for=\"(result, index) in control.root.hdf.segments\"\n              :key=\"'col' + index\"\n              :class=\"zebra(index)\"\n              :result=\"result\"\n              :status-code=\"result.status\"\n            />\n          </v-tab-item>\n\n          <v-tab-item value=\"tab-details\">\n            <v-container fluid>\n              <!-- Create a row for each detail -->\n              <template v-for=\"(detail, index) in details\">\n                <v-row :key=\"'tab' + index\" :class=\"zebra(index)\">\n                  <v-col cols=\"12\" :class=\"detail.class\">\n                    <h3>{{ detail.name }}:</h3>\n                    <!-- eslint-disable vue/no-v-html -->\n                    <h4 class=\"mono\" v-html=\"sanitize_html(detail.value)\" />\n                    <!-- eslint-enable vue/no-v-html -->\n                  </v-col>\n                  <v-divider />\n                </v-row>\n              </template>\n            </v-container>\n          </v-tab-item>\n\n          <v-tab-item value=\"tab-code\">\n            <v-container fluid>\n              <v-row>\n                <v-col cols=\"12\">\n                  <prism language=\"ruby\">{{ control.full_code }}</prism>\n                </v-col>\n              </v-row>\n            </v-container>\n          </v-tab-item>\n        </v-tabs>\n      </v-card>\n    </v-col>\n  </v-row>\n</template>\n\n<script lang=\"ts\">\nimport ControlRowCol from '@/components/cards/controltable/ControlRowCol.vue';\nimport HtmlSanitizeMixin from '@/mixins/HtmlSanitizeMixin';\nimport {ContextualizedControl} from 'inspecjs';\nimport _ from 'lodash';\n//TODO: add line numbers\nimport 'prismjs';\nimport 'prismjs/components/prism-makefile.js';\nimport 'prismjs/components/prism-ruby.js';\nimport 'prismjs/themes/prism-tomorrow.css';\nimport Component, {mixins} from 'vue-class-component';\n//@ts-ignore\nimport Prism from 'vue-prism-component';\nimport {Prop, Watch} from 'vue-property-decorator';\n\ninterface Detail {\n  name: string;\n  value: string;\n  class?: string;\n}\n\n@Component({\n  components: {\n    ControlRowCol,\n    Prism\n  }\n})\nexport default class ControlRowDetails extends mixins(HtmlSanitizeMixin) {\n  @Prop({type: String, default: 'tab-test'}) readonly tab!: string;\n  @Prop({type: Object, required: true})\n  readonly control!: ContextualizedControl;\n\n  localTab = this.tab;\n\n  @Watch('tab')\n  onTabChanged(newTab?: string, _oldVal?: string) {\n    if (newTab) {\n      this.localTab = newTab;\n    }\n  }\n\n  get cciControlString(): string | null {\n    const cci = this.control.hdf.wraps.tags.cci;\n    if (!cci) {\n      return null;\n    } else if (Array.isArray(cci)) {\n      return cci.join(', ');\n    } else {\n      return cci;\n    }\n  }\n\n  get main_desc(): string {\n    if (this.control.data.desc) {\n      return this.control.data.desc.trim();\n    } else {\n      return 'No description';\n    }\n  }\n\n  tab_change(tab: string) {\n    this.$emit('update:tab', tab);\n  }\n\n  /** Shown above the description */\n  get header(): string {\n    const msgSplit = this.control.root.hdf.finding_details.split(':');\n    if (msgSplit.length === 1) {\n      return msgSplit[0] + '.';\n    } else {\n      return msgSplit[0] + ':';\n    }\n  }\n\n  get caveat(): string | undefined {\n    return this.control.hdf.descriptions.caveat;\n  }\n\n  get details(): Detail[] {\n    const c = this.control;\n    const detailsMap = new Map();\n\n    detailsMap.set('Control', c.data.id);\n    detailsMap.set('Title', c.data.title);\n    detailsMap.set('Caveat', c.hdf.descriptions.caveat);\n    detailsMap.set('Desc', c.data.desc);\n    detailsMap.set('Rationale', c.hdf.descriptions.rationale);\n    detailsMap.set('Severity', c.root.hdf.severity);\n    detailsMap.set('Impact', c.data.impact);\n    detailsMap.set('Nist controls', c.hdf.rawNistTags.join(', '));\n    detailsMap.set('CCI controls', this.cciControlString);\n    detailsMap.set('Check', c.hdf.descriptions.check || c.data.tags.check);\n    detailsMap.set('Fix', c.hdf.descriptions.fix || c.data.tags.fix);\n    detailsMap.set('CWE ID', _.get(c, 'hdf.wraps.tags.cweid'));\n\n    for (const prop in c.hdf.descriptions) {\n      if (!detailsMap.has(_.capitalize(prop))) {\n        detailsMap.set(_.capitalize(prop), c.hdf.descriptions[prop]);\n      }\n    }\n    return Array.from(detailsMap, ([name, value]) => ({name, value})).filter(\n      (v) => v.value\n    );\n  }\n\n  //for zebra background\n  zebra(ix: number): string {\n    if (ix % 2 === 0) {\n      return 'zebra-table';\n    }\n    return 'non-zebra-table';\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n@import '@/sass/control-row-format.scss';\n\n.clickable {\n  cursor: pointer;\n}\n\n.v-application {\n  code.language-ruby {\n    border: none;\n    box-shadow: none;\n  }\n}\n\npre {\n  white-space: pre-wrap; /* Since CSS 2.1 */\n  white-space: -moz-pre-wrap; /* Mozilla, since 1999 */\n  white-space: -pre-wrap; /* Opera 4-6 */\n  white-space: -o-pre-wrap; /* Opera 7 */\n  word-wrap: break-word; /* Internet Explorer 5.5+ */\n}\n.theme--dark .zebra-table {\n  background-color: var(--v-secondary-lighten2);\n  max-width: 99.9%;\n  margin: auto;\n}\n\n.theme--dark .non-zebra-table {\n  max-width: 99.9%;\n  margin: auto;\n}\n\n.code-card {\n  height: inherit;\n  margin: inherit;\n  white-space: auto;\n}\n.wset {\n  min-width: 125px;\n  justify-content: center;\n}\n\n.right {\n  margin-left: -1px;\n}\n</style>\n\n",
  "/api/sources/raw?key=test:apps/backend/src/evaluations/evaluations.service.spec.ts": "import {NotFoundException} from '@nestjs/common';\nimport {SequelizeModule} from '@nestjs/sequelize';\nimport {Test} from '@nestjs/testing';\nimport {\n  CREATE_EVALUATION_DTO_WITHOUT_FILENAME,\n  CREATE_EVALUATION_DTO_WITHOUT_TAGS,\n  EVALUATION_WITH_TAGS_1,\n  UPDATE_EVALUATION,\n  UPDATE_EVALUATION_DATA_ONLY,\n  UPDATE_EVALUATION_FILENAME_ONLY\n} from '../../test/constants/evaluations-test.constant';\nimport {GROUP_1} from '../../test/constants/groups-test.constant';\nimport {CREATE_USER_DTO_TEST_OBJ} from '../../test/constants/users-test.constant';\nimport {DatabaseModule} from '../database/database.module';\nimport {DatabaseService} from '../database/database.service';\nimport {EvaluationTagsModule} from '../evaluation-tags/evaluation-tags.module';\nimport {EvaluationTagsService} from '../evaluation-tags/evaluation-tags.service';\nimport {GroupEvaluation} from '../group-evaluations/group-evaluation.model';\nimport {GroupUser} from '../group-users/group-user.model';\nimport {Group} from '../groups/group.model';\nimport {GroupsService} from '../groups/groups.service';\nimport {UserDto} from '../users/dto/user.dto';\nimport {UsersModule} from '../users/users.module';\nimport {UsersService} from '../users/users.service';\nimport {EvaluationDto} from './dto/evaluation.dto';\nimport {Evaluation} from './evaluation.model';\nimport {EvaluationsService} from './evaluations.service';\n\ndescribe('EvaluationsService', () => {\n  let evaluationsService: EvaluationsService;\n  let evaluationTagsService: EvaluationTagsService;\n  let databaseService: DatabaseService;\n  let usersService: UsersService;\n  let user: UserDto;\n  let groupsService: GroupsService;\n\n  beforeAll(async () => {\n    const module = await Test.createTestingModule({\n      imports: [\n        DatabaseModule,\n        SequelizeModule.forFeature([\n          Evaluation,\n          GroupUser,\n          Group,\n          GroupEvaluation\n        ]),\n        EvaluationTagsModule,\n        UsersModule\n      ],\n      providers: [\n        EvaluationsService,\n        DatabaseService,\n        UsersService,\n        GroupsService\n      ]\n    }).compile();\n\n    evaluationsService = module.get<EvaluationsService>(EvaluationsService);\n    evaluationTagsService = module.get<EvaluationTagsService>(\n      EvaluationTagsService\n    );\n    databaseService = module.get<DatabaseService>(DatabaseService);\n    usersService = module.get<UsersService>(UsersService);\n    groupsService = module.get<GroupsService>(GroupsService);\n  });\n\n  beforeEach(async () => {\n    await databaseService.cleanAll();\n    user = new UserDto(await usersService.create(CREATE_USER_DTO_TEST_OBJ));\n  });\n\n  describe('findAll', () => {\n    it('should find all evaluations', async () => {\n      let evaluationsDtoArray = await evaluationsService.findAll();\n      expect(evaluationsDtoArray).toEqual([]);\n\n      await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n      await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n      evaluationsDtoArray = await evaluationsService.findAll();\n      expect(evaluationsDtoArray.length).toEqual(2);\n    });\n\n    it('should include the evaluation user', async () => {\n      await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n\n      const evaluations = await evaluationsService.findAll();\n      expect(new UserDto(evaluations[0].user)).toEqual(user);\n    });\n\n    it('should include the evaluation group and group users', async () => {\n      const group = await groupsService.create(GROUP_1);\n      const owner = await usersService.findById(user.id);\n      const evaluation = await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n\n      let evaluations = await evaluationsService.findAll();\n      expect(evaluations[0].groups[0]).not.toBeDefined();\n\n      await groupsService.addEvaluationToGroup(group, evaluation);\n      await groupsService.addUserToGroup(group, owner, 'owner');\n\n      evaluations = await evaluationsService.findAll();\n      const foundGroup = evaluations[0].groups[0];\n      expect(foundGroup).toBeDefined();\n      expect(foundGroup.id).toEqual(group.id);\n      expect(foundGroup.users.length).toEqual(1);\n      expect(foundGroup.users[0].id).toEqual(owner.id);\n      expect(foundGroup.users[0].GroupUser.role).toEqual('owner');\n    });\n  });\n\n  describe('findById', () => {\n    it('should find evaluations by id', async () => {\n      expect.assertions(1);\n      const evaluation = await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n      const foundEvaluation = await evaluationsService.findById(evaluation.id);\n      expect(new EvaluationDto(evaluation)).toEqual(\n        new EvaluationDto(foundEvaluation)\n      );\n    });\n\n    it('should throw an error if an evaluation does not exist', async () => {\n      expect.assertions(1);\n      await expect(evaluationsService.findById('-1')).rejects.toThrow(\n        NotFoundException\n      );\n    });\n  });\n\n  describe('create', () => {\n    it('should create a new evaluation with evaluation tags', async () => {\n      const evaluation = await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n      expect(evaluation.id).toBeDefined();\n      expect(evaluation.updatedAt).toBeDefined();\n      expect(evaluation.createdAt).toBeDefined();\n      expect(evaluation.data).toEqual({});\n      expect(evaluation.filename).toEqual(EVALUATION_WITH_TAGS_1.filename);\n      expect(evaluation.evaluationTags[0].evaluationId).toBeDefined();\n      expect(evaluation.evaluationTags[0].updatedAt).toBeDefined();\n      expect(evaluation.evaluationTags[0].createdAt).toBeDefined();\n\n      if (EVALUATION_WITH_TAGS_1.evaluationTags === undefined) {\n        throw new TypeError(\n          'Evaluation fixture does not have any associated tags.'\n        );\n      }\n\n      expect(evaluation.evaluationTags?.[0].value).toEqual(\n        EVALUATION_WITH_TAGS_1.evaluationTags[0].value\n      );\n    });\n\n    it('should create a new evaluation without evaluation tags', async () => {\n      const evaluation = await evaluationsService.create({\n        ...CREATE_EVALUATION_DTO_WITHOUT_TAGS,\n        data: {},\n        userId: user.id\n      });\n      expect(evaluation.id).toBeDefined();\n      expect(evaluation.updatedAt).toBeDefined();\n      expect(evaluation.createdAt).toBeDefined();\n      expect(evaluation.data).toEqual({});\n      expect(evaluation.filename).toEqual(\n        CREATE_EVALUATION_DTO_WITHOUT_TAGS.filename\n      );\n      expect(evaluation.evaluationTags).not.toBeDefined();\n      expect((await evaluationTagsService.findAll()).length).toBe(0);\n    });\n\n    it('should throw an error when missing the filename field', async () => {\n      expect.assertions(1);\n      await expect(\n        evaluationsService.create({\n          ...CREATE_EVALUATION_DTO_WITHOUT_FILENAME,\n          data: {},\n          userId: user.id\n        })\n      ).rejects.toThrow(\n        'notNull Violation: Evaluation.filename cannot be null'\n      );\n    });\n  });\n\n  describe('update', () => {\n    it('should throw an error if an evaluation does not exist', async () => {\n      expect.assertions(1);\n      await expect(\n        evaluationsService.update('-1', UPDATE_EVALUATION)\n      ).rejects.toThrow(NotFoundException);\n    });\n\n    it('should update all fields of an evaluation', async () => {\n      const evaluation = await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n      const updatedEvaluation = await evaluationsService.update(\n        evaluation.id,\n        UPDATE_EVALUATION\n      );\n      expect(updatedEvaluation.id).toEqual(evaluation.id);\n      expect(updatedEvaluation.createdAt).toEqual(evaluation.createdAt);\n      expect(updatedEvaluation.updatedAt).not.toEqual(evaluation.updatedAt);\n      expect(updatedEvaluation.data).not.toEqual(evaluation.data);\n      expect(updatedEvaluation.filename).not.toEqual(evaluation.filename);\n    });\n\n    it('should only update data if provided', async () => {\n      const evaluation = await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n      const updatedEvaluation = await evaluationsService.update(\n        evaluation.id,\n        UPDATE_EVALUATION_DATA_ONLY\n      );\n      expect(updatedEvaluation.id).toEqual(evaluation.id);\n      expect(updatedEvaluation.createdAt).toEqual(evaluation.createdAt);\n      expect(updatedEvaluation.updatedAt).not.toEqual(evaluation.updatedAt);\n      expect(updatedEvaluation.evaluationTags.length).toEqual(\n        evaluation.evaluationTags.length\n      );\n      expect(updatedEvaluation.data).not.toEqual(evaluation.data);\n      expect(updatedEvaluation.filename).toEqual(evaluation.filename);\n    });\n\n    it('should only update filename if provided', async () => {\n      const evaluation = await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n\n      const updatedEvaluation = await evaluationsService.update(\n        evaluation.id,\n        UPDATE_EVALUATION_FILENAME_ONLY\n      );\n      expect(updatedEvaluation.id).toEqual(evaluation.id);\n      expect(updatedEvaluation.createdAt).toEqual(evaluation.createdAt);\n      expect(updatedEvaluation.updatedAt).not.toEqual(evaluation.updatedAt);\n      expect(updatedEvaluation.evaluationTags.length).toEqual(\n        evaluation.evaluationTags.length\n      );\n      expect(updatedEvaluation.data).toEqual(evaluation.data);\n      expect(updatedEvaluation.filename).not.toEqual(evaluation.filename);\n    });\n  });\n\n  describe('remove', () => {\n    it('should remove an evaluation and its evaluation tags given an id', async () => {\n      const evaluation = await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n      const removedEvaluation = await evaluationsService.remove(evaluation.id);\n      const foundEvaluationTags = await evaluationTagsService.findAll();\n      expect(foundEvaluationTags.length).toEqual(0);\n      expect(new EvaluationDto(removedEvaluation)).toEqual(\n        new EvaluationDto(evaluation)\n      );\n\n      await expect(\n        evaluationsService.findById(removedEvaluation.id)\n      ).rejects.toThrow(NotFoundException);\n    });\n\n    it('should throw an error when the evaluation does not exist', async () => {\n      expect.assertions(1);\n      await expect(evaluationsService.findById('-1')).rejects.toThrow(\n        NotFoundException\n      );\n    });\n  });\n\n  afterAll(async () => {\n    await databaseService.cleanAll();\n    await databaseService.closeConnection();\n  });\n});\n\n",
  "/api/sources/raw?key=test:apps/backend/src/config/config.service.spec.ts": "import * as dotenv from 'dotenv';\nimport mock from 'mock-fs';\nimport {\n  DATABASE_URL_MOCK_ENV,\n  ENV_MOCK_FILE,\n  SIMPLE_ENV_MOCK_FILE\n} from '../../test/constants/env-test.constant';\nimport {ConfigService} from './config.service';\n\n/* If you run the test without --silent , you need to add console.log() before you mock out the\nfile system in the beforeAll() or it'll throw an error (this is a documented bug which can be\nfound at https://github.com/tschaub/mock-fs/issues/234).\nIf you run the test with --silent (which we do by default), you don't need the log statement. */\ndescribe('Config Service', () => {\n  beforeAll(async () => {\n    // eslint-disable-next-line no-console\n    console.log();\n    // Used as an empty file system\n    mock({\n      // No files created (.env file does not exist yet)\n    });\n  });\n\n  describe('Tests the get function when .env file does not exist', () => {\n    it('should return undefined because env variable does not exist', () => {\n      const configService = new ConfigService();\n      expect(configService.get('DATABASE_NAME')).toBe(undefined);\n    });\n\n    it('should print to the console about how it was unable to read .env file', () => {\n      const consoleSpy = jest.spyOn(console, 'log');\n      // Used to make sure logs are outputted\n      new ConfigService();\n      expect(consoleSpy).toHaveBeenCalledWith(\n        'Unable to read configuration file `.env`!'\n      );\n      expect(consoleSpy).toHaveBeenCalledWith(\n        'Falling back to environment or undefined values!'\n      );\n    });\n  });\n\n  describe('Tests the get function when .env file does exist', () => {\n    beforeAll(() => {\n      // Mock .env file\n      mock({\n        '.env': ENV_MOCK_FILE\n      });\n    });\n\n    it('should return the correct database name', () => {\n      const configService = new ConfigService();\n      expect(configService.get('PORT')).toEqual('8000');\n      expect(configService.get('DATABASE_HOST')).toEqual('localhost');\n      expect(configService.get('DATABASE_PORT')).toEqual('5432');\n      expect(configService.get('DATABASE_USERNAME')).toEqual('postgres');\n      expect(configService.get('DATABASE_PASSWORD')).toEqual('postgres');\n      expect(configService.get('DATABASE_NAME')).toEqual(\n        'heimdallts_jest_testing_service_db'\n      );\n      expect(configService.get('JWT_SECRET')).toEqual('abc123');\n      expect(configService.get('NODE_ENV')).toEqual('test');\n    });\n\n    it('should return undefined because env variable does not exist', () => {\n      const configService = new ConfigService();\n      expect(configService.get('INVALID_VARIABLE')).toBe(undefined);\n    });\n  });\n\n  describe('Tests the get function when environment file is sourced externally', () => {\n    beforeAll(() => {\n      // Mock .env file\n      mock({\n        '.env-loaded-externally': SIMPLE_ENV_MOCK_FILE\n      });\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      dotenv.config({path: '.env-loaded-externally'});\n    });\n\n    it('should return the correct database port', () => {\n      const configService = new ConfigService();\n      expect(configService.get('PORT')).toEqual('8001');\n    });\n\n    it('should return undefined because env variable does not exist', () => {\n      const configService = new ConfigService();\n      expect(configService.get('INVALID_VARIABLE')).toBe(undefined);\n    });\n  });\n\n  describe('When using DATABASE_URL', () => {\n    beforeAll(() => {\n      mock({\n        '.env': DATABASE_URL_MOCK_ENV\n      });\n    });\n\n    it('should correctly parse DATABASE_URL into its components', () => {\n      const configService = new ConfigService();\n      expect(configService.get('DATABASE_HOST')).toEqual(\n        'ec2-00-000-11-123.compute-1.amazonaws.com'\n      );\n      expect(configService.get('DATABASE_PORT')).toEqual('5432');\n      expect(configService.get('DATABASE_USERNAME')).toEqual(\n        'abcdefghijk123456'\n      );\n      expect(configService.get('DATABASE_PASSWORD')).toEqual(\n        '000011112222333344455556666777778889999aaaabbbbccccddddeeeffff'\n      );\n      expect(configService.get('DATABASE_NAME')).toEqual('database01');\n    });\n  });\n\n  describe('Tests for thrown errors', () => {\n    it('should throw an EACCES error', () => {\n      expect.assertions(1);\n      mock({\n        '.env': mock.file({\n          content: 'DATABASE_NAME=heimdallts_jest_testing_service_db',\n          mode: 0o000 // Set file system permissions to none\n        })\n      });\n      expect(() => new ConfigService()).toThrowError(\n        \"EACCES: permission denied, open '.env'\"\n      );\n    });\n\n    it('should throw an error in the get function', () => {\n      mock({\n        '.env': ENV_MOCK_FILE\n      });\n      const configService = new ConfigService();\n      jest.spyOn(configService, 'get').mockImplementationOnce(() => {\n        throw new Error('');\n      });\n      expect(() => configService.get('DATABASE_NAME')).toThrowError();\n    });\n  });\n\n  describe('Set', () => {\n    it('should set a key value', () => {\n      const configService = new ConfigService();\n      configService.set('test', 'value');\n      expect(configService.get('test')).toBe('value');\n    });\n  });\n\n  afterAll(() => {\n    // Restore the fs binding to the real file system\n    mock.restore();\n  });\n});\n\n",
  "/api/sources/raw?key=test:apps/backend/src/pipes/password-complexity.pipe.spec.ts": "import {ArgumentMetadata, BadRequestException} from '@nestjs/common';\nimport {\n  CREATE_USER_DTO_TEST_OBJ,\n  CREATE_USER_DTO_TEST_OBJ_WITH_MISSING_PASSWORD_FIELD,\n  UPDATE_USER_DTO_TEST_OBJ,\n  UPDATE_USER_DTO_TEST_WITHOUT_PASSWORD,\n  UPDATE_USER_DTO_WITHOUT_PASSWORD_FIELDS\n} from '../../test/constants/users-test.constant';\nimport {PasswordComplexityPipe} from './password-complexity.pipe';\n\ndescribe('PasswordComplexityPipe', () => {\n  let passwordComplexityPipe: PasswordComplexityPipe;\n  let metaData: ArgumentMetadata;\n\n  beforeEach(() => {\n    passwordComplexityPipe = new PasswordComplexityPipe();\n  });\n\n  it('should make sure that the passwords-complexity pipe is defined', () => {\n    expect(passwordComplexityPipe).toBeDefined();\n  });\n\n  describe('Helper Function Tests', () => {\n    describe('hasClasses', () => {\n      it('should fail because the password length is less than 15 characters and it has all character classes', () => {\n        expect(passwordComplexityPipe.hasClasses('$7aB')).toBeFalsy();\n      });\n\n      it('should fail because the password does not contain a special character', () => {\n        expect(\n          passwordComplexityPipe.hasClasses('Testpasswordwithoutspecialchar7')\n        ).toBeFalsy();\n      });\n\n      it('should fail because the password does not contain a number', () => {\n        expect(\n          passwordComplexityPipe.hasClasses('Testpasswordwithoutnumber$')\n        ).toBeFalsy();\n      });\n\n      it('should fail because the password does not contain an uppercase letter', () => {\n        expect(\n          passwordComplexityPipe.hasClasses('testpasswordwithoutuppercase7$')\n        ).toBeFalsy();\n      });\n\n      it('should fail because the password does not contain a lowercase letter', () => {\n        expect(\n          passwordComplexityPipe.hasClasses('TESTPASSWORDWITHOUTLOWERCASE7$')\n        ).toBeFalsy();\n      });\n\n      it('should pass because the password has all character classes and is at least 15 characters', () => {\n        expect(\n          passwordComplexityPipe.hasClasses('Atestpassword7$')\n        ).toBeTruthy();\n      });\n    });\n\n    describe('noRepeats', () => {\n      it('should fail because there is more than 3 consecutive repeating lowercase characters in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('aaaa')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 lowercase characters back-to-back in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('test')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 consecutive repeating uppercase characters in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('AAAA')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 uppercase characters back-to-back in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('TEST')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 consecutive repeating numbers in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('7777')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 numbers back-to-back in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('1078')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 consecutive repeating numbers in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('$$$$')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 special characters back-to-back in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('!@#$')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 consecutive white spaces in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('spa    ce')).toBeFalsy();\n      });\n\n      it('should pass because the password meets all the minimum requirements', () => {\n        expect(passwordComplexityPipe.noRepeats('aaaBBB111$$$')).toBeTruthy();\n      });\n    });\n  });\n\n  /* Tests the complexity of a user's password and that when it meets the requirements of:\n    15 characters or longer, at least 1 uppercase letter, lowercase letter, number, special character,\n    the password meets the requirements of not containing more than three consecutive repeating\n    characters, and it contains no more than four repeating characters from the same character class,\n    the same dto object will be returned*/\n  describe('Test Valid Password', () => {\n    it('should return the same CreateUserDto', () => {\n      expect(\n        passwordComplexityPipe.transform(CREATE_USER_DTO_TEST_OBJ, metaData)\n      ).toEqual(CREATE_USER_DTO_TEST_OBJ);\n    });\n\n    it('should return the same UpdateUserDto', () => {\n      expect(\n        passwordComplexityPipe.transform(UPDATE_USER_DTO_TEST_OBJ, metaData)\n      ).toEqual(UPDATE_USER_DTO_TEST_OBJ);\n    });\n\n    it('should return UpdateUserDto if password fields are null', () => {\n      expect(\n        passwordComplexityPipe.transform(\n          UPDATE_USER_DTO_WITHOUT_PASSWORD_FIELDS,\n          metaData\n        )\n      ).toEqual(UPDATE_USER_DTO_WITHOUT_PASSWORD_FIELDS);\n    });\n  });\n\n  /* Tests that when a password does not meet all the minimum requirements,\n    a BadRequestException is thrown */\n  describe('Test Invalid Password', () => {\n    it('should throw a BadRequestException for CreateUserDto', () => {\n      expect(() =>\n        passwordComplexityPipe.transform(\n          CREATE_USER_DTO_TEST_OBJ_WITH_MISSING_PASSWORD_FIELD,\n          metaData\n        )\n      ).toThrowError(BadRequestException);\n      expect(() =>\n        passwordComplexityPipe.transform(\n          CREATE_USER_DTO_TEST_OBJ_WITH_MISSING_PASSWORD_FIELD,\n          metaData\n        )\n      ).toThrowError(\n        'Password does not meet complexity requirements. Passwords are a minimum of 15' +\n          ' characters in length. Passwords must contain at least one special character, number, upper-case letter, and' +\n          ' lower-case letter. Passwords cannot contain more than three consecutive repeating characters.' +\n          ' Passwords cannot contain more than four repeating characters from the same character class.'\n      );\n    });\n\n    it('should throw a BadRequestException for UpdateUserDto', () => {\n      expect(() =>\n        passwordComplexityPipe.transform(\n          UPDATE_USER_DTO_TEST_WITHOUT_PASSWORD,\n          metaData\n        )\n      ).toThrowError(BadRequestException);\n      expect(() =>\n        passwordComplexityPipe.transform(\n          UPDATE_USER_DTO_TEST_WITHOUT_PASSWORD,\n          metaData\n        )\n      ).toThrowError(\n        'Password does not meet complexity requirements. Passwords are a minimum of 15' +\n          ' characters in length. Passwords must contain at least one special character, number, upper-case letter, and' +\n          ' lower-case letter. Passwords cannot contain more than three consecutive repeating characters.' +\n          ' Passwords cannot contain more than four repeating characters from the same character class.'\n      );\n    });\n  });\n});\n\n",
  "/api/sources/raw?key=test:apps/backend/src/pipes/passwords-match.pipe.spec.ts": "import {ArgumentMetadata, BadRequestException} from '@nestjs/common';\nimport {\n  CREATE_USER_DTO_TEST_OBJ,\n  CREATE_USER_DTO_TEST_OBJ_WITH_UNMATCHING_PASSWORDS,\n  UPDATE_USER_DTO_TEST_OBJ,\n  UPDATE_USER_DTO_WITHOUT_PASSWORD_FIELDS\n} from '../../test/constants/users-test.constant';\nimport {PasswordsMatchPipe} from './passwords-match.pipe';\n\ndescribe('PasswordsMatchPipe', () => {\n  let passwordsMatchPipe: PasswordsMatchPipe;\n  let metaData: ArgumentMetadata;\n\n  beforeEach(() => {\n    passwordsMatchPipe = new PasswordsMatchPipe();\n  });\n\n  it('should make sure that the passwords-match pipe is defined', () => {\n    expect(passwordsMatchPipe).toBeDefined();\n  });\n\n  /* Tests that when password and passwordConfirmation match,\n   the same CreateUserDto obj that is passed to the pipeline, is returned */\n  describe('Test Matching Passwords', () => {\n    it('should return the same CreateUserDto', () => {\n      expect(\n        passwordsMatchPipe.transform(CREATE_USER_DTO_TEST_OBJ, metaData)\n      ).toEqual(CREATE_USER_DTO_TEST_OBJ);\n    });\n\n    it('should return the same UpdateUserDto', () => {\n      expect(\n        passwordsMatchPipe.transform(UPDATE_USER_DTO_TEST_OBJ, metaData)\n      ).toEqual(UPDATE_USER_DTO_TEST_OBJ);\n    });\n\n    it('should return UpdateUserDto if password fields are null', () => {\n      expect(\n        passwordsMatchPipe.transform(\n          UPDATE_USER_DTO_WITHOUT_PASSWORD_FIELDS,\n          metaData\n        )\n      ).toEqual(UPDATE_USER_DTO_WITHOUT_PASSWORD_FIELDS);\n    });\n  });\n\n  /* Tests that when password and passwordConfirmation don't match,\n    a BadRequestException is thrown */\n  describe('Test Mismatching Passwords', () => {\n    it('should throw a Bad Request Exception', () => {\n      expect(() =>\n        passwordsMatchPipe.transform(\n          CREATE_USER_DTO_TEST_OBJ_WITH_UNMATCHING_PASSWORDS,\n          metaData\n        )\n      ).toThrowError(BadRequestException);\n      expect(() =>\n        passwordsMatchPipe.transform(\n          CREATE_USER_DTO_TEST_OBJ_WITH_UNMATCHING_PASSWORDS,\n          metaData\n        )\n      ).toThrowError('Passwords do not match');\n    });\n  });\n});\n\n",
  "/api/rules/show?key=typescript:S3776": {
    "rule": {
      "key": "typescript:S3776",
      "repo": "typescript",
      "name": "Cognitive Complexity of functions should not be too high",
      "createdAt": "2021-08-13T16:14:42+0000",
      "htmlDesc": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>",
      "mdDesc": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>",
      "severity": "CRITICAL",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "brain-overload"
      ],
      "lang": "ts",
      "langName": "TypeScript",
      "params": [
        {
          "key": "threshold",
          "htmlDesc": "The maximum authorized complexity.",
          "defaultValue": 15,
          "type": "INTEGER"
        }
      ],
      "defaultDebtRemFnType": "LINEAR_OFFSET",
      "defaultDebtRemFnCoeff": "1min",
      "defaultDebtRemFnOffset": "5min",
      "effortToFixDescription": "per complexity point over the threshold",
      "debtOverloaded": false,
      "debtRemFnType": "LINEAR_OFFSET",
      "debtRemFnCoeff": "1min",
      "debtRemFnOffset": "5min",
      "type": "CODE_SMELL",
      "defaultRemFnType": "LINEAR_OFFSET",
      "defaultRemFnGapMultiplier": "1min",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "LINEAR_OFFSET",
      "remFnGapMultiplier": "1min",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "gapDescription": "per complexity point over the threshold",
      "scope": "MAIN",
      "isExternal": false
    },
    "actives": []
  },
  "/api/rules/show?key=typescript:S3317": {
    "rule": {
      "key": "typescript:S3317",
      "repo": "typescript",
      "name": "Default export names and file names should match",
      "createdAt": "2021-08-13T16:14:42+0000",
      "htmlDesc": "<p>By convention, a file that exports only one class, function, or constant should be named for that class, function or constant. Anything else may\nconfuse maintainers.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n// file path: myclass.js  -- Noncompliant\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n// file path: MyClass.js\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Exceptions</h2>\n<p>Case, underscores ( <code>_</code> ) and dashes (<code>-</code>) are ignored from the name comparison.</p>",
      "mdDesc": "<p>By convention, a file that exports only one class, function, or constant should be named for that class, function or constant. Anything else may\nconfuse maintainers.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n// file path: myclass.js  -- Noncompliant\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n// file path: MyClass.js\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Exceptions</h2>\n<p>Case, underscores ( <code>_</code> ) and dashes (<code>-</code>) are ignored from the name comparison.</p>",
      "severity": "MINOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "confusing",
        "convention",
        "es2015"
      ],
      "lang": "ts",
      "langName": "TypeScript",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "CODE_SMELL",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    "actives": []
  },
  "/api/rules/show?key=typescript:S1117": {
    "rule": {
      "key": "typescript:S1117",
      "repo": "typescript",
      "name": "Variables should not be shadowed",
      "createdAt": "2021-08-13T16:14:42+0000",
      "htmlDesc": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>",
      "mdDesc": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "pitfall",
        "suspicious"
      ],
      "lang": "ts",
      "langName": "TypeScript",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "CODE_SMELL",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    "actives": []
  },
  "/api/rules/show?key=typescript:S3358": {
    "rule": {
      "key": "typescript:S3358",
      "repo": "typescript",
      "name": "Ternary operators should not be nested",
      "createdAt": "2021-08-13T16:14:42+0000",
      "htmlDesc": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>",
      "mdDesc": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "confusing"
      ],
      "lang": "ts",
      "langName": "TypeScript",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "CODE_SMELL",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    "actives": []
  },
  "/api/rules/show?key=typescript:S4325": {
    "rule": {
      "key": "typescript:S4325",
      "repo": "typescript",
      "name": "Redundant casts and non-null assertions should be avoided",
      "createdAt": "2021-08-13T16:14:42+0000",
      "htmlDesc": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>",
      "mdDesc": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>",
      "severity": "MINOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "redundant"
      ],
      "lang": "ts",
      "langName": "TypeScript",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "1min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "1min",
      "type": "CODE_SMELL",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "1min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "1min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    "actives": []
  },
  "/api/rules/show?key=typescript:S4138": {
    "rule": {
      "key": "typescript:S4138",
      "repo": "typescript",
      "name": "\"for of\" should be used with Iterables",
      "createdAt": "2021-08-13T16:14:42+0000",
      "htmlDesc": "<p>If you have an iterable, such as an array, set, or list, your best option for looping through its values is the <code>for of</code> syntax. Use a\ncounter, and …​ well you’ll get the right behavior, but your code just isn’t as clean or clear.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nconst arr = [4, 3, 2, 1];\n\nfor (let i = 0; i &lt; arr.length; i++) {  // Noncompliant\n  console.log(arr[i]);\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nconst arr = [4, 3, 2, 1];\n\nfor (let value of arr) {\n  console.log(value);\n}\n</pre>",
      "mdDesc": "<p>If you have an iterable, such as an array, set, or list, your best option for looping through its values is the <code>for of</code> syntax. Use a\ncounter, and …​ well you’ll get the right behavior, but your code just isn’t as clean or clear.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nconst arr = [4, 3, 2, 1];\n\nfor (let i = 0; i &lt; arr.length; i++) {  // Noncompliant\n  console.log(arr[i]);\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nconst arr = [4, 3, 2, 1];\n\nfor (let value of arr) {\n  console.log(value);\n}\n</pre>",
      "severity": "MINOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "clumsy"
      ],
      "lang": "ts",
      "langName": "TypeScript",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "CODE_SMELL",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    "actives": []
  },
  "/api/rules/show?key=typescript:S4144": {
    "rule": {
      "key": "typescript:S4144",
      "repo": "typescript",
      "name": "Functions should not have identical implementations",
      "createdAt": "2021-08-13T16:14:42+0000",
      "htmlDesc": "<p>When two functions have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but\nmay be confusing to maintainers. In the latter case, the code should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {  // Noncompliant\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {\n  return calculateCode();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Functions with fewer than 3 lines are ignored.</p>",
      "mdDesc": "<p>When two functions have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but\nmay be confusing to maintainers. In the latter case, the code should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {  // Noncompliant\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {\n  return calculateCode();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Functions with fewer than 3 lines are ignored.</p>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "confusing",
        "duplicate",
        "suspicious"
      ],
      "lang": "ts",
      "langName": "TypeScript",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "15min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "15min",
      "type": "CODE_SMELL",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "15min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "15min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    "actives": []
  },
  "/api/rules/show?key=typescript:S1135": {
    "rule": {
      "key": "typescript:S1135",
      "repo": "typescript",
      "name": "Track uses of \"TODO\" tags",
      "createdAt": "2021-08-13T16:14:42+0000",
      "htmlDesc": "<p><code>TODO</code> tags are commonly used to mark places where some more code is required, but which the developer wants to implement later.</p>\n<p>Sometimes the developer will not have the time or will simply forget to get back to that tag.</p>\n<p>This rule is meant to track those tags and to ensure that they do not go unnoticed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction doSomething() {\n  // TODO\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/546.html\">MITRE, CWE-546</a> - Suspicious Comment </li>\n</ul>",
      "mdDesc": "<p><code>TODO</code> tags are commonly used to mark places where some more code is required, but which the developer wants to implement later.</p>\n<p>Sometimes the developer will not have the time or will simply forget to get back to that tag.</p>\n<p>This rule is meant to track those tags and to ensure that they do not go unnoticed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction doSomething() {\n  // TODO\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/546.html\">MITRE, CWE-546</a> - Suspicious Comment </li>\n</ul>",
      "severity": "INFO",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "cwe"
      ],
      "lang": "ts",
      "langName": "TypeScript",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "0min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "0min",
      "type": "CODE_SMELL",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "0min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "0min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    "actives": []
  },
  "/api/rules/show?key=typescript:S1848": {
    "rule": {
      "key": "typescript:S1848",
      "repo": "typescript",
      "name": "Objects should not be created to be dropped immediately without being used",
      "createdAt": "2021-08-13T16:14:42+0000",
      "htmlDesc": "<p>There is no good reason to create a new object to not do anything with it. Most of the time, this is due to a missing piece of code and so could\nlead to an unexpected behavior in production.</p>\n<p>If it was done on purpose because the constructor has side-effects, then that side-effect code should be moved into a separate method and called\ndirectly.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nnew MyConstructor(); // Non-Compliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar something = new MyConstructor();  // Compliant\n</pre>\n<h2>Exceptions</h2>\n<p>Immediately dropped new objects inside <code>try</code>-statements are ignored.</p>\n<pre>\ntry {\n  new MyConstructor();\n} catch (e) {\n  /* ... */\n}\n</pre>",
      "mdDesc": "<p>There is no good reason to create a new object to not do anything with it. Most of the time, this is due to a missing piece of code and so could\nlead to an unexpected behavior in production.</p>\n<p>If it was done on purpose because the constructor has side-effects, then that side-effect code should be moved into a separate method and called\ndirectly.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nnew MyConstructor(); // Non-Compliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar something = new MyConstructor();  // Compliant\n</pre>\n<h2>Exceptions</h2>\n<p>Immediately dropped new objects inside <code>try</code>-statements are ignored.</p>\n<pre>\ntry {\n  new MyConstructor();\n} catch (e) {\n  /* ... */\n}\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "ts",
      "langName": "TypeScript",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    "actives": []
  },
    "/api/issues/search?componentKeys=test&types=CODE_SMELL,BUG,VULNERABILITY&p=1": {
        "total": 68,
        "p": 1,
        "ps": 100,
        "paging": {
          "pageIndex": 1,
          "pageSize": 100,
          "total": 68
        },
        "effortTotal": 475,
        "issues": [
          {
            "key": "AXtAUPqUi8r-LMdMzpgJ",
            "rule": "typescript:S3776",
            "severity": "CRITICAL",
            "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
            "project": "test",
            "line": 353,
            "hash": "c8784c25364adaf775f446d53048aaad",
            "textRange": {
              "startLine": 353,
              "endLine": 353,
              "startOffset": 6,
              "endOffset": 11
            },
            "flows": [
              {
                "locations": [
                  {
                    "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                    "textRange": {
                      "startLine": 363,
                      "endLine": 363,
                      "startOffset": 4,
                      "endOffset": 6
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                    "textRange": {
                      "startLine": 363,
                      "endLine": 363,
                      "startOffset": 36,
                      "endOffset": 38
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                    "textRange": {
                      "startLine": 366,
                      "endLine": 366,
                      "startOffset": 6,
                      "endOffset": 8
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                    "textRange": {
                      "startLine": 369,
                      "endLine": 369,
                      "startOffset": 11,
                      "endOffset": 13
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                    "textRange": {
                      "startLine": 370,
                      "endLine": 370,
                      "startOffset": 38,
                      "endOffset": 40
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                    "textRange": {
                      "startLine": 374,
                      "endLine": 374,
                      "startOffset": 6,
                      "endOffset": 8
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                    "textRange": {
                      "startLine": 377,
                      "endLine": 377,
                      "startOffset": 11,
                      "endOffset": 13
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                    "textRange": {
                      "startLine": 378,
                      "endLine": 378,
                      "startOffset": 40,
                      "endOffset": 42
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                    "textRange": {
                      "startLine": 382,
                      "endLine": 382,
                      "startOffset": 6,
                      "endOffset": 8
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                    "textRange": {
                      "startLine": 385,
                      "endLine": 385,
                      "startOffset": 11,
                      "endOffset": 13
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                    "textRange": {
                      "startLine": 385,
                      "endLine": 385,
                      "startOffset": 44,
                      "endOffset": 46
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                    "textRange": {
                      "startLine": 387,
                      "endLine": 387,
                      "startOffset": 6,
                      "endOffset": 8
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                    "textRange": {
                      "startLine": 390,
                      "endLine": 390,
                      "startOffset": 11,
                      "endOffset": 13
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                    "textRange": {
                      "startLine": 399,
                      "endLine": 399,
                      "startOffset": 6,
                      "endOffset": 10
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                    "textRange": {
                      "startLine": 391,
                      "endLine": 391,
                      "startOffset": 39,
                      "endOffset": 41
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                    "textRange": {
                      "startLine": 396,
                      "endLine": 396,
                      "startOffset": 6,
                      "endOffset": 8
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                    "textRange": {
                      "startLine": 404,
                      "endLine": 404,
                      "startOffset": 4,
                      "endOffset": 6
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
                    "textRange": {
                      "startLine": 410,
                      "endLine": 410,
                      "startOffset": 4,
                      "endOffset": 6
                    },
                    "msg": "+1"
                  }
                ]
              }
            ],
            "status": "OPEN",
            "message": "Refactor this function to reduce its Cognitive Complexity from 23 to the 15 allowed.",
            "effort": "13min",
            "debt": "13min",
            "author": "rbclark@mitre.org",
            "tags": [
              "brain-overload"
            ],
            "creationDate": "2021-08-05T18:34:07+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "\n  /** Return items sorted and filters out viewed controls */\n  get items(): ListElt[] {\n    // Controls ascending/descending\n    let factor = 1;\n    // Whether or not we need to sort",
            "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
          },
          {
            "key": "AXtAUPhHi8r-LMdMzpf2",
            "rule": "typescript:S3317",
            "severity": "MINOR",
            "component": "test:apps/frontend/src/components/global/upload_tabs/aws/AuthStepBasic.vue",
            "project": "test",
            "flows": [],
            "status": "OPEN",
            "message": "Rename this file to \"S3Reader\"",
            "effort": "5min",
            "debt": "5min",
            "author": "rbclark@mitre.org",
            "tags": [
              "confusing",
              "convention",
              "es2015"
            ],
            "creationDate": "2021-08-05T18:34:07+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "",
            "summary": "<p>By convention, a file that exports only one class, function, or constant should be named for that class, function or constant. Anything else may\nconfuse maintainers.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n// file path: myclass.js  -- Noncompliant\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n// file path: MyClass.js\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Exceptions</h2>\n<p>Case, underscores ( <code>_</code> ) and dashes (<code>-</code>) are ignored from the name comparison.</p>"
          },
          {
            "key": "AXtAUPnEi8r-LMdMzpf3",
            "rule": "typescript:S3317",
            "severity": "MINOR",
            "component": "test:apps/frontend/src/components/global/upload_tabs/aws/AuthStepMFA.vue",
            "project": "test",
            "flows": [],
            "status": "OPEN",
            "message": "Rename this file to \"S3Reader\"",
            "effort": "5min",
            "debt": "5min",
            "author": "rbclark@mitre.org",
            "tags": [
              "confusing",
              "convention",
              "es2015"
            ],
            "creationDate": "2021-08-05T18:34:07+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "",
            "summary": "<p>By convention, a file that exports only one class, function, or constant should be named for that class, function or constant. Anything else may\nconfuse maintainers.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n// file path: myclass.js  -- Noncompliant\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n// file path: MyClass.js\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Exceptions</h2>\n<p>Case, underscores ( <code>_</code> ) and dashes (<code>-</code>) are ignored from the name comparison.</p>"
          },
          {
            "key": "AXtAUPy-i8r-LMdMzphZ",
            "rule": "typescript:S3776",
            "severity": "CRITICAL",
            "component": "test:libs/hdf-converters/src/base-converter.ts",
            "project": "test",
            "line": 195,
            "hash": "e3a2905493498652453fa20fca99f9b9",
            "textRange": {
              "startLine": 195,
              "endLine": 195,
              "startOffset": 2,
              "endOffset": 13
            },
            "flows": [
              {
                "locations": [
                  {
                    "component": "test:libs/hdf-converters/src/base-converter.ts",
                    "textRange": {
                      "startLine": 199,
                      "endLine": 199,
                      "startOffset": 4,
                      "endOffset": 6
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/hdf-converters/src/base-converter.ts",
                    "textRange": {
                      "startLine": 202,
                      "endLine": 202,
                      "startOffset": 4,
                      "endOffset": 6
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/hdf-converters/src/base-converter.ts",
                    "textRange": {
                      "startLine": 215,
                      "endLine": 215,
                      "startOffset": 6,
                      "endOffset": 10
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/hdf-converters/src/base-converter.ts",
                    "textRange": {
                      "startLine": 211,
                      "endLine": 211,
                      "startOffset": 6,
                      "endOffset": 8
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/hdf-converters/src/base-converter.ts",
                    "textRange": {
                      "startLine": 220,
                      "endLine": 220,
                      "startOffset": 6,
                      "endOffset": 8
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/hdf-converters/src/base-converter.ts",
                    "textRange": {
                      "startLine": 245,
                      "endLine": 245,
                      "startOffset": 8,
                      "endOffset": 12
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/hdf-converters/src/base-converter.ts",
                    "textRange": {
                      "startLine": 222,
                      "endLine": 222,
                      "startOffset": 8,
                      "endOffset": 10
                    },
                    "msg": "+3 (incl. 2 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/hdf-converters/src/base-converter.ts",
                    "textRange": {
                      "startLine": 238,
                      "endLine": 238,
                      "startOffset": 10,
                      "endOffset": 14
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/hdf-converters/src/base-converter.ts",
                    "textRange": {
                      "startLine": 231,
                      "endLine": 231,
                      "startOffset": 10,
                      "endOffset": 12
                    },
                    "msg": "+4 (incl. 3 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/hdf-converters/src/base-converter.ts",
                    "textRange": {
                      "startLine": 234,
                      "endLine": 234,
                      "startOffset": 10,
                      "endOffset": 12
                    },
                    "msg": "+4 (incl. 3 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/hdf-converters/src/base-converter.ts",
                    "textRange": {
                      "startLine": 239,
                      "endLine": 239,
                      "startOffset": 10,
                      "endOffset": 12
                    },
                    "msg": "+4 (incl. 3 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/hdf-converters/src/base-converter.ts",
                    "textRange": {
                      "startLine": 241,
                      "endLine": 241,
                      "startOffset": 12,
                      "endOffset": 16
                    },
                    "msg": "+1"
                  }
                ]
              }
            ],
            "status": "OPEN",
            "message": "Refactor this function to reduce its Cognitive Complexity from 25 to the 15 allowed.",
            "effort": "15min",
            "debt": "15min",
            "author": "rbclark@mitre.org",
            "tags": [
              "brain-overload"
            ],
            "creationDate": "2021-08-05T16:58:31+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "  }\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  handleArray<T extends object>(\n    file: Record<string, unknown>,\n    v: Array<T & ILookupPath>\n  ): Array<T> {",
            "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
          },
          {
            "key": "AXtAUP0Hi8r-LMdMzph5",
            "rule": "typescript:S3776",
            "severity": "CRITICAL",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
            "project": "test",
            "line": 228,
            "hash": "5fd6dcc3adfc524cd3dd083080299a0c",
            "textRange": {
              "startLine": 228,
              "endLine": 228,
              "startOffset": 9,
              "endOffset": 18
            },
            "flows": [
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                    "textRange": {
                      "startLine": 286,
                      "endLine": 286,
                      "startOffset": 4,
                      "endOffset": 6
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                    "textRange": {
                      "startLine": 287,
                      "endLine": 287,
                      "startOffset": 4,
                      "endOffset": 6
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                    "textRange": {
                      "startLine": 288,
                      "endLine": 288,
                      "startOffset": 8,
                      "endOffset": 10
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                    "textRange": {
                      "startLine": 291,
                      "endLine": 291,
                      "startOffset": 4,
                      "endOffset": 6
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                    "textRange": {
                      "startLine": 292,
                      "endLine": 292,
                      "startOffset": 4,
                      "endOffset": 9
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                    "textRange": {
                      "startLine": 292,
                      "endLine": 292,
                      "startOffset": 35,
                      "endOffset": 37
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                    "textRange": {
                      "startLine": 295,
                      "endLine": 295,
                      "startOffset": 4,
                      "endOffset": 6
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                    "textRange": {
                      "startLine": 296,
                      "endLine": 296,
                      "startOffset": 4,
                      "endOffset": 6
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                    "textRange": {
                      "startLine": 297,
                      "endLine": 297,
                      "startOffset": 50,
                      "endOffset": 51
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                    "textRange": {
                      "startLine": 298,
                      "endLine": 298,
                      "startOffset": 50,
                      "endOffset": 51
                    },
                    "msg": "+3 (incl. 2 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                    "textRange": {
                      "startLine": 299,
                      "endLine": 299,
                      "startOffset": 50,
                      "endOffset": 51
                    },
                    "msg": "+4 (incl. 3 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                    "textRange": {
                      "startLine": 303,
                      "endLine": 303,
                      "startOffset": 4,
                      "endOffset": 6
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                    "textRange": {
                      "startLine": 303,
                      "endLine": 303,
                      "startOffset": 21,
                      "endOffset": 23
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                    "textRange": {
                      "startLine": 230,
                      "endLine": 230,
                      "startOffset": 8,
                      "endOffset": 10
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                    "textRange": {
                      "startLine": 237,
                      "endLine": 237,
                      "startOffset": 8,
                      "endOffset": 11
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                    "textRange": {
                      "startLine": 241,
                      "endLine": 241,
                      "startOffset": 14,
                      "endOffset": 19
                    },
                    "msg": "+3 (incl. 2 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                    "textRange": {
                      "startLine": 247,
                      "endLine": 247,
                      "startOffset": 8,
                      "endOffset": 10
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                    "textRange": {
                      "startLine": 253,
                      "endLine": 253,
                      "startOffset": 8,
                      "endOffset": 10
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                    "textRange": {
                      "startLine": 258,
                      "endLine": 258,
                      "startOffset": 8,
                      "endOffset": 10
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                    "textRange": {
                      "startLine": 262,
                      "endLine": 262,
                      "startOffset": 8,
                      "endOffset": 10
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                    "textRange": {
                      "startLine": 269,
                      "endLine": 269,
                      "startOffset": 8,
                      "endOffset": 10
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                    "textRange": {
                      "startLine": 269,
                      "endLine": 269,
                      "startOffset": 52,
                      "endOffset": 54
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                    "textRange": {
                      "startLine": 275,
                      "endLine": 275,
                      "startOffset": 69,
                      "endOffset": 70
                    },
                    "msg": "+3 (incl. 2 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
                    "textRange": {
                      "startLine": 279,
                      "endLine": 279,
                      "startOffset": 12,
                      "endOffset": 14
                    },
                    "msg": "+3 (incl. 2 for nesting)"
                  }
                ]
              }
            ],
            "status": "OPEN",
            "message": "Refactor this function to reduce its Cognitive Complexity from 44 to the 15 allowed.",
            "effort": "34min",
            "debt": "34min",
            "author": "66632401+sesheikholeslam@users.noreply.github.com",
            "tags": [
              "brain-overload"
            ],
            "creationDate": "2021-08-02T17:29:14+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "}\n\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);",
            "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
          },
          {
            "key": "AXtAUP0Hi8r-LMdMzph9",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
            "project": "test",
            "line": 238,
            "hash": "c18b29c89a7108ee069bbe31d8a88c35",
            "textRange": {
              "startLine": 238,
              "endLine": 238,
              "startOffset": 18,
              "endOffset": 21
            },
            "flows": [],
            "status": "OPEN",
            "message": "'typ' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "66632401+sesheikholeslam@users.noreply.github.com",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2021-08-02T17:29:14+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "        const l = typs.length;\n        for (let i = 0; i < l; i++) {\n            const typ = typs[i];\n            try {\n                return transform(val, typ, getProps);\n            } catch (_) {}",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUP0Hi8r-LMdMzpiC",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
            "project": "test",
            "line": 268,
            "hash": "00fba73079d5d65a34ef9c6a86abaae5",
            "textRange": {
              "startLine": 268,
              "endLine": 268,
              "startOffset": 75,
              "endOffset": 83
            },
            "flows": [],
            "status": "OPEN",
            "message": "'val' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "66632401+sesheikholeslam@users.noreply.github.com",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2021-08-02T17:29:14+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "    }\n\n    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {\n        if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n            return invalidValue(\"object\", val);\n        }",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUP0Hi8r-LMdMzpiD",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
            "project": "test",
            "line": 273,
            "hash": "f55f8faca787b16a5de85276cda27696",
            "textRange": {
              "startLine": 273,
              "endLine": 273,
              "startOffset": 50,
              "endOffset": 53
            },
            "flows": [],
            "status": "OPEN",
            "message": "'key' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "66632401+sesheikholeslam@users.noreply.github.com",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2021-08-02T17:29:14+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "        }\n        const result: any = {};\n        Object.getOwnPropertyNames(props).forEach(key => {\n            const prop = props[key];\n            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;\n            result[prop.key] = transform(v, prop.typ, getProps, prop.key);",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUP0Hi8r-LMdMzpiE",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
            "project": "test",
            "line": 278,
            "hash": "85cdf91827cdae6313afff45d00a55bf",
            "textRange": {
              "startLine": 278,
              "endLine": 278,
              "startOffset": 48,
              "endOffset": 51
            },
            "flows": [],
            "status": "OPEN",
            "message": "'key' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "66632401+sesheikholeslam@users.noreply.github.com",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2021-08-02T17:29:14+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "            result[prop.key] = transform(v, prop.typ, getProps, prop.key);\n        });\n        Object.getOwnPropertyNames(val).forEach(key => {\n            if (!Object.prototype.hasOwnProperty.call(props, key)) {\n                result[key] = transform(val[key], additional, getProps, key);\n            }",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUP0Hi8r-LMdMzpiF",
            "rule": "typescript:S3358",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
            "project": "test",
            "line": 298,
            "hash": "312531a9243571ab2555c04a21adee70",
            "textRange": {
              "startLine": 298,
              "endLine": 300,
              "startOffset": 14,
              "endOffset": 36
            },
            "flows": [],
            "status": "OPEN",
            "message": "Extract this nested ternary operation into an independent statement.",
            "effort": "5min",
            "debt": "5min",
            "author": "66632401+sesheikholeslam@users.noreply.github.com",
            "tags": [
              "confusing"
            ],
            "creationDate": "2021-08-02T17:29:14+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "    if (typeof typ === \"object\") {\n        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);",
            "summary": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>"
          },
          {
            "key": "AXtAUP0Ii8r-LMdMzpiG",
            "rule": "typescript:S3358",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
            "project": "test",
            "line": 299,
            "hash": "8a63580931669d2f7b7d79bda6f68a08",
            "textRange": {
              "startLine": 299,
              "endLine": 300,
              "startOffset": 14,
              "endOffset": 36
            },
            "flows": [],
            "status": "OPEN",
            "message": "Extract this nested ternary operation into an independent statement.",
            "effort": "5min",
            "debt": "5min",
            "author": "66632401+sesheikholeslam@users.noreply.github.com",
            "tags": [
              "confusing"
            ],
            "creationDate": "2021-08-02T17:29:14+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);",
            "summary": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>"
          },
          {
            "key": "AXtAUPz9i8r-LMdMzphr",
            "rule": "typescript:S3776",
            "severity": "CRITICAL",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
            "project": "test",
            "line": 90,
            "hash": "5fd6dcc3adfc524cd3dd083080299a0c",
            "textRange": {
              "startLine": 90,
              "endLine": 90,
              "startOffset": 9,
              "endOffset": 18
            },
            "flows": [
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                    "textRange": {
                      "startLine": 148,
                      "endLine": 148,
                      "startOffset": 4,
                      "endOffset": 6
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                    "textRange": {
                      "startLine": 149,
                      "endLine": 149,
                      "startOffset": 4,
                      "endOffset": 6
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                    "textRange": {
                      "startLine": 150,
                      "endLine": 150,
                      "startOffset": 8,
                      "endOffset": 10
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                    "textRange": {
                      "startLine": 153,
                      "endLine": 153,
                      "startOffset": 4,
                      "endOffset": 6
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                    "textRange": {
                      "startLine": 154,
                      "endLine": 154,
                      "startOffset": 4,
                      "endOffset": 9
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                    "textRange": {
                      "startLine": 154,
                      "endLine": 154,
                      "startOffset": 35,
                      "endOffset": 37
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                    "textRange": {
                      "startLine": 157,
                      "endLine": 157,
                      "startOffset": 4,
                      "endOffset": 6
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                    "textRange": {
                      "startLine": 158,
                      "endLine": 158,
                      "startOffset": 4,
                      "endOffset": 6
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                    "textRange": {
                      "startLine": 159,
                      "endLine": 159,
                      "startOffset": 50,
                      "endOffset": 51
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                    "textRange": {
                      "startLine": 160,
                      "endLine": 160,
                      "startOffset": 50,
                      "endOffset": 51
                    },
                    "msg": "+3 (incl. 2 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                    "textRange": {
                      "startLine": 161,
                      "endLine": 161,
                      "startOffset": 50,
                      "endOffset": 51
                    },
                    "msg": "+4 (incl. 3 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                    "textRange": {
                      "startLine": 165,
                      "endLine": 165,
                      "startOffset": 4,
                      "endOffset": 6
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                    "textRange": {
                      "startLine": 165,
                      "endLine": 165,
                      "startOffset": 21,
                      "endOffset": 23
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                    "textRange": {
                      "startLine": 92,
                      "endLine": 92,
                      "startOffset": 8,
                      "endOffset": 10
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                    "textRange": {
                      "startLine": 99,
                      "endLine": 99,
                      "startOffset": 8,
                      "endOffset": 11
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                    "textRange": {
                      "startLine": 103,
                      "endLine": 103,
                      "startOffset": 14,
                      "endOffset": 19
                    },
                    "msg": "+3 (incl. 2 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                    "textRange": {
                      "startLine": 109,
                      "endLine": 109,
                      "startOffset": 8,
                      "endOffset": 10
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                    "textRange": {
                      "startLine": 115,
                      "endLine": 115,
                      "startOffset": 8,
                      "endOffset": 10
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                    "textRange": {
                      "startLine": 120,
                      "endLine": 120,
                      "startOffset": 8,
                      "endOffset": 10
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                    "textRange": {
                      "startLine": 124,
                      "endLine": 124,
                      "startOffset": 8,
                      "endOffset": 10
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                    "textRange": {
                      "startLine": 131,
                      "endLine": 131,
                      "startOffset": 8,
                      "endOffset": 10
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                    "textRange": {
                      "startLine": 131,
                      "endLine": 131,
                      "startOffset": 52,
                      "endOffset": 54
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                    "textRange": {
                      "startLine": 137,
                      "endLine": 137,
                      "startOffset": 69,
                      "endOffset": 70
                    },
                    "msg": "+3 (incl. 2 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
                    "textRange": {
                      "startLine": 141,
                      "endLine": 141,
                      "startOffset": 12,
                      "endOffset": 14
                    },
                    "msg": "+3 (incl. 2 for nesting)"
                  }
                ]
              }
            ],
            "status": "OPEN",
            "message": "Refactor this function to reduce its Cognitive Complexity from 44 to the 15 allowed.",
            "effort": "34min",
            "debt": "34min",
            "author": "66632401+sesheikholeslam@users.noreply.github.com",
            "tags": [
              "brain-overload"
            ],
            "creationDate": "2021-08-02T17:29:14+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "}\n\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);",
            "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
          },
          {
            "key": "AXtAUPz9i8r-LMdMzph0",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
            "project": "test",
            "line": 130,
            "hash": "00fba73079d5d65a34ef9c6a86abaae5",
            "textRange": {
              "startLine": 130,
              "endLine": 130,
              "startOffset": 75,
              "endOffset": 83
            },
            "flows": [],
            "status": "OPEN",
            "message": "'val' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "66632401+sesheikholeslam@users.noreply.github.com",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2021-08-02T17:29:14+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "    }\n\n    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {\n        if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n            return invalidValue(\"object\", val);\n        }",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUPz9i8r-LMdMzph1",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
            "project": "test",
            "line": 135,
            "hash": "f55f8faca787b16a5de85276cda27696",
            "textRange": {
              "startLine": 135,
              "endLine": 135,
              "startOffset": 50,
              "endOffset": 53
            },
            "flows": [],
            "status": "OPEN",
            "message": "'key' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "66632401+sesheikholeslam@users.noreply.github.com",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2021-08-02T17:29:14+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "        }\n        const result: any = {};\n        Object.getOwnPropertyNames(props).forEach(key => {\n            const prop = props[key];\n            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;\n            result[prop.key] = transform(v, prop.typ, getProps, prop.key);",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUPz9i8r-LMdMzph2",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
            "project": "test",
            "line": 140,
            "hash": "85cdf91827cdae6313afff45d00a55bf",
            "textRange": {
              "startLine": 140,
              "endLine": 140,
              "startOffset": 48,
              "endOffset": 51
            },
            "flows": [],
            "status": "OPEN",
            "message": "'key' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "66632401+sesheikholeslam@users.noreply.github.com",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2021-08-02T17:29:14+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "            result[prop.key] = transform(v, prop.typ, getProps, prop.key);\n        });\n        Object.getOwnPropertyNames(val).forEach(key => {\n            if (!Object.prototype.hasOwnProperty.call(props, key)) {\n                result[key] = transform(val[key], additional, getProps, key);\n            }",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUPz9i8r-LMdMzph3",
            "rule": "typescript:S3358",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
            "project": "test",
            "line": 160,
            "hash": "312531a9243571ab2555c04a21adee70",
            "textRange": {
              "startLine": 160,
              "endLine": 162,
              "startOffset": 14,
              "endOffset": 36
            },
            "flows": [],
            "status": "OPEN",
            "message": "Extract this nested ternary operation into an independent statement.",
            "effort": "5min",
            "debt": "5min",
            "author": "66632401+sesheikholeslam@users.noreply.github.com",
            "tags": [
              "confusing"
            ],
            "creationDate": "2021-08-02T17:29:14+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "    if (typeof typ === \"object\") {\n        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);",
            "summary": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>"
          },
          {
            "key": "AXtAUPz9i8r-LMdMzph4",
            "rule": "typescript:S3358",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
            "project": "test",
            "line": 161,
            "hash": "8a63580931669d2f7b7d79bda6f68a08",
            "textRange": {
              "startLine": 161,
              "endLine": 162,
              "startOffset": 14,
              "endOffset": 36
            },
            "flows": [],
            "status": "OPEN",
            "message": "Extract this nested ternary operation into an independent statement.",
            "effort": "5min",
            "debt": "5min",
            "author": "66632401+sesheikholeslam@users.noreply.github.com",
            "tags": [
              "confusing"
            ],
            "creationDate": "2021-08-02T17:29:14+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);",
            "summary": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>"
          },
          {
            "key": "AXtAUPzsi8r-LMdMzphd",
            "rule": "typescript:S3776",
            "severity": "CRITICAL",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
            "project": "test",
            "line": 147,
            "hash": "5fd6dcc3adfc524cd3dd083080299a0c",
            "textRange": {
              "startLine": 147,
              "endLine": 147,
              "startOffset": 9,
              "endOffset": 18
            },
            "flows": [
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                    "textRange": {
                      "startLine": 205,
                      "endLine": 205,
                      "startOffset": 4,
                      "endOffset": 6
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                    "textRange": {
                      "startLine": 206,
                      "endLine": 206,
                      "startOffset": 4,
                      "endOffset": 6
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                    "textRange": {
                      "startLine": 207,
                      "endLine": 207,
                      "startOffset": 8,
                      "endOffset": 10
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                    "textRange": {
                      "startLine": 210,
                      "endLine": 210,
                      "startOffset": 4,
                      "endOffset": 6
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                    "textRange": {
                      "startLine": 211,
                      "endLine": 211,
                      "startOffset": 4,
                      "endOffset": 9
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                    "textRange": {
                      "startLine": 211,
                      "endLine": 211,
                      "startOffset": 35,
                      "endOffset": 37
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                    "textRange": {
                      "startLine": 214,
                      "endLine": 214,
                      "startOffset": 4,
                      "endOffset": 6
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                    "textRange": {
                      "startLine": 215,
                      "endLine": 215,
                      "startOffset": 4,
                      "endOffset": 6
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                    "textRange": {
                      "startLine": 216,
                      "endLine": 216,
                      "startOffset": 50,
                      "endOffset": 51
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                    "textRange": {
                      "startLine": 217,
                      "endLine": 217,
                      "startOffset": 50,
                      "endOffset": 51
                    },
                    "msg": "+3 (incl. 2 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                    "textRange": {
                      "startLine": 218,
                      "endLine": 218,
                      "startOffset": 50,
                      "endOffset": 51
                    },
                    "msg": "+4 (incl. 3 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                    "textRange": {
                      "startLine": 222,
                      "endLine": 222,
                      "startOffset": 4,
                      "endOffset": 6
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                    "textRange": {
                      "startLine": 222,
                      "endLine": 222,
                      "startOffset": 21,
                      "endOffset": 23
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                    "textRange": {
                      "startLine": 149,
                      "endLine": 149,
                      "startOffset": 8,
                      "endOffset": 10
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                    "textRange": {
                      "startLine": 156,
                      "endLine": 156,
                      "startOffset": 8,
                      "endOffset": 11
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                    "textRange": {
                      "startLine": 160,
                      "endLine": 160,
                      "startOffset": 14,
                      "endOffset": 19
                    },
                    "msg": "+3 (incl. 2 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                    "textRange": {
                      "startLine": 166,
                      "endLine": 166,
                      "startOffset": 8,
                      "endOffset": 10
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                    "textRange": {
                      "startLine": 172,
                      "endLine": 172,
                      "startOffset": 8,
                      "endOffset": 10
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                    "textRange": {
                      "startLine": 177,
                      "endLine": 177,
                      "startOffset": 8,
                      "endOffset": 10
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                    "textRange": {
                      "startLine": 181,
                      "endLine": 181,
                      "startOffset": 8,
                      "endOffset": 10
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                    "textRange": {
                      "startLine": 188,
                      "endLine": 188,
                      "startOffset": 8,
                      "endOffset": 10
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                    "textRange": {
                      "startLine": 188,
                      "endLine": 188,
                      "startOffset": 52,
                      "endOffset": 54
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                    "textRange": {
                      "startLine": 194,
                      "endLine": 194,
                      "startOffset": 69,
                      "endOffset": 70
                    },
                    "msg": "+3 (incl. 2 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
                    "textRange": {
                      "startLine": 198,
                      "endLine": 198,
                      "startOffset": 12,
                      "endOffset": 14
                    },
                    "msg": "+3 (incl. 2 for nesting)"
                  }
                ]
              }
            ],
            "status": "OPEN",
            "message": "Refactor this function to reduce its Cognitive Complexity from 44 to the 15 allowed.",
            "effort": "34min",
            "debt": "34min",
            "author": "66632401+sesheikholeslam@users.noreply.github.com",
            "tags": [
              "brain-overload"
            ],
            "creationDate": "2021-08-02T17:29:14+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "}\n\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);",
            "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
          },
          {
            "key": "AXtAUPzsi8r-LMdMzphh",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
            "project": "test",
            "line": 157,
            "hash": "c18b29c89a7108ee069bbe31d8a88c35",
            "textRange": {
              "startLine": 157,
              "endLine": 157,
              "startOffset": 18,
              "endOffset": 21
            },
            "flows": [],
            "status": "OPEN",
            "message": "'typ' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "66632401+sesheikholeslam@users.noreply.github.com",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2021-08-02T17:29:14+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "        const l = typs.length;\n        for (let i = 0; i < l; i++) {\n            const typ = typs[i];\n            try {\n                return transform(val, typ, getProps);\n            } catch (_) {}",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUPzsi8r-LMdMzphm",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
            "project": "test",
            "line": 187,
            "hash": "00fba73079d5d65a34ef9c6a86abaae5",
            "textRange": {
              "startLine": 187,
              "endLine": 187,
              "startOffset": 75,
              "endOffset": 83
            },
            "flows": [],
            "status": "OPEN",
            "message": "'val' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "66632401+sesheikholeslam@users.noreply.github.com",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2021-08-02T17:29:14+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "    }\n\n    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {\n        if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n            return invalidValue(\"object\", val);\n        }",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUPzsi8r-LMdMzphn",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
            "project": "test",
            "line": 192,
            "hash": "f55f8faca787b16a5de85276cda27696",
            "textRange": {
              "startLine": 192,
              "endLine": 192,
              "startOffset": 50,
              "endOffset": 53
            },
            "flows": [],
            "status": "OPEN",
            "message": "'key' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "66632401+sesheikholeslam@users.noreply.github.com",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2021-08-02T17:29:14+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "        }\n        const result: any = {};\n        Object.getOwnPropertyNames(props).forEach(key => {\n            const prop = props[key];\n            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;\n            result[prop.key] = transform(v, prop.typ, getProps, prop.key);",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUPzsi8r-LMdMzpho",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
            "project": "test",
            "line": 197,
            "hash": "85cdf91827cdae6313afff45d00a55bf",
            "textRange": {
              "startLine": 197,
              "endLine": 197,
              "startOffset": 48,
              "endOffset": 51
            },
            "flows": [],
            "status": "OPEN",
            "message": "'key' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "66632401+sesheikholeslam@users.noreply.github.com",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2021-08-02T17:29:14+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "            result[prop.key] = transform(v, prop.typ, getProps, prop.key);\n        });\n        Object.getOwnPropertyNames(val).forEach(key => {\n            if (!Object.prototype.hasOwnProperty.call(props, key)) {\n                result[key] = transform(val[key], additional, getProps, key);\n            }",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUPzsi8r-LMdMzphp",
            "rule": "typescript:S3358",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
            "project": "test",
            "line": 217,
            "hash": "312531a9243571ab2555c04a21adee70",
            "textRange": {
              "startLine": 217,
              "endLine": 219,
              "startOffset": 14,
              "endOffset": 36
            },
            "flows": [],
            "status": "OPEN",
            "message": "Extract this nested ternary operation into an independent statement.",
            "effort": "5min",
            "debt": "5min",
            "author": "66632401+sesheikholeslam@users.noreply.github.com",
            "tags": [
              "confusing"
            ],
            "creationDate": "2021-08-02T17:29:14+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "    if (typeof typ === \"object\") {\n        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);",
            "summary": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>"
          },
          {
            "key": "AXtAUPzsi8r-LMdMzphq",
            "rule": "typescript:S3358",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
            "project": "test",
            "line": 218,
            "hash": "8a63580931669d2f7b7d79bda6f68a08",
            "textRange": {
              "startLine": 218,
              "endLine": 219,
              "startOffset": 14,
              "endOffset": 36
            },
            "flows": [],
            "status": "OPEN",
            "message": "Extract this nested ternary operation into an independent statement.",
            "effort": "5min",
            "debt": "5min",
            "author": "66632401+sesheikholeslam@users.noreply.github.com",
            "tags": [
              "confusing"
            ],
            "creationDate": "2021-08-02T17:29:14+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);",
            "summary": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>"
          },
          {
            "key": "AXtAUPqri8r-LMdMzpgL",
            "rule": "typescript:S3776",
            "severity": "CRITICAL",
            "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
            "project": "test",
            "line": 71,
            "hash": "033d83583fb5666efff076b608fc30c3",
            "textRange": {
              "startLine": 71,
              "endLine": 71,
              "startOffset": 6,
              "endOffset": 19
            },
            "flows": [
              {
                "locations": [
                  {
                    "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                    "textRange": {
                      "startLine": 78,
                      "endLine": 78,
                      "startOffset": 6,
                      "endOffset": 9
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                    "textRange": {
                      "startLine": 80,
                      "endLine": 80,
                      "startOffset": 8,
                      "endOffset": 10
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                    "textRange": {
                      "startLine": 99,
                      "endLine": 99,
                      "startOffset": 8,
                      "endOffset": 10
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                    "textRange": {
                      "startLine": 105,
                      "endLine": 105,
                      "startOffset": 10,
                      "endOffset": 14
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                    "textRange": {
                      "startLine": 100,
                      "endLine": 100,
                      "startOffset": 10,
                      "endOffset": 12
                    },
                    "msg": "+3 (incl. 2 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                    "textRange": {
                      "startLine": 102,
                      "endLine": 102,
                      "startOffset": 12,
                      "endOffset": 16
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                    "textRange": {
                      "startLine": 100,
                      "endLine": 100,
                      "startOffset": 31,
                      "endOffset": 33
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                    "textRange": {
                      "startLine": 109,
                      "endLine": 109,
                      "startOffset": 6,
                      "endOffset": 11
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                    "textRange": {
                      "startLine": 88,
                      "endLine": 88,
                      "startOffset": 10,
                      "endOffset": 12
                    },
                    "msg": "+3 (incl. 2 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
                    "textRange": {
                      "startLine": 95,
                      "endLine": 95,
                      "startOffset": 12,
                      "endOffset": 16
                    },
                    "msg": "+1"
                  }
                ]
              }
            ],
            "status": "OPEN",
            "message": "Refactor this function to reduce its Cognitive Complexity from 16 to the 15 allowed.",
            "effort": "6min",
            "debt": "6min",
            "author": "66632401+sesheikholeslam@users.noreply.github.com",
            "tags": [
              "brain-overload"
            ],
            "creationDate": "2021-06-30T16:09:04+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "\n  /** The currently selected treemap node. Wrapped to avoid initialization woes */\n  get selected_node(): d3.HierarchyRectangularNode<TreemapNode> {\n    // Get typed versions of the curr state\n    // Set curr to root\n    let curr = this.treemap_layout;",
            "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
          },
          {
            "key": "AXtAUPnSi8r-LMdMzpf4",
            "rule": "typescript:S4325",
            "severity": "MINOR",
            "component": "test:apps/frontend/src/components/global/upload_tabs/aws/FileList.vue",
            "project": "test",
            "line": 79,
            "hash": "8a88aeebc2f9b4b0ecc10da38885032e",
            "textRange": {
              "startLine": 79,
              "endLine": 79,
              "startOffset": 41,
              "endOffset": 50
            },
            "flows": [],
            "status": "OPEN",
            "message": "This assertion is unnecessary since it does not change the type of the expression.",
            "effort": "1min",
            "debt": "1min",
            "author": "66632401+sesheikholeslam@users.noreply.github.com",
            "tags": [
              "redundant"
            ],
            "creationDate": "2021-06-30T16:09:04+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "\n    // Fetch it from s3, and promise to submit it to be loaded afterwards\n    await fetch_s3_file(this.auth.creds, file.Key!, this.formBucketName).then(\n      (content) => {\n        InspecIntakeModule.loadText({\n          text: content,",
            "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
          },
          {
            "key": "AXtAUPnsi8r-LMdMzpf6",
            "rule": "typescript:S4325",
            "severity": "MINOR",
            "component": "test:apps/frontend/src/components/global/upload_tabs/aws/S3Reader.vue",
            "project": "test",
            "line": 184,
            "hash": "9a4009784ecd065c4fe9baa831240022",
            "textRange": {
              "startLine": 184,
              "endLine": 184,
              "startOffset": 22,
              "endOffset": 39
            },
            "flows": [],
            "status": "OPEN",
            "message": "This assertion is unnecessary since it does not change the type of the expression.",
            "effort": "1min",
            "debt": "1min",
            "author": "66632401+sesheikholeslam@users.noreply.github.com",
            "tags": [
              "redundant"
            ],
            "creationDate": "2021-06-30T16:09:04+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "   */\n  async load_bucket(name: string) {\n    const s3 = new S3(this.assumedRole!.creds);\n    await s3\n      .listObjectsV2({\n        Bucket: name,",
            "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
          },
          {
            "key": "AXtAUPr3i8r-LMdMzpgO",
            "rule": "typescript:S4325",
            "severity": "MINOR",
            "component": "test:apps/frontend/src/store/data_filters.ts",
            "project": "test",
            "line": 96,
            "hash": "13967f9141b7884039ec8d6481313af7",
            "textRange": {
              "startLine": 96,
              "endLine": 103,
              "startOffset": 32,
              "endOffset": 41
            },
            "flows": [],
            "status": "OPEN",
            "message": "This assertion is unnecessary since it does not change the type of the expression.",
            "effort": "1min",
            "debt": "1min",
            "author": "sheikholeslam@mitre.org",
            "tags": [
              "redundant"
            ],
            "creationDate": "2021-06-23T16:08:32+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "  const asHDF = contextControl.root.hdf;\n  // Get our (non-null) searchable data\n  const searchables: string[] = [\n    asHDF.wraps.id,\n    asHDF.wraps.title,\n    asHDF.wraps.code,\n    asHDF.severity,\n    asHDF.status,\n    asHDF.finding_details\n  ].filter((s) => s !== null) as string[];\n\n  // See if any contain term\n  return searchables.some((s) => s.toLowerCase().includes(term));",
            "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
          },
          {
            "key": "AXtAUPs3i8r-LMdMzpgS",
            "rule": "typescript:S4325",
            "severity": "MINOR",
            "component": "test:apps/frontend/src/utilities/format_util.ts",
            "project": "test",
            "line": 29,
            "hash": "0c2f340c5bacde239d24920b8a453c6b",
            "textRange": {
              "startLine": 29,
              "endLine": 29,
              "startOffset": 6,
              "endOffset": 60
            },
            "flows": [],
            "status": "OPEN",
            "message": "This assertion is unnecessary since it does not change the type of the expression.",
            "effort": "1min",
            "debt": "1min",
            "author": "sheikholeslam@mitre.org",
            "tags": [
              "redundant"
            ],
            "creationDate": "2021-06-23T14:32:15+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "  } else {\n    return `${execution_unique_key(\n      profile.sourcedFrom as SourcedContextualizedEvaluation\n    )}-${profile.data.name}`;\n  }\n}",
            "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
          },
          {
            "key": "AXtAUP0Vi8r-LMdMzpiH",
            "rule": "typescript:S3776",
            "severity": "CRITICAL",
            "component": "test:libs/inspecjs/src/context.ts",
            "project": "test",
            "line": 153,
            "hash": "bd47be4985f547192f96954033d9e458",
            "textRange": {
              "startLine": 153,
              "endLine": 153,
              "startOffset": 16,
              "endOffset": 39
            },
            "flows": [
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/context.ts",
                    "textRange": {
                      "startLine": 162,
                      "endLine": 162,
                      "startOffset": 2,
                      "endOffset": 5
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/context.ts",
                    "textRange": {
                      "startLine": 176,
                      "endLine": 176,
                      "startOffset": 2,
                      "endOffset": 5
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/context.ts",
                    "textRange": {
                      "startLine": 181,
                      "endLine": 181,
                      "startOffset": 4,
                      "endOffset": 6
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/context.ts",
                    "textRange": {
                      "startLine": 188,
                      "endLine": 188,
                      "startOffset": 6,
                      "endOffset": 8
                    },
                    "msg": "+3 (incl. 2 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/context.ts",
                    "textRange": {
                      "startLine": 199,
                      "endLine": 199,
                      "startOffset": 2,
                      "endOffset": 5
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/context.ts",
                    "textRange": {
                      "startLine": 208,
                      "endLine": 208,
                      "startOffset": 2,
                      "endOffset": 5
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/context.ts",
                    "textRange": {
                      "startLine": 210,
                      "endLine": 210,
                      "startOffset": 4,
                      "endOffset": 6
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/context.ts",
                    "textRange": {
                      "startLine": 233,
                      "endLine": 233,
                      "startOffset": 6,
                      "endOffset": 10
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/context.ts",
                    "textRange": {
                      "startLine": 210,
                      "endLine": 210,
                      "startOffset": 42,
                      "endOffset": 44
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/context.ts",
                    "textRange": {
                      "startLine": 213,
                      "endLine": 213,
                      "startOffset": 6,
                      "endOffset": 8
                    },
                    "msg": "+3 (incl. 2 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/context.ts",
                    "textRange": {
                      "startLine": 220,
                      "endLine": 220,
                      "startOffset": 6,
                      "endOffset": 9
                    },
                    "msg": "+3 (incl. 2 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/context.ts",
                    "textRange": {
                      "startLine": 226,
                      "endLine": 226,
                      "startOffset": 8,
                      "endOffset": 10
                    },
                    "msg": "+4 (incl. 3 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/context.ts",
                    "textRange": {
                      "startLine": 245,
                      "endLine": 245,
                      "startOffset": 6,
                      "endOffset": 8
                    },
                    "msg": "+3 (incl. 2 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/context.ts",
                    "textRange": {
                      "startLine": 250,
                      "endLine": 250,
                      "startOffset": 6,
                      "endOffset": 8
                    },
                    "msg": "+3 (incl. 2 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/context.ts",
                    "textRange": {
                      "startLine": 252,
                      "endLine": 252,
                      "startOffset": 8,
                      "endOffset": 12
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/context.ts",
                    "textRange": {
                      "startLine": 241,
                      "endLine": 241,
                      "startOffset": 30,
                      "endOffset": 32
                    },
                    "msg": "+1"
                  }
                ]
              }
            ],
            "status": "OPEN",
            "message": "Refactor this function to reduce its Cognitive Complexity from 31 to the 15 allowed.",
            "effort": "21min",
            "debt": "21min",
            "author": "sheikholeslam@mitre.org",
            "tags": [
              "brain-overload"
            ],
            "creationDate": "2021-06-23T14:32:15+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "}\n\nexport function contextualizeEvaluation(\n  evaluation: AnyEval\n): ContextualizedEvaluation {\n  // To begin, create basic context for profiles and evaluation",
            "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
          },
          {
            "key": "AXtAUP0Hi8r-LMdMzpiB",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
            "project": "test",
            "line": 257,
            "hash": "ec0d349e10fedfa2b54a27dd6cf235ca",
            "textRange": {
              "startLine": 257,
              "endLine": 257,
              "startOffset": 27,
              "endOffset": 35
            },
            "flows": [],
            "status": "OPEN",
            "message": "'val' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "sheikholeslam@mitre.org",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2021-06-23T14:32:15+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "    }\n\n    function transformDate(val: any): any {\n        if (val === null) {\n            return null;\n        }",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUPz9i8r-LMdMzphz",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
            "project": "test",
            "line": 119,
            "hash": "ec0d349e10fedfa2b54a27dd6cf235ca",
            "textRange": {
              "startLine": 119,
              "endLine": 119,
              "startOffset": 27,
              "endOffset": 35
            },
            "flows": [],
            "status": "OPEN",
            "message": "'val' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "sheikholeslam@mitre.org",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2021-06-23T14:32:15+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "    }\n\n    function transformDate(val: any): any {\n        if (val === null) {\n            return null;\n        }",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUPzsi8r-LMdMzphl",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
            "project": "test",
            "line": 176,
            "hash": "ec0d349e10fedfa2b54a27dd6cf235ca",
            "textRange": {
              "startLine": 176,
              "endLine": 176,
              "startOffset": 27,
              "endOffset": 35
            },
            "flows": [],
            "status": "OPEN",
            "message": "'val' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "sheikholeslam@mitre.org",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2021-06-23T14:32:15+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "    }\n\n    function transformDate(val: any): any {\n        if (val === null) {\n            return null;\n        }",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUPz9i8r-LMdMzphv",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
            "project": "test",
            "line": 100,
            "hash": "c18b29c89a7108ee069bbe31d8a88c35",
            "textRange": {
              "startLine": 100,
              "endLine": 100,
              "startOffset": 18,
              "endOffset": 21
            },
            "flows": [],
            "status": "OPEN",
            "message": "'typ' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "sheikholeslam@mitre.org",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2021-06-22T15:34:30+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "        const l = typs.length;\n        for (let i = 0; i < l; i++) {\n            const typ = typs[i];\n            try {\n                return transform(val, typ, getProps);\n            } catch (_) {}",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUPzdi8r-LMdMzphc",
            "rule": "typescript:S3776",
            "severity": "CRITICAL",
            "component": "test:libs/inspecjs/src/nist.ts",
            "project": "test",
            "line": 126,
            "hash": "99d4f34dee5a16b69df60f274112f848",
            "textRange": {
              "startLine": 126,
              "endLine": 126,
              "startOffset": 2,
              "endOffset": 10
            },
            "flows": [
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/nist.ts",
                    "textRange": {
                      "startLine": 131,
                      "endLine": 131,
                      "startOffset": 24,
                      "endOffset": 26
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/nist.ts",
                    "textRange": {
                      "startLine": 132,
                      "endLine": 132,
                      "startOffset": 4,
                      "endOffset": 6
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/nist.ts",
                    "textRange": {
                      "startLine": 136,
                      "endLine": 136,
                      "startOffset": 4,
                      "endOffset": 7
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/nist.ts",
                    "textRange": {
                      "startLine": 136,
                      "endLine": 136,
                      "startOffset": 34,
                      "endOffset": 36
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/nist.ts",
                    "textRange": {
                      "startLine": 140,
                      "endLine": 140,
                      "startOffset": 6,
                      "endOffset": 8
                    },
                    "msg": "+2 (incl. 1 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/nist.ts",
                    "textRange": {
                      "startLine": 142,
                      "endLine": 142,
                      "startOffset": 8,
                      "endOffset": 10
                    },
                    "msg": "+3 (incl. 2 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/nist.ts",
                    "textRange": {
                      "startLine": 142,
                      "endLine": 142,
                      "startOffset": 29,
                      "endOffset": 31
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/nist.ts",
                    "textRange": {
                      "startLine": 147,
                      "endLine": 147,
                      "startOffset": 8,
                      "endOffset": 10
                    },
                    "msg": "+3 (incl. 2 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/nist.ts",
                    "textRange": {
                      "startLine": 148,
                      "endLine": 148,
                      "startOffset": 10,
                      "endOffset": 12
                    },
                    "msg": "+4 (incl. 3 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/nist.ts",
                    "textRange": {
                      "startLine": 153,
                      "endLine": 153,
                      "startOffset": 10,
                      "endOffset": 12
                    },
                    "msg": "+4 (incl. 3 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/nist.ts",
                    "textRange": {
                      "startLine": 160,
                      "endLine": 160,
                      "startOffset": 13,
                      "endOffset": 15
                    },
                    "msg": "+1"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/nist.ts",
                    "textRange": {
                      "startLine": 162,
                      "endLine": 162,
                      "startOffset": 8,
                      "endOffset": 10
                    },
                    "msg": "+3 (incl. 2 for nesting)"
                  }
                ]
              },
              {
                "locations": [
                  {
                    "component": "test:libs/inspecjs/src/nist.ts",
                    "textRange": {
                      "startLine": 166,
                      "endLine": 166,
                      "startOffset": 8,
                      "endOffset": 10
                    },
                    "msg": "+3 (incl. 2 for nesting)"
                  }
                ]
              }
            ],
            "status": "OPEN",
            "message": "Refactor this function to reduce its Cognitive Complexity from 28 to the 15 allowed.",
            "effort": "18min",
            "debt": "18min",
            "author": "sheikholeslam@mitre.org",
            "tags": [
              "brain-overload"
            ],
            "creationDate": "2021-06-22T15:34:30+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "   * Avoid repeating this if possible.\n   */\n  canonize(config: CanonizationConfig): string {\n    config = default_partial_config(config);\n    const ss = this.subSpecifiers;\n",
            "summary": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>"
          },
          {
            "key": "AXtAUPrqi8r-LMdMzpgN",
            "rule": "typescript:S4325",
            "severity": "MINOR",
            "component": "test:apps/frontend/src/store/data_store.ts",
            "project": "test",
            "line": 81,
            "hash": "3899fef5cfc73d590869dd79cb4cc7e9",
            "textRange": {
              "startLine": 81,
              "endLine": 83,
              "startOffset": 11,
              "endOffset": 39
            },
            "flows": [],
            "status": "OPEN",
            "message": "This assertion is unnecessary since it does not change the type of the expression.",
            "effort": "1min",
            "debt": "1min",
            "author": "66680985+camdenmoors@users.noreply.github.com",
            "tags": [
              "redundant"
            ],
            "creationDate": "2021-04-06T20:31:54+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "   */\n  get contextualExecutionProfiles(): readonly SourcedContextualizedProfile[] {\n    return this.contextualExecutions.flatMap(\n      (evaluation) => evaluation.contains\n    ) as SourcedContextualizedProfile[];\n  }\n\n  /**",
            "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
          },
          {
            "key": "AXtAUPqii8r-LMdMzpgK",
            "rule": "typescript:S4325",
            "severity": "MINOR",
            "component": "test:apps/frontend/src/components/cards/treemap/Cell.vue",
            "project": "test",
            "line": 84,
            "hash": "132666a69b184b8b50ac1bf8e461a4d6",
            "textRange": {
              "startLine": 84,
              "endLine": 84,
              "startOffset": 7,
              "endOffset": 40
            },
            "flows": [],
            "status": "OPEN",
            "message": "This assertion is unnecessary since it does not change the type of the expression.",
            "effort": "1min",
            "debt": "1min",
            "author": "rbclark@mitre.org",
            "tags": [
              "redundant"
            ],
            "creationDate": "2020-10-14T22:38:18+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "    return (\n      this.is_control && // We are a control\n      (this.node.data as TreemapNodeLeaf).control.data.id ===\n        this.selectedControlId // Our control id matches\n    );\n  }",
            "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
          },
          {
            "key": "AXtAUPnSi8r-LMdMzpf5",
            "rule": "typescript:S4325",
            "severity": "MINOR",
            "component": "test:apps/frontend/src/components/global/upload_tabs/aws/FileList.vue",
            "project": "test",
            "line": 83,
            "hash": "74f2f0146720ebd242fef2ef1727b1cd",
            "textRange": {
              "startLine": 83,
              "endLine": 83,
              "startOffset": 20,
              "endOffset": 29
            },
            "flows": [],
            "status": "OPEN",
            "message": "This assertion is unnecessary since it does not change the type of the expression.",
            "effort": "1min",
            "debt": "1min",
            "author": "rbclark@mitre.org",
            "tags": [
              "redundant"
            ],
            "creationDate": "2020-09-22T22:33:07+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "        InspecIntakeModule.loadText({\n          text: content,\n          filename: file.Key!\n        }).then((uniqueId) => this.$emit('got-files', [uniqueId]));\n      }\n    );",
            "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
          },
          {
            "key": "AXtAUPrPi8r-LMdMzpgM",
            "rule": "typescript:S4138",
            "severity": "MINOR",
            "component": "test:apps/frontend/src/components/generic/ApexLineChart.vue",
            "project": "test",
            "line": 46,
            "hash": "9acd2d681bf613b90597cfd8bcf316e8",
            "textRange": {
              "startLine": 46,
              "endLine": 48,
              "startOffset": 4,
              "endOffset": 5
            },
            "flows": [],
            "status": "OPEN",
            "message": "Expected a `for-of` loop instead of a `for` loop with this simple iteration.",
            "effort": "5min",
            "debt": "5min",
            "author": "51336847+cjdoherty@users.noreply.github.com",
            "tags": [
              "clumsy"
            ],
            "creationDate": "2020-08-26T14:02:11+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "  get label_colors(): string[] {\n    const colors = [];\n    for (let i = 0; i < this.categories.length; i++) {\n      colors.push('#FFFFFF');\n    }\n    return colors;\n  }\n",
            "summary": "<p>If you have an iterable, such as an array, set, or list, your best option for looping through its values is the <code>for of</code> syntax. Use a\ncounter, and …​ well you’ll get the right behavior, but your code just isn’t as clean or clear.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nconst arr = [4, 3, 2, 1];\n\nfor (let i = 0; i &lt; arr.length; i++) {  // Noncompliant\n  console.log(arr[i]);\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nconst arr = [4, 3, 2, 1];\n\nfor (let value of arr) {\n  console.log(value);\n}\n</pre>"
          },
          {
            "key": "AXtAUPsri8r-LMdMzpgQ",
            "rule": "typescript:S4325",
            "severity": "MINOR",
            "component": "test:apps/frontend/src/utilities/delta_util.ts",
            "project": "test",
            "line": 158,
            "hash": "1ff214edad50c0e11919635e4a4da1fe",
            "textRange": {
              "startLine": 158,
              "endLine": 158,
              "startOffset": 10,
              "endOffset": 28
            },
            "flows": [],
            "status": "OPEN",
            "message": "This assertion is unnecessary since it does not change the type of the expression.",
            "effort": "1min",
            "debt": "1min",
            "author": "51336847+cjdoherty@users.noreply.github.com",
            "tags": [
              "redundant"
            ],
            "creationDate": "2020-08-26T14:02:11+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "  for (const prof of ev.contains) {\n    for (const ctrl of prof.contains) {\n      if (ctrl.hdf.segments!.length) {\n        return ctrl.hdf.segments![0].start_time;\n      }\n    }",
            "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
          },
          {
            "key": "AXtAUPssi8r-LMdMzpgR",
            "rule": "typescript:S4325",
            "severity": "MINOR",
            "component": "test:apps/frontend/src/utilities/delta_util.ts",
            "project": "test",
            "line": 159,
            "hash": "a35b4c61d3b8c13f7961feca7a6ec00c",
            "textRange": {
              "startLine": 159,
              "endLine": 159,
              "startOffset": 15,
              "endOffset": 33
            },
            "flows": [],
            "status": "OPEN",
            "message": "This assertion is unnecessary since it does not change the type of the expression.",
            "effort": "1min",
            "debt": "1min",
            "author": "51336847+cjdoherty@users.noreply.github.com",
            "tags": [
              "redundant"
            ],
            "creationDate": "2020-08-26T14:02:11+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "    for (const ctrl of prof.contains) {\n      if (ctrl.hdf.segments!.length) {\n        return ctrl.hdf.segments![0].start_time;\n      }\n    }\n  }",
            "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
          },
          {
            "key": "AXtAUPt6i8r-LMdMzpgU",
            "rule": "typescript:S4144",
            "severity": "MAJOR",
            "component": "test:apps/frontend/tests/unit/Compare.spec.ts",
            "project": "test",
            "line": 46,
            "hash": "a68d822d383917a99ac357fd376a830d",
            "textRange": {
              "startLine": 46,
              "endLine": 46,
              "startOffset": 55,
              "endOffset": 57
            },
            "flows": [
              {
                "locations": [
                  {
                    "component": "test:apps/frontend/tests/unit/Compare.spec.ts",
                    "textRange": {
                      "startLine": 38,
                      "endLine": 38,
                      "startOffset": 55,
                      "endOffset": 57
                    },
                    "msg": "Original implementation"
                  }
                ]
              }
            ],
            "status": "OPEN",
            "message": "Update this function so that its implementation is not identical to the one on line 38.",
            "effort": "15min",
            "debt": "15min",
            "author": "51336847+cjdoherty@users.noreply.github.com",
            "tags": [
              "confusing",
              "duplicate",
              "suspicious"
            ],
            "creationDate": "2020-08-26T14:02:11+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "  });\n\n  it('does not recount same controls with 3 files', () => {\n    loadSample('NGINX With Failing Tests');\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets",
            "summary": "<p>When two functions have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but\nmay be confusing to maintainers. In the latter case, the code should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {  // Noncompliant\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {\n  return calculateCode();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Functions with fewer than 3 lines are ignored.</p>"
          },
          {
            "key": "AXtAUPtAi8r-LMdMzpgT",
            "rule": "typescript:S1135",
            "severity": "INFO",
            "component": "test:apps/frontend/src/utilities/splunk_util.ts",
            "project": "test",
            "line": 341,
            "hash": "4ad01e433047b4d0b74d3a3bd46ae007",
            "textRange": {
              "startLine": 341,
              "endLine": 341,
              "startOffset": 3,
              "endOffset": 7
            },
            "flows": [],
            "status": "OPEN",
            "message": "Complete the task associated to this \"TODO\" comment.",
            "effort": "0min",
            "debt": "0min",
            "author": "51966679+mitriol@users.noreply.github.com",
            "tags": [
              "cwe"
            ],
            "creationDate": "2020-08-26T14:01:58+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": " * HDF heirarchy.\n *\n * TODO: Provide a mechanism for also returning orphaned items\n */\nexport function consolidate_payloads(\n  payloads: UnknownPayload[]",
            "summary": "<p><code>TODO</code> tags are commonly used to mark places where some more code is required, but which the developer wants to implement later.</p>\n<p>Sometimes the developer will not have the time or will simply forget to get back to that tag.</p>\n<p>This rule is meant to track those tags and to ensure that they do not go unnoticed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction doSomething() {\n  // TODO\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/546.html\">MITRE, CWE-546</a> - Suspicious Comment </li>\n</ul>"
          },
          {
            "key": "AXtAUPsYi8r-LMdMzpgP",
            "rule": "typescript:S4325",
            "severity": "MINOR",
            "component": "test:apps/frontend/src/utilities/treemap_util.ts",
            "project": "test",
            "line": 222,
            "hash": "9a78ca4b58afc6956625e79056466a00",
            "textRange": {
              "startLine": 222,
              "endLine": 222,
              "startOffset": 21,
              "endOffset": 33
            },
            "flows": [],
            "status": "OPEN",
            "message": "This assertion is unnecessary since it does not change the type of the expression.",
            "effort": "1min",
            "debt": "1min",
            "author": "51966679+mitriol@users.noreply.github.com",
            "tags": [
              "redundant"
            ],
            "creationDate": "2020-08-26T14:01:23+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "        }\n      } else if (root.parent !== null) {\n        return 1.0 / root.parent!.children.length;\n      }\n      return 0;\n    });",
            "summary": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>"
          },
          {
            "key": "AXtAUPp3i8r-LMdMzpgG",
            "rule": "typescript:S1135",
            "severity": "INFO",
            "component": "test:apps/frontend/src/components/cards/controltable/ControlRowDetails.vue",
            "project": "test",
            "line": 67,
            "hash": "b3b8610f2f997ad05a0cc9fcc8d5aa17",
            "textRange": {
              "startLine": 67,
              "endLine": 67,
              "startOffset": 2,
              "endOffset": 6
            },
            "flows": [],
            "status": "OPEN",
            "message": "Complete the task associated to this \"TODO\" comment.",
            "effort": "0min",
            "debt": "0min",
            "author": "lippold@gmail.com",
            "tags": [
              "cwe"
            ],
            "creationDate": "2020-08-26T14:01:02+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "import {ContextualizedControl} from 'inspecjs';\nimport _ from 'lodash';\n//TODO: add line numbers\nimport 'prismjs';\nimport 'prismjs/components/prism-makefile.js';\nimport 'prismjs/components/prism-ruby.js';",
            "summary": "<p><code>TODO</code> tags are commonly used to mark places where some more code is required, but which the developer wants to implement later.</p>\n<p>Sometimes the developer will not have the time or will simply forget to get back to that tag.</p>\n<p>This rule is meant to track those tags and to ensure that they do not go unnoticed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction doSomething() {\n  // TODO\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/546.html\">MITRE, CWE-546</a> - Suspicious Comment </li>\n</ul>"
          },
          {
            "key": "AXtAUPuhi8r-LMdMzpgV",
            "rule": "typescript:S4144",
            "severity": "MAJOR",
            "component": "test:apps/backend/src/evaluations/evaluations.service.spec.ts",
            "project": "test",
            "line": 293,
            "hash": "4fb693e4f6656b1e3dbad68b47593776",
            "textRange": {
              "startLine": 293,
              "endLine": 293,
              "startOffset": 76,
              "endOffset": 78
            },
            "flows": [
              {
                "locations": [
                  {
                    "component": "test:apps/backend/src/evaluations/evaluations.service.spec.ts",
                    "textRange": {
                      "startLine": 141,
                      "endLine": 141,
                      "startOffset": 73,
                      "endOffset": 75
                    },
                    "msg": "Original implementation"
                  }
                ]
              }
            ],
            "status": "OPEN",
            "message": "Update this function so that its implementation is not identical to the one on line 141.",
            "effort": "15min",
            "debt": "15min",
            "author": "kfagan@mitre.org",
            "tags": [
              "confusing",
              "duplicate",
              "suspicious"
            ],
            "creationDate": "2020-08-19T20:43:00+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "    });\n\n    it('should throw an error when the evaluation does not exist', async () => {\n      expect.assertions(1);\n      await expect(evaluationsService.findById('-1')).rejects.toThrow(\n        NotFoundException",
            "summary": "<p>When two functions have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but\nmay be confusing to maintainers. In the latter case, the code should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {  // Noncompliant\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {\n  return calculateCode();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Functions with fewer than 3 lines are ignored.</p>"
          },
          {
            "key": "AXtAUPwji8r-LMdMzpga",
            "rule": "typescript:S1848",
            "severity": "MAJOR",
            "component": "test:apps/backend/src/config/config.service.spec.ts",
            "project": "test",
            "line": 33,
            "hash": "3cf63da6002c83ff5e01af3ea9a377fe",
            "textRange": {
              "startLine": 33,
              "endLine": 33,
              "startOffset": 6,
              "endOffset": 23
            },
            "flows": [],
            "status": "OPEN",
            "message": "Either remove this useless object instantiation of \"ConfigService\" or use it.",
            "effort": "5min",
            "debt": "5min",
            "author": "60075714+samuelsunvold@users.noreply.github.com",
            "tags": [],
            "creationDate": "2020-07-01T16:16:10+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "BUG",
            "scope": "MAIN",
            "snip": "      const consoleSpy = jest.spyOn(console, 'log');\n      // Used to make sure logs are outputted\n      new ConfigService();\n      expect(consoleSpy).toHaveBeenCalledWith(\n        'Unable to read configuration file `.env`!'\n      );",
            "summary": "<p>There is no good reason to create a new object to not do anything with it. Most of the time, this is due to a missing piece of code and so could\nlead to an unexpected behavior in production.</p>\n<p>If it was done on purpose because the constructor has side-effects, then that side-effect code should be moved into a separate method and called\ndirectly.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nnew MyConstructor(); // Non-Compliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar something = new MyConstructor();  // Compliant\n</pre>\n<h2>Exceptions</h2>\n<p>Immediately dropped new objects inside <code>try</code>-statements are ignored.</p>\n<pre>\ntry {\n  new MyConstructor();\n} catch (e) {\n  /* ... */\n}\n</pre>"
          },
          {
            "key": "AXtAUPwFi8r-LMdMzpgY",
            "rule": "typescript:S4144",
            "severity": "MAJOR",
            "component": "test:apps/backend/src/pipes/password-complexity.pipe.spec.ts",
            "project": "test",
            "line": 141,
            "hash": "7bdcb56ce070e980805d0246390b76f1",
            "textRange": {
              "startLine": 141,
              "endLine": 141,
              "startOffset": 16,
              "endOffset": 18
            },
            "flows": [
              {
                "locations": [
                  {
                    "component": "test:apps/backend/src/pipes/password-complexity.pipe.spec.ts",
                    "textRange": {
                      "startLine": 135,
                      "endLine": 135,
                      "startOffset": 16,
                      "endOffset": 18
                    },
                    "msg": "Original implementation"
                  }
                ]
              }
            ],
            "status": "OPEN",
            "message": "Update this function so that its implementation is not identical to the one on line 135.",
            "effort": "15min",
            "debt": "15min",
            "author": "kfagan@mitre.org",
            "tags": [
              "confusing",
              "duplicate",
              "suspicious"
            ],
            "creationDate": "2020-07-01T13:38:16+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "        )\n      ).toThrowError(BadRequestException);\n      expect(() =>\n        passwordComplexityPipe.transform(\n          CREATE_USER_DTO_TEST_OBJ_WITH_MISSING_PASSWORD_FIELD,\n          metaData",
            "summary": "<p>When two functions have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but\nmay be confusing to maintainers. In the latter case, the code should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {  // Noncompliant\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {\n  return calculateCode();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Functions with fewer than 3 lines are ignored.</p>"
          },
          {
            "key": "AXtAUPwFi8r-LMdMzpgZ",
            "rule": "typescript:S4144",
            "severity": "MAJOR",
            "component": "test:apps/backend/src/pipes/password-complexity.pipe.spec.ts",
            "project": "test",
            "line": 161,
            "hash": "7bdcb56ce070e980805d0246390b76f1",
            "textRange": {
              "startLine": 161,
              "endLine": 161,
              "startOffset": 16,
              "endOffset": 18
            },
            "flows": [
              {
                "locations": [
                  {
                    "component": "test:apps/backend/src/pipes/password-complexity.pipe.spec.ts",
                    "textRange": {
                      "startLine": 155,
                      "endLine": 155,
                      "startOffset": 16,
                      "endOffset": 18
                    },
                    "msg": "Original implementation"
                  }
                ]
              }
            ],
            "status": "OPEN",
            "message": "Update this function so that its implementation is not identical to the one on line 155.",
            "effort": "15min",
            "debt": "15min",
            "author": "kfagan@mitre.org",
            "tags": [
              "confusing",
              "duplicate",
              "suspicious"
            ],
            "creationDate": "2020-07-01T13:38:16+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "        )\n      ).toThrowError(BadRequestException);\n      expect(() =>\n        passwordComplexityPipe.transform(\n          UPDATE_USER_DTO_TEST_WITHOUT_PASSWORD,\n          metaData",
            "summary": "<p>When two functions have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but\nmay be confusing to maintainers. In the latter case, the code should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {  // Noncompliant\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {\n  return calculateCode();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Functions with fewer than 3 lines are ignored.</p>"
          },
          {
            "key": "AXtAUPv_i8r-LMdMzpgX",
            "rule": "typescript:S4144",
            "severity": "MAJOR",
            "component": "test:apps/backend/src/pipes/passwords-match.pipe.spec.ts",
            "project": "test",
            "line": 57,
            "hash": "7bdcb56ce070e980805d0246390b76f1",
            "textRange": {
              "startLine": 57,
              "endLine": 57,
              "startOffset": 16,
              "endOffset": 18
            },
            "flows": [
              {
                "locations": [
                  {
                    "component": "test:apps/backend/src/pipes/passwords-match.pipe.spec.ts",
                    "textRange": {
                      "startLine": 51,
                      "endLine": 51,
                      "startOffset": 16,
                      "endOffset": 18
                    },
                    "msg": "Original implementation"
                  }
                ]
              }
            ],
            "status": "OPEN",
            "message": "Update this function so that its implementation is not identical to the one on line 51.",
            "effort": "15min",
            "debt": "15min",
            "author": "kfagan@mitre.org",
            "tags": [
              "confusing",
              "duplicate",
              "suspicious"
            ],
            "creationDate": "2020-07-01T13:38:16+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "        )\n      ).toThrowError(BadRequestException);\n      expect(() =>\n        passwordsMatchPipe.transform(\n          CREATE_USER_DTO_TEST_OBJ_WITH_UNMATCHING_PASSWORDS,\n          metaData",
            "summary": "<p>When two functions have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but\nmay be confusing to maintainers. In the latter case, the code should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {  // Noncompliant\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {\n  return calculateCode();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Functions with fewer than 3 lines are ignored.</p>"
          },
          {
            "key": "AXtAUP0Hi8r-LMdMzph6",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
            "project": "test",
            "line": 229,
            "hash": "b981ea8d10d148243a1b3b9ee8a0c3a4",
            "textRange": {
              "startLine": 229,
              "endLine": 229,
              "startOffset": 32,
              "endOffset": 43
            },
            "flows": [],
            "status": "OPEN",
            "message": "'typ' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "jchenry@mitre.org",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2019-07-25T22:13:43+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUP0Hi8r-LMdMzph7",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
            "project": "test",
            "line": 229,
            "hash": "b981ea8d10d148243a1b3b9ee8a0c3a4",
            "textRange": {
              "startLine": 229,
              "endLine": 229,
              "startOffset": 45,
              "endOffset": 53
            },
            "flows": [],
            "status": "OPEN",
            "message": "'val' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "jchenry@mitre.org",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2019-07-25T22:13:43+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUP0Hi8r-LMdMzph8",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
            "project": "test",
            "line": 234,
            "hash": "c0531a3bd0eb2b95bf1124e7638d6e3d",
            "textRange": {
              "startLine": 234,
              "endLine": 234,
              "startOffset": 41,
              "endOffset": 49
            },
            "flows": [],
            "status": "OPEN",
            "message": "'val' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "jchenry@mitre.org",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2019-07-25T22:13:43+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "    }\n\n    function transformUnion(typs: any[], val: any): any {\n        // val must validate against one typ in typs\n        const l = typs.length;\n        for (let i = 0; i < l; i++) {",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUP0Hi8r-LMdMzph-",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
            "project": "test",
            "line": 246,
            "hash": "f326b05dbcd91d3c9c8640bc74bcce26",
            "textRange": {
              "startLine": 246,
              "endLine": 246,
              "startOffset": 44,
              "endOffset": 52
            },
            "flows": [],
            "status": "OPEN",
            "message": "'val' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "jchenry@mitre.org",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2019-07-25T22:13:43+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "    }\n\n    function transformEnum(cases: string[], val: any): any {\n        if (cases.indexOf(val) !== -1) return val;\n        return invalidValue(cases, val);\n    }",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUP0Hi8r-LMdMzph_",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
            "project": "test",
            "line": 251,
            "hash": "1c3e797b8d85c13b868b149ec110baa3",
            "textRange": {
              "startLine": 251,
              "endLine": 251,
              "startOffset": 28,
              "endOffset": 36
            },
            "flows": [],
            "status": "OPEN",
            "message": "'typ' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "jchenry@mitre.org",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2019-07-25T22:13:43+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUP0Hi8r-LMdMzpiA",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
            "project": "test",
            "line": 251,
            "hash": "1c3e797b8d85c13b868b149ec110baa3",
            "textRange": {
              "startLine": 251,
              "endLine": 251,
              "startOffset": 38,
              "endOffset": 46
            },
            "flows": [],
            "status": "OPEN",
            "message": "'val' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "jchenry@mitre.org",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2019-07-25T22:13:43+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUPz9i8r-LMdMzphs",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
            "project": "test",
            "line": 91,
            "hash": "b981ea8d10d148243a1b3b9ee8a0c3a4",
            "textRange": {
              "startLine": 91,
              "endLine": 91,
              "startOffset": 32,
              "endOffset": 43
            },
            "flows": [],
            "status": "OPEN",
            "message": "'typ' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "jchenry@mitre.org",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2019-07-25T22:13:43+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUPz9i8r-LMdMzpht",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
            "project": "test",
            "line": 91,
            "hash": "b981ea8d10d148243a1b3b9ee8a0c3a4",
            "textRange": {
              "startLine": 91,
              "endLine": 91,
              "startOffset": 45,
              "endOffset": 53
            },
            "flows": [],
            "status": "OPEN",
            "message": "'val' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "jchenry@mitre.org",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2019-07-25T22:13:43+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUPz9i8r-LMdMzphu",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
            "project": "test",
            "line": 96,
            "hash": "c0531a3bd0eb2b95bf1124e7638d6e3d",
            "textRange": {
              "startLine": 96,
              "endLine": 96,
              "startOffset": 41,
              "endOffset": 49
            },
            "flows": [],
            "status": "OPEN",
            "message": "'val' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "jchenry@mitre.org",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2019-07-25T22:13:43+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "    }\n\n    function transformUnion(typs: any[], val: any): any {\n        // val must validate against one typ in typs\n        const l = typs.length;\n        for (let i = 0; i < l; i++) {",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUPz9i8r-LMdMzphw",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
            "project": "test",
            "line": 108,
            "hash": "f326b05dbcd91d3c9c8640bc74bcce26",
            "textRange": {
              "startLine": 108,
              "endLine": 108,
              "startOffset": 44,
              "endOffset": 52
            },
            "flows": [],
            "status": "OPEN",
            "message": "'val' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "jchenry@mitre.org",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2019-07-25T22:13:43+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "    }\n\n    function transformEnum(cases: string[], val: any): any {\n        if (cases.indexOf(val) !== -1) return val;\n        return invalidValue(cases, val);\n    }",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUPz9i8r-LMdMzphx",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
            "project": "test",
            "line": 113,
            "hash": "1c3e797b8d85c13b868b149ec110baa3",
            "textRange": {
              "startLine": 113,
              "endLine": 113,
              "startOffset": 28,
              "endOffset": 36
            },
            "flows": [],
            "status": "OPEN",
            "message": "'typ' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "jchenry@mitre.org",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2019-07-25T22:13:43+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUPz9i8r-LMdMzphy",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
            "project": "test",
            "line": 113,
            "hash": "1c3e797b8d85c13b868b149ec110baa3",
            "textRange": {
              "startLine": 113,
              "endLine": 113,
              "startOffset": 38,
              "endOffset": 46
            },
            "flows": [],
            "status": "OPEN",
            "message": "'val' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "jchenry@mitre.org",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2019-07-25T22:13:43+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUPzsi8r-LMdMzphe",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
            "project": "test",
            "line": 148,
            "hash": "b981ea8d10d148243a1b3b9ee8a0c3a4",
            "textRange": {
              "startLine": 148,
              "endLine": 148,
              "startOffset": 32,
              "endOffset": 43
            },
            "flows": [],
            "status": "OPEN",
            "message": "'typ' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "jchenry@mitre.org",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2019-07-25T22:13:43+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUPzsi8r-LMdMzphf",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
            "project": "test",
            "line": 148,
            "hash": "b981ea8d10d148243a1b3b9ee8a0c3a4",
            "textRange": {
              "startLine": 148,
              "endLine": 148,
              "startOffset": 45,
              "endOffset": 53
            },
            "flows": [],
            "status": "OPEN",
            "message": "'val' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "jchenry@mitre.org",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2019-07-25T22:13:43+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUPzsi8r-LMdMzphg",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
            "project": "test",
            "line": 153,
            "hash": "c0531a3bd0eb2b95bf1124e7638d6e3d",
            "textRange": {
              "startLine": 153,
              "endLine": 153,
              "startOffset": 41,
              "endOffset": 49
            },
            "flows": [],
            "status": "OPEN",
            "message": "'val' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "jchenry@mitre.org",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2019-07-25T22:13:43+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "    }\n\n    function transformUnion(typs: any[], val: any): any {\n        // val must validate against one typ in typs\n        const l = typs.length;\n        for (let i = 0; i < l; i++) {",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUPzsi8r-LMdMzphi",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
            "project": "test",
            "line": 165,
            "hash": "f326b05dbcd91d3c9c8640bc74bcce26",
            "textRange": {
              "startLine": 165,
              "endLine": 165,
              "startOffset": 44,
              "endOffset": 52
            },
            "flows": [],
            "status": "OPEN",
            "message": "'val' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "jchenry@mitre.org",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2019-07-25T22:13:43+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "    }\n\n    function transformEnum(cases: string[], val: any): any {\n        if (cases.indexOf(val) !== -1) return val;\n        return invalidValue(cases, val);\n    }",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUPzsi8r-LMdMzphj",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
            "project": "test",
            "line": 170,
            "hash": "1c3e797b8d85c13b868b149ec110baa3",
            "textRange": {
              "startLine": 170,
              "endLine": 170,
              "startOffset": 28,
              "endOffset": 36
            },
            "flows": [],
            "status": "OPEN",
            "message": "'typ' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "jchenry@mitre.org",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2019-07-25T22:13:43+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          },
          {
            "key": "AXtAUPzsi8r-LMdMzphk",
            "rule": "typescript:S1117",
            "severity": "MAJOR",
            "component": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
            "project": "test",
            "line": 170,
            "hash": "1c3e797b8d85c13b868b149ec110baa3",
            "textRange": {
              "startLine": 170,
              "endLine": 170,
              "startOffset": 38,
              "endOffset": 46
            },
            "flows": [],
            "status": "OPEN",
            "message": "'val' is already declared in the upper scope.",
            "effort": "5min",
            "debt": "5min",
            "author": "jchenry@mitre.org",
            "tags": [
              "pitfall",
              "suspicious"
            ],
            "creationDate": "2019-07-25T22:13:43+0000",
            "updateDate": "2021-08-13T16:18:45+0000",
            "type": "CODE_SMELL",
            "scope": "MAIN",
            "snip": "    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));",
            "summary": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>"
          }
        ],
        "components": [
          {
            "key": "test:apps/frontend/src/components/cards/controltable/ControlRowDetails.vue",
            "enabled": true,
            "qualifier": "FIL",
            "name": "ControlRowDetails.vue",
            "longName": "apps/frontend/src/components/cards/controltable/ControlRowDetails.vue",
            "path": "apps/frontend/src/components/cards/controltable/ControlRowDetails.vue"
          },
          {
            "key": "test:apps/backend/src/pipes/passwords-match.pipe.spec.ts",
            "enabled": true,
            "qualifier": "FIL",
            "name": "passwords-match.pipe.spec.ts",
            "longName": "apps/backend/src/pipes/passwords-match.pipe.spec.ts",
            "path": "apps/backend/src/pipes/passwords-match.pipe.spec.ts"
          },
          {
            "key": "test:apps/backend/src/pipes/password-complexity.pipe.spec.ts",
            "enabled": true,
            "qualifier": "FIL",
            "name": "password-complexity.pipe.spec.ts",
            "longName": "apps/backend/src/pipes/password-complexity.pipe.spec.ts",
            "path": "apps/backend/src/pipes/password-complexity.pipe.spec.ts"
          },
          {
            "key": "test:apps/frontend/src/components/cards/controltable/ControlTable.vue",
            "enabled": true,
            "qualifier": "FIL",
            "name": "ControlTable.vue",
            "longName": "apps/frontend/src/components/cards/controltable/ControlTable.vue",
            "path": "apps/frontend/src/components/cards/controltable/ControlTable.vue"
          },
          {
            "key": "test:libs/hdf-converters/src/base-converter.ts",
            "enabled": true,
            "qualifier": "FIL",
            "name": "base-converter.ts",
            "longName": "libs/hdf-converters/src/base-converter.ts",
            "path": "libs/hdf-converters/src/base-converter.ts"
          },
          {
            "key": "test:apps/frontend/src/utilities/treemap_util.ts",
            "enabled": true,
            "qualifier": "FIL",
            "name": "treemap_util.ts",
            "longName": "apps/frontend/src/utilities/treemap_util.ts",
            "path": "apps/frontend/src/utilities/treemap_util.ts"
          },
          {
            "key": "test:apps/frontend/src/store/data_store.ts",
            "enabled": true,
            "qualifier": "FIL",
            "name": "data_store.ts",
            "longName": "apps/frontend/src/store/data_store.ts",
            "path": "apps/frontend/src/store/data_store.ts"
          },
          {
            "key": "test:apps/frontend/src/store/data_filters.ts",
            "enabled": true,
            "qualifier": "FIL",
            "name": "data_filters.ts",
            "longName": "apps/frontend/src/store/data_filters.ts",
            "path": "apps/frontend/src/store/data_filters.ts"
          },
          {
            "key": "test:apps/backend/src/evaluations/evaluations.service.spec.ts",
            "enabled": true,
            "qualifier": "FIL",
            "name": "evaluations.service.spec.ts",
            "longName": "apps/backend/src/evaluations/evaluations.service.spec.ts",
            "path": "apps/backend/src/evaluations/evaluations.service.spec.ts"
          },
          {
            "key": "test:apps/frontend/src/components/global/upload_tabs/aws/S3Reader.vue",
            "enabled": true,
            "qualifier": "FIL",
            "name": "S3Reader.vue",
            "longName": "apps/frontend/src/components/global/upload_tabs/aws/S3Reader.vue",
            "path": "apps/frontend/src/components/global/upload_tabs/aws/S3Reader.vue"
          },
          {
            "key": "test:apps/frontend/src/components/global/upload_tabs/aws/FileList.vue",
            "enabled": true,
            "qualifier": "FIL",
            "name": "FileList.vue",
            "longName": "apps/frontend/src/components/global/upload_tabs/aws/FileList.vue",
            "path": "apps/frontend/src/components/global/upload_tabs/aws/FileList.vue"
          },
          {
            "key": "test:apps/frontend/src/components/global/upload_tabs/aws/AuthStepMFA.vue",
            "enabled": true,
            "qualifier": "FIL",
            "name": "AuthStepMFA.vue",
            "longName": "apps/frontend/src/components/global/upload_tabs/aws/AuthStepMFA.vue",
            "path": "apps/frontend/src/components/global/upload_tabs/aws/AuthStepMFA.vue"
          },
          {
            "key": "test:apps/frontend/src/components/global/upload_tabs/aws/AuthStepBasic.vue",
            "enabled": true,
            "qualifier": "FIL",
            "name": "AuthStepBasic.vue",
            "longName": "apps/frontend/src/components/global/upload_tabs/aws/AuthStepBasic.vue",
            "path": "apps/frontend/src/components/global/upload_tabs/aws/AuthStepBasic.vue"
          },
          {
            "key": "test:apps/frontend/src/utilities/delta_util.ts",
            "enabled": true,
            "qualifier": "FIL",
            "name": "delta_util.ts",
            "longName": "apps/frontend/src/utilities/delta_util.ts",
            "path": "apps/frontend/src/utilities/delta_util.ts"
          },
          {
            "key": "test:apps/frontend/src/components/cards/treemap/Treemap.vue",
            "enabled": true,
            "qualifier": "FIL",
            "name": "Treemap.vue",
            "longName": "apps/frontend/src/components/cards/treemap/Treemap.vue",
            "path": "apps/frontend/src/components/cards/treemap/Treemap.vue"
          },
          {
            "key": "test:apps/frontend/tests/unit/Compare.spec.ts",
            "enabled": true,
            "qualifier": "FIL",
            "name": "Compare.spec.ts",
            "longName": "apps/frontend/tests/unit/Compare.spec.ts",
            "path": "apps/frontend/tests/unit/Compare.spec.ts"
          },
          {
            "key": "test:apps/frontend/src/utilities/format_util.ts",
            "enabled": true,
            "qualifier": "FIL",
            "name": "format_util.ts",
            "longName": "apps/frontend/src/utilities/format_util.ts",
            "path": "apps/frontend/src/utilities/format_util.ts"
          },
          {
            "key": "test:apps/frontend/src/utilities/splunk_util.ts",
            "enabled": true,
            "qualifier": "FIL",
            "name": "splunk_util.ts",
            "longName": "apps/frontend/src/utilities/splunk_util.ts",
            "path": "apps/frontend/src/utilities/splunk_util.ts"
          },
          {
            "key": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
            "enabled": true,
            "qualifier": "FIL",
            "name": "exec-jsonmin.ts",
            "longName": "libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts",
            "path": "libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts"
          },
          {
            "key": "test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
            "enabled": true,
            "qualifier": "FIL",
            "name": "exec-json.ts",
            "longName": "libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts",
            "path": "libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts"
          },
          {
            "key": "test:apps/frontend/src/components/cards/treemap/Cell.vue",
            "enabled": true,
            "qualifier": "FIL",
            "name": "Cell.vue",
            "longName": "apps/frontend/src/components/cards/treemap/Cell.vue",
            "path": "apps/frontend/src/components/cards/treemap/Cell.vue"
          },
          {
            "key": "test:libs/inspecjs/src/context.ts",
            "enabled": true,
            "qualifier": "FIL",
            "name": "context.ts",
            "longName": "libs/inspecjs/src/context.ts",
            "path": "libs/inspecjs/src/context.ts"
          },
          {
            "key": "test:apps/frontend/src/components/generic/ApexLineChart.vue",
            "enabled": true,
            "qualifier": "FIL",
            "name": "ApexLineChart.vue",
            "longName": "apps/frontend/src/components/generic/ApexLineChart.vue",
            "path": "apps/frontend/src/components/generic/ApexLineChart.vue"
          },
          {
            "key": "test:libs/inspecjs/src/nist.ts",
            "enabled": true,
            "qualifier": "FIL",
            "name": "nist.ts",
            "longName": "libs/inspecjs/src/nist.ts",
            "path": "libs/inspecjs/src/nist.ts"
          },
          {
            "key": "test",
            "enabled": true,
            "qualifier": "TRK",
            "name": "test",
            "longName": "test"
          },
          {
            "key": "test:apps/backend/src/config/config.service.spec.ts",
            "enabled": true,
            "qualifier": "FIL",
            "name": "config.service.spec.ts",
            "longName": "apps/backend/src/config/config.service.spec.ts",
            "path": "apps/backend/src/config/config.service.spec.ts"
          },
          {
            "key": "test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
            "enabled": true,
            "qualifier": "FIL",
            "name": "profile-json.ts",
            "longName": "libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts",
            "path": "libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts"
          }
        ],
        "facets": []
    },
    "/api/sources/raw?key=test:apps/frontend/src/components/cards/controltable/ControlTable.vue": "<template>\n  <v-container fluid class=\"font-weight-bold\">\n    <div\n      ref=\"controlTableTitle\"\n      :class=\"\n        $vuetify.breakpoint.smAndDown\n          ? 'control-table-title'\n          : 'pinned-header control-table-title'\n      \"\n      :style=\"controlTableTitleStyle\"\n    >\n      <!-- Toolbar -->\n      <v-row v-resize=\"onResize\">\n        <v-row>\n          <v-col cols=\"12\" md=\"3\" class=\"pb-0\">\n            <v-card-title class=\"pb-0\">Results View Data</v-card-title>\n          </v-col>\n          <v-spacer />\n          <v-col cols=\"3\" md=\"auto\" class=\"text-right pl-6 pb-0\">\n            <v-switch\n              v-model=\"displayUnviewedControls\"\n              label=\"Show Only Unviewed\"\n            />\n          </v-col>\n          <v-col cols=\"3\" md=\"auto\" class=\"text-right pb-0\">\n            <v-switch v-model=\"syncTabs\" label=\"Sync Tabs\" />\n          </v-col>\n          <v-col cols=\"3\" md=\"auto\" class=\"text-right pb-0\">\n            <v-switch\n              v-model=\"singleExpand\"\n              label=\"Single Expand\"\n              @change=\"handleToggleSingleExpand\"\n            />\n          </v-col>\n          <v-col cols=\"3\" md=\"auto\" class=\"text-right pb-0\">\n            <v-switch v-model=\"expandAll\" label=\"Expand All\" class=\"mr-5\" />\n          </v-col>\n        </v-row>\n      </v-row>\n\n      <!-- Header. This should mirror the structure of ControlRowHeader -->\n      <ResponsiveRowSwitch>\n        <template #status>\n          <ColumnHeader\n            text=\"Status\"\n            :sort=\"sortStatus\"\n            @input=\"set_sort('status', $event)\"\n          />\n        </template>\n\n        <template #set>\n          <ColumnHeader\n            text=\"Result Set\"\n            :sort=\"sortSet\"\n            @input=\"set_sort('set', $event)\"\n          />\n        </template>\n\n        <template #id>\n          <ColumnHeader\n            text=\"ID\"\n            :sort=\"sortId\"\n            @input=\"set_sort('id', $event)\"\n          />\n        </template>\n\n        <template #severity>\n          <ColumnHeader\n            :text=\"showImpact ? 'Impact' : 'Severity'\"\n            :sort=\"sortSeverity\"\n            @input=\"set_sort('severity', $event)\"\n          />\n        </template>\n\n        <template #title>\n          <ColumnHeader text=\"Title\" sort=\"disabled\" />\n        </template>\n\n        <template #tags>\n          <ColumnHeader text=\"800-53 Controls & CCIs\" sort=\"disabled\" />\n        </template>\n\n        <template #runTime>\n          <ColumnHeader\n            text=\"Run Time\"\n            :sort=\"sortRunTime\"\n            @input=\"set_sort('runTime', $event)\"\n          />\n        </template>\n\n        <template #viewed class=\"my-2 px-1\">\n          <ColumnHeader\n            text=\"Controls Viewed\"\n            sort=\"disabled\"\n            :viewed-header=\"true\"\n            :number-of-viewed-controls=\"viewedControlIds.length\"\n            :number-of-all-controls=\"raw_items.length\"\n          />\n        </template>\n      </ResponsiveRowSwitch>\n    </div>\n\n    <!-- Body -->\n    <v-lazy\n      v-for=\"item in items\"\n      :key=\"item.key\"\n      min-height=\"50\"\n      transition=\"fade-transition\"\n    >\n      <div :id=\"striptoChars(item.key)\">\n        <ControlRowHeader\n          :class=\"$vuetify.breakpoint.smAndDown ? '' : 'pinned-header'\"\n          :style=\"controlRowPinOffset\"\n          :control=\"item.control\"\n          :expanded=\"expanded.includes(item.key)\"\n          :show-impact=\"showImpact\"\n          :viewed-controls=\"viewedControlIds\"\n          @toggle=\"toggle(item.key)\"\n          @control-viewed=\"toggleControlViewed\"\n        />\n        <ControlRowDetails\n          v-if=\"expanded.includes(item.key)\"\n          :control=\"item.control\"\n          :tab=\"syncTabs ? syncTab : undefined\"\n          @update:tab=\"updateTab\"\n        />\n      </div>\n    </v-lazy>\n  </v-container>\n</template>\n\n<script lang=\"ts\">\nimport ControlRowDetails from '@/components/cards/controltable/ControlRowDetails.vue';\nimport ControlRowHeader, {\n  getControlRunTime\n} from '@/components/cards/controltable/ControlRowHeader.vue';\nimport ResponsiveRowSwitch from '@/components/cards/controltable/ResponsiveRowSwitch.vue';\nimport ColumnHeader, {Sort} from '@/components/generic/ColumnHeader.vue';\nimport {Filter, FilteredDataModule} from '@/store/data_filters';\nimport {HeightsModule} from '@/store/heights';\nimport {control_unique_key} from '@/utilities/format_util';\nimport {ContextualizedControl} from 'inspecjs';\nimport _ from 'lodash';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\nimport {Prop, Ref} from 'vue-property-decorator';\n\n// Tracks the visibility of an HDF control\ninterface ListElt {\n  // A unique id to be used as a key.\n  key: string;\n\n  filename: string;\n\n  // Computed values for status and severity \"value\", for sorting\n  status_val: number;\n  severity_val: number;\n\n  control: ContextualizedControl;\n}\n\n@Component({\n  components: {\n    ControlRowHeader,\n    ControlRowDetails,\n    ColumnHeader,\n    ResponsiveRowSwitch\n  }\n})\nexport default class ControlTable extends Vue {\n  @Ref('controlTableTitle') readonly controlTableTitle!: Element;\n  @Prop({type: Object, required: true}) readonly filter!: Filter;\n  @Prop({type: Boolean, required: true}) readonly showImpact!: boolean;\n\n  // Whether to allow multiple expansions\n  singleExpand = true;\n\n  // If the currently selected tab should sync\n  syncTabs = false;\n  syncTab = 'tab-test';\n\n  // List of currently expanded options. If unique id is in here, it is expanded\n  expanded: Array<string> = [];\n\n  // Sorts\n  sortId: Sort = 'none';\n  sortStatus: Sort = 'none';\n  sortSet: Sort = 'none';\n  sortSeverity: Sort = 'none';\n  sortRunTime: Sort = 'none';\n\n  // Used for viewed/unviewed controls.\n  viewedControlIds: string[] = [];\n  displayUnviewedControls = true;\n\n  toggleControlViewed(control: ContextualizedControl) {\n    const alreadyViewed = this.viewedControlIds.indexOf(control.data.id);\n    // If the control hasn't been marked as viewed yet, mark it as viewed.\n    if (alreadyViewed === -1) {\n      this.viewedControlIds.push(control.data.id);\n    }\n    // Else, remove it from the view controls array.\n    else {\n      this.viewedControlIds.splice(alreadyViewed, 1);\n    }\n  }\n\n  mounted() {\n    this.onResize();\n  }\n\n  onResize() {\n    // Allow the page to settle before checking the controlTableHeader height\n    // (this is what $nextTick is supposed to do but it's firing too quickly)\n    setTimeout(() => {\n      HeightsModule.setControlTableHeaderHeight(\n        this.controlTableTitle?.clientHeight\n      );\n    }, 2000);\n  }\n\n  /** Callback to handle setting a new sort */\n  set_sort(column: string, newSort: Sort) {\n    this.sortId = 'none';\n    this.sortSet = 'none';\n    this.sortStatus = 'none';\n    this.sortSeverity = 'none';\n    this.sortRunTime = 'none';\n    switch (column) {\n      case 'id':\n        this.sortId = newSort;\n        break;\n      case 'status':\n        this.sortStatus = newSort;\n        break;\n      case 'set':\n        this.sortSet = newSort;\n        break;\n      case 'severity':\n        this.sortSeverity = newSort;\n        break;\n      case 'runTime':\n        this.sortRunTime = newSort;\n        break;\n    }\n  }\n\n  get expandAll() {\n    return this.expanded.length === this.items.length;\n  }\n\n  set expandAll(value: boolean) {\n    if (value) {\n      this.singleExpand = false;\n      this.expanded = this.items.map((items) => items.key);\n    } else {\n      this.expanded = [];\n    }\n  }\n\n  get controlTableTitleStyle() {\n    return {top: `${HeightsModule.topbarHeight}px`};\n  }\n\n  get controlRowPinOffset() {\n    // There is ~10px of padding being added which makes the ControlRowHeader look out of place\n    return {top: `${this.topOfPage - 10}px`};\n  }\n\n  // The top of the page, relative to the topbar and the title bar\n  get topOfPage() {\n    return HeightsModule.topbarHeight + HeightsModule.controlTableHeaderHeight;\n  }\n\n  /** Closes all open controls when single-expand is re-enabled */\n  async handleToggleSingleExpand(singleExpand: boolean): Promise<void> {\n    if (singleExpand) {\n      this.expandAll = false;\n    }\n  }\n\n  async updateTab(tab: string) {\n    this.syncTab = tab;\n  }\n\n  /** Toggles the given expansion of a control details panel */\n  toggle(key: string) {\n    if (this.singleExpand) {\n      // Check if key already there\n      const had = this.expanded.includes(key);\n\n      // Clear\n      this.expanded = [];\n\n      // If key is new, add it\n      if (!had) {\n        this.expanded.push(key);\n        this.jump_to_key(key);\n      }\n    } else {\n      // Add or remove it from the set, as appropriate. Shortcut this by only adding if delete fails\n      const i = this.expanded.indexOf(key);\n      if (i < 0) {\n        this.expanded.push(key);\n        this.jump_to_key(key);\n      } else {\n        this.expanded.splice(i, 1);\n      }\n    }\n  }\n\n  jump_to_key(key: string) {\n    if (!this.$vuetify.breakpoint.smAndDown) {\n      this.$nextTick(() => {\n        this.$vuetify.goTo(`#${this.striptoChars(key)}`, {\n          offset: this.topOfPage,\n          duration: 300\n        });\n      });\n    }\n  }\n\n  striptoChars(key: string) {\n    return key.replace(/[^a-z0-9]/gi, '');\n  }\n\n  /** Return items as key, value pairs */\n  get raw_items(): ListElt[] {\n    return FilteredDataModule.controls(this.filter).map((d) => {\n      const key = control_unique_key(d);\n\n      // File, hdf wrapper\n      return {\n        key,\n        control: d,\n        status_val: [\n          'Passed',\n          'Not Applicable',\n          'No Data',\n          'Not Reviewed',\n          'Profile Error',\n          'Failed'\n        ].indexOf(d.root.hdf.status),\n        severity_val: ['none', 'low', 'medium', 'high', 'critical'].indexOf(\n          d.root.hdf.severity\n        ),\n        filename: _.get(d, 'sourcedFrom.sourcedFrom.from_file.filename')\n      };\n    });\n  }\n\n  /** Return items sorted and filters out viewed controls */\n  get items(): ListElt[] {\n    // Controls ascending/descending\n    let factor = 1;\n    // Whether or not we need to sort\n    let sort = true;\n    // Our comparator function\n    let cmp: (a: ListElt, b: ListElt) => number;\n\n    let items = this.raw_items;\n\n    if (this.sortId === 'ascending' || this.sortId === 'descending') {\n      cmp = (a: ListElt, b: ListElt) =>\n        a.control.data.id.localeCompare(b.control.data.id);\n      if (this.sortId === 'ascending') {\n        factor = -1;\n      }\n    } else if (\n      this.sortStatus === 'ascending' ||\n      this.sortStatus === 'descending'\n    ) {\n      cmp = (a: ListElt, b: ListElt) => a.status_val - b.status_val;\n      if (this.sortStatus === 'ascending') {\n        factor = -1;\n      }\n    } else if (\n      this.sortSeverity === 'ascending' ||\n      this.sortSeverity === 'descending'\n    ) {\n      cmp = (a: ListElt, b: ListElt) => a.severity_val - b.severity_val;\n      if (this.sortSeverity === 'ascending') {\n        factor = -1;\n      }\n    } else if (this.sortSet === 'ascending' || this.sortSet === 'descending') {\n      cmp = (a: ListElt, b: ListElt) => a.filename.localeCompare(b.filename);\n      if (this.sortSet === 'ascending') {\n        factor = -1;\n      }\n    } else if (\n      this.sortRunTime === 'ascending' ||\n      this.sortRunTime === 'descending'\n    ) {\n      cmp = (a: ListElt, b: ListElt) =>\n        getControlRunTime(b.control) - getControlRunTime(a.control);\n      if (this.sortRunTime === 'ascending') {\n        factor = -1;\n      }\n    } else {\n      sort = false;\n    }\n\n    // Displays only unviewed controls.\n    if (this.displayUnviewedControls) {\n      items = items.filter(\n        (val) => !this.viewedControlIds.includes(val.control.data.id)\n      );\n    }\n\n    if (sort === true) {\n      items = items.sort((a, b) => cmp(a, b) * factor);\n    }\n\n    return items;\n  }\n}\n</script>\n\n<style scoped>\n.pinned-header {\n  position: sticky;\n  z-index: 2;\n  padding-top: 2px;\n  padding-bottom: 2px;\n}\n\n.control-table-title {\n  background-color: var(--v-secondary-lighten1);\n  z-index: 10;\n}\n</style>\n\n",
    "/api/sources/raw?key=test:apps/frontend/src/components/global/upload_tabs/aws/AuthStepBasic.vue": "<template>\n  <v-stepper-content step=\"1\">\n    <v-form v-model=\"valid\">\n      <v-text-field\n        :value=\"accessToken\"\n        label=\"User Account Access Token\"\n        lazy-validation=\"lazy\"\n        :rules=\"[reqRule]\"\n        @input=\"change_access_token\"\n      />\n      <v-text-field\n        :value=\"secretToken\"\n        label=\"User Account Secret Token\"\n        type=\"password\"\n        :rules=\"[reqRule]\"\n        @input=\"change_secret_token\"\n      />\n    </v-form>\n    <v-btn\n      color=\"primary\"\n      :disabled=\"!valid\"\n      class=\"my-2 mr-3\"\n      @click=\"$emit('auth-basic')\"\n    >\n      Basic Login\n    </v-btn>\n    <v-btn\n      color=\"green\"\n      :disabled=\"!valid\"\n      class=\"my-2 mr-3\"\n      @click=\"$emit('goto-mfa')\"\n    >\n      MFA Login\n    </v-btn>\n  </v-stepper-content>\n</template>\n\n<script lang=\"ts\">\nimport FileList from '@/components/global/upload_tabs/aws/FileList.vue';\nimport {LocalStorageVal} from '@/utilities/helper_util';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\nimport {Prop} from 'vue-property-decorator';\n\n/** Localstorage keys */\nconst localAccessToken = new LocalStorageVal<string>('aws_s3_access_token');\nconst localSecretToken = new LocalStorageVal<string>('aws_s3_secret_token');\n\n/**\n * File reader component for taking in inspec JSON data.\n * Uploads data to the store with unique IDs asynchronously as soon as data is entered.\n * Emits \"got-files\" with a list of the unique_ids of the loaded files.\n */\n@Component({\n  components: {\n    FileList\n  }\n})\nexport default class S3Reader extends Vue {\n  @Prop({type: String}) readonly accessToken!: string;\n  @Prop({type: String}) readonly secretToken!: string;\n\n  /** Models if currently displayed form is valid.\n   * Shouldn't be used to interpret literally anything else as valid - just checks fields filled\n   */\n  valid = false;\n\n  /** Form required field rules. Maybe eventually expand to other stuff */\n  reqRule = (v: string | null | undefined) =>\n    (v || '').trim().length > 0 || 'Field is Required';\n\n  // Callback for change in access token\n  change_access_token(token: string) {\n    localAccessToken.set(token);\n    this.$emit('update:accessToken', token);\n  }\n\n  // Callback for change in secret token\n  change_secret_token(token: string) {\n    localSecretToken.set(token);\n    this.$emit('update:secretToken', token);\n  }\n\n  /** On mount, try to look up stored auth info */\n  mounted() {\n    // Load our credentials\n    this.change_access_token(localAccessToken.get_default(''));\n    this.change_secret_token(localSecretToken.get_default(''));\n  }\n}\n</script>\n\n",
    "/api/sources/raw?key=test:apps/frontend/src/components/global/upload_tabs/aws/AuthStepMFA.vue": "<template>\n  <v-stepper-content step=\"2\">\n    <v-form v-model=\"valid\">\n      <v-text-field\n        :value=\"mfaToken\"\n        label=\"MFA Token\"\n        :rules=\"[reqRule, mfaRule]\"\n        @input=\"change_mfa_token\"\n        @keyup.enter=\"proceed\"\n      />\n      <v-text-field\n        :value=\"mfaSerial\"\n        label=\"MFA Device ARN (Optional)\"\n        hint=\"Defaults to virtual IAM device\"\n        @input=\"changeMFASerial\"\n        @keyup.enter=\"proceed\"\n      />\n      <v-btn\n        color=\"primary\"\n        :disabled=\"!valid\"\n        class=\"my-2 mr-2\"\n        @click=\"$emit('auth-mfa')\"\n      >\n        Login\n      </v-btn>\n      <v-btn color=\"red\" class=\"my-2 ml-2\" @click=\"proceed\"> Cancel </v-btn>\n    </v-form>\n  </v-stepper-content>\n</template>\n\n<script lang=\"ts\">\nimport {LocalStorageVal} from '@/utilities/helper_util';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\nimport {PropSync} from 'vue-property-decorator';\n\n/** Localstorage keys */\nconst localMFASerial = new LocalStorageVal<string>('aws_s3_mfa_serial');\n\n/**\n * File reader component for taking in inspec JSON data.\n * Uploads data to the store with unique IDs asynchronously as soon as data is entered.\n * Emits \"got-files\" with a list of the unique_ids of the loaded files.\n */\n@Component\nexport default class S3Reader extends Vue {\n  @PropSync('mfaToken', {type: String}) token!: string;\n  @PropSync('mfaSerial', {type: String}) serial!: string;\n  /** Models if currently displayed form is valid.\n   * Shouldn't be used to interpret literally anything else as valid - just checks fields filled\n   */\n  valid = false;\n\n  /** Form required field rules. Maybe eventually expand to other stuff */\n  reqRule = (v: string | null | undefined) =>\n    (v || '').trim().length > 0 || 'Field is Required';\n\n  mfaRule = (v: string | null | undefined) =>\n    (v || '').trim().match('^\\\\d{6}$') !== null ||\n    'Field must be the 6 number code from a valid authenticator device';\n\n  /** On mount, try to look up stored auth info */\n  mounted() {\n    this.changeMFASerial(localMFASerial.get_default(''));\n  }\n\n  /** Handles changes to mfa serial */\n  change_mfa_token(newValue: string) {\n    this.token = newValue;\n  }\n\n  /** Handles changes to mfa token */\n  changeMFASerial(newValue: string) {\n    localMFASerial.set(newValue);\n    this.serial = newValue;\n  }\n\n  /** When button is pressed or enter is pressed */\n  proceed() {\n    this.$emit('exit-mfa');\n  }\n}\n</script>\n\n",
    "/api/sources/raw?key=test:libs/hdf-converters/src/base-converter.ts": "import {createHash} from 'crypto';\nimport * as htmlparser from 'htmlparser2';\nimport {ExecJSON} from 'inspecjs';\nimport _ from 'lodash';\n\nexport interface ILookupPath {\n  path?: string;\n  transformer?: (value: unknown) => unknown;\n  arrayTransformer?: (value: unknown[], file: unknown) => unknown[];\n  key?: string;\n}\n\nexport type ObjectEntries<T> = {[K in keyof T]: readonly [K, T[K]]}[keyof T];\n/* eslint-disable @typescript-eslint/ban-types */\nexport type MappedTransform<T, U extends ILookupPath> = {\n  [K in keyof T]: Exclude<T[K], undefined | null> extends Array<any>\n    ? MappedTransform<T[K], U>\n    : T[K] extends Function\n    ? T[K]\n    : T[K] extends object\n    ? MappedTransform<\n        T[K] &\n          (U & {\n            arrayTransformer?: (\n              value: unknown[],\n              file: Record<string, unknown>\n            ) => T[K][];\n          }),\n        U\n      >\n    : T[K] | (U & {transformer?: (value: unknown) => T[K]});\n};\nexport type MappedReform<T, U> = {\n  [K in keyof T]: Exclude<T[K], undefined | null> extends Array<any>\n    ? MappedReform<T[K], U>\n    : T[K] extends object\n    ? MappedReform<T[K] & U, U>\n    : Exclude<T[K], U>;\n};\n/* eslint-enable @typescript-eslint/ban-types */\n\n// Hashing Function\nexport function generateHash(data: string, algorithm = 'sha256'): string {\n  const hash = createHash(algorithm);\n  return hash.update(data).digest('hex');\n}\n\nexport function parseHtml(input: unknown): string {\n  const textData: string[] = [];\n  const myParser = new htmlparser.Parser({\n    ontext(text: string) {\n      textData.push(text);\n    }\n  });\n  if (typeof input === 'string') {\n    myParser.write(input);\n  }\n  return textData.join('');\n}\nexport function impactMapping(\n  mapping: Map<string, number>\n): (severity: unknown) => number {\n  return (severity: unknown): number => {\n    if (typeof severity === 'string' || typeof severity === 'number') {\n      return mapping.get(severity.toString().toLowerCase()) || 0;\n    } else {\n      return 0;\n    }\n  };\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction collapseDuplicates<T extends object>(\n  array: Array<T>,\n  key: string,\n  collapseResults: boolean\n): Array<T> {\n  const seen = new Map<string, number>();\n  const newArray: T[] = [];\n  let counter = 0;\n  array.forEach((item: T) => {\n    const propertyValue = _.get(item, key);\n    if (typeof propertyValue === 'string') {\n      const index = seen.get(propertyValue) || 0;\n      if (!seen.has(propertyValue)) {\n        newArray.push(item);\n        seen.set(propertyValue, counter);\n        counter++;\n      } else {\n        const oldResult = _.get(\n          newArray[index],\n          'results'\n        ) as ExecJSON.ControlResult[];\n        const descriptions = oldResult.map((element) =>\n          _.get(element, 'code_desc')\n        );\n        if (collapseResults) {\n          if (\n            descriptions.indexOf(\n              _.get(item, 'results[0].code_desc') as string\n            ) === -1\n          ) {\n            _.set(\n              newArray[index],\n              'results',\n              oldResult.concat(\n                _.get(item, 'results') as ExecJSON.ControlResult[]\n              )\n            );\n          }\n        } else {\n          _.set(\n            newArray[index],\n            'results',\n            oldResult.concat(_.get(item, 'results') as ExecJSON.ControlResult[])\n          );\n        }\n      }\n    }\n  });\n  return newArray;\n}\nexport class BaseConverter {\n  data: Record<string, unknown>;\n  mappings?: MappedTransform<ExecJSON.Execution, ILookupPath>;\n  collapseResults: boolean;\n\n  constructor(data: Record<string, unknown>, collapseResults = false) {\n    this.data = data;\n    this.collapseResults = collapseResults;\n  }\n  setMappings(\n    mappings: MappedTransform<ExecJSON.Execution, ILookupPath>\n  ): void {\n    this.mappings = mappings;\n  }\n  toHdf(): ExecJSON.Execution {\n    if (this.mappings === undefined) {\n      throw new Error('Mappings must be provided');\n    } else {\n      const v = this.convertInternal(this.data, this.mappings);\n      v.profiles.forEach((element) => {\n        element.sha256 = generateHash(JSON.stringify(element));\n      });\n      return v;\n    }\n  }\n\n  objectMap<T, V>(obj: T, fn: (v: ObjectEntries<T>) => V): {[K in keyof T]: V} {\n    return Object.fromEntries(\n      Object.entries(obj).map(([k, v]) => [k, fn(v)])\n    ) as Record<keyof T, V>;\n  }\n  convertInternal<T>(\n    file: Record<string, unknown>,\n    fields: T\n  ): MappedReform<T, ILookupPath> {\n    const result = this.objectMap(fields, (v: ObjectEntries<T>) =>\n      this.evaluate(file, v)\n    );\n    return result as MappedReform<T, ILookupPath>;\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  evaluate<T extends object>(\n    file: Record<string, unknown>,\n    v: Array<T> | T\n  ): T | Array<T> | MappedReform<T, ILookupPath> {\n    const transformer = _.get(v, 'transformer');\n    if (Array.isArray(v)) {\n      return this.handleArray(file, v);\n    } else if (\n      typeof v === 'string' ||\n      typeof v === 'number' ||\n      typeof v === 'boolean' ||\n      v === null\n    ) {\n      return v;\n    } else if (_.has(v, 'path')) {\n      if (typeof transformer === 'function') {\n        return transformer(this.handlePath(file, _.get(v, 'path') as string));\n      }\n      const pathVal = this.handlePath(file, _.get(v, 'path') as string);\n      if (Array.isArray(pathVal)) {\n        return pathVal as T[];\n      }\n      return pathVal as T;\n    }\n    if (typeof transformer === 'function') {\n      return transformer(file);\n    } else {\n      return this.convertInternal(file, v);\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  handleArray<T extends object>(\n    file: Record<string, unknown>,\n    v: Array<T & ILookupPath>\n  ): Array<T> {\n    if (v.length === 0) {\n      return [];\n    }\n    if (v[0].path === undefined) {\n      const arrayTransformer = v[0].arrayTransformer;\n      v = v.map((element) => {\n        return _.omit(element, ['arrayTransformer']) as T & ILookupPath;\n      });\n      let output: Array<T> = [];\n      v.forEach((element) => {\n        output.push(this.evaluate(file, element) as T);\n      });\n      if (arrayTransformer !== undefined) {\n        output = arrayTransformer(output, this.data) as T[];\n      }\n      return output;\n    } else {\n      const path = v[0].path;\n      const key = v[0].key;\n      const arrayTransformer = v[0].arrayTransformer;\n      const transformer = v[0].transformer;\n      if (this.hasPath(file, path)) {\n        const pathVal = this.handlePath(file, path);\n        if (Array.isArray(pathVal)) {\n          v = pathVal.map((element: Record<string, unknown>) => {\n            return _.omit(this.convertInternal(element, v[0]), [\n              'path',\n              'transformer',\n              'arrayTransformer',\n              'key'\n            ]) as T;\n          });\n          if (key !== undefined) {\n            v = collapseDuplicates(v, key, this.collapseResults);\n          }\n          if (arrayTransformer !== undefined) {\n            v = arrayTransformer(v, this.data) as T[];\n          }\n          return v;\n        } else {\n          if (transformer !== undefined) {\n            return [transformer(this.handlePath(file, path)) as T];\n          } else {\n            return [this.handlePath(file, path) as T];\n          }\n        }\n      } else {\n        return [];\n      }\n    }\n  }\n  handlePath(file: Record<string, unknown>, path: string): unknown {\n    if (path.startsWith('$.')) {\n      return _.get(this.data, path.slice(2)) || '';\n    } else {\n      return _.get(file, path) || '';\n    }\n  }\n  hasPath(file: Record<string, unknown>, path: string): boolean {\n    if (path.startsWith('$.')) {\n      return _.has(this.data, path.slice(2));\n    } else {\n      return _.has(file, path);\n    }\n  }\n}\n\n",
    "/api/sources/raw?key=test:libs/inspecjs/src/generated_parsers/v_1_0/exec-json.ts": "// To parse this data:\n//\n//   import { Convert, ExecJSON } from \"./file\";\n//\n//   const execJSON = Convert.toExecJSON(json);\n//\n// These functions will throw an error if the JSON doesn't\n// match the expected interface, even if the JSON is valid.\n\nexport interface ExecJSON {\n    platform:   Platform;\n    profiles:   ExecJSONProfile[];\n    statistics: Statistics;\n    version:    string;\n}\n\nexport interface Platform {\n    /**\n     * The name of the platform this was run on.\n     */\n    name: string;\n    /**\n     * The version of the platform this was run on.\n     */\n    release:    string;\n    target_id?: null | string;\n}\n\nexport interface ExecJSONProfile {\n    attributes:       { [key: string]: any }[];\n    controls:         ExecJSONControl[];\n    copyright?:       null | string;\n    copyright_email?: null | string;\n    depends?:         Dependency[] | null;\n    description?:     null | string;\n    groups:           ControlGroup[];\n    inspec_version?:  null | string;\n    license?:         null | string;\n    maintainer?:      null | string;\n    name:             string;\n    parent_profile?:  null | string;\n    sha256:           string;\n    skip_message?:    null | string;\n    status?:          null | string;\n    status_message?:  null | string;\n    summary?:         null | string;\n    supports:         SupportedPlatform[];\n    title?:           null | string;\n    version?:         null | string;\n}\n\nexport interface ExecJSONControl {\n    /**\n     * The raw source code of the control. Note that if this is an overlay control, it does not\n     * include the underlying source code\n     */\n    code?:         null | string;\n    desc?:         null | string;\n    descriptions?: ControlDescription[] | null;\n    /**\n     * The ID of this control\n     */\n    id:     string;\n    impact: number;\n    refs:   Reference[];\n    /**\n     * A list of all results of the controls describe blocks.\n     *\n     * For instance, if in the controls code we had the following:\n     * describe sshd_config do\n     * its('Port') { should cmp 22 }\n     * end\n     * The result of this block as a ControlResult would be appended to the results list.\n     */\n    results:         ControlResult[];\n    source_location: SourceLocation;\n    tags:            { [key: string]: any };\n    title?:          null | string;\n    waiver_data?:    null | WaiverData;\n}\n\nexport interface ControlDescription {\n    data:  string;\n    label: string;\n}\n\nexport interface Reference {\n    ref?: { [key: string]: any }[] | string;\n    url?: string;\n    uri?: string;\n}\n\nexport interface ControlResult {\n    backtrace?:    string[] | null;\n    code_desc:     string;\n    exception?:    null | string;\n    message?:      null | string;\n    resource?:     null | string;\n    run_time?:     number | null;\n    skip_message?: null | string;\n    start_time:    string;\n    status?:       ControlResultStatus | null;\n}\n\nexport enum ControlResultStatus {\n    Error = \"error\",\n    Failed = \"failed\",\n    Passed = \"passed\",\n    Skipped = \"skipped\",\n}\n\nexport interface SourceLocation {\n    /**\n     * The line at which this statement is located in the file\n     */\n    line?: number | null;\n    /**\n     * Path to the file that this statement originates from\n     */\n    ref?: null | string;\n}\n\nexport interface WaiverData {\n    expiration_date?:       null | string;\n    justification?:         null | string;\n    message?:               null | string;\n    run?:                   boolean | null;\n    skipped_due_to_waiver?: boolean | null | string;\n}\n\nexport interface Dependency {\n    branch?:         null | string;\n    compliance?:     null | string;\n    git?:            null | string;\n    name?:           null | string;\n    path?:           null | string;\n    status?:         null | string;\n    status_message?: null | string;\n    supermarket?:    null | string;\n    url?:            null | string;\n}\n\nexport interface ControlGroup {\n    /**\n     * The control IDs in this group\n     */\n    controls: string[];\n    /**\n     * The unique identifier of the group\n     */\n    id: string;\n    /**\n     * The name of the group\n     */\n    title?: null | string;\n}\n\nexport interface SupportedPlatform {\n    \"os-family\"?:       null | string;\n    \"os-name\"?:         null | string;\n    platform?:          null | string;\n    \"platform-family\"?: null | string;\n    \"platform-name\"?:   null | string;\n    release?:           null | string;\n}\n\nexport interface Statistics {\n    controls?: null | StatisticHash;\n    /**\n     * How long (in seconds) this inspec exec ran for.\n     */\n    duration?: number | null;\n}\n\n/**\n * Breakdowns of control statistics by result\n */\nexport interface StatisticHash {\n    failed?:  null | StatisticBlock;\n    passed?:  null | StatisticBlock;\n    skipped?: null | StatisticBlock;\n}\n\nexport interface StatisticBlock {\n    /**\n     * Total number of controls (in this category) for this inspec execution.\n     */\n    total: number;\n}\n\n// Converts JSON strings to/from your types\n// and asserts the results of JSON.parse at runtime\nexport class Convert {\n    public static toExecJSON(json: string): ExecJSON {\n        return cast(JSON.parse(json), r(\"ExecJSON\"));\n    }\n\n    public static execJSONToJson(value: ExecJSON): string {\n        return JSON.stringify(uncast(value, r(\"ExecJSON\")), null, 2);\n    }\n}\n\nfunction invalidValue(typ: any, val: any, key: any = ''): never {\n    if (key) {\n        throw Error(`Invalid value for key \"${key}\". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);\n    }\n    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );\n}\n\nfunction jsonToJSProps(typ: any): any {\n    if (typ.jsonToJS === undefined) {\n        const map: any = {};\n        typ.props.forEach((p: any) => map[p.json] = { key: p.js, typ: p.typ });\n        typ.jsonToJS = map;\n    }\n    return typ.jsonToJS;\n}\n\nfunction jsToJSONProps(typ: any): any {\n    if (typ.jsToJSON === undefined) {\n        const map: any = {};\n        typ.props.forEach((p: any) => map[p.js] = { key: p.json, typ: p.typ });\n        typ.jsToJSON = map;\n    }\n    return typ.jsToJSON;\n}\n\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }\n\n    function transformUnion(typs: any[], val: any): any {\n        // val must validate against one typ in typs\n        const l = typs.length;\n        for (let i = 0; i < l; i++) {\n            const typ = typs[i];\n            try {\n                return transform(val, typ, getProps);\n            } catch (_) {}\n        }\n        return invalidValue(typs, val);\n    }\n\n    function transformEnum(cases: string[], val: any): any {\n        if (cases.indexOf(val) !== -1) return val;\n        return invalidValue(cases, val);\n    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));\n    }\n\n    function transformDate(val: any): any {\n        if (val === null) {\n            return null;\n        }\n        const d = new Date(val);\n        if (isNaN(d.valueOf())) {\n            return invalidValue(\"Date\", val);\n        }\n        return d;\n    }\n\n    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {\n        if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n            return invalidValue(\"object\", val);\n        }\n        const result: any = {};\n        Object.getOwnPropertyNames(props).forEach(key => {\n            const prop = props[key];\n            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;\n            result[prop.key] = transform(v, prop.typ, getProps, prop.key);\n        });\n        Object.getOwnPropertyNames(val).forEach(key => {\n            if (!Object.prototype.hasOwnProperty.call(props, key)) {\n                result[key] = transform(val[key], additional, getProps, key);\n            }\n        });\n        return result;\n    }\n\n    if (typ === \"any\") return val;\n    if (typ === null) {\n        if (val === null) return val;\n        return invalidValue(typ, val);\n    }\n    if (typ === false) return invalidValue(typ, val);\n    while (typeof typ === \"object\" && typ.ref !== undefined) {\n        typ = typeMap[typ.ref];\n    }\n    if (Array.isArray(typ)) return transformEnum(typ, val);\n    if (typeof typ === \"object\") {\n        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);\n    return transformPrimitive(typ, val);\n}\n\nfunction cast<T>(val: any, typ: any): T {\n    return transform(val, typ, jsonToJSProps);\n}\n\nfunction uncast<T>(val: T, typ: any): any {\n    return transform(val, typ, jsToJSONProps);\n}\n\nfunction a(typ: any) {\n    return { arrayItems: typ };\n}\n\nfunction u(...typs: any[]) {\n    return { unionMembers: typs };\n}\n\nfunction o(props: any[], additional: any) {\n    return { props, additional };\n}\n\nfunction m(additional: any) {\n    return { props: [], additional };\n}\n\nfunction r(name: string) {\n    return { ref: name };\n}\n\nconst typeMap: any = {\n    \"ExecJSON\": o([\n        { json: \"platform\", js: \"platform\", typ: r(\"Platform\") },\n        { json: \"profiles\", js: \"profiles\", typ: a(r(\"ExecJSONProfile\")) },\n        { json: \"statistics\", js: \"statistics\", typ: r(\"Statistics\") },\n        { json: \"version\", js: \"version\", typ: \"\" },\n    ], \"any\"),\n    \"Platform\": o([\n        { json: \"name\", js: \"name\", typ: \"\" },\n        { json: \"release\", js: \"release\", typ: \"\" },\n        { json: \"target_id\", js: \"target_id\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"ExecJSONProfile\": o([\n        { json: \"attributes\", js: \"attributes\", typ: a(m(\"any\")) },\n        { json: \"controls\", js: \"controls\", typ: a(r(\"ExecJSONControl\")) },\n        { json: \"copyright\", js: \"copyright\", typ: u(undefined, u(null, \"\")) },\n        { json: \"copyright_email\", js: \"copyright_email\", typ: u(undefined, u(null, \"\")) },\n        { json: \"depends\", js: \"depends\", typ: u(undefined, u(a(r(\"Dependency\")), null)) },\n        { json: \"description\", js: \"description\", typ: u(undefined, u(null, \"\")) },\n        { json: \"groups\", js: \"groups\", typ: a(r(\"ControlGroup\")) },\n        { json: \"inspec_version\", js: \"inspec_version\", typ: u(undefined, u(null, \"\")) },\n        { json: \"license\", js: \"license\", typ: u(undefined, u(null, \"\")) },\n        { json: \"maintainer\", js: \"maintainer\", typ: u(undefined, u(null, \"\")) },\n        { json: \"name\", js: \"name\", typ: \"\" },\n        { json: \"parent_profile\", js: \"parent_profile\", typ: u(undefined, u(null, \"\")) },\n        { json: \"sha256\", js: \"sha256\", typ: \"\" },\n        { json: \"skip_message\", js: \"skip_message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"status\", js: \"status\", typ: u(undefined, u(null, \"\")) },\n        { json: \"status_message\", js: \"status_message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"summary\", js: \"summary\", typ: u(undefined, u(null, \"\")) },\n        { json: \"supports\", js: \"supports\", typ: a(r(\"SupportedPlatform\")) },\n        { json: \"title\", js: \"title\", typ: u(undefined, u(null, \"\")) },\n        { json: \"version\", js: \"version\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"ExecJSONControl\": o([\n        { json: \"code\", js: \"code\", typ: u(undefined, u(null, \"\")) },\n        { json: \"desc\", js: \"desc\", typ: u(undefined, u(null, \"\")) },\n        { json: \"descriptions\", js: \"descriptions\", typ: u(undefined, u(a(r(\"ControlDescription\")), null)) },\n        { json: \"id\", js: \"id\", typ: \"\" },\n        { json: \"impact\", js: \"impact\", typ: 3.14 },\n        { json: \"refs\", js: \"refs\", typ: a(r(\"Reference\")) },\n        { json: \"results\", js: \"results\", typ: a(r(\"ControlResult\")) },\n        { json: \"source_location\", js: \"source_location\", typ: r(\"SourceLocation\") },\n        { json: \"tags\", js: \"tags\", typ: m(\"any\") },\n        { json: \"title\", js: \"title\", typ: u(undefined, u(null, \"\")) },\n        { json: \"waiver_data\", js: \"waiver_data\", typ: u(undefined, u(null, r(\"WaiverData\"))) },\n    ], \"any\"),\n    \"ControlDescription\": o([\n        { json: \"data\", js: \"data\", typ: \"\" },\n        { json: \"label\", js: \"label\", typ: \"\" },\n    ], \"any\"),\n    \"Reference\": o([\n        { json: \"ref\", js: \"ref\", typ: u(undefined, u(a(m(\"any\")), \"\")) },\n        { json: \"url\", js: \"url\", typ: u(undefined, \"\") },\n        { json: \"uri\", js: \"uri\", typ: u(undefined, \"\") },\n    ], \"any\"),\n    \"ControlResult\": o([\n        { json: \"backtrace\", js: \"backtrace\", typ: u(undefined, u(a(\"\"), null)) },\n        { json: \"code_desc\", js: \"code_desc\", typ: \"\" },\n        { json: \"exception\", js: \"exception\", typ: u(undefined, u(null, \"\")) },\n        { json: \"message\", js: \"message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"resource\", js: \"resource\", typ: u(undefined, u(null, \"\")) },\n        { json: \"run_time\", js: \"run_time\", typ: u(undefined, u(3.14, null)) },\n        { json: \"skip_message\", js: \"skip_message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"start_time\", js: \"start_time\", typ: \"\" },\n        { json: \"status\", js: \"status\", typ: u(undefined, u(r(\"ControlResultStatus\"), null)) },\n    ], \"any\"),\n    \"SourceLocation\": o([\n        { json: \"line\", js: \"line\", typ: u(undefined, u(3.14, null)) },\n        { json: \"ref\", js: \"ref\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"WaiverData\": o([\n        { json: \"expiration_date\", js: \"expiration_date\", typ: u(undefined, u(null, \"\")) },\n        { json: \"justification\", js: \"justification\", typ: u(undefined, u(null, \"\")) },\n        { json: \"message\", js: \"message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"run\", js: \"run\", typ: u(undefined, u(true, null)) },\n        { json: \"skipped_due_to_waiver\", js: \"skipped_due_to_waiver\", typ: u(undefined, u(true, null, \"\")) },\n    ], \"any\"),\n    \"Dependency\": o([\n        { json: \"branch\", js: \"branch\", typ: u(undefined, u(null, \"\")) },\n        { json: \"compliance\", js: \"compliance\", typ: u(undefined, u(null, \"\")) },\n        { json: \"git\", js: \"git\", typ: u(undefined, u(null, \"\")) },\n        { json: \"name\", js: \"name\", typ: u(undefined, u(null, \"\")) },\n        { json: \"path\", js: \"path\", typ: u(undefined, u(null, \"\")) },\n        { json: \"status\", js: \"status\", typ: u(undefined, u(null, \"\")) },\n        { json: \"status_message\", js: \"status_message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"supermarket\", js: \"supermarket\", typ: u(undefined, u(null, \"\")) },\n        { json: \"url\", js: \"url\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"ControlGroup\": o([\n        { json: \"controls\", js: \"controls\", typ: a(\"\") },\n        { json: \"id\", js: \"id\", typ: \"\" },\n        { json: \"title\", js: \"title\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"SupportedPlatform\": o([\n        { json: \"os-family\", js: \"os-family\", typ: u(undefined, u(null, \"\")) },\n        { json: \"os-name\", js: \"os-name\", typ: u(undefined, u(null, \"\")) },\n        { json: \"platform\", js: \"platform\", typ: u(undefined, u(null, \"\")) },\n        { json: \"platform-family\", js: \"platform-family\", typ: u(undefined, u(null, \"\")) },\n        { json: \"platform-name\", js: \"platform-name\", typ: u(undefined, u(null, \"\")) },\n        { json: \"release\", js: \"release\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"Statistics\": o([\n        { json: \"controls\", js: \"controls\", typ: u(undefined, u(null, r(\"StatisticHash\"))) },\n        { json: \"duration\", js: \"duration\", typ: u(undefined, u(3.14, null)) },\n    ], \"any\"),\n    \"StatisticHash\": o([\n        { json: \"failed\", js: \"failed\", typ: u(undefined, u(null, r(\"StatisticBlock\"))) },\n        { json: \"passed\", js: \"passed\", typ: u(undefined, u(null, r(\"StatisticBlock\"))) },\n        { json: \"skipped\", js: \"skipped\", typ: u(undefined, u(null, r(\"StatisticBlock\"))) },\n    ], \"any\"),\n    \"StatisticBlock\": o([\n        { json: \"total\", js: \"total\", typ: 3.14 },\n    ], \"any\"),\n    \"ControlResultStatus\": [\n        \"error\",\n        \"failed\",\n        \"passed\",\n        \"skipped\",\n    ],\n};\n\n",
    "/api/sources/raw?key=test:libs/inspecjs/src/generated_parsers/v_1_0/exec-jsonmin.ts": "// To parse this data:\n//\n//   import { Convert, ExecJsonmin } from \"./file\";\n//\n//   const execJsonmin = Convert.toExecJsonmin(json);\n//\n// These functions will throw an error if the JSON doesn't\n// match the expected interface, even if the JSON is valid.\n\nexport interface ExecJsonmin {\n    controls:   ExecJSONMINControl[];\n    statistics: Statistics;\n    version:    string;\n}\n\nexport interface ExecJSONMINControl {\n    backtrace?:     string[] | null;\n    code_desc:      string;\n    exception?:     null | string;\n    id:             string;\n    message?:       null | string;\n    profile_id?:    null | string;\n    profile_sha256: string;\n    resource?:      null | string;\n    skip_message?:  null | string;\n    status:         string;\n}\n\nexport interface Statistics {\n    controls?: null | StatisticHash;\n    /**\n     * How long (in seconds) this inspec exec ran for.\n     */\n    duration: number;\n}\n\n/**\n * Breakdowns of control statistics by result\n */\nexport interface StatisticHash {\n    failed?:  null | StatisticBlock;\n    passed?:  null | StatisticBlock;\n    skipped?: null | StatisticBlock;\n}\n\nexport interface StatisticBlock {\n    /**\n     * Total number of controls (in this category) for this inspec execution.\n     */\n    total: number;\n}\n\n// Converts JSON strings to/from your types\n// and asserts the results of JSON.parse at runtime\nexport class Convert {\n    public static toExecJsonmin(json: string): ExecJsonmin {\n        return cast(JSON.parse(json), r(\"ExecJsonmin\"));\n    }\n\n    public static execJsonminToJson(value: ExecJsonmin): string {\n        return JSON.stringify(uncast(value, r(\"ExecJsonmin\")), null, 2);\n    }\n}\n\nfunction invalidValue(typ: any, val: any, key: any = ''): never {\n    if (key) {\n        throw Error(`Invalid value for key \"${key}\". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);\n    }\n    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );\n}\n\nfunction jsonToJSProps(typ: any): any {\n    if (typ.jsonToJS === undefined) {\n        const map: any = {};\n        typ.props.forEach((p: any) => map[p.json] = { key: p.js, typ: p.typ });\n        typ.jsonToJS = map;\n    }\n    return typ.jsonToJS;\n}\n\nfunction jsToJSONProps(typ: any): any {\n    if (typ.jsToJSON === undefined) {\n        const map: any = {};\n        typ.props.forEach((p: any) => map[p.js] = { key: p.json, typ: p.typ });\n        typ.jsToJSON = map;\n    }\n    return typ.jsToJSON;\n}\n\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }\n\n    function transformUnion(typs: any[], val: any): any {\n        // val must validate against one typ in typs\n        const l = typs.length;\n        for (let i = 0; i < l; i++) {\n            const typ = typs[i];\n            try {\n                return transform(val, typ, getProps);\n            } catch (_) {}\n        }\n        return invalidValue(typs, val);\n    }\n\n    function transformEnum(cases: string[], val: any): any {\n        if (cases.indexOf(val) !== -1) return val;\n        return invalidValue(cases, val);\n    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));\n    }\n\n    function transformDate(val: any): any {\n        if (val === null) {\n            return null;\n        }\n        const d = new Date(val);\n        if (isNaN(d.valueOf())) {\n            return invalidValue(\"Date\", val);\n        }\n        return d;\n    }\n\n    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {\n        if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n            return invalidValue(\"object\", val);\n        }\n        const result: any = {};\n        Object.getOwnPropertyNames(props).forEach(key => {\n            const prop = props[key];\n            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;\n            result[prop.key] = transform(v, prop.typ, getProps, prop.key);\n        });\n        Object.getOwnPropertyNames(val).forEach(key => {\n            if (!Object.prototype.hasOwnProperty.call(props, key)) {\n                result[key] = transform(val[key], additional, getProps, key);\n            }\n        });\n        return result;\n    }\n\n    if (typ === \"any\") return val;\n    if (typ === null) {\n        if (val === null) return val;\n        return invalidValue(typ, val);\n    }\n    if (typ === false) return invalidValue(typ, val);\n    while (typeof typ === \"object\" && typ.ref !== undefined) {\n        typ = typeMap[typ.ref];\n    }\n    if (Array.isArray(typ)) return transformEnum(typ, val);\n    if (typeof typ === \"object\") {\n        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);\n    return transformPrimitive(typ, val);\n}\n\nfunction cast<T>(val: any, typ: any): T {\n    return transform(val, typ, jsonToJSProps);\n}\n\nfunction uncast<T>(val: T, typ: any): any {\n    return transform(val, typ, jsToJSONProps);\n}\n\nfunction a(typ: any) {\n    return { arrayItems: typ };\n}\n\nfunction u(...typs: any[]) {\n    return { unionMembers: typs };\n}\n\nfunction o(props: any[], additional: any) {\n    return { props, additional };\n}\n\nfunction m(additional: any) {\n    return { props: [], additional };\n}\n\nfunction r(name: string) {\n    return { ref: name };\n}\n\nconst typeMap: any = {\n    \"ExecJsonmin\": o([\n        { json: \"controls\", js: \"controls\", typ: a(r(\"ExecJSONMINControl\")) },\n        { json: \"statistics\", js: \"statistics\", typ: r(\"Statistics\") },\n        { json: \"version\", js: \"version\", typ: \"\" },\n    ], \"any\"),\n    \"ExecJSONMINControl\": o([\n        { json: \"backtrace\", js: \"backtrace\", typ: u(undefined, u(a(\"\"), null)) },\n        { json: \"code_desc\", js: \"code_desc\", typ: \"\" },\n        { json: \"exception\", js: \"exception\", typ: u(undefined, u(null, \"\")) },\n        { json: \"id\", js: \"id\", typ: \"\" },\n        { json: \"message\", js: \"message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"profile_id\", js: \"profile_id\", typ: u(undefined, u(null, \"\")) },\n        { json: \"profile_sha256\", js: \"profile_sha256\", typ: \"\" },\n        { json: \"resource\", js: \"resource\", typ: u(undefined, u(null, \"\")) },\n        { json: \"skip_message\", js: \"skip_message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"status\", js: \"status\", typ: \"\" },\n    ], \"any\"),\n    \"Statistics\": o([\n        { json: \"controls\", js: \"controls\", typ: u(undefined, u(null, r(\"StatisticHash\"))) },\n        { json: \"duration\", js: \"duration\", typ: 3.14 },\n    ], \"any\"),\n    \"StatisticHash\": o([\n        { json: \"failed\", js: \"failed\", typ: u(undefined, u(null, r(\"StatisticBlock\"))) },\n        { json: \"passed\", js: \"passed\", typ: u(undefined, u(null, r(\"StatisticBlock\"))) },\n        { json: \"skipped\", js: \"skipped\", typ: u(undefined, u(null, r(\"StatisticBlock\"))) },\n    ], \"any\"),\n    \"StatisticBlock\": o([\n        { json: \"total\", js: \"total\", typ: 3.14 },\n    ], \"any\"),\n};\n\n",
    "/api/sources/raw?key=test:libs/inspecjs/src/generated_parsers/v_1_0/profile-json.ts": "// To parse this data:\n//\n//   import { Convert, ProfileJSON } from \"./file\";\n//\n//   const profileJSON = Convert.toProfileJSON(json);\n//\n// These functions will throw an error if the JSON doesn't\n// match the expected interface, even if the JSON is valid.\n\nexport interface ProfileJSON {\n    controls:         ProfileJSONControl[];\n    copyright?:       null | string;\n    copyright_email?: null | string;\n    depends?:         Dependency[] | null;\n    generator?:       null | Generator;\n    groups:           ControlGroup[];\n    inputs?:          { [key: string]: any }[] | null;\n    maintainer?:      null | string;\n    name:             string;\n    sha256:           string;\n    status?:          null | string;\n    supports:         SupportedPlatform[];\n    title?:           null | string;\n    version?:         null | string;\n}\n\nexport interface ProfileJSONControl {\n    /**\n     * The raw source code of the control. Note that if this is an overlay control, it does not\n     * include the underlying source code\n     */\n    code:          string;\n    desc?:         null | string;\n    descriptions?: { [key: string]: any } | null;\n    /**\n     * The ID of this control\n     */\n    id:               string;\n    impact:           number;\n    refs?:            Reference[] | null;\n    source_location?: null | SourceLocation;\n    tags:             { [key: string]: any };\n    title?:           null | string;\n}\n\nexport interface Reference {\n    ref?: { [key: string]: any }[] | string;\n    url?: string;\n    uri?: string;\n}\n\nexport interface SourceLocation {\n    /**\n     * The line at which this statement is located in the file\n     */\n    line?: number | null;\n    /**\n     * Path to the file that this statement originates from\n     */\n    ref?: null | string;\n}\n\nexport interface Dependency {\n    branch?:         null | string;\n    compliance?:     null | string;\n    git?:            null | string;\n    name?:           null | string;\n    path?:           null | string;\n    status?:         null | string;\n    status_message?: null | string;\n    supermarket?:    null | string;\n    url?:            null | string;\n}\n\nexport interface Generator {\n    /**\n     * The name of the software that generated this report.\n     */\n    name: string;\n    /**\n     * The version of the software that generated this report.\n     */\n    version: string;\n}\n\nexport interface ControlGroup {\n    /**\n     * The control IDs in this group\n     */\n    controls: string[];\n    /**\n     * The unique identifier of the group\n     */\n    id: string;\n    /**\n     * The name of the group\n     */\n    title?: null | string;\n}\n\nexport interface SupportedPlatform {\n    \"os-family\"?:       null | string;\n    \"os-name\"?:         null | string;\n    platform?:          null | string;\n    \"platform-family\"?: null | string;\n    \"platform-name\"?:   null | string;\n    release?:           null | string;\n}\n\n// Converts JSON strings to/from your types\n// and asserts the results of JSON.parse at runtime\nexport class Convert {\n    public static toProfileJSON(json: string): ProfileJSON {\n        return cast(JSON.parse(json), r(\"ProfileJSON\"));\n    }\n\n    public static profileJSONToJson(value: ProfileJSON): string {\n        return JSON.stringify(uncast(value, r(\"ProfileJSON\")), null, 2);\n    }\n}\n\nfunction invalidValue(typ: any, val: any, key: any = ''): never {\n    if (key) {\n        throw Error(`Invalid value for key \"${key}\". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);\n    }\n    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );\n}\n\nfunction jsonToJSProps(typ: any): any {\n    if (typ.jsonToJS === undefined) {\n        const map: any = {};\n        typ.props.forEach((p: any) => map[p.json] = { key: p.js, typ: p.typ });\n        typ.jsonToJS = map;\n    }\n    return typ.jsonToJS;\n}\n\nfunction jsToJSONProps(typ: any): any {\n    if (typ.jsToJSON === undefined) {\n        const map: any = {};\n        typ.props.forEach((p: any) => map[p.js] = { key: p.json, typ: p.typ });\n        typ.jsToJSON = map;\n    }\n    return typ.jsToJSON;\n}\n\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val, key);\n    }\n\n    function transformUnion(typs: any[], val: any): any {\n        // val must validate against one typ in typs\n        const l = typs.length;\n        for (let i = 0; i < l; i++) {\n            const typ = typs[i];\n            try {\n                return transform(val, typ, getProps);\n            } catch (_) {}\n        }\n        return invalidValue(typs, val);\n    }\n\n    function transformEnum(cases: string[], val: any): any {\n        if (cases.indexOf(val) !== -1) return val;\n        return invalidValue(cases, val);\n    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));\n    }\n\n    function transformDate(val: any): any {\n        if (val === null) {\n            return null;\n        }\n        const d = new Date(val);\n        if (isNaN(d.valueOf())) {\n            return invalidValue(\"Date\", val);\n        }\n        return d;\n    }\n\n    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {\n        if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n            return invalidValue(\"object\", val);\n        }\n        const result: any = {};\n        Object.getOwnPropertyNames(props).forEach(key => {\n            const prop = props[key];\n            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;\n            result[prop.key] = transform(v, prop.typ, getProps, prop.key);\n        });\n        Object.getOwnPropertyNames(val).forEach(key => {\n            if (!Object.prototype.hasOwnProperty.call(props, key)) {\n                result[key] = transform(val[key], additional, getProps, key);\n            }\n        });\n        return result;\n    }\n\n    if (typ === \"any\") return val;\n    if (typ === null) {\n        if (val === null) return val;\n        return invalidValue(typ, val);\n    }\n    if (typ === false) return invalidValue(typ, val);\n    while (typeof typ === \"object\" && typ.ref !== undefined) {\n        typ = typeMap[typ.ref];\n    }\n    if (Array.isArray(typ)) return transformEnum(typ, val);\n    if (typeof typ === \"object\") {\n        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);\n    return transformPrimitive(typ, val);\n}\n\nfunction cast<T>(val: any, typ: any): T {\n    return transform(val, typ, jsonToJSProps);\n}\n\nfunction uncast<T>(val: T, typ: any): any {\n    return transform(val, typ, jsToJSONProps);\n}\n\nfunction a(typ: any) {\n    return { arrayItems: typ };\n}\n\nfunction u(...typs: any[]) {\n    return { unionMembers: typs };\n}\n\nfunction o(props: any[], additional: any) {\n    return { props, additional };\n}\n\nfunction m(additional: any) {\n    return { props: [], additional };\n}\n\nfunction r(name: string) {\n    return { ref: name };\n}\n\nconst typeMap: any = {\n    \"ProfileJSON\": o([\n        { json: \"controls\", js: \"controls\", typ: a(r(\"ProfileJSONControl\")) },\n        { json: \"copyright\", js: \"copyright\", typ: u(undefined, u(null, \"\")) },\n        { json: \"copyright_email\", js: \"copyright_email\", typ: u(undefined, u(null, \"\")) },\n        { json: \"depends\", js: \"depends\", typ: u(undefined, u(a(r(\"Dependency\")), null)) },\n        { json: \"generator\", js: \"generator\", typ: u(undefined, u(null, r(\"Generator\"))) },\n        { json: \"groups\", js: \"groups\", typ: a(r(\"ControlGroup\")) },\n        { json: \"inputs\", js: \"inputs\", typ: u(undefined, u(a(m(\"any\")), null)) },\n        { json: \"maintainer\", js: \"maintainer\", typ: u(undefined, u(null, \"\")) },\n        { json: \"name\", js: \"name\", typ: \"\" },\n        { json: \"sha256\", js: \"sha256\", typ: \"\" },\n        { json: \"status\", js: \"status\", typ: u(undefined, u(null, \"\")) },\n        { json: \"supports\", js: \"supports\", typ: a(r(\"SupportedPlatform\")) },\n        { json: \"title\", js: \"title\", typ: u(undefined, u(null, \"\")) },\n        { json: \"version\", js: \"version\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"ProfileJSONControl\": o([\n        { json: \"code\", js: \"code\", typ: \"\" },\n        { json: \"desc\", js: \"desc\", typ: u(undefined, u(null, \"\")) },\n        { json: \"descriptions\", js: \"descriptions\", typ: u(undefined, u(m(\"any\"), null)) },\n        { json: \"id\", js: \"id\", typ: \"\" },\n        { json: \"impact\", js: \"impact\", typ: 3.14 },\n        { json: \"refs\", js: \"refs\", typ: u(undefined, u(a(r(\"Reference\")), null)) },\n        { json: \"source_location\", js: \"source_location\", typ: u(undefined, u(null, r(\"SourceLocation\"))) },\n        { json: \"tags\", js: \"tags\", typ: m(\"any\") },\n        { json: \"title\", js: \"title\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"Reference\": o([\n        { json: \"ref\", js: \"ref\", typ: u(undefined, u(a(m(\"any\")), \"\")) },\n        { json: \"url\", js: \"url\", typ: u(undefined, \"\") },\n        { json: \"uri\", js: \"uri\", typ: u(undefined, \"\") },\n    ], \"any\"),\n    \"SourceLocation\": o([\n        { json: \"line\", js: \"line\", typ: u(undefined, u(3.14, null)) },\n        { json: \"ref\", js: \"ref\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"Dependency\": o([\n        { json: \"branch\", js: \"branch\", typ: u(undefined, u(null, \"\")) },\n        { json: \"compliance\", js: \"compliance\", typ: u(undefined, u(null, \"\")) },\n        { json: \"git\", js: \"git\", typ: u(undefined, u(null, \"\")) },\n        { json: \"name\", js: \"name\", typ: u(undefined, u(null, \"\")) },\n        { json: \"path\", js: \"path\", typ: u(undefined, u(null, \"\")) },\n        { json: \"status\", js: \"status\", typ: u(undefined, u(null, \"\")) },\n        { json: \"status_message\", js: \"status_message\", typ: u(undefined, u(null, \"\")) },\n        { json: \"supermarket\", js: \"supermarket\", typ: u(undefined, u(null, \"\")) },\n        { json: \"url\", js: \"url\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"Generator\": o([\n        { json: \"name\", js: \"name\", typ: \"\" },\n        { json: \"version\", js: \"version\", typ: \"\" },\n    ], \"any\"),\n    \"ControlGroup\": o([\n        { json: \"controls\", js: \"controls\", typ: a(\"\") },\n        { json: \"id\", js: \"id\", typ: \"\" },\n        { json: \"title\", js: \"title\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n    \"SupportedPlatform\": o([\n        { json: \"os-family\", js: \"os-family\", typ: u(undefined, u(null, \"\")) },\n        { json: \"os-name\", js: \"os-name\", typ: u(undefined, u(null, \"\")) },\n        { json: \"platform\", js: \"platform\", typ: u(undefined, u(null, \"\")) },\n        { json: \"platform-family\", js: \"platform-family\", typ: u(undefined, u(null, \"\")) },\n        { json: \"platform-name\", js: \"platform-name\", typ: u(undefined, u(null, \"\")) },\n        { json: \"release\", js: \"release\", typ: u(undefined, u(null, \"\")) },\n    ], \"any\"),\n};\n\n",
    "/api/sources/raw?key=test:apps/frontend/src/components/cards/treemap/Treemap.vue": "<template>\n  <v-container ref=\"treemapContainer\" fluid>\n    <v-row dense>\n      <v-col :cols=\"4\">\n        NIST SP 800-53 Security and Privacy Control Coverage\n      </v-col>\n      <v-col :cols=\"8\">\n        <v-btn :disabled=\"!allow_up\" block x-small @click=\"up\">\n          <v-icon v-if=\"allow_up\"> mdi-arrow-left </v-icon>\n          {{ 'NIST-SP-800-53 -> ' + value.join(' -> ') }}\n        </v-btn>\n      </v-col>\n    </v-row>\n    <v-row>\n      <v-col v-resize=\"on_resize\" :cols=\"12\">\n        <svg id=\"chartBody\" :width=\"width\" :height=\"height\">\n          <g\n            style=\"shape-rendering: crispEdges\"\n            preserveAspectRatio=\"xMidYMid meet\"\n          >\n            <!-- The body -->\n            <Cell\n              :selected_control_id=\"selected_control\"\n              :node=\"selected_node\"\n              :scales=\"scales\"\n              :depth=\"0\"\n              @select-node=\"select_node\"\n            />\n          </g>\n        </svg>\n      </v-col>\n    </v-row>\n  </v-container>\n</template>\n\n<script lang=\"ts\">\nimport Cell, {XYScale} from '@/components/cards/treemap/Cell.vue';\nimport {ColorHackModule} from '@/store/color_hack';\nimport {Filter, FilteredDataModule, TreeMapState} from '@/store/data_filters';\nimport {compare_arrays} from '@/utilities/helper_util';\nimport {\n  build_nist_tree_map,\n  is_leaf,\n  is_parent,\n  TreemapNode\n} from '@/utilities/treemap_util';\nimport * as d3 from 'd3';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\nimport {Prop, PropSync, Ref} from 'vue-property-decorator';\n\n// Respects a v-model of type TreeMapState\n@Component({\n  components: {\n    Cell\n  }\n})\nexport default class Treemap extends Vue {\n  @Ref('treemapContainer') readonly treemapContainer!: Element;\n  @Prop({type: Array, required: true}) readonly value!: TreeMapState;\n  @Prop({type: Object, required: true}) readonly filter!: Filter;\n  @PropSync('selected_control', {type: String}) syncedSelectedControl!:\n    | string\n    | null;\n\n  /** The svg internal coordinate space */\n  width = 1600;\n  height = 530;\n\n  /** The currently selected treemap node. Wrapped to avoid initialization woes */\n  get selected_node(): d3.HierarchyRectangularNode<TreemapNode> {\n    // Get typed versions of the curr state\n    // Set curr to root\n    let curr = this.treemap_layout;\n    let depth = 0;\n\n    try {\n      for (; depth < this.value.length; depth++) {\n        // If the current has no children, then just bail here\n        if (curr.children === undefined) {\n          throw Error('no children to go into');\n        }\n\n        // Fetch the next path spec\n        const nextSpecifiers = this.value.slice(0, depth + 1);\n\n        const newCurr = curr.children.find((child) => {\n          if (is_parent(child.data)) {\n            const ssA = child.data.nist_control.subSpecifiers;\n            return (\n              compare_arrays(ssA, nextSpecifiers, (a, b) =>\n                a.localeCompare(b)\n              ) === 0\n            );\n          } else {\n            return false; // We cannot go into a leaf (OR CAN WE? MUST DECIDE, AT SOME POINT)\n          }\n        });\n        if (newCurr) {\n          if (newCurr.children && newCurr.children.length) {\n            curr = newCurr;\n          } else {\n            throw Error('empty');\n          }\n        } else {\n          throw Error('truncate');\n        }\n      }\n    } catch (someTraversalError) {\n      // Slice to last successful depth. Slice is non inclusive so this works\n      this.set_path(this.value.slice(0, depth));\n    }\n\n    // Return as deep as we travelled\n    return curr;\n  }\n\n  /** Get our viewbox */\n  get view_box(): string {\n    return `0 0 ${this.width} ${this.height}`;\n  }\n\n  /** Get our scales */\n  get scales(): XYScale {\n    return {\n      scale_x: d3\n        .scaleLinear()\n        .domain([this.selected_node.x0, this.selected_node.x1])\n        .range([0, this.width]),\n      scale_y: d3\n        .scaleLinear()\n        .domain([this.selected_node.y0, this.selected_node.y1])\n        .range([0, this.height])\n    };\n  }\n\n  /** Generates a d3 heirarchy structure, with appropriate bounds to our width\n   *  detailing all of the controls in the nist hash */\n  get treemap_layout(): d3.HierarchyRectangularNode<TreemapNode> {\n    // Get the current filtered data\n    const controls = FilteredDataModule.controls(this.filter);\n\n    // Build the map\n    const hierarchy = build_nist_tree_map(controls, ColorHackModule);\n    return d3\n      .treemap<TreemapNode>()\n      .size([this.width, this.height])\n      .round(false)\n      .paddingInner(0)(hierarchy);\n  }\n\n  // Callbacks for our tree\n  select_node(n: d3.HierarchyRectangularNode<TreemapNode>): void {\n    // If it is a leaf, then select it\n    if (is_leaf(n.data)) {\n      const id = n.data.control.data.id;\n      this.syncedSelectedControl =\n        id !== this.syncedSelectedControl ? id : null;\n    } else {\n      // Otherwise, dive away. Set course for the leading title\n      const cntrl = n.data.nist_control;\n      if (cntrl) {\n        this.set_path(cntrl.subSpecifiers);\n      }\n    }\n  }\n\n  /** Submits an event to go up one node */\n  up(): void {\n    if (this.value.length) {\n      // Slice and dice, baybee\n      this.set_path(this.value.slice(0, this.value.length - 1));\n\n      // Also clear selected\n      this.syncedSelectedControl = null;\n    }\n  }\n\n  /** Typed method to wrap changes in the depth */\n  set_path(pathSpec: TreeMapState) {\n    this.$emit('input', pathSpec);\n  }\n\n  /** Controls whether we should allow up */\n  get allow_up(): boolean {\n    return this.value.length > 0;\n  }\n\n  /** Called on resize */\n  on_resize() {\n    this.width = this.treemapContainer.clientWidth;\n  }\n}\n</script>\n\n<style scoped>\ntext {\n  pointer-events: none;\n  font-weight: bold;\n  font-size: 1.1em;\n  fill: 'primary';\n}\n\nrect {\n  fill: none;\n}\n</style>\n\n",
    "/api/sources/raw?key=test:apps/frontend/src/components/global/upload_tabs/aws/FileList.vue": "<template>\n  <v-stepper-content step=\"3\">\n    <div class=\"d-flex flex-column\">\n      <div class=\"d-flex justify-space-between\">\n        <v-text-field\n          v-model=\"formBucketName\"\n          label=\"Bucket name\"\n          @keyup.enter=\"load\"\n        />\n        <v-btn\n          title=\"Load\"\n          :disabled=\"formBucketName.length < 1\"\n          class=\"fill-height pa-0\"\n          @click=\"load\"\n        >\n          <v-icon>mdi-cloud-download</v-icon>\n        </v-btn>\n      </div>\n\n      <v-list :two-line=\"true\">\n        <v-list-item v-if=\"files.length === 0\"\n          >No items found! Try different terms?</v-list-item\n        >\n        <v-list-item v-for=\"(val, index) in files\" :key=\"val.Key\">\n          <v-list-item-content>\n            <!-- Title: The item key -->\n            <v-list-item-title>{{ val.Key }}</v-list-item-title>\n            <!-- Subtitle: Date of creation -->\n            <v-list-item-subtitle>\n              {{ val.LastModified }}\n            </v-list-item-subtitle>\n          </v-list-item-content>\n          <!-- Action: Click to add -->\n          <v-list-item-action>\n            <v-btn icon @click=\"load_file(index)\">\n              <v-icon>mdi-plus-circle</v-icon>\n            </v-btn>\n          </v-list-item-action>\n        </v-list-item>\n      </v-list>\n      <v-btn color=\"red\" class=\"my-2 mr-3\" @click=\"$emit('exit-list')\">\n        Cancel\n      </v-btn>\n    </div>\n  </v-stepper-content>\n</template>\n\n<script lang=\"ts\">\nimport {InspecIntakeModule} from '@/store/report_intake';\nimport {Auth, fetch_s3_file} from '@/utilities/aws_util';\nimport {LocalStorageVal} from '@/utilities/helper_util';\nimport S3 from 'aws-sdk/clients/s3';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\nimport {Prop} from 'vue-property-decorator';\n\n// Caches the bucket name\nconst localBucketName = new LocalStorageVal<string>('aws_bucket_name');\n\n@Component({\n  components: {}\n})\nexport default class FileList extends Vue {\n  @Prop({type: Object}) readonly auth!: Auth;\n  @Prop({type: Array}) readonly files!: S3.Object[];\n\n  /** The name written in the form */\n  formBucketName = '';\n\n  /** On mount, try to look up stored auth info */\n  /** Callback for when user selects a file.\n   * Loads it into our system.\n   */\n  async load_file(index: number): Promise<void> {\n    // Get it out of the list\n    const file = this.files[index];\n\n    // Fetch it from s3, and promise to submit it to be loaded afterwards\n    await fetch_s3_file(this.auth.creds, file.Key!, this.formBucketName).then(\n      (content) => {\n        InspecIntakeModule.loadText({\n          text: content,\n          filename: file.Key!\n        }).then((uniqueId) => this.$emit('got-files', [uniqueId]));\n      }\n    );\n  }\n\n  /** Recalls the last entered bucket name.  */\n  mounted() {\n    this.formBucketName = localBucketName.get_default('');\n  }\n\n  /** Handles when load button clicked */\n  load() {\n    localBucketName.set(this.formBucketName);\n    this.$emit('load-bucket', this.formBucketName);\n  }\n}\n</script>\n\n",
    "/api/sources/raw?key=test:apps/frontend/src/components/global/upload_tabs/aws/S3Reader.vue": "<template>\n  <v-stepper v-model=\"step\" vertical class=\"elevation-0\">\n    <v-stepper-step :complete=\"!!assumedRole\" step=\"1\">\n      Account Credentials\n    </v-stepper-step>\n\n    <AuthStepBasic\n      :access-token.sync=\"accessToken\"\n      :secret-token.sync=\"secretToken\"\n      @auth-basic=\"handle_basic\"\n      @goto-mfa=\"handle_goto_mfa\"\n    />\n\n    <v-stepper-step :complete=\"!!assumedRole && assumedRole.from_mfa\" step=\"2\">\n      MFA Authorization\n    </v-stepper-step>\n\n    <AuthStepMFA\n      :mfa-token.sync=\"mfaToken\"\n      :mfa-serial.sync=\"mfaSerial\"\n      @auth-mfa=\"handle_proceed_mfa\"\n      @exit-mfa=\"handle_cancel_mfa\"\n    />\n\n    <v-stepper-step step=\"3\"> Browse Bucket </v-stepper-step>\n\n    <FileList\n      :auth=\"assumedRole\"\n      :files=\"files\"\n      @exit-list=\"handle_cancel_mfa\"\n      @got-files=\"got_files\"\n      @load-bucket=\"load_bucket\"\n    />\n  </v-stepper>\n</template>\n\n<script lang=\"ts\">\nimport AuthStepBasic from '@/components/global/upload_tabs/aws/AuthStepBasic.vue';\nimport AuthStepMFA from '@/components/global/upload_tabs/aws/AuthStepMFA.vue';\nimport FileList from '@/components/global/upload_tabs/aws/FileList.vue';\nimport {FileID} from '@/store/report_intake';\nimport {SnackbarModule} from '@/store/snackbar';\nimport {\n  Auth,\n  AUTH_DURATION,\n  get_session_token,\n  MFAInfo,\n  transcribe_error\n} from '@/utilities/aws_util';\nimport {LocalStorageVal} from '@/utilities/helper_util';\nimport S3 from 'aws-sdk/clients/s3';\nimport {AWSError} from 'aws-sdk/lib/error';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\n\n/** The cached session info */\nconst localSessionInformation = new LocalStorageVal<Auth | null>(\n  'aws_session_info'\n);\n\n/**\n * Uploads data to the store with unique IDs asynchronously as soon as data is entered.\n * Emits \"got-files\" with a list of the unique_ids of the loaded files.\n */\n@Component({\n  components: {\n    AuthStepBasic,\n    AuthStepMFA,\n    FileList\n  }\n})\nexport default class S3Reader extends Vue {\n  /** Form required field rules. Maybe eventually expand to other stuff */\n  reqRule = (v: string | null | undefined) =>\n    (v || '').trim().length > 0 || 'Field is Required';\n\n  /** Passed from step 1 to step 2 (MFA) if necessary */\n  /** State of all globally relevant fields */\n  accessToken = '';\n  secretToken = '';\n  mfaSerial = '';\n  mfaToken = '';\n\n  /** Our session information, generated by AWS STS */\n  assumedRole: Auth | null = null;\n\n  /** Current step */\n  step = 1;\n\n  /** Currently loaded file list from bucket */\n  files: S3.Object[] = [];\n\n  /**\n   * Handle a basic login.\n   * Gets a session token\n   */\n  handle_basic() {\n    // Attempt to assume role based on if we've determined 2fa necessary\n    get_session_token(this.accessToken, this.secretToken, AUTH_DURATION).then(\n      // Success of get session token - now need to determine if MFA necessary\n      (success) => {\n        this.assumedRole = success;\n        this.step = 3;\n      },\n\n      // Failure of initial get session token: want to set error normally\n      (failure) => {\n        this.handle_error(failure);\n      }\n    );\n  }\n\n  /** If the user tries to login by going to MFA, first check that the account is valid */\n  handle_goto_mfa() {\n    // Attempt to assume role based on if we've determined 2fa necessary\n    // Don't need the duration to be very long\n    get_session_token(this.accessToken, this.secretToken, 10).then(\n      // Success of get session token - now need to determine if MFA necessary\n      () => {\n        this.step = 2;\n      },\n\n      // Failure of initial get session token: want to set error normally\n      (failure) => {\n        this.handle_error(failure);\n      }\n    );\n  }\n\n  handle_cancel_mfa() {\n    this.step = 1;\n    this.mfaToken = '';\n    this.assumedRole = null; // Just in case\n  }\n\n  handle_exit_list() {\n    this.step = 1;\n    this.mfaToken = '';\n    this.assumedRole = null;\n    this.files = []; // Just in case\n  }\n\n  /** Handle an MFA login.\n   * Determine whether further action is necessary\n   */\n  handle_proceed_mfa() {\n    // Build our mfa params\n    const mfa: MFAInfo = {\n      SerialNumber: this.mfaSerial || null,\n      TokenCode: this.mfaToken\n    };\n\n    // Attempt to assume role based on if we've determined 2fa necessary\n    get_session_token(\n      this.accessToken,\n      this.secretToken,\n      AUTH_DURATION,\n      mfa\n    ).then(\n      (success) => {\n        // Keep them\n        this.assumedRole = success;\n        this.step = 3;\n      },\n      (failure) => {\n        this.handle_error(failure);\n      }\n    );\n  }\n\n  /** On mount, try to look up stored auth info */\n  mounted() {\n    // Load our session, if there is one\n    this.assumedRole = localSessionInformation.get_default(null);\n    if (this.assumedRole) {\n      this.step = 3;\n    }\n  }\n\n  /** Attempt to load.\n   * Basically just wraps fetch_files with error handling\n   */\n  async load_bucket(name: string) {\n    const s3 = new S3(this.assumedRole!.creds);\n    await s3\n      .listObjectsV2({\n        Bucket: name,\n        MaxKeys: 100\n      })\n      .promise()\n      .then((success) => {\n        this.files = success.Contents || [];\n      })\n      .catch((failure) => this.handle_error(failure));\n  }\n\n  /** Save the current credentials to local storage */\n  save_creds() {\n    localSessionInformation.set(this.assumedRole);\n  }\n\n  /** Callback to handle an AWS error.\n   * Sets shown error.\n   */\n  handle_error(error: AWSError): void {\n    const formattedError = transcribe_error(error);\n    // Toast whatever error we got\n    SnackbarModule.failure(formattedError);\n  }\n\n  /** Callback on got files */\n  got_files(files: Array<FileID>) {\n    this.$emit('got-files', files);\n  }\n}\n</script>\n\n",
    "/api/sources/raw?key=test:apps/frontend/src/store/data_filters.ts": "/**\n * This module provides a cached, reusable method for filtering data from data_store.\n */\n\nimport {Trinary} from '@/enums/Trinary';\nimport {InspecDataModule} from '@/store/data_store';\nimport {\n  FileID,\n  SourcedContextualizedEvaluation,\n  SourcedContextualizedProfile\n} from '@/store/report_intake';\nimport Store from '@/store/store';\nimport {\n  ContextualizedControl,\n  ContextualizedProfile,\n  ControlStatus,\n  NistControl,\n  Severity\n} from 'inspecjs';\nimport _ from 'lodash';\nimport LRUCache from 'lru-cache';\nimport {\n  Action,\n  getModule,\n  Module,\n  Mutation,\n  VuexModule\n} from 'vuex-module-decorators';\n\nconst MAX_CACHE_ENTRIES = 20;\n\nexport declare type ExtendedControlStatus = ControlStatus | 'Waived';\n\n/** Contains common filters on data from the store. */\nexport interface Filter {\n  // General\n  /** Which file these objects came from. Undefined => any */\n  fromFile: FileID[];\n\n  // Control specific\n  /** What status the controls can have. Undefined => any */\n  status?: ExtendedControlStatus[];\n\n  /** What severity the controls can have. Undefined => any */\n  severity?: Severity[];\n\n  /** Whether or not to allow/include overlayed controls */\n  omit_overlayed_controls?: boolean;\n\n  /** Control IDs to search for */\n  ids?: string[];\n\n  /** Titles to search for */\n  titleSearchTerms?: string[];\n\n  /** Descriptions to search for */\n  descriptionSearchTerms?: string[];\n\n  /** Code to search for */\n  codeSearchTerms?: string[];\n\n  /** CCIs to search for */\n  nistIdFilter?: string[];\n\n  /** A search term string, case insensitive\n   * We look for this in\n   * - control ID\n   * - rule title\n   * - severity\n   * - status\n   * - finding details (from HDF)\n   * - code\n   */\n  searchTerm?: string;\n\n  /** The current state of the Nist Treemap. Used to further filter by nist categories etc. */\n  treeFilters?: TreeMapState;\n\n  /** A specific control id */\n  control_id?: string;\n}\n\nexport type TreeMapState = string[]; // Representing the current path spec, from root\n\n/**\n * Facillitates the search functionality\n * @param term The string to search with\n * @param contextControl The control to search for term in\n */\nfunction contains_term(\n  contextControl: ContextualizedControl,\n  term: string\n): boolean {\n  const asHDF = contextControl.root.hdf;\n  // Get our (non-null) searchable data\n  const searchables: string[] = [\n    asHDF.wraps.id,\n    asHDF.wraps.title,\n    asHDF.wraps.code,\n    asHDF.severity,\n    asHDF.status,\n    asHDF.finding_details\n  ].filter((s) => s !== null) as string[];\n\n  // See if any contain term\n  return searchables.some((s) => s.toLowerCase().includes(term));\n}\n\n@Module({\n  namespaced: true,\n  dynamic: true,\n  store: Store,\n  name: 'filteredData'\n})\nexport class FilteredData extends VuexModule {\n  selectedEvaluationIds: FileID[] = [];\n  selectedProfileIds: FileID[] = [];\n\n  @Mutation\n  SELECT_EVALUATIONS(files: FileID[]): void {\n    this.selectedEvaluationIds = [\n      ...new Set([...files, ...this.selectedEvaluationIds])\n    ];\n  }\n\n  @Mutation\n  SELECT_PROFILES(files: FileID[]): void {\n    this.selectedProfileIds = [\n      ...new Set([...files, ...this.selectedProfileIds])\n    ];\n  }\n\n  @Mutation\n  CLEAR_EVALUATION(removeId: FileID): void {\n    this.selectedEvaluationIds = this.selectedEvaluationIds.filter(\n      (ids) => ids !== removeId\n    );\n  }\n\n  @Mutation\n  CLEAR_PROFILE(removeId: FileID): void {\n    this.selectedProfileIds = this.selectedProfileIds.filter(\n      (ids) => ids !== removeId\n    );\n  }\n\n  @Mutation\n  CLEAR_ALL_EVALUATIONS(): void {\n    this.selectedEvaluationIds = [];\n  }\n\n  @Mutation\n  CLEAR_ALL_PROFILES(): void {\n    this.selectedProfileIds = [];\n  }\n\n  @Action\n  public toggle_all_evaluations(): void {\n    if (this.all_evaluations_selected === Trinary.On) {\n      this.CLEAR_ALL_EVALUATIONS();\n    } else {\n      this.SELECT_EVALUATIONS(\n        InspecDataModule.allEvaluationFiles.map((v) => v.uniqueId)\n      );\n    }\n  }\n\n  @Action\n  public toggle_all_profiles(): void {\n    if (this.all_profiles_selected === Trinary.On) {\n      this.CLEAR_ALL_PROFILES();\n    } else {\n      this.SELECT_PROFILES(\n        InspecDataModule.allProfileFiles.map((v) => v.uniqueId)\n      );\n    }\n  }\n\n  @Action\n  public select_exclusive_evaluation(fileID: FileID): void {\n    this.CLEAR_ALL_EVALUATIONS();\n    this.SELECT_EVALUATIONS([fileID]);\n  }\n\n  @Action\n  public select_exclusive_profile(fileID: FileID): void {\n    this.CLEAR_ALL_PROFILES();\n    this.SELECT_PROFILES([fileID]);\n  }\n\n  @Action\n  public toggle_evaluation(fileID: FileID): void {\n    if (this.selectedEvaluationIds.includes(fileID)) {\n      this.CLEAR_EVALUATION(fileID);\n    } else {\n      this.SELECT_EVALUATIONS([fileID]);\n    }\n  }\n\n  @Action\n  public toggle_profile(fileID: FileID): void {\n    if (this.selectedProfileIds.includes(fileID)) {\n      this.CLEAR_PROFILE(fileID);\n    } else {\n      this.SELECT_PROFILES([fileID]);\n    }\n  }\n\n  @Action\n  public clear_file(fileID: FileID): void {\n    this.CLEAR_EVALUATION(fileID);\n    this.CLEAR_PROFILE(fileID);\n  }\n\n  /**\n   * Parameterized getter.\n   * Get all evaluations from the specified file ids\n   */\n  get evaluations(): (\n    files: FileID[]\n  ) => readonly SourcedContextualizedEvaluation[] {\n    return (files: FileID[]) => {\n      return InspecDataModule.contextualExecutions.filter((e) =>\n        files.includes(e.from_file.uniqueId)\n      );\n    };\n  }\n\n  get profiles_for_evaluations(): (\n    files: FileID[]\n  ) => readonly ContextualizedProfile[] {\n    return (files: FileID[]) => {\n      // Filter to those that match our filter. In this case that just means come from the right file id\n      return this.evaluations(files).flatMap(\n        (evaluation) => evaluation.contains\n      );\n    };\n  }\n\n  /**\n   * Parameterized getter.\n   * Get all profiles from the specified file ids.\n   */\n  get profiles(): (files: FileID[]) => readonly SourcedContextualizedProfile[] {\n    return (files: FileID[]) => {\n      return InspecDataModule.contextualProfiles.filter((e) => {\n        return files.includes(e.from_file.uniqueId);\n      });\n    };\n  }\n\n  get selected_file_ids(): FileID[] {\n    return [...this.selectedEvaluationIds, ...this.selectedProfileIds];\n  }\n\n  // check to see if all profiles are selected\n  get all_profiles_selected(): Trinary {\n    switch (this.selectedProfileIds.length) {\n      case 0:\n        return Trinary.Off;\n      case InspecDataModule.allProfileFiles.length:\n        return Trinary.On;\n      default:\n        return Trinary.Mixed;\n    }\n  }\n\n  // check to see if all evaluations are selected\n  get all_evaluations_selected(): Trinary {\n    switch (this.selectedEvaluationIds.length) {\n      case 0:\n        return Trinary.Off;\n      case InspecDataModule.allEvaluationFiles.length:\n        return Trinary.On;\n      default:\n        return Trinary.Mixed;\n    }\n  }\n\n  /**\n   * Parameterized getter.\n   * Get all controls from all profiles from the specified file id.\n   * Utlizes the profiles getter to accelerate the file filter.\n   */\n  get controls(): (filter: Filter) => readonly ContextualizedControl[] {\n    /** Cache by filter */\n    const localCache: LRUCache<string, readonly ContextualizedControl[]> =\n      new LRUCache(MAX_CACHE_ENTRIES);\n\n    return (filter: Filter) => {\n      // Generate a hash for cache purposes.\n      // If the \"searchTerm\" string is not null, we don't cache - no need to pollute\n      const id: string = filter_cache_key(filter);\n\n      // Check if we have this cached:\n      const cached = localCache.get(id);\n      if (cached !== undefined) {\n        return cached;\n      }\n\n      // Get profiles from loaded Results\n      let profiles: readonly ContextualizedProfile[] =\n        this.profiles_for_evaluations(filter.fromFile);\n\n      // Get profiles from loaded Profiles\n      profiles = profiles.concat(this.profiles(filter.fromFile));\n\n      // And all the controls they contain\n      let controls: readonly ContextualizedControl[] = profiles.flatMap(\n        (profile) => profile.contains\n      );\n\n      // Filter by single control id\n      if (filter.control_id !== undefined) {\n        controls = controls.filter((c) => c.data.id === filter.control_id);\n      }\n\n      const controlFilters: Record<\n        string,\n        boolean | Array<string> | undefined\n      > = {\n        'root.hdf.severity': filter.severity,\n        'hdf.wraps.id': filter.ids,\n        'hdf.wraps.title': filter.titleSearchTerms,\n        'hdf.wraps.desc': filter.descriptionSearchTerms,\n        'hdf.raw_nist_tags': filter.nistIdFilter,\n        full_code: filter.codeSearchTerms,\n        'hdf.waived': filter.status?.includes('Waived'),\n        'root.hdf.status': _.filter(\n          filter.status,\n          (status) => status !== 'Waived'\n        )\n      };\n\n      controls = filterControlsBy(controls, controlFilters);\n\n      // Filter by overlay\n      if (filter.omit_overlayed_controls) {\n        controls = controls.filter(\n          (control) => control.extendedBy.length === 0\n        );\n      }\n\n      // Freeform search\n      if (filter.searchTerm !== undefined) {\n        const term = filter.searchTerm.toLowerCase();\n\n        // Filter controls to those that contain search term\n        controls = controls.filter((c) => contains_term(c, term));\n      }\n\n      // Filter by nist stuff\n      if (filter.treeFilters && filter.treeFilters.length > 0) {\n        // Construct a nist control to represent the filter\n        const control = new NistControl(filter.treeFilters);\n\n        controls = controls.filter((c) => {\n          // Get an hdf version so we have the fixed nist tags\n          return c.root.hdf.parsedNistTags.some((t) => control.contains(t));\n        });\n      }\n\n      // Freeze and save to cache\n      const r = Object.freeze(controls);\n      localCache.set(id, r);\n      return r;\n    };\n  }\n}\n\nexport const FilteredDataModule = getModule(FilteredData);\n\n/**\n * Generates a unique string to represent a filter.\n * Does some minor \"acceleration\" techniques such as\n * - annihilating empty search terms\n * - defaulting \"omit_overlayed_controls\"\n */\nexport function filter_cache_key(f: Filter) {\n  const newFilter: Filter = {\n    searchTerm: f.searchTerm?.trim() || '',\n    omit_overlayed_controls: f.omit_overlayed_controls || false,\n    ...f\n  };\n  return JSON.stringify(newFilter);\n}\n\nexport function filterControlsBy(\n  controls: readonly ContextualizedControl[],\n  filters: Record<string, boolean | Array<string> | undefined>\n): readonly ContextualizedControl[] {\n  const activeFilters: typeof filters = _.pickBy(\n    filters,\n    (value, _key) =>\n      (Array.isArray(value) && value.length > 0) ||\n      (typeof value === 'boolean' && value)\n  );\n  return controls.filter((control) => {\n    return Object.entries(activeFilters).every(([filter, value]) => {\n      const item: string | string[] | boolean = _.get(control, filter);\n      if (Array.isArray(value) && typeof item !== 'boolean') {\n        return value?.some((term) => {\n          return arrayOrStringIncludes(item, (compareValue) =>\n            compareValue.toLowerCase().includes(term.toLowerCase())\n          );\n        });\n      } else {\n        return item === value;\n      }\n    });\n  });\n}\n\n/** Iterate over a string or array of strings and call the string compare function provided on every element **/\nfunction arrayOrStringIncludes(\n  arrayOrString: string | string[],\n  comparator: (compareValue: string) => boolean\n) {\n  if (typeof arrayOrString === 'string') {\n    return comparator(arrayOrString);\n  } else {\n    return arrayOrString.some((value) => comparator(value));\n  }\n}\n\n",
    "/api/sources/raw?key=test:apps/frontend/src/utilities/format_util.ts": "/**\n * Functions for formatting items to have unique keys. Principally used for vuex v-for key generation.\n */\n\nimport {isFromProfileFile} from '@/store/data_store';\nimport {\n  SourcedContextualizedEvaluation,\n  SourcedContextualizedProfile\n} from '@/store/report_intake';\nimport {ContextualizedControl} from 'inspecjs';\n\nexport function execution_unique_key(\n  exec: Readonly<SourcedContextualizedEvaluation>\n): string {\n  return `exec_${exec.from_file.uniqueId}`;\n}\n\n/**\n * Generates a unique key for the given profile\n * @param profile\n */\nexport function profile_unique_key(\n  profile: Readonly<SourcedContextualizedProfile>\n): string {\n  if (isFromProfileFile(profile)) {\n    return `profile_${profile.from_file.uniqueId}`;\n  } else {\n    return `${execution_unique_key(\n      profile.sourcedFrom as SourcedContextualizedEvaluation\n    )}-${profile.data.name}`;\n  }\n}\n\n/**\n * Generates a unique key for the given control\n * @param ctrl The control to generate the key for\n */\nexport function control_unique_key(\n  ctrl: Readonly<ContextualizedControl>\n): string {\n  return `${profile_unique_key(\n    ctrl.sourcedFrom as Readonly<SourcedContextualizedProfile>\n  )}-${ctrl.data.id}`;\n}\n\n",
    "/api/sources/raw?key=test:libs/inspecjs/src/context.ts": "/**\n * Provides general utilities for articulating associations beteen evaluations, profiles, and controls.\n * Especially useful for handling overlay/wrapper profiles.\n */\n\nimport {HDFControl, hdfWrapControl} from './compat_wrappers';\nimport {\n  AnyControl,\n  AnyEval,\n  AnyEvalControl,\n  AnyEvalProfile,\n  AnyProfile\n} from './fileparse';\n\n/**\n * Mixin type to express that this type wraps another data type to add additional fields,\n * without modifying the inner type.\n */\ninterface WrapsType<Data> {\n  data: Data;\n}\n\n/**\n * Mixin type to express that this type has some sort \"parent\".\n * Sort of an inverse to the Contains mixin.\n * E.g. A control is sourced from a profile, and an execution is from a file.\n */\ninterface Sourced<From> {\n  sourcedFrom: From;\n}\n\n/**\n * Mixin type to express that this type has some sort of directional dependency-graph with members of a (usually the same) type.\n * For instance, profiles overlay/are overlayed by profiles.\n * Controls override behavior/are overrideen by other controls\n */\ninterface Extendable<By> {\n  /**\n   * What is this data extended by?\n   * E.g. a profile that overlays this profile.\n   * Can be empty.\n   */\n  extendedBy: By[];\n\n  /**\n   * What data is this node extending?\n   * E.g. is this overlaying a profile? Another control?\n   * Can be empty.\n   */\n  extendsFrom: By[];\n}\n\n/**\n * Mixin type to express that this type is primarily a parent to some other data.\n * For instance, profiles are most directly a parent of controls .\n * What objects/resources does this item contain?\n */\ninterface Contains<Item> {\n  contains: Item;\n}\n\n// Create our three primary data types from the above mixins\n// Essentially this is just describing the parent/child relationships each type has\nexport interface ContextualizedEvaluation\n  extends WrapsType<AnyEval>,\n    Contains<ContextualizedProfile[]> {}\n\nexport interface ContextualizedProfile\n  extends WrapsType<AnyProfile>,\n    Sourced<ContextualizedEvaluation | null>,\n    Contains<ContextualizedControl[]>,\n    Extendable<ContextualizedProfile> {}\nexport interface ContextualizedControl\n  extends WrapsType<AnyControl>,\n    Sourced<ContextualizedProfile>,\n    Extendable<ContextualizedControl> {\n  /** The HDF version of this particular control */\n  hdf: HDFControl;\n\n  /** Drills down to this controls root CC. In general you should use this for all data operations */\n  root: ContextualizedControl;\n\n  /** Yields the full code of this control, by concatenating overlay code. */\n  full_code: string;\n}\n\nclass ContextualizedControlImp implements ContextualizedControl {\n  // Imp stuff\n  data: AnyControl;\n  sourcedFrom: ContextualizedProfile;\n  extendsFrom: ContextualizedControl[];\n  extendedBy: ContextualizedControl[];\n  hdf: HDFControl;\n\n  constructor(\n    data: AnyControl,\n    sourcedFrom: ContextualizedProfile,\n    extendedBy: ContextualizedControl[],\n    extendsFrom: ContextualizedControl[]\n  ) {\n    // Simple save\n    this.data = data;\n    this.sourcedFrom = sourcedFrom;\n    this.hdf = hdfWrapControl(data);\n    this.extendedBy = extendedBy;\n    this.extendsFrom = extendsFrom;\n  }\n\n  get root(): ContextualizedControl {\n    if (this.extendsFrom.length) {\n      return this.extendsFrom[0].root;\n    }\n    return this;\n  }\n\n  /** Returns whether this control is just a duplicate of base/root (but is not itself root) */\n  get is_redundant(): boolean {\n    return (\n      !this.data.code ||\n      this.data.code.trim() === '' ||\n      (this.extendsFrom.length > 0 && this.data.code === this.root.data.code)\n    );\n  }\n\n  get full_code(): string {\n    // If we extend from something, we behave slightly differently\n    if (this.extendsFrom.length) {\n      const ancestor = this.extendsFrom[0];\n      if (this.is_redundant) {\n        return ancestor.full_code;\n      } else {\n        return `\\\n=========================================================\n# Profile name: ${this.sourcedFrom.data.name}\n=========================================================\n\n${this.data.code}\n\n${this.extendsFrom[0].full_code}`.trim();\n      }\n    } else {\n      // We are the endpoint\n      return `\\\n=========================================================\n# Profile name: ${this.sourcedFrom.data.name}\n=========================================================\n\n${this.data.code}`.trim();\n    }\n  }\n}\n\nexport function contextualizeEvaluation(\n  evaluation: AnyEval\n): ContextualizedEvaluation {\n  // To begin, create basic context for profiles and evaluation\n  const evalContext: ContextualizedEvaluation = {\n    data: evaluation,\n    contains: []\n  };\n\n  for (const profile of evaluation.profiles) {\n    const evalProfileContext: ContextualizedProfile = {\n      data: profile,\n      sourcedFrom: evalContext,\n      extendedBy: [],\n      extendsFrom: [],\n      contains: []\n    };\n\n    // Add it to our parent\n    evalContext.contains.push(evalProfileContext);\n  }\n\n  // After our initial save of profiles, we go over them again to establish parentage/dependency\n  for (const profile of evalContext.contains) {\n    // We know these are from a report; label as such\n    const asExec = profile.data as AnyEvalProfile;\n\n    // If it has a parent profile then we link them by extendedby/extendsfrom\n    if (asExec.parent_profile !== undefined) {\n      // Look it up\n      const parent = evalContext.contains.find(\n        (p) => p.data.name === asExec.parent_profile\n      );\n\n      // Link it up\n      if (parent) {\n        parent.extendsFrom.push(profile);\n        profile.extendedBy.push(parent);\n      }\n    }\n  }\n\n  // Next step: Extract controls and connect them\n  // Extract the controls and set them as the \"contained\" data for each profile\n  // These ContextualizedControls are basically empty - just have data and from where they were sourced\n  const allControls: ContextualizedControl[] = [];\n  for (const profile of evalContext.contains) {\n    const pControls = profile.data.controls as AnyEvalControl[];\n    profile.contains = pControls.map((c) => {\n      return new ContextualizedControlImp(c, profile, [], []);\n    });\n    allControls.push(...profile.contains);\n  }\n\n  // Link each contextualized control\n  for (const cc of allControls) {\n    // Behaviour changes based on if we have well-formed or malformed profile dependency\n    if (cc.sourcedFrom.extendsFrom.length || cc.sourcedFrom.extendedBy.length) {\n      // Our profile is a baseline! No need to continue - children will make connections for us\n      // If we aren't extended from something we just drop. Our children will make connections for us\n      if (cc.sourcedFrom.extendsFrom.length === 0) {\n        continue;\n      }\n\n      // Get the profile(s) that this control's owning profile is extending\n      // For a wrapper profile, there might be many of these!\n      // We don't know which one it will be, so we iterate\n      for (const extendedProfile of cc.sourcedFrom.extendsFrom) {\n        // Hunt for its ancestor in the extended profile\n        const ancestor = extendedProfile.contains.find(\n          (c) => c.data.id === cc.data.id\n        );\n        // First one we find with a matching id we assume is the root (or at least, closer to root)\n        if (ancestor) {\n          ancestor.extendedBy.push(cc);\n          cc.extendsFrom.push(ancestor);\n          break; // Note that we're in a nested loop here\n        }\n      }\n      // If it's not found, then we just assume it does not exist!\n    } else {\n      // If we don't have a normal profile dependency layout, then we have to hunt ye-olde-fashioned-way\n      // Unfortunately, if theres more than 2 profiles there's ultimately no way to figure out which one was applied \"last\".\n      // This method leaves them as siblings. However, as a fallback method that is perhaps the best we can hope for\n      // First, hunt out all controls from this file that have the same id as cc\n      const sameId = allControls.filter((c) => c.data.id === cc.data.id);\n      // Find which of them, if any, is populated with results.\n      let sameIdPopulated = sameId.find(\n        (c) => c.hdf.segments && c.hdf.segments.length\n      );\n\n      // If found a populated base, use that. If not, we substitute in the first found element in sameId. This is arbitrary.\n      if (!sameIdPopulated) {\n        sameIdPopulated = sameId[0];\n      }\n\n      // If the object we end up with is \"us\", then just ignore\n      if (Object.is(cc, sameIdPopulated)) {\n        continue;\n      } else {\n        // Otherwise, bind\n        sameIdPopulated.extendedBy.push(cc);\n        cc.extendsFrom.push(sameIdPopulated);\n      }\n    }\n  }\n  return evalContext;\n}\n\n// Here we handle the independent profile (IE those in their own files, generated by inspec json).\n// These are slightly simpler because they do not actually include their overlays (even if they depend on them)\n// as a separate data structure.\n// As such, we can just do all the profile and controls from each in one fell swoop\nexport function contextualizeProfile(\n  profile: AnyProfile\n): ContextualizedProfile {\n  const profileContext: ContextualizedProfile = {\n    data: profile,\n    extendedBy: [],\n    extendsFrom: [],\n    contains: [],\n    sourcedFrom: null\n  };\n\n  // Now give it its controls\n  for (const c of profile.controls) {\n    const result = new ContextualizedControlImp(c, profileContext, [], []);\n    profileContext.contains.push(result);\n  }\n\n  return profileContext;\n}\n\n",
    "/api/sources/raw?key=test:libs/inspecjs/src/nist.ts": "import {ControlStatus} from './compat_wrappers';\nimport {ALL_NIST_CONTROL_NUMBERS, ALL_NIST_FAMILIES} from './raw_nist';\n\n// Regexes.\nconst NIST_FAMILY_RE = /^[A-Z]{2}$/;\n// Limit length of children to avoid potential DoS on malicious NIST Control strings\nconst NIST_CONTROL_RE = /^([A-Z]{2})-([0-9]+)(.{0,60})$/;\nconst SPEC_SPLITTER = /[\\s\\(\\)\\.]+/; // Includes all whitespace, periods, and parenthesis\nconst REV_RE = /^rev[\\s_.]+(\\d+)$/i; // Matches Rev_5 etc\ntype ParseNist = NistControl | NistRevision | null;\n\nexport interface CanonizationConfig {\n  max_specifiers: number;\n\n  // All are assumed false\n  pad_zeros?: boolean; // default false\n  allow_letters?: boolean; // default true\n  add_spaces?: boolean; // default true\n  add_parens?: boolean; // default true\n  add_periods?: boolean; // default true\n}\n\nfunction default_partial_config(c: CanonizationConfig): CanonizationConfig {\n  return {\n    pad_zeros: false,\n    allow_letters: true,\n    add_spaces: true,\n    add_parens: true,\n    add_periods: true,\n    ...c\n  };\n}\n\n/** Represents a single nist control, or group of controls if the sub specs are vague enoug. */\nexport class NistControl {\n  /** The sequence of sub-specifiers making up the \"parts\" of the nist tags\n   * E.g.  in \"SI-7 (14)(b)\", we would have [\"SI\", \"7\", \"14\", \"b\"]\n   *       in \"SI-4a.2.\", we would have [\"SI\", \"4\", \"a, \"2\"];\n   * First element is guaranteed to be a 2-letter family\n   * Note that we strip punctuation\n   */\n  subSpecifiers: string[]; // Guaranteed to be of length at least one on a \"real\" control\n\n  /** Holds the string from which this control was generated. */\n  rawText?: string;\n\n  /** Trivial constructor */\n  constructor(subSpecs: string[], rawRext?: string) {\n    this.subSpecifiers = subSpecs;\n    this.rawText = rawRext;\n  }\n\n  /** This function checks if the given control is contained by or equivalent to this control.\n   * It is purely a wrapper around compare_lineage\n   */\n  contains(other: NistControl): boolean {\n    return this.compare_lineage(other) !== -1;\n  }\n\n  /** This function compares this nist control to another nist control.\n   * If the other control is the same control as this one, returns 0.\n   *\n   * If the other control is a child of this control\n   * (IE it is the same base directives with further enhancements, e.g. `IA-4` -> `IA-4b.` or `AC-9a.` -> `AC-9a. (2)`)\n   * and returns how many further enhancements have been applied (IE what is the number of additional subdirectives.)\n   *\n   * If the other control is NOT a child of this control, return -1\n   */\n  compare_lineage(other: NistControl): number {\n    // Can't contain if we're more specific\n    if (this.subSpecifiers.length > other.subSpecifiers.length) {\n      return -1;\n    }\n\n    // After that we just need to iterate\n    for (let i = 0; i < this.subSpecifiers.length; i++) {\n      // If our subspec differentiate at any point, then we do not match\n      if (this.subSpecifiers[i] !== other.subSpecifiers[i]) {\n        return -1;\n      }\n    }\n\n    // We survived! The change in # sub specs is thus the # of changes to enhancements\n    return other.subSpecifiers.length - this.subSpecifiers.length;\n  }\n\n  /** Gives a numeric value indicating how these controls compare, lexicographically.\n   * See string.localCompare for the output format.\n   */\n  localCompare(other: NistControl): number {\n    // Convert into a chain of directives\n    const aChain = this.subSpecifiers;\n    const bChain = other.subSpecifiers;\n    for (let i = 0; i < aChain.length && i < bChain.length; i++) {\n      // Compare corresponding elements of the chain\n      const idA = aChain[i];\n      const idB = bChain[i];\n\n      // Return only if significant\n      const lc = idA.localeCompare(idB, 'en', {numeric: true});\n      if (lc) {\n        return lc;\n      }\n    }\n\n    // Fall back to length comparison. We want shorter first, so ascending's good\n    return aChain.length - bChain.length;\n  }\n\n  /**\n   * Quick accessor to the leading family letters for the nsit control\n   */\n  get family(): string | undefined {\n    if (this.subSpecifiers.length) {\n      return this.subSpecifiers[0];\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * Returns the \"canonical\" representation of this control, based on the provided parameters.\n   * This is, unfortunately, slightly expensive.\n   * Avoid repeating this if possible.\n   */\n  canonize(config: CanonizationConfig): string {\n    config = default_partial_config(config);\n    const ss = this.subSpecifiers;\n\n    // Build our string. Start with family\n    let s = this.family || '';\n    if (ss.length > 1) {\n      s += '-';\n    }\n\n    for (let i = 1; i < ss.length && i < config.max_specifiers; i++) {\n      let spec = ss[i];\n\n      // Handle numbers\n      if (!Number.isNaN(Number.parseInt(spec))) {\n        // If we need to, pad zeros\n        if (config.pad_zeros && spec.length < 2) {\n          spec = '0' + spec;\n        }\n\n        // If index past 1, wrap in parens\n        if (i > 1) {\n          if (config.add_parens) {\n            spec = `(${spec})`;\n          }\n\n          // If space, add space\n          if (config.add_spaces) {\n            spec = ' ' + spec;\n          }\n        }\n\n        // Append\n        s += spec;\n      } else if (config.allow_letters) {\n        // It's a letter. Add a .\n        if (config.add_spaces) {\n          s += ' ';\n        }\n        s += spec;\n        if (config.add_periods) {\n          s += '.';\n        }\n      }\n    }\n    return s;\n  }\n}\n\n/** Wrapper around a revision number. Currently has no additional functionality, but this may change. */\nexport class NistRevision {\n  revNum: number;\n  constructor(revNum: number) {\n    this.revNum = revNum;\n  }\n}\n\nexport function parse_nist(rawNist: string): ParseNist {\n  // Is it a revision? Get the match, continuing if none\n  const revMatch = rawNist.match(REV_RE);\n  if (revMatch) {\n    return new NistRevision(Number.parseInt(revMatch[1]));\n  }\n  // Is it just a family?\n  // Get the match, failing out if we can't\n  const famMatch = rawNist.match(NIST_FAMILY_RE);\n  if (famMatch) {\n    return new NistControl([famMatch[0]], famMatch[0]);\n  }\n\n  // Next try it as a full control\n  const fullMatch = rawNist.match(NIST_CONTROL_RE);\n  if (!fullMatch) {\n    return null;\n  }\n\n  // Parse sub-elements\n  const family = fullMatch[1];\n  const controlNum = fullMatch[2];\n  const subspecsRaw = (fullMatch[3] || '').trim();\n\n  // Init sub-specs\n  const subSpecs: string[] = [family, controlNum];\n\n  // Filter garbage from subspecsRaw\n  let subspecsSplit = subspecsRaw.split(SPEC_SPLITTER);\n  subspecsSplit = subspecsSplit.filter((s) => s !== '');\n  return new NistControl(subSpecs.concat(subspecsSplit), rawNist);\n}\n\n/** Simple discriminators */\nexport function is_control(\n  x: NistControl | NistRevision | null\n): x is NistControl {\n  if (x && (x as NistControl).subSpecifiers !== undefined) {\n    return true;\n  }\n  return false;\n}\n\n/** Simple discriminators */\nexport function is_revision(\n  x: NistControl | NistRevision | null\n): x is NistRevision {\n  if (x && (x as NistRevision).revNum !== undefined) {\n    return true;\n  }\n  return false;\n}\n\n/** All a control in a nist hash really needs is a status */\nexport interface CategoryItemRequirements {\n  status: ControlStatus;\n}\n\n// Represents the status of a group of controsl. Typically holds the value of the \"worst\" control amongst the group\n// Empty means no controls are in the given group\nexport type ControlGroupStatus = ControlStatus | 'Empty';\n\n/**\n * Computes the groups status having added control.\n * There's a natural precedence to statuses, at least in a list/group\n * For instance, we would not mark a group as Passed if it contained a Failed.\n * Clearly \"Empty\" is the lowest precedence, as adding any control would wipe it out.\n * Following we have \"From Profile\" since it is in some way the absence of status, but also lacks run context. We care more about literally anything else\n * Next, \"Not Applicable\" since it means that though we ran we don't care about the result\n * \"Not Reviewed\" implies that had the test run it would've mattered, but it was skipped deliberately\n * \"No Data\" is similarly a lack of result, but in this case unexpected, and thus worthy of more scrutiny\n * \"Passed\" means that a test passed! But \"Failed\" should override, since fails are really what we're looking for\n * Finally, \"Profile Errors\" mean something is broken and needs to be fixed, and thus overrides all\n *\n * Returns:\n * < 0  if a < b (by the above criteria)\n * 0    if a === b\n * > 0  if a > b\n */\nexport function compare_statuses(\n  a: ControlGroupStatus,\n  b: ControlGroupStatus\n): number {\n  const precedence: ControlGroupStatus[] = [\n    'Empty',\n    'From Profile',\n    'Not Applicable',\n    'Not Reviewed',\n    'Passed',\n    'Failed',\n    'Profile Error'\n  ];\n  const idA = precedence.indexOf(a);\n  const idB = precedence.indexOf(b);\n  return idA - idB;\n}\n\nexport function updateStatus(\n  group: ControlGroupStatus,\n  control: ControlStatus\n): ControlGroupStatus {\n  if (compare_statuses(group, control) > 0) {\n    // Our new control has shifted the status!\n    return control;\n  } else {\n    // Our existing group status was \"greater\"\n    return group;\n  }\n}\n\nexport interface NistHierarchyNode {\n  control: NistControl;\n  children: NistHierarchyNode[];\n}\nexport type NistHierarchy = NistHierarchyNode[];\n\nfunction _control_parent(c: NistControl): NistControl | null {\n  if (c.subSpecifiers.length) {\n    return new NistControl(\n      c.subSpecifiers.slice(0, c.subSpecifiers.length - 1)\n    );\n  } else {\n    return null; // Can't get any shorter\n  }\n}\n\nfunction _key_for(c: NistControl): string {\n  return c.subSpecifiers.join('-');\n}\n\nfunction _generate_full_nist_hierarchy(): NistHierarchy {\n  // Initialize our roots\n  const roots: NistHierarchy = ALL_NIST_FAMILIES.map((family) => {\n    return {\n      control: new NistControl([family], family),\n      children: []\n    };\n  });\n\n  // Init our map, which maps _key_for of controls to their corresponding hierarchy nodes\n  const map: {[key: string]: NistHierarchyNode} = {};\n\n  // Add roots to the map\n  roots.forEach((r) => {\n    map[_key_for(r.control)] = r;\n  });\n\n  // Iterate over all controls\n  ALL_NIST_CONTROL_NUMBERS.forEach((n) => {\n    const asControl = parse_nist(n) as NistControl | null; // We know there are no revs in our file\n    if (!asControl) {\n      throw new Error(`Invalid nist control constant ${n}`);\n    }\n\n    // If our node has already been created, replace the temporary control with the \"real\" one\n    const key = _key_for(asControl);\n    let asNode: NistHierarchyNode;\n    if (map[key]) {\n      asNode = map[key];\n      asNode.control = asControl;\n    } else {\n      //Make it fresh\n      asNode = {\n        control: asControl,\n        children: []\n      };\n\n      // Register in map\n      map[key] = asNode;\n    }\n\n    const parent = _control_parent(asControl);\n\n    // If parent is null, add to roots.\n    if (!parent) {\n      roots.push({\n        control: asControl,\n        children: []\n      });\n    } else {\n      // Valid parent; look it up and append us to it\n      const parentKey = _key_for(parent);\n      const parentNode = map[parentKey];\n\n      // If parent has been explored already, simply append this node to that\n      if (parentNode) {\n        parentNode.children.push(asNode);\n      } else {\n        // It's not? make a stub\n        map[parentKey] = {\n          control: parent,\n          children: [asNode] // \"Us\"\n        };\n      }\n    }\n  });\n\n  // Now roots are our final answers!\n  return roots;\n}\n\nexport const FULL_NIST_HIERARCHY: Readonly<NistHierarchy> =\n  _generate_full_nist_hierarchy();\n\n",
    "/api/sources/raw?key=test:apps/frontend/src/store/data_store.ts": "/**\n * Tracks uploaded files, and their parsed contents\n */\n\nimport {\n  EvaluationFile,\n  FileID,\n  ProfileFile,\n  SourcedContextualizedEvaluation,\n  SourcedContextualizedProfile\n} from '@/store/report_intake';\nimport Store from '@/store/store';\nimport {\n  Action,\n  getModule,\n  Module,\n  Mutation,\n  VuexModule\n} from 'vuex-module-decorators';\nimport {FilteredDataModule} from './data_filters';\n\n/** We make some new variant types of the Contextual types, to include their files*/\nexport function isFromProfileFile(p: SourcedContextualizedProfile) {\n  return p.sourcedFrom === null;\n}\n\n@Module({\n  namespaced: true,\n  dynamic: true,\n  store: Store,\n  name: 'data'\n})\nexport class InspecData extends VuexModule {\n  /** State var containing all execution files that have been added */\n  executionFiles: EvaluationFile[] = [];\n\n  /** State var containing all profile files that have been added */\n  profileFiles: ProfileFile[] = [];\n\n  /** Return all of the files that we currently have. */\n  get allFiles(): (EvaluationFile | ProfileFile)[] {\n    const result: (EvaluationFile | ProfileFile)[] = [];\n    result.push(...this.executionFiles);\n    result.push(...this.profileFiles);\n    return result;\n  }\n\n  /* Return all evaluation files only */\n  get allEvaluationFiles(): EvaluationFile[] {\n    return this.executionFiles;\n  }\n\n  /* Return all profile files only */\n  get allProfileFiles(): ProfileFile[] {\n    return this.profileFiles;\n  }\n\n  /**\n   * Returns a readonly list of all executions currently held in the data store\n   * including associated context\n   */\n  get contextualExecutions(): readonly SourcedContextualizedEvaluation[] {\n    return this.executionFiles.map((file) => file.evaluation);\n  }\n\n  get loadedDatabaseIds(): string[] {\n    const ids: string[] = [];\n    this.allFiles.forEach((file) => {\n      if (file.database_id) {\n        ids.push(file.database_id.toString());\n      }\n    });\n    return ids;\n  }\n\n  /**\n   * Returns a readonly list of all profiles belonging to executions currently\n   * held in the data store\n   */\n  get contextualExecutionProfiles(): readonly SourcedContextualizedProfile[] {\n    return this.contextualExecutions.flatMap(\n      (evaluation) => evaluation.contains\n    ) as SourcedContextualizedProfile[];\n  }\n\n  /**\n   * Returns a readonly list of all profiles currently held in the data store\n   * including associated context\n   */\n  get contextualProfiles(): readonly SourcedContextualizedProfile[] {\n    return this.profileFiles.map((file) => file.profile);\n  }\n\n  get allProfiles(): readonly SourcedContextualizedProfile[] {\n    return this.contextualProfiles.concat(this.contextualExecutionProfiles);\n  }\n\n  /**\n   * Adds a profile file to the store.\n   * @param newProfile The profile to add\n   */\n  @Mutation\n  addProfile(newProfile: ProfileFile) {\n    this.profileFiles.push(newProfile);\n  }\n\n  /**\n   * Adds an execution file to the store.\n   * @param newExecution The execution to add\n   */\n  @Mutation\n  addExecution(newExecution: EvaluationFile) {\n    this.executionFiles.push(newExecution);\n  }\n\n  /**\n   * Unloads the file with the given id\n   */\n  @Action\n  removeFile(fileId: FileID) {\n    FilteredDataModule.clear_file(fileId);\n    this.context.commit('REMOVE_PROFILE', fileId);\n    this.context.commit('REMOVE_RESULT', fileId);\n  }\n\n  @Mutation\n  REMOVE_PROFILE(fileId: FileID) {\n    this.profileFiles = this.profileFiles.filter(\n      (pf) => pf.uniqueId !== fileId\n    );\n  }\n\n  @Mutation\n  REMOVE_RESULT(fileId: FileID) {\n    this.executionFiles = this.executionFiles.filter(\n      (ef) => ef.uniqueId !== fileId\n    );\n  }\n\n  /**\n   * Clear all stored data.\n   */\n  @Mutation\n  reset() {\n    this.profileFiles = [];\n    this.executionFiles = [];\n  }\n}\n\nexport const InspecDataModule = getModule(InspecData);\n\n",
    "/api/sources/raw?key=test:apps/frontend/src/components/cards/treemap/Cell.vue": "<template>\n  <!-- We can use Vue transitions too! -->\n  <g>\n    <!-- Generate our children here. Only do so for parents, and if they aren't too deep -->\n    <g v-if=\"is_parent\">\n      <Cell\n        v-for=\"child in node.children\"\n        :key=\"child.data.key\"\n        :selected-control-id=\"selectedControlId\"\n        :depth=\"depth + 1\"\n        :node=\"child\"\n        :scales=\"scales\"\n        @select-node=\"select_node\"\n      />\n    </g>\n\n    <!-- The actual body of this square. Visible only if depth === 1 (ie a direct child of parent) or depth === 2 (one level deeper) -->\n    <rect\n      v-if=\"depth >= 1\"\n      :style=\"cell_style\"\n      :x=\"x\"\n      :y=\"y\"\n      :width=\"width\"\n      :height=\"height\"\n      :class=\"cell_classes\"\n      :rx=\"is_selected ? 20 : 0\"\n      @click=\"select_node(node)\"\n    />\n\n    <text\n      v-if=\"depth === 1\"\n      dominant-baseline=\"middle\"\n      text-anchor=\"middle\"\n      :x=\"x + width / 2\"\n      :y=\"y + height / 2\"\n      >{{ node.data.title }}</text\n    >\n  </g>\n</template>\n\n<script lang=\"ts\">\nimport {is_leaf, TreemapNode, TreemapNodeLeaf} from '@/utilities/treemap_util';\nimport * as d3 from 'd3';\nimport Vue from 'vue';\nimport Component from 'vue-class-component';\nimport {Prop} from 'vue-property-decorator';\n\nexport interface XYScale {\n  scale_x: d3.ScaleLinear<number, number>;\n  scale_y: d3.ScaleLinear<number, number>;\n}\n\n/**\n * Categories property must be of type Category\n * Emits \"select-node\" with payload of type d3.HierarchyRectangularNode<TreemapNode>\n */\n@Component({\n  name: 'Cell'\n})\nexport default class Cell extends Vue {\n  @Prop({type: String}) readonly selectedControlId!: string;\n  @Prop({type: Object, required: true})\n  readonly node!: d3.HierarchyRectangularNode<TreemapNode>;\n\n  @Prop({type: Number, default: 0}) readonly depth!: number;\n  @Prop({type: Object, default: 0}) readonly scales!: XYScale;\n\n  scale = 1.0;\n\n  /** Are we a control? Use treemap util type checker */\n  get is_control(): boolean {\n    return is_leaf(this.node.data);\n  }\n\n  /** Invert of above. Checks if this node has children, essentially */\n  get is_parent(): boolean {\n    return !this.is_control;\n  }\n\n  /** Are we selected? True if selectedControlId matches our id, and we are in selected hierarchy */\n  get is_selected(): boolean {\n    return (\n      this.is_control && // We are a control\n      (this.node.data as TreemapNodeLeaf).control.data.id ===\n        this.selectedControlId // Our control id matches\n    );\n  }\n\n  /** Compute the top-left x coord of this cell rect based on the provided scale_x prop */\n  get x(): number {\n    return this.scales.scale_x(this.node.x0);\n  }\n\n  /** Compute the top-left y coord of this cell rect based on the provided scale_y prop */\n  get y(): number {\n    return this.scales.scale_y(this.node.y0);\n  }\n\n  /**\n   * Compute the width of this rect based on scale, and base x position\n   */\n  get width(): number {\n    return this.scales.scale_x(this.node.x1) - this.x;\n  }\n\n  /**\n   * Compute the height of this rect based on scale, and base y position\n   */\n  get height(): number {\n    return this.scales.scale_y(this.node.y1) - this.y;\n  }\n\n  /** Returns a list of classes appropriate to this nodes Rect\n   * These are contextual based on type of data, and depth within the tree\n   */\n  get cell_classes(): string[] {\n    const s: string[] = [];\n    if (this.is_parent) {\n      s.push('parent');\n      if (!this.node.children || !this.node.children.length) {\n        s.push('empty');\n      }\n    } else {\n      s.push('leaf');\n    }\n\n    // Depth stuff\n    if (this.depth === 0) {\n      s.push('root');\n    } else if (this.depth === 1) {\n      s.push('top');\n    } else if (this.depth >= 1) {\n      s.push('nested');\n    }\n\n    return s;\n  }\n\n  get cell_style(): string {\n    if (this.node.data.color) {\n      return `fill: ${this.node.data.color.css()};`;\n    }\n    return 'fill-opacity: 0';\n  }\n\n  /**\n   * Callback fired when the user clicks a node. Passes up from cell to cell until it reaches Treemap\n   */\n  select_node(n: d3.HierarchyRectangularNode<TreemapNode>): void {\n    // Pass it up to root\n    this.$emit('select-node', n);\n  }\n}\n</script>\n\n<style scoped>\ntext {\n  pointer-events: none;\n}\n\n.theme--dark text {\n  fill: #f8f8f8;\n  font-size: large;\n}\n\n/* Basic settings for our chart. Things unclickable by default */\nrect {\n  stroke: #000000;\n  pointer-events: none;\n  fill-opacity: 0;\n}\n\n/* We want top to be clickable. */\nrect.top {\n  pointer-events: auto;\n  stroke-width: 2;\n}\n\n/* We want leaves */\nrect.leaf {\n  fill-opacity: 1;\n}\n\n/* Otherwise, don't want nested to draw strokes */\nrect.nested {\n  stroke-width: 1;\n}\n\nrect.nested.leaf {\n  stroke-width: 0;\n}\n\n/* Make tops transparent but also more thickly drawn when hovered */\nrect.top:hover {\n  stroke-width: 3;\n}\n</style>\n\n",
    "/api/sources/raw?key=test:apps/frontend/src/components/generic/ApexLineChart.vue": "<template>\n  <div style=\"color: black\">\n    <vue-apex-charts\n      type=\"line\"\n      height=\"350\"\n      :options=\"chartOptions\"\n      :series=\"series\"\n    />\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport {ApexOptions} from 'apexcharts';\nimport Vue from 'vue';\nimport VueApexCharts from 'vue-apexcharts';\nimport Component from 'vue-class-component';\nimport {Prop} from 'vue-property-decorator';\nimport {Category} from './ApexPieChart.vue';\n\nexport interface SeriesItem {\n  name: string;\n  data: number[];\n}\n\n/**\n * Emits \"category-selected\" with payload of type Category whenever a category is selected.\n */\n@Component({\n  components: {\n    VueApexCharts\n  }\n})\nexport default class ApexLineChart extends Vue {\n  @Prop({required: true, type: Array}) readonly categories!: Category<string>[];\n  @Prop({required: true, type: Array}) readonly series!: number[];\n  @Prop({type: Number}) readonly upperRange!: number; //upper bound of y axis\n  @Prop({type: Boolean}) readonly sevChart!: boolean; //identifies chart as severity chart\n  @Prop({type: String}) readonly title!: string;\n  @Prop({type: String}) readonly yTitle!: string;\n\n  //gives apex charts the severity colors\n  sevColors: string[] = ['#FFEB3B', '#FF9800', '#FF5722', '#F44336'];\n\n  get label_colors(): string[] {\n    const colors = [];\n    for (let i = 0; i < this.categories.length; i++) {\n      colors.push('#FFFFFF');\n    }\n    return colors;\n  }\n\n  //creates differing number of ticks based on number of controls\n  get y_axis_tick(): number {\n    if (this.upperRange < 15) {\n      return this.upperRange;\n    } else if (this.upperRange < 50) {\n      return Math.floor(this.upperRange / 5);\n    } else {\n      return Math.floor(this.upperRange / 10);\n    }\n  }\n\n  get line_colors(): string[] | undefined {\n    if (this.sevChart) {\n      return this.sevColors;\n    }\n    return undefined;\n  }\n\n  // Generate the chart options based on _categories\n  get chartOptions(): ApexOptions {\n    return {\n      chart: {\n        height: 350,\n        type: 'line',\n        zoom: {\n          enabled: false\n        }\n        //background: '#000'\n      },\n      colors: this.line_colors,\n      dataLabels: {\n        enabled: false\n      },\n      stroke: {\n        width: 5,\n        curve: 'straight'\n      },\n      title: {\n        text: this.title,\n        align: 'left',\n        style: {\n          fontFamily: 'Arial Black',\n          fontSize: '14px',\n          color: '#FFFFFF'\n        }\n      },\n      legend: {\n        labels: {\n          useSeriesColors: true\n        }\n      },\n      xaxis: {\n        categories: this.categories,\n        labels: {\n          style: {\n            colors: this.label_colors\n          }\n        }\n      },\n      yaxis: {\n        min: 0,\n        max: this.upperRange,\n        tickAmount: this.y_axis_tick,\n        axisTicks: {\n          color: '#FF0000'\n        },\n        axisBorder: {\n          show: true,\n          color: '#FFFFFF',\n          offsetX: 0,\n          offsetY: 0\n        },\n        title: {\n          text: this.yTitle,\n          style: {\n            color: '#FFFFFF'\n          }\n        },\n        labels: {\n          style: {\n            colors: '#FFFFFF'\n          }\n        }\n      },\n      grid: {\n        borderColor: '#f1f1f1'\n      }\n    };\n  }\n}\n</script>\n\n",
    "/api/sources/raw?key=test:apps/frontend/src/utilities/delta_util.ts": "/**\n * Provides utlities for comparing executions\n */\n\nimport {SourcedContextualizedEvaluation} from '@/store/report_intake';\nimport {ContextualizedControl, ContextualizedEvaluation} from 'inspecjs';\nimport {DateTime} from 'luxon';\n\nexport const NOT_SELECTED = 'not selected';\n\n// Unique ID is the unique ID of a file\n// Controls is a list of controls\ninterface ResultControls {\n  uniqueId: string;\n  controls: ContextualizedControl[];\n}\n\n/**\n * Represents a change in a property.\n * We assume that the \"old\" property is the name to use for both.\n * IE that they are the same property value.\n */\nexport class ControlChange {\n  name: string; // the key/title of these values\n  values: string[]; // values over controls sorted by time\n\n  /** Trivial constructor */\n  constructor(name: string, values: string[]) {\n    this.values = values;\n    this.name = name;\n  }\n\n  /** Checks if this actually changes anything.\n   * Returns true iff old !== new\n   */\n  get valid(): boolean {\n    let firstSelected = -1;\n    for (let i = 0; i < this.values.length; i++) {\n      if (this.values[i] !== NOT_SELECTED) {\n        firstSelected = i;\n        break;\n      }\n    }\n    if (firstSelected === -1) {\n      return false;\n    }\n    for (let i = firstSelected + 1; i < this.values.length; i++) {\n      if (\n        this.values[i] !== this.values[firstSelected] &&\n        this.values[i] !== NOT_SELECTED\n      ) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\n/**\n * Represents a group of changes all under one cnosistent named banner.\n */\nexport class ControlChangeGroup {\n  name: string;\n  changes: ControlChange[];\n\n  /** Trivial constructor */\n  constructor(name: string, changes: ControlChange[]) {\n    this.name = name;\n    this.changes = changes;\n  }\n\n  /** Checks if this has any changes at all. Simple shorthand */\n  get any(): boolean {\n    return this.changes.length > 0;\n  }\n\n  /** Removes any changes if they aren't actually changes */\n  clean() {\n    this.changes = this.changes.filter((c) => c.valid);\n  }\n}\n\n/**\n * Holds/computes the differences between two runs of the same control.\n */\nexport class ControlDelta {\n  controls: ContextualizedControl[] = [];\n  controlsandnull: (ContextualizedControl | null)[] = [];\n  numNull = 0;\n\n  constructor(controls: (ContextualizedControl | null)[]) {\n    this.controlsandnull = controls;\n    for (const value of controls) {\n      if (value !== null) {\n        this.controls.push(value);\n      } else {\n        this.numNull += 1;\n      }\n    }\n  }\n\n  /** Returns the changes in \"header\" elements of a control. E.g. name, status, etc. */\n  get headerChanges(): ControlChangeGroup {\n    // Init the list\n    const headerChanges: ControlChange[] = [];\n\n    // Change in... ID? Theoretically possible!\n    headerChanges.push(\n      new ControlChange(\n        'ID',\n        this.controlsandnull.map((c) => {\n          if (c === null) {\n            return NOT_SELECTED;\n          }\n          return c.data.id;\n        })\n      )\n    );\n\n    // And severity! Why not\n    headerChanges.push(\n      new ControlChange(\n        'Severity',\n        this.controlsandnull.map((c) => {\n          if (c === null) {\n            return NOT_SELECTED;\n          }\n          return c.hdf.severity;\n        })\n      )\n    );\n\n    // Change in nist tags!\n    headerChanges.push(\n      new ControlChange(\n        'NIST Tags',\n        this.controlsandnull.map((c) => {\n          if (c === null) {\n            return NOT_SELECTED;\n          }\n          return c.hdf.rawNistTags.join(', ');\n        })\n      )\n    );\n\n    // Make the group and clean it\n    const result = new ControlChangeGroup('Control Details', headerChanges);\n    result.clean();\n    return result;\n  }\n}\n\nexport function get_eval_start_time(\n  ev: ContextualizedEvaluation\n): string | null {\n  for (const prof of ev.contains) {\n    for (const ctrl of prof.contains) {\n      if (ctrl.hdf.segments!.length) {\n        return ctrl.hdf.segments![0].start_time;\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Grabs the \"top\" (IE non-overlayed/end of overlay chain) controls from the execution.\n *\n * @param exec The execution to grab controls from\n */\nfunction extract_top_level_controls(\n  exec: SourcedContextualizedEvaluation\n): ResultControls {\n  // Get all controls\n  const allControls = exec.contains.flatMap((p) => p.contains);\n\n  // Filter to controls that aren't overlayed further\n  const top = allControls.filter((control) => control.extendedBy.length === 0);\n  return {uniqueId: exec.from_file.uniqueId, controls: top};\n}\n\n/** An object of contextualized controls with the same V-ID */\nexport type ControlSeries = {[key: string]: ContextualizedControl};\n\n/** Matches ControlID keys to Arrays of Controls */\nexport type ControlSeriesLookup = {[key: string]: ControlSeries};\n\n/** Helps manage comparing change(s) between one or more profile executions */\nexport class ComparisonContext {\n  /** A list of old-new control pairings */\n  pairings: ControlSeriesLookup;\n\n  constructor(executions: readonly SourcedContextualizedEvaluation[]) {\n    // Get all of the \"top level\" controls from each execution, IE those that actually ran\n    // grouped by their files unique id.\n    const allControls = executions.map(extract_top_level_controls);\n    // Organize the controls by ID\n    // The structure this returns is as follows:\n    // {{\"V-XXX\": {\"unique_file_id_1\": control, \"unique_file_id_2\": control, ...}}}\n    const matched = allControls.reduce(\n      (acc: ControlSeriesLookup, evaluation: ResultControls) => {\n        evaluation.controls.forEach((control) => {\n          // Group initialization\n          if (!acc[control.data.id]) {\n            acc[control.data.id] = {};\n          }\n          // Grouping\n          acc[control.data.id][evaluation.uniqueId] = control;\n        });\n\n        return acc;\n      },\n      {}\n    );\n    // Store\n    this.pairings = matched;\n  }\n}\n\n/*\n  DateTime parsing in Chrome works very different than Safari and Firefox\n  Using luxon provides consistent timestamp information with a fallback to\n  using the native browser date parsing.\n\n  Chrome already supports parsing all of these formats natively, however it\n  is the only browser that does so.\n*/\nexport function parse_datetime(dateString: string): DateTime {\n  let result: DateTime;\n\n  result = DateTime.fromRFC2822(dateString);\n  if (result.isValid) {\n    return result;\n  }\n  result = DateTime.fromISO(dateString);\n  if (result.isValid) {\n    return result;\n  }\n  result = DateTime.fromHTTP(dateString);\n  if (result.isValid) {\n    return result;\n  }\n  result = DateTime.fromSQL(dateString);\n  if (result.isValid) {\n    return result;\n  }\n\n  return DateTime.fromJSDate(new Date(dateString));\n}\n\nexport function compare_times(\n  a: SourcedContextualizedEvaluation,\n  b: SourcedContextualizedEvaluation\n) {\n  const aDate = parse_datetime(get_eval_start_time(a) || '');\n  const bDate = parse_datetime(get_eval_start_time(b) || '');\n\n  return aDate.valueOf() - bDate.valueOf();\n}\n\n",
    "/api/sources/raw?key=test:apps/frontend/tests/unit/Compare.spec.ts": "import {FilteredDataModule} from '@/store/data_filters';\nimport {SearchModule} from '@/store/search';\nimport {StatusCountModule} from '@/store/status_counts';\nimport {ComparisonContext, ControlSeries} from '@/utilities/delta_util';\nimport Compare from '@/views/Compare.vue';\nimport {shallowMount, Wrapper} from '@vue/test-utils';\nimport 'jest';\nimport Vue from 'vue';\nimport Vuetify from 'vuetify';\nimport {fileCompliance, loadSample, removeAllFiles} from '../util/testingUtils';\n\nconst vuetify = new Vuetify();\n\nconst wrapper: Wrapper<Vue> = shallowMount(Compare, {\n  vuetify,\n  propsData: {}\n});\n\nexport interface SeriesItem {\n  name: string;\n  data: number[];\n}\n\nconst redHatControlCount = 247;\nconst nginxControlCount = 41;\nconst nginxDelta = 3;\n\ndescribe('Compare table data', () => {\n  loadSample('NGINX With Failing Tests');\n  it('correctly counts controls with 1 file', () => {\n    (wrapper.vm as Vue & {changedOnly: boolean}).changedOnly = false;\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(nginxControlCount);\n  });\n\n  it('does not recount same controls with 2 files', () => {\n    loadSample('NGINX With Failing Tests');\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(nginxControlCount);\n  });\n\n  it('does not recount same controls with 3 files', () => {\n    loadSample('NGINX With Failing Tests');\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(nginxControlCount);\n  });\n\n  it('does not show any changed between two of the same', () => {\n    (wrapper.vm as Vue & {changedOnly: boolean}).changedOnly = true;\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(0);\n  });\n\n  it('search works when nothing fits criteria', () => {\n    (wrapper.vm as Vue & {searchTerm: string}).searchTerm = 'failed';\n    SearchModule.parseSearch();\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(0);\n  });\n\n  it('search id works', () => {\n    (wrapper.vm as Vue & {changedOnly: boolean}).changedOnly = false;\n    (wrapper.vm as Vue & {searchTerm: string}).searchTerm = 'v-13613';\n    SearchModule.parseSearch();\n    setTimeout(() => {\n      expect(\n        (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n          .length\n      ).toBe(1);\n    }, 1000);\n  });\n\n  it('shows differing delta data when \"show only changed\"', () => {\n    (wrapper.vm as Vue & {searchTerm: string}).searchTerm = '';\n    (wrapper.vm as Vue & {changedOnly: boolean}).changedOnly = true;\n    loadSample('NGINX Clean Sample');\n    SearchModule.parseSearch();\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(nginxDelta);\n  });\n\n  it('search status works', () => {\n    (wrapper.vm as Vue & {changedOnly: boolean}).changedOnly = false;\n    (wrapper.vm as Vue & {searchTerm: string}).searchTerm = 'failed';\n    SearchModule.parseSearch();\n    setTimeout(() => {\n      expect(\n        (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n          .length\n      ).toBe(nginxDelta);\n    }, 1000);\n  });\n\n  it('counts every unique control', () => {\n    loadSample('Red Hat With Failing Tests');\n    (wrapper.vm as Vue & {searchTerm: string}).searchTerm = '';\n    (wrapper.vm as Vue & {changedOnly: boolean}).changedOnly = true;\n    SearchModule.parseSearch();\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(nginxControlCount + redHatControlCount);\n  });\n\n  it('shows all delta data of controls with multiple occurances when \"show only changed\"', () => {\n    loadSample('Red Hat Clean Sample');\n    expect(\n      (wrapper.vm as Vue & {show_sets: [string, ControlSeries][]}).show_sets\n        .length\n    ).toBe(nginxControlCount + redHatControlCount);\n  });\n\n  it('ComparisonContext counts status correctly', () => {\n    let failed = 0;\n    let passed = 0;\n    let na = 0;\n    let nr = 0;\n    let pe = 0;\n    const selectedData = FilteredDataModule.evaluations(\n      FilteredDataModule.selected_file_ids\n    );\n    const currDelta = new ComparisonContext(selectedData);\n    for (const pairing of Object.values(currDelta.pairings)) {\n      for (const ctrl of Object.values(pairing)) {\n        if (ctrl === null) {\n          continue;\n        } else if (ctrl.root.hdf.status === 'Passed') {\n          passed++;\n        } else if (ctrl.root.hdf.status === 'Failed') {\n          failed++;\n        } else if (ctrl.root.hdf.status === 'Not Applicable') {\n          na++;\n        } else if (ctrl.root.hdf.status === 'Not Reviewed') {\n          nr++;\n        } else if (ctrl.root.hdf.status === 'Profile Error') {\n          pe++;\n        }\n      }\n    }\n    const expected = {\n      Failed: StatusCountModule.hash({\n        omit_overlayed_controls: true,\n        fromFile: [...FilteredDataModule.selected_file_ids]\n      }).Failed,\n      Passed: StatusCountModule.hash({\n        omit_overlayed_controls: true,\n        fromFile: [...FilteredDataModule.selected_file_ids]\n      }).Passed,\n      'From Profile': 0,\n      'Profile Error': StatusCountModule.hash({\n        omit_overlayed_controls: true,\n        fromFile: [...FilteredDataModule.selected_file_ids]\n      })['Profile Error'],\n      'Not Reviewed': StatusCountModule.hash({\n        omit_overlayed_controls: true,\n        fromFile: [...FilteredDataModule.selected_file_ids]\n      })['Not Reviewed'],\n      'Not Applicable': StatusCountModule.hash({\n        omit_overlayed_controls: true,\n        fromFile: [...FilteredDataModule.selected_file_ids]\n      })['Not Applicable']\n    };\n    const actual = {\n      Failed: failed,\n      Passed: passed,\n      'From Profile': 0,\n      'Profile Error': pe,\n      'Not Reviewed': nr,\n      'Not Applicable': na\n    };\n    expect(actual).toEqual(expected);\n  });\n});\n\ndescribe('compare charts', () => {\n  it('sev chart gets correct data with 2 files', () => {\n    removeAllFiles();\n    loadSample('NGINX With Failing Tests');\n    loadSample('NGINX Clean Sample');\n    //the values in expected are the correct data\n    expect((wrapper.vm as Vue & {sev_series: number[][]}).sev_series).toEqual([\n      [0, 0],\n      [3, 0],\n      [0, 0],\n      [0, 0]\n    ]);\n  });\n\n  it('sev chart gets correct data with 2 files with differing profiles', () => {\n    removeAllFiles();\n    loadSample('NGINX With Failing Tests');\n    loadSample('Red Hat With Failing Tests');\n    //the values in expected are the correct data\n    expect((wrapper.vm as Vue & {sev_series: number[][]}).sev_series).toEqual([\n      [0, 6],\n      [3, 18],\n      [0, 3],\n      [0, 0]\n    ]);\n  });\n\n  it('sev chart gets correct data with 2 files with overlayed profiles', () => {\n    removeAllFiles();\n    loadSample('Triple Overlay Example');\n    loadSample('Acme Overlay Example');\n    //the values in expected are the correct data\n    expect((wrapper.vm as Vue & {sev_series: number[][]}).sev_series).toEqual([\n      [3, 0],\n      [51, 0],\n      [1, 0],\n      [0, 60]\n    ]);\n  });\n\n  it('compliance chart gets correct data with 2 files', () => {\n    removeAllFiles();\n    loadSample('NGINX With Failing Tests');\n    loadSample('NGINX Clean Sample');\n    expect(\n      new Set(\n        (\n          wrapper.vm as Vue & {\n            compliance_series: SeriesItem[];\n          }\n        ).compliance_series[0].data\n      )\n    ).toEqual(\n      new Set([\n        fileCompliance(FilteredDataModule.selected_file_ids[0]),\n        fileCompliance(FilteredDataModule.selected_file_ids[1])\n      ])\n    );\n  });\n\n  it('compliance chart gets correct data with 2 files with differing profiles', () => {\n    removeAllFiles();\n    loadSample('NGINX With Failing Tests');\n    loadSample('Red Hat With Failing Tests');\n    expect(\n      new Set(\n        (\n          wrapper.vm as Vue & {\n            compliance_series: SeriesItem[];\n          }\n        ).compliance_series[0].data\n      )\n    ).toEqual(\n      new Set([\n        fileCompliance(FilteredDataModule.selected_file_ids[0]),\n        fileCompliance(FilteredDataModule.selected_file_ids[1])\n      ])\n    );\n  });\n\n  it('compliance chart gets correct data with 2 files with overlayed profiles', () => {\n    removeAllFiles();\n    loadSample('Triple Overlay Example');\n    loadSample('Acme Overlay Example');\n    expect(\n      new Set(\n        (\n          wrapper.vm as Vue & {\n            compliance_series: SeriesItem[];\n          }\n        ).compliance_series[0].data\n      )\n    ).toEqual(\n      new Set([\n        fileCompliance(FilteredDataModule.selected_file_ids[0]),\n        fileCompliance(FilteredDataModule.selected_file_ids[1])\n      ])\n    );\n  });\n});\n\n",
    "/api/sources/raw?key=test:apps/frontend/src/utilities/splunk_util.ts": "import {ConversionResult, convertFile, ExecJSON} from 'inspecjs';\nimport {ElementCompact, xml2js} from 'xml-js';\nimport {delay} from './async_util';\nimport {basic_auth, group_by, map_hash} from './helper_util';\n\nexport type JobID = string;\n\n// Interfaces\n/** The parent type to other interfaces, to save duplication */\ninterface AbsMetaInfo {\n  /** The file this came from */\n  filename: string;\n\n  /** The type of the file (NOT of this event!) */\n  filetype: 'evaluation' | 'profile';\n\n  /** The subtype of this specific event */\n  subtype: 'header' | 'profile' | 'control';\n\n  /** A randomly generated GUID capturing all of the events in this file */\n  guid: string;\n\n  /** When this event was parsed */\n  parse_time: string;\n\n  /** The schema version: */\n  hdf_splunk_schema: string;\n\n  /** The sha256 hash of the profile that is/contains this event */\n  profile_sha256: string;\n\n  /** The start time of the control in ISO format */\n  startTime: string;\n\n  /** The control ID, repeated for convenience in splunk searches */\n  control_id: string;\n}\n\n/** The meta information for an event with the \"evaluation\" subtype */\nexport interface ExecutionMetaInfo\n  extends Omit<AbsMetaInfo, 'control_id' | 'startTime' | 'profile_sha256'> {\n  subtype: 'header';\n}\n\n/** The meta information for an event with the \"profile\" subtype */\nexport interface ProfileMetaInfo\n  extends Omit<AbsMetaInfo, 'control_id' | 'startTime'> {\n  subtype: 'profile';\n}\n\n/** The meta information for an event with the \"control\" subtype */\nexport interface ControlMetaInfo extends AbsMetaInfo {\n  subtype: 'control';\n}\n\n/** This is what we expect to find in every parsed event representing an Evaluation\n * Note that Profiles will typically be initially empty\n */\nexport interface ExecutionPayload {\n  meta: ExecutionMetaInfo;\n  profiles: ProfilePayload[];\n}\n\n/** This is what we expect to find in every parsed event representing a Profile.\n * Note that controls will typically be initially empty\n */\nexport interface ProfilePayload {\n  meta: ProfileMetaInfo;\n  controls: ControlPayload[];\n}\n\n/** This is what we expect to find in every parsed event representing a Control */\nexport interface ControlPayload {\n  meta: ControlMetaInfo;\n}\n\n// Could be any!\nexport type UnknownPayload = ExecutionPayload | ProfilePayload | ControlPayload;\n\n/* Job states */\ntype CompleteJobStatus = 'succeeded' | 'failed';\ntype PendingJobStatus = 'pending'; // There are others, but we don't handle them for now\ntype JobStatus = CompleteJobStatus | PendingJobStatus;\ninterface JobState {\n  status: JobStatus;\n  jobId: JobID;\n}\n\n/** This info is used to negotiate splunk connections */\nexport class SplunkEndpoint {\n  /** The full host information, including port (typically 8089).\n   * EX: https://localhost:8089\n   */\n  host: string;\n\n  /** Username to use for authentication */\n  username: string;\n\n  /** Password to use for authentication */\n  password: string;\n\n  constructor(host: string, username: string, password: string) {\n    this.host = host;\n    this.username = username;\n    this.password = password;\n  }\n\n  /** Checks whether we're able to successfully get jobs,\n   * which indicates proper auth.\n   *\n   * Will error if we aren't\n   */\n\n  process_response(response: Response) {\n    if (!response.ok) {\n      throw process_error(response);\n    }\n    return response.text();\n  }\n\n  async check_auth(): Promise<void> {\n    return fetch(`${this.host}/services/search/jobs`, {\n      headers: {\n        Authorization: this.authString\n      },\n      method: 'GET'\n    }).then(\n      (response) => {\n        if (!response.ok) {\n          throw process_error(response);\n        }\n      },\n      (failure) => {\n        throw process_error(failure);\n      }\n    );\n  }\n\n  /** Provides a list of Evaluation meta headers from recent executions.\n   * We should eventually change this to allow more specific criteria\n   */\n  async fetch_execution_list(): Promise<ExecutionMetaInfo[]> {\n    // This search lists evaluation headers\n    const getExecutionsSearch =\n      'spath \"meta.subtype\" | search \"meta.subtype\"=header';\n\n    return this.hdf_event_search(getExecutionsSearch).then((events) => {\n      // Because we only searched for headers, we can assume these to be eval events\n      const evalEvents = events as ExecutionPayload[];\n\n      // Could perhaps just return e but I'd rather people didn't screw themselves\n      return evalEvents.map((e) => e.meta);\n    });\n  }\n\n  async get_execution_events(executionGuid: string): Promise<UnknownPayload[]> {\n    // This search, provided a guid, returns all headers for that guid\n    const specificEvaluation = `spath \"meta.guid\" | search \"meta.guid\"=${executionGuid}`;\n    return this.hdf_event_search(specificEvaluation);\n  }\n\n  async get_execution(executionGuid: string): Promise<ExecJSON.Execution> {\n    return this.get_execution_events(executionGuid)\n      .then((events) => consolidate_payloads(events))\n      .then((execs) => {\n        if (execs.length !== 1) {\n          throw SplunkErrorCode.InvalidGUID;\n        } else {\n          return execs[0];\n        }\n      })\n      .then((fullEvent) => {\n        // This is dumb and we should make the inspecjs layer more accepting of many file types\n        let result: ConversionResult;\n        try {\n          result = convertFile(JSON.stringify(fullEvent));\n        } catch (e) {\n          throw SplunkErrorCode.SchemaViolation;\n        }\n\n        // Determine what sort of file we (hopefully) have, then add it\n        if (result['1_0_ExecJson']) {\n          // Handle as exec\n          return result['1_0_ExecJson'];\n        } else {\n          throw SplunkErrorCode.SchemaViolation;\n        }\n      });\n  }\n\n  /** Creates a proper base64 encoded auth string, using this objects credentials. */\n  private get authString(): string {\n    return basic_auth(this.username, this.password);\n  }\n\n  /** Performs the entire process of search string -> results array\n   *  Performs no consolidation.\n   *  Assumes your search string is properly constrained to the hdf index\n   */\n  async hdf_event_search(searchString: string): Promise<UnknownPayload[]> {\n    return this.create_search(searchString)\n      .then((jobId) => this.pend_job(jobId, 500))\n      .then((jobState) => {\n        if (jobState.status === 'failed') {\n          throw SplunkErrorCode.SearchFailed;\n        }\n\n        return this.get_search_results(jobState.jobId);\n      })\n      .catch((error) => {\n        throw process_error(error);\n      });\n  }\n\n  /** Returns the job id */\n  private async create_search(searchString: string): Promise<JobID> {\n    return fetch(`${this.host}/services/search/jobs`, {\n      method: 'POST',\n      headers: new Headers({\n        Authorization: this.authString\n      }),\n      body: `search=search index=\"hdf\" | ${searchString}`\n    })\n      .then(this.process_response)\n      .then((text) => {\n        // Parse the xml\n        const xml = xml2js(text, {\n          compact: true\n        }) as ElementCompact;\n        return xml.response.sid._text as string;\n      });\n  }\n\n  /** Returns the current state of the job */\n  private async check_job(jobId: JobID): Promise<JobState> {\n    return fetch(`${this.host}/services/search/jobs/${jobId}`, {\n      method: 'GET',\n      headers: new Headers({\n        Authorization: this.authString\n      })\n    })\n      .then(this.process_response)\n      .then((text) => {\n        // Parse the xml\n        const xml = xml2js(text, {\n          compact: true\n        }) as ElementCompact;\n\n        // Get the keys, and find the one with name \"dispatchState\"\n        const keys = xml.entry.content['s:dict']['s:key'];\n        let state: string | undefined;\n        for (const k of keys) {\n          if (k._attributes.name === 'dispatchState') {\n            state = k._text;\n          }\n        }\n\n        // Check we found state\n        if (!state) {\n          // It probably failed if we can't find it lol\n          state = 'FAILED';\n        }\n\n        // Decide result based on state\n        let status: JobStatus;\n        if (state === 'DONE') {\n          status = 'succeeded';\n        } else if (state === 'FAILED') {\n          status = 'failed';\n        } else {\n          status = 'pending';\n        }\n\n        // Construct the state\n        return {\n          status,\n          jobId\n        };\n      });\n  }\n\n  /** Continually checks the job until resolution */\n  private async pend_job(jobId: JobID, interval: number): Promise<JobState> {\n    /* eslint-disable */\n        while (true) {\n            /* eslint-enable */\n      const state = await this.check_job(jobId);\n      if (state.status === 'pending') {\n        await delay(interval);\n      } else {\n        return state;\n      }\n    }\n  }\n\n  /** Gets the search results for a given job id, if it is done */\n  private async get_search_results(jobId: JobID): Promise<UnknownPayload[]> {\n    return fetch(\n      `${this.host}/services/search/jobs/${jobId}/results/?output_mode=json&count=0`,\n      {\n        headers: {\n          Authorization: this.authString\n        },\n        method: 'GET'\n      }\n    )\n      .then((response) => {\n        if (!response.ok) {\n          throw process_error(response);\n        }\n        return response.json();\n      })\n      .then((data) => {\n        // We basically can't, and really shouldn't, do typescript here. Output is 50% guaranteed to be wonk\n        // Get all the raws\n        const raws: Array<string> = data['results'].map(\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          (datum: any) => datum._raw\n        );\n\n        // Parse to json, and freeze\n        const parsed = [] as UnknownPayload[];\n        for (const v of raws) {\n          try {\n            parsed.push(JSON.parse(v) as UnknownPayload);\n          } catch (err) {\n            // eslint-disable-next-line no-console\n            console.warn(err);\n          }\n        }\n\n        return parsed;\n      });\n  }\n}\n\n/** Given: A list of all payloads from a search,\n * Produce: A list of Evaluation payloads containing all data properly reconstructed, recursively, into a \"normal\"\n * HDF heirarchy.\n *\n * TODO: Provide a mechanism for also returning orphaned items\n */\nexport function consolidate_payloads(\n  payloads: UnknownPayload[]\n): ExecutionPayload[] {\n  // Group by exec id\n  const grouped = group_by(payloads, (pl) => pl.meta.guid);\n\n  const built = map_hash(grouped, consolidate_file_payloads);\n\n  return Object.values(built);\n}\n\n/** Given: A list of all payloads from a search with the same GUID\n * Produce: A single EvaluationPayload containing all of these payloads reconstructed into the expected HDF heirarchy\n */\nfunction consolidate_file_payloads(\n  filePayloads: UnknownPayload[]\n): ExecutionPayload {\n  // In the end we wish to produce a single evaluation EventPayload which in fact contains all data for the guid\n  // Group by subtype\n  const subtypes = group_by(filePayloads, (event) => event.meta.subtype);\n  const execEvents = (subtypes['header'] || []) as ExecutionPayload[];\n  const profileEvents = (subtypes['profile'] || []) as ProfilePayload[];\n  const controlEvents = (subtypes['control'] || []) as ControlPayload[];\n\n  // Verify we only have one exec event\n  if (execEvents.length !== 1) {\n    throw new Error(\n      `Incorrect # of Evaluation events. Expected 1, got ${execEvents.length}`\n    );\n  }\n\n  // Pull it out\n  const exec = execEvents[0];\n\n  // Put all the profiles into the exec\n  exec.profiles.push(...profileEvents);\n\n  // Group controls, and then put them into the profiles\n  const shaGroupedControls = group_by(\n    controlEvents,\n    (ctrl) => ctrl.meta.profile_sha256\n  );\n  for (const profile of profileEvents) {\n    // Get the corresponding controls, and put them into the profile\n    const sha = profile.meta.profile_sha256;\n    const corrControls = shaGroupedControls[sha] || [];\n    profile.controls.push(...corrControls);\n  }\n\n  // Spit it back out\n  return exec;\n}\n\nexport enum SplunkErrorCode {\n  BadNetwork, // Server could not be reached, either due to bad address or bad CORS\n  BadUrl, // URL poorly formed\n  PageNotFound, // Server gave error 404\n  BadAuth, // Authorization credentials are no good\n  SearchFailed, // For whatever reason, the splunk search failed\n  ConsolidationFailed, // Something went wrong during event consolidation phase\n  SchemaViolation, // The data we got out isn't valid HDF. Hope to not see this too often\n  InvalidGUID, // If the provided GUID did not match to exactly one header\n  UnknownError // No clue!\n}\n\n/** Converts Responses and Errorcodes into purely just errorcodes */\nexport function process_error(\n  r: Response | SplunkErrorCode | TypeError\n): SplunkErrorCode {\n  if (r instanceof TypeError) {\n    if (r.message.includes('NetworkError')) {\n      return SplunkErrorCode.BadNetwork;\n    } else if (r.message.includes('not a valid URL')) {\n      return SplunkErrorCode.BadUrl;\n    }\n  } else if (r instanceof Response) {\n    // Based on the network code, guess\n    const response = r;\n    switch (response.status) {\n      case 401: // Bad username/password\n        return SplunkErrorCode.BadAuth;\n      case 404: // URL got borked\n        return SplunkErrorCode.PageNotFound;\n      default:\n        return SplunkErrorCode.UnknownError;\n    }\n  } else if (typeof r === typeof SplunkErrorCode.UnknownError) {\n    // It's already an error code - pass along\n    return r;\n  }\n  // idk lol\n  return SplunkErrorCode.UnknownError;\n}\n\n",
    "/api/sources/raw?key=test:apps/frontend/src/utilities/treemap_util.ts": "/**\n * Tools used for generating the treemaps consumed by, of course, the Treemap card and associated components.\n */\n\nimport {ColorHack} from '@/store/color_hack';\nimport Chroma from 'chroma-js';\nimport * as d3 from 'd3';\nimport {\n  ContextualizedControl,\n  FULL_NIST_HIERARCHY,\n  NistControl,\n  NistHierarchyNode\n} from 'inspecjs';\nimport {control_unique_key} from './format_util';\n\n// How deep into nist trees we allow\nconst depthMax = 2;\n\n/** A simple wrapper type representing what any node's data might be in our treemap */\ninterface AbsTreemapNode {\n  title: string;\n  subtitle?: string;\n  hovertext?: string;\n  key: string;\n  color?: Chroma.Color;\n  parent: TreemapNodeParent | null; // The parent of this node.\n  nist_control: NistControl; // The nist control which this node is associated with. Not necessarily unique (e.g. leaves)\n}\nexport interface TreemapNodeParent extends AbsTreemapNode {\n  children: TreemapNode[]; // Maps the next sub-specifier to children\n}\n\nexport interface TreemapNodeLeaf extends AbsTreemapNode {\n  control: ContextualizedControl;\n}\n\nexport function is_leaf(n: TreemapNode): n is TreemapNodeLeaf {\n  return (n as TreemapNodeLeaf).control !== undefined;\n}\n\nexport function is_parent(n: TreemapNode): n is TreemapNodeParent {\n  return (n as TreemapNodeParent).children !== undefined;\n}\n\n/** The type of our treemap nodes, prior to rendering */\nexport type TreemapNode = TreemapNodeLeaf | TreemapNodeParent;\nexport type D3TreemapNode = d3.HierarchyNode<TreemapNode>;\n\n/**\n * Converts a list of controls to treemap leaves.\n * Actually a one-to-many mapping since we must make a unique leaf for each nist control on each control!\n * @param controls The controls to build into a nist node map\n */\nfunction controls_to_nist_node_data(\n  contextualizedControls: Readonly<ContextualizedControl[]>,\n  colors: ColorHack\n): TreemapNodeLeaf[] {\n  return contextualizedControls.flatMap((cc) => {\n    // Get the status color\n    const color = Chroma.hex(colors.colorForStatus(cc.root.hdf.status));\n    // Now make leaves for each nist control\n    return cc.root.hdf.parsedNistTags.map((nc) => {\n      return {\n        title: cc.data.id,\n        subtitle: cc.data.title || undefined,\n        hovertext: cc.data.desc || undefined,\n        key: control_unique_key(cc) + nc.rawText,\n        control: cc,\n        nist_control: nc,\n        color,\n        parent: null // We set this later\n      };\n    });\n  });\n}\n\n/** Builds a scaffolding for the nist items using the given root.\n * Also constructs a lookup table of control nodes.\n * Only goes maxDepth deep.\n */\nfunction recursive_nist_map(\n  parent: TreemapNodeParent | null,\n  node: Readonly<NistHierarchyNode>,\n  controlLookup: {[key: string]: TreemapNodeParent},\n  maxDepth: number\n): TreemapNodeParent {\n  // Init child list\n  const children: TreemapNode[] = [];\n\n  // Make our final value\n  const ret: TreemapNodeParent = {\n    key: node.control.rawText || '',\n    title: node.control.rawText || '',\n    nist_control: node.control,\n    parent,\n    children\n  };\n\n  // Fill our children\n  if (node.control.subSpecifiers.length < maxDepth) {\n    node.children.forEach((child) => {\n      // Assign it, recursively computing the rest\n      children.push(recursive_nist_map(ret, child, controlLookup, maxDepth));\n    });\n  }\n\n  // Save to lookup\n  controlLookup[lookup_key_for(node.control, maxDepth)] = ret;\n  return ret;\n}\n\n/** Colorizes a treemap based on each nodes children. */\nfunction colorize_tree_map(root: TreemapNodeParent) {\n  // First colorize children, recursively\n  root.children.forEach((child) => {\n    if (is_parent(child)) {\n      colorize_tree_map(child);\n    }\n  });\n\n  // Now all children should have valid colors\n  // We decide this node's color as a composite of all underlying node colors\n  const childColors = root.children\n    .map((c) => c.color)\n    .filter((c): c is Chroma.Color => !!c);\n  // If we have any, then set our color\n  if (childColors.length) {\n    // Set the color\n    const avgColor = Chroma.average(childColors);\n    root.color = avgColor;\n  }\n}\n\n/** Generates a lookup key for the given control */\nfunction lookup_key_for(x: NistControl, maxDepth: number): string {\n  if (maxDepth) {\n    return x.subSpecifiers.slice(0, maxDepth).join('-');\n  } else {\n    return x.subSpecifiers.join('-');\n  }\n}\n\n/** Populates a treemap using the given lookup table */\nfunction populate_tree_map(\n  lookup: {[key: string]: TreemapNodeParent},\n  leaves: TreemapNodeLeaf[],\n  maxDepth: number\n) {\n  // Populate it\n  leaves.forEach((leaf) => {\n    const parent = lookup[lookup_key_for(leaf.nist_control, maxDepth)];\n    if (parent) {\n      // We found a node that will accept it (matches its control)\n      // We can do this as because we know we constructed these to only have empty children\n      parent.children.push(leaf);\n      leaf.parent = parent;\n    } else {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `Warning: unable to assign control ${leaf.nist_control.rawText} to valid treemap leaf`\n      );\n    }\n  });\n}\n\n/**\n * Assembles the provided leaves into a nist map.\n * Colorizes nodes as appropriate, and assigns parentage\n */\nfunction build_populated_nist_map(data: TreemapNodeLeaf[]): TreemapNodeParent {\n  // Build our scaffold\n  const lookup: {[key: string]: TreemapNodeParent} = {};\n  const rootChildren: TreemapNodeParent[] = [];\n  const root: TreemapNodeParent = {\n    key: 'tree_root',\n    title: 'NIST-853 Controls',\n    children: rootChildren,\n    parent: null,\n    nist_control: new NistControl([], 'NIST-853')\n  };\n\n  // Fill out children, recursively\n  FULL_NIST_HIERARCHY.forEach((n) => {\n    const child = recursive_nist_map(root, n, lookup, depthMax);\n    rootChildren.push(child);\n  });\n\n  // Populate them with leaves\n  populate_tree_map(lookup, data, depthMax);\n\n  // Colorize it\n  colorize_tree_map(root);\n\n  // Done\n  return root;\n}\n\n/**\n * Generates a tree map from the given nist hash, using the size of each category to inversely scale it with controls.\n * Thus each category has a fixed weight!\n * Categories/Families are further sorted by name, and the\n *\n * @param data The nist hash to turn into a tree map\n */\nfunction node_data_to_tree_map(\n  data: Readonly<TreemapNodeParent>\n): D3TreemapNode {\n  return d3\n    .hierarchy<TreemapNode>(data, (d: TreemapNode) => {\n      if (is_parent(d)) {\n        return d.children;\n      }\n      return null;\n    })\n    .sort((a, b) => a.data.title.localeCompare(b.data.title))\n    .sum((root) => {\n      if (is_parent(root)) {\n        if (root.children.length === 0) {\n          return 1;\n        }\n      } else if (root.parent !== null) {\n        return 1.0 / root.parent!.children.length;\n      }\n      return 0;\n    });\n}\n\n/** Does all the steps */\nexport function build_nist_tree_map(\n  data: Readonly<ContextualizedControl[]>,\n  colors: ColorHack\n): D3TreemapNode {\n  const leaves = controls_to_nist_node_data(data, colors);\n  const b = build_populated_nist_map(leaves);\n  return node_data_to_tree_map(b);\n}\n\n",
    "/api/sources/raw?key=test:apps/frontend/src/components/cards/controltable/ControlRowDetails.vue": "<template>\n  <v-row no-gutters dense class=\"pb-1\">\n    <v-col cols=\"12\" class=\"font-weight-bold\">\n      <v-card>\n        <v-tabs v-model=\"localTab\" fixed-tabs show-arrows @change=\"tab_change\">\n          <!-- Declare our tabs -->\n          <v-tab href=\"#tab-test\"> Test </v-tab>\n          <v-tab href=\"#tab-details\"> Details </v-tab>\n          <v-tab href=\"#tab-code\"> Code </v-tab>\n\n          <v-tab-item value=\"tab-test\">\n            <div class=\"pa-4\">\n              <div v-if=\"caveat\">\n                Caveat: {{ caveat }}\n                <v-divider />\n                <br />\n              </div>\n              <!-- eslint-disable-next-line vue/no-v-html -->\n              <div v-html=\"sanitize_html(main_desc)\" />\n            </div>\n            <ControlRowCol\n              v-for=\"(result, index) in control.root.hdf.segments\"\n              :key=\"'col' + index\"\n              :class=\"zebra(index)\"\n              :result=\"result\"\n              :status-code=\"result.status\"\n            />\n          </v-tab-item>\n\n          <v-tab-item value=\"tab-details\">\n            <v-container fluid>\n              <!-- Create a row for each detail -->\n              <template v-for=\"(detail, index) in details\">\n                <v-row :key=\"'tab' + index\" :class=\"zebra(index)\">\n                  <v-col cols=\"12\" :class=\"detail.class\">\n                    <h3>{{ detail.name }}:</h3>\n                    <!-- eslint-disable vue/no-v-html -->\n                    <h4 class=\"mono\" v-html=\"sanitize_html(detail.value)\" />\n                    <!-- eslint-enable vue/no-v-html -->\n                  </v-col>\n                  <v-divider />\n                </v-row>\n              </template>\n            </v-container>\n          </v-tab-item>\n\n          <v-tab-item value=\"tab-code\">\n            <v-container fluid>\n              <v-row>\n                <v-col cols=\"12\">\n                  <prism language=\"ruby\">{{ control.full_code }}</prism>\n                </v-col>\n              </v-row>\n            </v-container>\n          </v-tab-item>\n        </v-tabs>\n      </v-card>\n    </v-col>\n  </v-row>\n</template>\n\n<script lang=\"ts\">\nimport ControlRowCol from '@/components/cards/controltable/ControlRowCol.vue';\nimport HtmlSanitizeMixin from '@/mixins/HtmlSanitizeMixin';\nimport {ContextualizedControl} from 'inspecjs';\nimport _ from 'lodash';\n//TODO: add line numbers\nimport 'prismjs';\nimport 'prismjs/components/prism-makefile.js';\nimport 'prismjs/components/prism-ruby.js';\nimport 'prismjs/themes/prism-tomorrow.css';\nimport Component, {mixins} from 'vue-class-component';\n//@ts-ignore\nimport Prism from 'vue-prism-component';\nimport {Prop, Watch} from 'vue-property-decorator';\n\ninterface Detail {\n  name: string;\n  value: string;\n  class?: string;\n}\n\n@Component({\n  components: {\n    ControlRowCol,\n    Prism\n  }\n})\nexport default class ControlRowDetails extends mixins(HtmlSanitizeMixin) {\n  @Prop({type: String, default: 'tab-test'}) readonly tab!: string;\n  @Prop({type: Object, required: true})\n  readonly control!: ContextualizedControl;\n\n  localTab = this.tab;\n\n  @Watch('tab')\n  onTabChanged(newTab?: string, _oldVal?: string) {\n    if (newTab) {\n      this.localTab = newTab;\n    }\n  }\n\n  get cciControlString(): string | null {\n    const cci = this.control.hdf.wraps.tags.cci;\n    if (!cci) {\n      return null;\n    } else if (Array.isArray(cci)) {\n      return cci.join(', ');\n    } else {\n      return cci;\n    }\n  }\n\n  get main_desc(): string {\n    if (this.control.data.desc) {\n      return this.control.data.desc.trim();\n    } else {\n      return 'No description';\n    }\n  }\n\n  tab_change(tab: string) {\n    this.$emit('update:tab', tab);\n  }\n\n  /** Shown above the description */\n  get header(): string {\n    const msgSplit = this.control.root.hdf.finding_details.split(':');\n    if (msgSplit.length === 1) {\n      return msgSplit[0] + '.';\n    } else {\n      return msgSplit[0] + ':';\n    }\n  }\n\n  get caveat(): string | undefined {\n    return this.control.hdf.descriptions.caveat;\n  }\n\n  get details(): Detail[] {\n    const c = this.control;\n    const detailsMap = new Map();\n\n    detailsMap.set('Control', c.data.id);\n    detailsMap.set('Title', c.data.title);\n    detailsMap.set('Caveat', c.hdf.descriptions.caveat);\n    detailsMap.set('Desc', c.data.desc);\n    detailsMap.set('Rationale', c.hdf.descriptions.rationale);\n    detailsMap.set('Severity', c.root.hdf.severity);\n    detailsMap.set('Impact', c.data.impact);\n    detailsMap.set('Nist controls', c.hdf.rawNistTags.join(', '));\n    detailsMap.set('CCI controls', this.cciControlString);\n    detailsMap.set('Check', c.hdf.descriptions.check || c.data.tags.check);\n    detailsMap.set('Fix', c.hdf.descriptions.fix || c.data.tags.fix);\n    detailsMap.set('CWE ID', _.get(c, 'hdf.wraps.tags.cweid'));\n\n    for (const prop in c.hdf.descriptions) {\n      if (!detailsMap.has(_.capitalize(prop))) {\n        detailsMap.set(_.capitalize(prop), c.hdf.descriptions[prop]);\n      }\n    }\n    return Array.from(detailsMap, ([name, value]) => ({name, value})).filter(\n      (v) => v.value\n    );\n  }\n\n  //for zebra background\n  zebra(ix: number): string {\n    if (ix % 2 === 0) {\n      return 'zebra-table';\n    }\n    return 'non-zebra-table';\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n@import '@/sass/control-row-format.scss';\n\n.clickable {\n  cursor: pointer;\n}\n\n.v-application {\n  code.language-ruby {\n    border: none;\n    box-shadow: none;\n  }\n}\n\npre {\n  white-space: pre-wrap; /* Since CSS 2.1 */\n  white-space: -moz-pre-wrap; /* Mozilla, since 1999 */\n  white-space: -pre-wrap; /* Opera 4-6 */\n  white-space: -o-pre-wrap; /* Opera 7 */\n  word-wrap: break-word; /* Internet Explorer 5.5+ */\n}\n.theme--dark .zebra-table {\n  background-color: var(--v-secondary-lighten2);\n  max-width: 99.9%;\n  margin: auto;\n}\n\n.theme--dark .non-zebra-table {\n  max-width: 99.9%;\n  margin: auto;\n}\n\n.code-card {\n  height: inherit;\n  margin: inherit;\n  white-space: auto;\n}\n.wset {\n  min-width: 125px;\n  justify-content: center;\n}\n\n.right {\n  margin-left: -1px;\n}\n</style>\n\n",
    "/api/sources/raw?key=test:apps/backend/src/evaluations/evaluations.service.spec.ts": "import {NotFoundException} from '@nestjs/common';\nimport {SequelizeModule} from '@nestjs/sequelize';\nimport {Test} from '@nestjs/testing';\nimport {\n  CREATE_EVALUATION_DTO_WITHOUT_FILENAME,\n  CREATE_EVALUATION_DTO_WITHOUT_TAGS,\n  EVALUATION_WITH_TAGS_1,\n  UPDATE_EVALUATION,\n  UPDATE_EVALUATION_DATA_ONLY,\n  UPDATE_EVALUATION_FILENAME_ONLY\n} from '../../test/constants/evaluations-test.constant';\nimport {GROUP_1} from '../../test/constants/groups-test.constant';\nimport {CREATE_USER_DTO_TEST_OBJ} from '../../test/constants/users-test.constant';\nimport {DatabaseModule} from '../database/database.module';\nimport {DatabaseService} from '../database/database.service';\nimport {EvaluationTagsModule} from '../evaluation-tags/evaluation-tags.module';\nimport {EvaluationTagsService} from '../evaluation-tags/evaluation-tags.service';\nimport {GroupEvaluation} from '../group-evaluations/group-evaluation.model';\nimport {GroupUser} from '../group-users/group-user.model';\nimport {Group} from '../groups/group.model';\nimport {GroupsService} from '../groups/groups.service';\nimport {UserDto} from '../users/dto/user.dto';\nimport {UsersModule} from '../users/users.module';\nimport {UsersService} from '../users/users.service';\nimport {EvaluationDto} from './dto/evaluation.dto';\nimport {Evaluation} from './evaluation.model';\nimport {EvaluationsService} from './evaluations.service';\n\ndescribe('EvaluationsService', () => {\n  let evaluationsService: EvaluationsService;\n  let evaluationTagsService: EvaluationTagsService;\n  let databaseService: DatabaseService;\n  let usersService: UsersService;\n  let user: UserDto;\n  let groupsService: GroupsService;\n\n  beforeAll(async () => {\n    const module = await Test.createTestingModule({\n      imports: [\n        DatabaseModule,\n        SequelizeModule.forFeature([\n          Evaluation,\n          GroupUser,\n          Group,\n          GroupEvaluation\n        ]),\n        EvaluationTagsModule,\n        UsersModule\n      ],\n      providers: [\n        EvaluationsService,\n        DatabaseService,\n        UsersService,\n        GroupsService\n      ]\n    }).compile();\n\n    evaluationsService = module.get<EvaluationsService>(EvaluationsService);\n    evaluationTagsService = module.get<EvaluationTagsService>(\n      EvaluationTagsService\n    );\n    databaseService = module.get<DatabaseService>(DatabaseService);\n    usersService = module.get<UsersService>(UsersService);\n    groupsService = module.get<GroupsService>(GroupsService);\n  });\n\n  beforeEach(async () => {\n    await databaseService.cleanAll();\n    user = new UserDto(await usersService.create(CREATE_USER_DTO_TEST_OBJ));\n  });\n\n  describe('findAll', () => {\n    it('should find all evaluations', async () => {\n      let evaluationsDtoArray = await evaluationsService.findAll();\n      expect(evaluationsDtoArray).toEqual([]);\n\n      await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n      await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n      evaluationsDtoArray = await evaluationsService.findAll();\n      expect(evaluationsDtoArray.length).toEqual(2);\n    });\n\n    it('should include the evaluation user', async () => {\n      await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n\n      const evaluations = await evaluationsService.findAll();\n      expect(new UserDto(evaluations[0].user)).toEqual(user);\n    });\n\n    it('should include the evaluation group and group users', async () => {\n      const group = await groupsService.create(GROUP_1);\n      const owner = await usersService.findById(user.id);\n      const evaluation = await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n\n      let evaluations = await evaluationsService.findAll();\n      expect(evaluations[0].groups[0]).not.toBeDefined();\n\n      await groupsService.addEvaluationToGroup(group, evaluation);\n      await groupsService.addUserToGroup(group, owner, 'owner');\n\n      evaluations = await evaluationsService.findAll();\n      const foundGroup = evaluations[0].groups[0];\n      expect(foundGroup).toBeDefined();\n      expect(foundGroup.id).toEqual(group.id);\n      expect(foundGroup.users.length).toEqual(1);\n      expect(foundGroup.users[0].id).toEqual(owner.id);\n      expect(foundGroup.users[0].GroupUser.role).toEqual('owner');\n    });\n  });\n\n  describe('findById', () => {\n    it('should find evaluations by id', async () => {\n      expect.assertions(1);\n      const evaluation = await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n      const foundEvaluation = await evaluationsService.findById(evaluation.id);\n      expect(new EvaluationDto(evaluation)).toEqual(\n        new EvaluationDto(foundEvaluation)\n      );\n    });\n\n    it('should throw an error if an evaluation does not exist', async () => {\n      expect.assertions(1);\n      await expect(evaluationsService.findById('-1')).rejects.toThrow(\n        NotFoundException\n      );\n    });\n  });\n\n  describe('create', () => {\n    it('should create a new evaluation with evaluation tags', async () => {\n      const evaluation = await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n      expect(evaluation.id).toBeDefined();\n      expect(evaluation.updatedAt).toBeDefined();\n      expect(evaluation.createdAt).toBeDefined();\n      expect(evaluation.data).toEqual({});\n      expect(evaluation.filename).toEqual(EVALUATION_WITH_TAGS_1.filename);\n      expect(evaluation.evaluationTags[0].evaluationId).toBeDefined();\n      expect(evaluation.evaluationTags[0].updatedAt).toBeDefined();\n      expect(evaluation.evaluationTags[0].createdAt).toBeDefined();\n\n      if (EVALUATION_WITH_TAGS_1.evaluationTags === undefined) {\n        throw new TypeError(\n          'Evaluation fixture does not have any associated tags.'\n        );\n      }\n\n      expect(evaluation.evaluationTags?.[0].value).toEqual(\n        EVALUATION_WITH_TAGS_1.evaluationTags[0].value\n      );\n    });\n\n    it('should create a new evaluation without evaluation tags', async () => {\n      const evaluation = await evaluationsService.create({\n        ...CREATE_EVALUATION_DTO_WITHOUT_TAGS,\n        data: {},\n        userId: user.id\n      });\n      expect(evaluation.id).toBeDefined();\n      expect(evaluation.updatedAt).toBeDefined();\n      expect(evaluation.createdAt).toBeDefined();\n      expect(evaluation.data).toEqual({});\n      expect(evaluation.filename).toEqual(\n        CREATE_EVALUATION_DTO_WITHOUT_TAGS.filename\n      );\n      expect(evaluation.evaluationTags).not.toBeDefined();\n      expect((await evaluationTagsService.findAll()).length).toBe(0);\n    });\n\n    it('should throw an error when missing the filename field', async () => {\n      expect.assertions(1);\n      await expect(\n        evaluationsService.create({\n          ...CREATE_EVALUATION_DTO_WITHOUT_FILENAME,\n          data: {},\n          userId: user.id\n        })\n      ).rejects.toThrow(\n        'notNull Violation: Evaluation.filename cannot be null'\n      );\n    });\n  });\n\n  describe('update', () => {\n    it('should throw an error if an evaluation does not exist', async () => {\n      expect.assertions(1);\n      await expect(\n        evaluationsService.update('-1', UPDATE_EVALUATION)\n      ).rejects.toThrow(NotFoundException);\n    });\n\n    it('should update all fields of an evaluation', async () => {\n      const evaluation = await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n      const updatedEvaluation = await evaluationsService.update(\n        evaluation.id,\n        UPDATE_EVALUATION\n      );\n      expect(updatedEvaluation.id).toEqual(evaluation.id);\n      expect(updatedEvaluation.createdAt).toEqual(evaluation.createdAt);\n      expect(updatedEvaluation.updatedAt).not.toEqual(evaluation.updatedAt);\n      expect(updatedEvaluation.data).not.toEqual(evaluation.data);\n      expect(updatedEvaluation.filename).not.toEqual(evaluation.filename);\n    });\n\n    it('should only update data if provided', async () => {\n      const evaluation = await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n      const updatedEvaluation = await evaluationsService.update(\n        evaluation.id,\n        UPDATE_EVALUATION_DATA_ONLY\n      );\n      expect(updatedEvaluation.id).toEqual(evaluation.id);\n      expect(updatedEvaluation.createdAt).toEqual(evaluation.createdAt);\n      expect(updatedEvaluation.updatedAt).not.toEqual(evaluation.updatedAt);\n      expect(updatedEvaluation.evaluationTags.length).toEqual(\n        evaluation.evaluationTags.length\n      );\n      expect(updatedEvaluation.data).not.toEqual(evaluation.data);\n      expect(updatedEvaluation.filename).toEqual(evaluation.filename);\n    });\n\n    it('should only update filename if provided', async () => {\n      const evaluation = await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n\n      const updatedEvaluation = await evaluationsService.update(\n        evaluation.id,\n        UPDATE_EVALUATION_FILENAME_ONLY\n      );\n      expect(updatedEvaluation.id).toEqual(evaluation.id);\n      expect(updatedEvaluation.createdAt).toEqual(evaluation.createdAt);\n      expect(updatedEvaluation.updatedAt).not.toEqual(evaluation.updatedAt);\n      expect(updatedEvaluation.evaluationTags.length).toEqual(\n        evaluation.evaluationTags.length\n      );\n      expect(updatedEvaluation.data).toEqual(evaluation.data);\n      expect(updatedEvaluation.filename).not.toEqual(evaluation.filename);\n    });\n  });\n\n  describe('remove', () => {\n    it('should remove an evaluation and its evaluation tags given an id', async () => {\n      const evaluation = await evaluationsService.create({\n        ...EVALUATION_WITH_TAGS_1,\n        data: {},\n        userId: user.id\n      });\n      const removedEvaluation = await evaluationsService.remove(evaluation.id);\n      const foundEvaluationTags = await evaluationTagsService.findAll();\n      expect(foundEvaluationTags.length).toEqual(0);\n      expect(new EvaluationDto(removedEvaluation)).toEqual(\n        new EvaluationDto(evaluation)\n      );\n\n      await expect(\n        evaluationsService.findById(removedEvaluation.id)\n      ).rejects.toThrow(NotFoundException);\n    });\n\n    it('should throw an error when the evaluation does not exist', async () => {\n      expect.assertions(1);\n      await expect(evaluationsService.findById('-1')).rejects.toThrow(\n        NotFoundException\n      );\n    });\n  });\n\n  afterAll(async () => {\n    await databaseService.cleanAll();\n    await databaseService.closeConnection();\n  });\n});\n\n",
    "/api/sources/raw?key=test:apps/backend/src/config/config.service.spec.ts": "import * as dotenv from 'dotenv';\nimport mock from 'mock-fs';\nimport {\n  DATABASE_URL_MOCK_ENV,\n  ENV_MOCK_FILE,\n  SIMPLE_ENV_MOCK_FILE\n} from '../../test/constants/env-test.constant';\nimport {ConfigService} from './config.service';\n\n/* If you run the test without --silent , you need to add console.log() before you mock out the\nfile system in the beforeAll() or it'll throw an error (this is a documented bug which can be\nfound at https://github.com/tschaub/mock-fs/issues/234).\nIf you run the test with --silent (which we do by default), you don't need the log statement. */\ndescribe('Config Service', () => {\n  beforeAll(async () => {\n    // eslint-disable-next-line no-console\n    console.log();\n    // Used as an empty file system\n    mock({\n      // No files created (.env file does not exist yet)\n    });\n  });\n\n  describe('Tests the get function when .env file does not exist', () => {\n    it('should return undefined because env variable does not exist', () => {\n      const configService = new ConfigService();\n      expect(configService.get('DATABASE_NAME')).toBe(undefined);\n    });\n\n    it('should print to the console about how it was unable to read .env file', () => {\n      const consoleSpy = jest.spyOn(console, 'log');\n      // Used to make sure logs are outputted\n      new ConfigService();\n      expect(consoleSpy).toHaveBeenCalledWith(\n        'Unable to read configuration file `.env`!'\n      );\n      expect(consoleSpy).toHaveBeenCalledWith(\n        'Falling back to environment or undefined values!'\n      );\n    });\n  });\n\n  describe('Tests the get function when .env file does exist', () => {\n    beforeAll(() => {\n      // Mock .env file\n      mock({\n        '.env': ENV_MOCK_FILE\n      });\n    });\n\n    it('should return the correct database name', () => {\n      const configService = new ConfigService();\n      expect(configService.get('PORT')).toEqual('8000');\n      expect(configService.get('DATABASE_HOST')).toEqual('localhost');\n      expect(configService.get('DATABASE_PORT')).toEqual('5432');\n      expect(configService.get('DATABASE_USERNAME')).toEqual('postgres');\n      expect(configService.get('DATABASE_PASSWORD')).toEqual('postgres');\n      expect(configService.get('DATABASE_NAME')).toEqual(\n        'heimdallts_jest_testing_service_db'\n      );\n      expect(configService.get('JWT_SECRET')).toEqual('abc123');\n      expect(configService.get('NODE_ENV')).toEqual('test');\n    });\n\n    it('should return undefined because env variable does not exist', () => {\n      const configService = new ConfigService();\n      expect(configService.get('INVALID_VARIABLE')).toBe(undefined);\n    });\n  });\n\n  describe('Tests the get function when environment file is sourced externally', () => {\n    beforeAll(() => {\n      // Mock .env file\n      mock({\n        '.env-loaded-externally': SIMPLE_ENV_MOCK_FILE\n      });\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      dotenv.config({path: '.env-loaded-externally'});\n    });\n\n    it('should return the correct database port', () => {\n      const configService = new ConfigService();\n      expect(configService.get('PORT')).toEqual('8001');\n    });\n\n    it('should return undefined because env variable does not exist', () => {\n      const configService = new ConfigService();\n      expect(configService.get('INVALID_VARIABLE')).toBe(undefined);\n    });\n  });\n\n  describe('When using DATABASE_URL', () => {\n    beforeAll(() => {\n      mock({\n        '.env': DATABASE_URL_MOCK_ENV\n      });\n    });\n\n    it('should correctly parse DATABASE_URL into its components', () => {\n      const configService = new ConfigService();\n      expect(configService.get('DATABASE_HOST')).toEqual(\n        'ec2-00-000-11-123.compute-1.amazonaws.com'\n      );\n      expect(configService.get('DATABASE_PORT')).toEqual('5432');\n      expect(configService.get('DATABASE_USERNAME')).toEqual(\n        'abcdefghijk123456'\n      );\n      expect(configService.get('DATABASE_PASSWORD')).toEqual(\n        '000011112222333344455556666777778889999aaaabbbbccccddddeeeffff'\n      );\n      expect(configService.get('DATABASE_NAME')).toEqual('database01');\n    });\n  });\n\n  describe('Tests for thrown errors', () => {\n    it('should throw an EACCES error', () => {\n      expect.assertions(1);\n      mock({\n        '.env': mock.file({\n          content: 'DATABASE_NAME=heimdallts_jest_testing_service_db',\n          mode: 0o000 // Set file system permissions to none\n        })\n      });\n      expect(() => new ConfigService()).toThrowError(\n        \"EACCES: permission denied, open '.env'\"\n      );\n    });\n\n    it('should throw an error in the get function', () => {\n      mock({\n        '.env': ENV_MOCK_FILE\n      });\n      const configService = new ConfigService();\n      jest.spyOn(configService, 'get').mockImplementationOnce(() => {\n        throw new Error('');\n      });\n      expect(() => configService.get('DATABASE_NAME')).toThrowError();\n    });\n  });\n\n  describe('Set', () => {\n    it('should set a key value', () => {\n      const configService = new ConfigService();\n      configService.set('test', 'value');\n      expect(configService.get('test')).toBe('value');\n    });\n  });\n\n  afterAll(() => {\n    // Restore the fs binding to the real file system\n    mock.restore();\n  });\n});\n\n",
    "/api/sources/raw?key=test:apps/backend/src/pipes/password-complexity.pipe.spec.ts": "import {ArgumentMetadata, BadRequestException} from '@nestjs/common';\nimport {\n  CREATE_USER_DTO_TEST_OBJ,\n  CREATE_USER_DTO_TEST_OBJ_WITH_MISSING_PASSWORD_FIELD,\n  UPDATE_USER_DTO_TEST_OBJ,\n  UPDATE_USER_DTO_TEST_WITHOUT_PASSWORD,\n  UPDATE_USER_DTO_WITHOUT_PASSWORD_FIELDS\n} from '../../test/constants/users-test.constant';\nimport {PasswordComplexityPipe} from './password-complexity.pipe';\n\ndescribe('PasswordComplexityPipe', () => {\n  let passwordComplexityPipe: PasswordComplexityPipe;\n  let metaData: ArgumentMetadata;\n\n  beforeEach(() => {\n    passwordComplexityPipe = new PasswordComplexityPipe();\n  });\n\n  it('should make sure that the passwords-complexity pipe is defined', () => {\n    expect(passwordComplexityPipe).toBeDefined();\n  });\n\n  describe('Helper Function Tests', () => {\n    describe('hasClasses', () => {\n      it('should fail because the password length is less than 15 characters and it has all character classes', () => {\n        expect(passwordComplexityPipe.hasClasses('$7aB')).toBeFalsy();\n      });\n\n      it('should fail because the password does not contain a special character', () => {\n        expect(\n          passwordComplexityPipe.hasClasses('Testpasswordwithoutspecialchar7')\n        ).toBeFalsy();\n      });\n\n      it('should fail because the password does not contain a number', () => {\n        expect(\n          passwordComplexityPipe.hasClasses('Testpasswordwithoutnumber$')\n        ).toBeFalsy();\n      });\n\n      it('should fail because the password does not contain an uppercase letter', () => {\n        expect(\n          passwordComplexityPipe.hasClasses('testpasswordwithoutuppercase7$')\n        ).toBeFalsy();\n      });\n\n      it('should fail because the password does not contain a lowercase letter', () => {\n        expect(\n          passwordComplexityPipe.hasClasses('TESTPASSWORDWITHOUTLOWERCASE7$')\n        ).toBeFalsy();\n      });\n\n      it('should pass because the password has all character classes and is at least 15 characters', () => {\n        expect(\n          passwordComplexityPipe.hasClasses('Atestpassword7$')\n        ).toBeTruthy();\n      });\n    });\n\n    describe('noRepeats', () => {\n      it('should fail because there is more than 3 consecutive repeating lowercase characters in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('aaaa')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 lowercase characters back-to-back in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('test')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 consecutive repeating uppercase characters in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('AAAA')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 uppercase characters back-to-back in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('TEST')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 consecutive repeating numbers in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('7777')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 numbers back-to-back in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('1078')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 consecutive repeating numbers in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('$$$$')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 special characters back-to-back in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('!@#$')).toBeFalsy();\n      });\n\n      it('should fail because there is more than 3 consecutive white spaces in the password', () => {\n        expect(passwordComplexityPipe.noRepeats('spa    ce')).toBeFalsy();\n      });\n\n      it('should pass because the password meets all the minimum requirements', () => {\n        expect(passwordComplexityPipe.noRepeats('aaaBBB111$$$')).toBeTruthy();\n      });\n    });\n  });\n\n  /* Tests the complexity of a user's password and that when it meets the requirements of:\n    15 characters or longer, at least 1 uppercase letter, lowercase letter, number, special character,\n    the password meets the requirements of not containing more than three consecutive repeating\n    characters, and it contains no more than four repeating characters from the same character class,\n    the same dto object will be returned*/\n  describe('Test Valid Password', () => {\n    it('should return the same CreateUserDto', () => {\n      expect(\n        passwordComplexityPipe.transform(CREATE_USER_DTO_TEST_OBJ, metaData)\n      ).toEqual(CREATE_USER_DTO_TEST_OBJ);\n    });\n\n    it('should return the same UpdateUserDto', () => {\n      expect(\n        passwordComplexityPipe.transform(UPDATE_USER_DTO_TEST_OBJ, metaData)\n      ).toEqual(UPDATE_USER_DTO_TEST_OBJ);\n    });\n\n    it('should return UpdateUserDto if password fields are null', () => {\n      expect(\n        passwordComplexityPipe.transform(\n          UPDATE_USER_DTO_WITHOUT_PASSWORD_FIELDS,\n          metaData\n        )\n      ).toEqual(UPDATE_USER_DTO_WITHOUT_PASSWORD_FIELDS);\n    });\n  });\n\n  /* Tests that when a password does not meet all the minimum requirements,\n    a BadRequestException is thrown */\n  describe('Test Invalid Password', () => {\n    it('should throw a BadRequestException for CreateUserDto', () => {\n      expect(() =>\n        passwordComplexityPipe.transform(\n          CREATE_USER_DTO_TEST_OBJ_WITH_MISSING_PASSWORD_FIELD,\n          metaData\n        )\n      ).toThrowError(BadRequestException);\n      expect(() =>\n        passwordComplexityPipe.transform(\n          CREATE_USER_DTO_TEST_OBJ_WITH_MISSING_PASSWORD_FIELD,\n          metaData\n        )\n      ).toThrowError(\n        'Password does not meet complexity requirements. Passwords are a minimum of 15' +\n          ' characters in length. Passwords must contain at least one special character, number, upper-case letter, and' +\n          ' lower-case letter. Passwords cannot contain more than three consecutive repeating characters.' +\n          ' Passwords cannot contain more than four repeating characters from the same character class.'\n      );\n    });\n\n    it('should throw a BadRequestException for UpdateUserDto', () => {\n      expect(() =>\n        passwordComplexityPipe.transform(\n          UPDATE_USER_DTO_TEST_WITHOUT_PASSWORD,\n          metaData\n        )\n      ).toThrowError(BadRequestException);\n      expect(() =>\n        passwordComplexityPipe.transform(\n          UPDATE_USER_DTO_TEST_WITHOUT_PASSWORD,\n          metaData\n        )\n      ).toThrowError(\n        'Password does not meet complexity requirements. Passwords are a minimum of 15' +\n          ' characters in length. Passwords must contain at least one special character, number, upper-case letter, and' +\n          ' lower-case letter. Passwords cannot contain more than three consecutive repeating characters.' +\n          ' Passwords cannot contain more than four repeating characters from the same character class.'\n      );\n    });\n  });\n});\n\n",
    "/api/sources/raw?key=test:apps/backend/src/pipes/passwords-match.pipe.spec.ts": "import {ArgumentMetadata, BadRequestException} from '@nestjs/common';\nimport {\n  CREATE_USER_DTO_TEST_OBJ,\n  CREATE_USER_DTO_TEST_OBJ_WITH_UNMATCHING_PASSWORDS,\n  UPDATE_USER_DTO_TEST_OBJ,\n  UPDATE_USER_DTO_WITHOUT_PASSWORD_FIELDS\n} from '../../test/constants/users-test.constant';\nimport {PasswordsMatchPipe} from './passwords-match.pipe';\n\ndescribe('PasswordsMatchPipe', () => {\n  let passwordsMatchPipe: PasswordsMatchPipe;\n  let metaData: ArgumentMetadata;\n\n  beforeEach(() => {\n    passwordsMatchPipe = new PasswordsMatchPipe();\n  });\n\n  it('should make sure that the passwords-match pipe is defined', () => {\n    expect(passwordsMatchPipe).toBeDefined();\n  });\n\n  /* Tests that when password and passwordConfirmation match,\n   the same CreateUserDto obj that is passed to the pipeline, is returned */\n  describe('Test Matching Passwords', () => {\n    it('should return the same CreateUserDto', () => {\n      expect(\n        passwordsMatchPipe.transform(CREATE_USER_DTO_TEST_OBJ, metaData)\n      ).toEqual(CREATE_USER_DTO_TEST_OBJ);\n    });\n\n    it('should return the same UpdateUserDto', () => {\n      expect(\n        passwordsMatchPipe.transform(UPDATE_USER_DTO_TEST_OBJ, metaData)\n      ).toEqual(UPDATE_USER_DTO_TEST_OBJ);\n    });\n\n    it('should return UpdateUserDto if password fields are null', () => {\n      expect(\n        passwordsMatchPipe.transform(\n          UPDATE_USER_DTO_WITHOUT_PASSWORD_FIELDS,\n          metaData\n        )\n      ).toEqual(UPDATE_USER_DTO_WITHOUT_PASSWORD_FIELDS);\n    });\n  });\n\n  /* Tests that when password and passwordConfirmation don't match,\n    a BadRequestException is thrown */\n  describe('Test Mismatching Passwords', () => {\n    it('should throw a Bad Request Exception', () => {\n      expect(() =>\n        passwordsMatchPipe.transform(\n          CREATE_USER_DTO_TEST_OBJ_WITH_UNMATCHING_PASSWORDS,\n          metaData\n        )\n      ).toThrowError(BadRequestException);\n      expect(() =>\n        passwordsMatchPipe.transform(\n          CREATE_USER_DTO_TEST_OBJ_WITH_UNMATCHING_PASSWORDS,\n          metaData\n        )\n      ).toThrowError('Passwords do not match');\n    });\n  });\n});\n\n",
    "/api/rules/show?key=typescript:S3776": {
      "rule": {
        "key": "typescript:S3776",
        "repo": "typescript",
        "name": "Cognitive Complexity of functions should not be too high",
        "createdAt": "2021-08-13T16:14:42+0000",
        "htmlDesc": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>",
        "mdDesc": "<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>",
        "severity": "CRITICAL",
        "status": "READY",
        "isTemplate": false,
        "tags": [],
        "sysTags": [
          "brain-overload"
        ],
        "lang": "ts",
        "langName": "TypeScript",
        "params": [
          {
            "key": "threshold",
            "htmlDesc": "The maximum authorized complexity.",
            "defaultValue": 15,
            "type": "INTEGER"
          }
        ],
        "defaultDebtRemFnType": "LINEAR_OFFSET",
        "defaultDebtRemFnCoeff": "1min",
        "defaultDebtRemFnOffset": "5min",
        "effortToFixDescription": "per complexity point over the threshold",
        "debtOverloaded": false,
        "debtRemFnType": "LINEAR_OFFSET",
        "debtRemFnCoeff": "1min",
        "debtRemFnOffset": "5min",
        "type": "CODE_SMELL",
        "defaultRemFnType": "LINEAR_OFFSET",
        "defaultRemFnGapMultiplier": "1min",
        "defaultRemFnBaseEffort": "5min",
        "remFnType": "LINEAR_OFFSET",
        "remFnGapMultiplier": "1min",
        "remFnBaseEffort": "5min",
        "remFnOverloaded": false,
        "gapDescription": "per complexity point over the threshold",
        "scope": "MAIN",
        "isExternal": false
      },
      "actives": []
    },
    "/api/rules/show?key=typescript:S3317": {
      "rule": {
        "key": "typescript:S3317",
        "repo": "typescript",
        "name": "Default export names and file names should match",
        "createdAt": "2021-08-13T16:14:42+0000",
        "htmlDesc": "<p>By convention, a file that exports only one class, function, or constant should be named for that class, function or constant. Anything else may\nconfuse maintainers.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n// file path: myclass.js  -- Noncompliant\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n// file path: MyClass.js\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Exceptions</h2>\n<p>Case, underscores ( <code>_</code> ) and dashes (<code>-</code>) are ignored from the name comparison.</p>",
        "mdDesc": "<p>By convention, a file that exports only one class, function, or constant should be named for that class, function or constant. Anything else may\nconfuse maintainers.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n// file path: myclass.js  -- Noncompliant\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n// file path: MyClass.js\nclass MyClass {\n  // ...\n}\nexport default MyClass;\n</pre>\n<h2>Exceptions</h2>\n<p>Case, underscores ( <code>_</code> ) and dashes (<code>-</code>) are ignored from the name comparison.</p>",
        "severity": "MINOR",
        "status": "READY",
        "isTemplate": false,
        "tags": [],
        "sysTags": [
          "confusing",
          "convention",
          "es2015"
        ],
        "lang": "ts",
        "langName": "TypeScript",
        "params": [],
        "defaultDebtRemFnType": "CONSTANT_ISSUE",
        "defaultDebtRemFnOffset": "5min",
        "debtOverloaded": false,
        "debtRemFnType": "CONSTANT_ISSUE",
        "debtRemFnOffset": "5min",
        "type": "CODE_SMELL",
        "defaultRemFnType": "CONSTANT_ISSUE",
        "defaultRemFnBaseEffort": "5min",
        "remFnType": "CONSTANT_ISSUE",
        "remFnBaseEffort": "5min",
        "remFnOverloaded": false,
        "scope": "MAIN",
        "isExternal": false
      },
      "actives": []
    },
    "/api/rules/show?key=typescript:S1117": {
      "rule": {
        "key": "typescript:S1117",
        "repo": "typescript",
        "name": "Variables should not be shadowed",
        "createdAt": "2021-08-13T16:14:42+0000",
        "htmlDesc": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>",
        "mdDesc": "<p>Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.</p>",
        "severity": "MAJOR",
        "status": "READY",
        "isTemplate": false,
        "tags": [],
        "sysTags": [
          "pitfall",
          "suspicious"
        ],
        "lang": "ts",
        "langName": "TypeScript",
        "params": [],
        "defaultDebtRemFnType": "CONSTANT_ISSUE",
        "defaultDebtRemFnOffset": "5min",
        "debtOverloaded": false,
        "debtRemFnType": "CONSTANT_ISSUE",
        "debtRemFnOffset": "5min",
        "type": "CODE_SMELL",
        "defaultRemFnType": "CONSTANT_ISSUE",
        "defaultRemFnBaseEffort": "5min",
        "remFnType": "CONSTANT_ISSUE",
        "remFnBaseEffort": "5min",
        "remFnOverloaded": false,
        "scope": "MAIN",
        "isExternal": false
      },
      "actives": []
    },
    "/api/rules/show?key=typescript:S3358": {
      "rule": {
        "key": "typescript:S3358",
        "repo": "typescript",
        "name": "Ternary operators should not be nested",
        "createdAt": "2021-08-13T16:14:42+0000",
        "htmlDesc": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>",
        "mdDesc": "<p>Just because you <em>can</em> do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getReadableStatus(job) {\n  return job.isRunning() ? \"Running\" : job.hasErrors() ? \"Failed\" : \"Succeeded \";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getReadableStatus(job) {\n  if (job.isRunning()) {\n    return \"Running\";\n  }\n  return job.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n</pre>",
        "severity": "MAJOR",
        "status": "READY",
        "isTemplate": false,
        "tags": [],
        "sysTags": [
          "confusing"
        ],
        "lang": "ts",
        "langName": "TypeScript",
        "params": [],
        "defaultDebtRemFnType": "CONSTANT_ISSUE",
        "defaultDebtRemFnOffset": "5min",
        "debtOverloaded": false,
        "debtRemFnType": "CONSTANT_ISSUE",
        "debtRemFnOffset": "5min",
        "type": "CODE_SMELL",
        "defaultRemFnType": "CONSTANT_ISSUE",
        "defaultRemFnBaseEffort": "5min",
        "remFnType": "CONSTANT_ISSUE",
        "remFnBaseEffort": "5min",
        "remFnOverloaded": false,
        "scope": "MAIN",
        "isExternal": false
      },
      "actives": []
    },
    "/api/rules/show?key=typescript:S4325": {
      "rule": {
        "key": "typescript:S4325",
        "repo": "typescript",
        "name": "Redundant casts and non-null assertions should be avoided",
        "createdAt": "2021-08-13T16:14:42+0000",
        "htmlDesc": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>",
        "mdDesc": "<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer the type (because\n<code>typeof</code>, <code>instanceof</code>, etc was used). This compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>",
        "severity": "MINOR",
        "status": "READY",
        "isTemplate": false,
        "tags": [],
        "sysTags": [
          "redundant"
        ],
        "lang": "ts",
        "langName": "TypeScript",
        "params": [],
        "defaultDebtRemFnType": "CONSTANT_ISSUE",
        "defaultDebtRemFnOffset": "1min",
        "debtOverloaded": false,
        "debtRemFnType": "CONSTANT_ISSUE",
        "debtRemFnOffset": "1min",
        "type": "CODE_SMELL",
        "defaultRemFnType": "CONSTANT_ISSUE",
        "defaultRemFnBaseEffort": "1min",
        "remFnType": "CONSTANT_ISSUE",
        "remFnBaseEffort": "1min",
        "remFnOverloaded": false,
        "scope": "MAIN",
        "isExternal": false
      },
      "actives": []
    },
    "/api/rules/show?key=typescript:S4138": {
      "rule": {
        "key": "typescript:S4138",
        "repo": "typescript",
        "name": "\"for of\" should be used with Iterables",
        "createdAt": "2021-08-13T16:14:42+0000",
        "htmlDesc": "<p>If you have an iterable, such as an array, set, or list, your best option for looping through its values is the <code>for of</code> syntax. Use a\ncounter, and …​ well you’ll get the right behavior, but your code just isn’t as clean or clear.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nconst arr = [4, 3, 2, 1];\n\nfor (let i = 0; i &lt; arr.length; i++) {  // Noncompliant\n  console.log(arr[i]);\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nconst arr = [4, 3, 2, 1];\n\nfor (let value of arr) {\n  console.log(value);\n}\n</pre>",
        "mdDesc": "<p>If you have an iterable, such as an array, set, or list, your best option for looping through its values is the <code>for of</code> syntax. Use a\ncounter, and …​ well you’ll get the right behavior, but your code just isn’t as clean or clear.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nconst arr = [4, 3, 2, 1];\n\nfor (let i = 0; i &lt; arr.length; i++) {  // Noncompliant\n  console.log(arr[i]);\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nconst arr = [4, 3, 2, 1];\n\nfor (let value of arr) {\n  console.log(value);\n}\n</pre>",
        "severity": "MINOR",
        "status": "READY",
        "isTemplate": false,
        "tags": [],
        "sysTags": [
          "clumsy"
        ],
        "lang": "ts",
        "langName": "TypeScript",
        "params": [],
        "defaultDebtRemFnType": "CONSTANT_ISSUE",
        "defaultDebtRemFnOffset": "5min",
        "debtOverloaded": false,
        "debtRemFnType": "CONSTANT_ISSUE",
        "debtRemFnOffset": "5min",
        "type": "CODE_SMELL",
        "defaultRemFnType": "CONSTANT_ISSUE",
        "defaultRemFnBaseEffort": "5min",
        "remFnType": "CONSTANT_ISSUE",
        "remFnBaseEffort": "5min",
        "remFnOverloaded": false,
        "scope": "MAIN",
        "isExternal": false
      },
      "actives": []
    },
    "/api/rules/show?key=typescript:S4144": {
      "rule": {
        "key": "typescript:S4144",
        "repo": "typescript",
        "name": "Functions should not have identical implementations",
        "createdAt": "2021-08-13T16:14:42+0000",
        "htmlDesc": "<p>When two functions have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but\nmay be confusing to maintainers. In the latter case, the code should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {  // Noncompliant\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {\n  return calculateCode();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Functions with fewer than 3 lines are ignored.</p>",
        "mdDesc": "<p>When two functions have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but\nmay be confusing to maintainers. In the latter case, the code should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {  // Noncompliant\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction calculateCode() {\n  doTheThing();\n  doOtherThing();\n  return code;\n}\n\nfunction getName() {\n  return calculateCode();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Functions with fewer than 3 lines are ignored.</p>",
        "severity": "MAJOR",
        "status": "READY",
        "isTemplate": false,
        "tags": [],
        "sysTags": [
          "confusing",
          "duplicate",
          "suspicious"
        ],
        "lang": "ts",
        "langName": "TypeScript",
        "params": [],
        "defaultDebtRemFnType": "CONSTANT_ISSUE",
        "defaultDebtRemFnOffset": "15min",
        "debtOverloaded": false,
        "debtRemFnType": "CONSTANT_ISSUE",
        "debtRemFnOffset": "15min",
        "type": "CODE_SMELL",
        "defaultRemFnType": "CONSTANT_ISSUE",
        "defaultRemFnBaseEffort": "15min",
        "remFnType": "CONSTANT_ISSUE",
        "remFnBaseEffort": "15min",
        "remFnOverloaded": false,
        "scope": "MAIN",
        "isExternal": false
      },
      "actives": []
    },
    "/api/rules/show?key=typescript:S1135": {
      "rule": {
        "key": "typescript:S1135",
        "repo": "typescript",
        "name": "Track uses of \"TODO\" tags",
        "createdAt": "2021-08-13T16:14:42+0000",
        "htmlDesc": "<p><code>TODO</code> tags are commonly used to mark places where some more code is required, but which the developer wants to implement later.</p>\n<p>Sometimes the developer will not have the time or will simply forget to get back to that tag.</p>\n<p>This rule is meant to track those tags and to ensure that they do not go unnoticed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction doSomething() {\n  // TODO\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/546.html\">MITRE, CWE-546</a> - Suspicious Comment </li>\n</ul>",
        "mdDesc": "<p><code>TODO</code> tags are commonly used to mark places where some more code is required, but which the developer wants to implement later.</p>\n<p>Sometimes the developer will not have the time or will simply forget to get back to that tag.</p>\n<p>This rule is meant to track those tags and to ensure that they do not go unnoticed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction doSomething() {\n  // TODO\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/546.html\">MITRE, CWE-546</a> - Suspicious Comment </li>\n</ul>",
        "severity": "INFO",
        "status": "READY",
        "isTemplate": false,
        "tags": [],
        "sysTags": [
          "cwe"
        ],
        "lang": "ts",
        "langName": "TypeScript",
        "params": [],
        "defaultDebtRemFnType": "CONSTANT_ISSUE",
        "defaultDebtRemFnOffset": "0min",
        "debtOverloaded": false,
        "debtRemFnType": "CONSTANT_ISSUE",
        "debtRemFnOffset": "0min",
        "type": "CODE_SMELL",
        "defaultRemFnType": "CONSTANT_ISSUE",
        "defaultRemFnBaseEffort": "0min",
        "remFnType": "CONSTANT_ISSUE",
        "remFnBaseEffort": "0min",
        "remFnOverloaded": false,
        "scope": "MAIN",
        "isExternal": false
      },
      "actives": []
    },
    "/api/rules/show?key=typescript:S1848": {
      "rule": {
        "key": "typescript:S1848",
        "repo": "typescript",
        "name": "Objects should not be created to be dropped immediately without being used",
        "createdAt": "2021-08-13T16:14:42+0000",
        "htmlDesc": "<p>There is no good reason to create a new object to not do anything with it. Most of the time, this is due to a missing piece of code and so could\nlead to an unexpected behavior in production.</p>\n<p>If it was done on purpose because the constructor has side-effects, then that side-effect code should be moved into a separate method and called\ndirectly.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nnew MyConstructor(); // Non-Compliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar something = new MyConstructor();  // Compliant\n</pre>\n<h2>Exceptions</h2>\n<p>Immediately dropped new objects inside <code>try</code>-statements are ignored.</p>\n<pre>\ntry {\n  new MyConstructor();\n} catch (e) {\n  /* ... */\n}\n</pre>",
        "mdDesc": "<p>There is no good reason to create a new object to not do anything with it. Most of the time, this is due to a missing piece of code and so could\nlead to an unexpected behavior in production.</p>\n<p>If it was done on purpose because the constructor has side-effects, then that side-effect code should be moved into a separate method and called\ndirectly.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nnew MyConstructor(); // Non-Compliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar something = new MyConstructor();  // Compliant\n</pre>\n<h2>Exceptions</h2>\n<p>Immediately dropped new objects inside <code>try</code>-statements are ignored.</p>\n<pre>\ntry {\n  new MyConstructor();\n} catch (e) {\n  /* ... */\n}\n</pre>",
        "severity": "MAJOR",
        "status": "READY",
        "isTemplate": false,
        "tags": [],
        "sysTags": [],
        "lang": "ts",
        "langName": "TypeScript",
        "params": [],
        "defaultDebtRemFnType": "CONSTANT_ISSUE",
        "defaultDebtRemFnOffset": "5min",
        "debtOverloaded": false,
        "debtRemFnType": "CONSTANT_ISSUE",
        "debtRemFnOffset": "5min",
        "type": "BUG",
        "defaultRemFnType": "CONSTANT_ISSUE",
        "defaultRemFnBaseEffort": "5min",
        "remFnType": "CONSTANT_ISSUE",
        "remFnBaseEffort": "5min",
        "remFnOverloaded": false,
        "scope": "MAIN",
        "isExternal": false
      },
      "actives": []
    }
  }
  