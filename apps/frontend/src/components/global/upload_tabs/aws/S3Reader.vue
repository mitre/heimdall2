<template>
  <v-stepper v-model="step" vertical>
    <v-stepper-step :complete="!!assumed_role" step="1">
      Account Credentials {{ step === 1 ? shown_error : "" }}
    </v-stepper-step>

    <AuthStepBasic
      v-bind:access_token.sync="access_token"
      v-bind:secret_token.sync="secret_token"
      @auth-basic="handle_basic"
      @goto-mfa="handle_goto_mfa"
    />

    <v-stepper-step
      :complete="!!assumed_role && assumed_role.from_mfa"
      step="2"
    >
      MFA Authorization {{ step === 2 ? shown_error : "" }}
    </v-stepper-step>

    <AuthStepMFA
      v-bind:mfa_token.sync="mfa_token"
      v-bind:mfa_serial.sync="mfa_serial"
      @auth-mfa="handle_mfa"
      @exit-mfa="handle_cancel_mfa"
    />

    <v-stepper-step step="3">
      Browse Bucket {{ step === 3 ? shown_error : "" }}
    </v-stepper-step>

    <FileList
      :auth="assumed_role"
      :files="files"
      @exit-list="handle_cancel_mfa"
      @got-files="got_files"
      @load-bucket="load_bucket"
    />
  </v-stepper>
</template>

<script lang="ts">
import Vue from "vue";
import Component from "vue-class-component";
import { getModule } from "vuex-module-decorators";
import S3, { ObjectKey } from "aws-sdk/clients/s3";
import { AWSError } from "aws-sdk/lib/error";
import { LocalStorageVal } from "../../../../utilities/helper_util";
import FileList from "@/components/global/upload_tabs/aws/FileList.vue";
import AuthStepMFA from "@/components/global/upload_tabs/aws/AuthStepMFA.vue";
import AuthStepBasic from "@/components/global/upload_tabs/aws/AuthStepBasic.vue";
import {
  Auth,
  transcribe_error,
  get_session_token,
  MFA_Info,
  AUTH_DURATION
} from "../../../../utilities/aws_util";
import InspecIntakeModule, { FileID } from "@/store/report_intake";

// We declare the props separately to make props types inferable.
const Props = Vue.extend({
  props: {}
});

/** The cached session info */
const local_session_information = new LocalStorageVal<Auth | null>(
  "aws_session_info"
);

/**
 * File reader component for taking in inspec JSON data.
 * Uploads data to the store with unique IDs asynchronously as soon as data is entered.
 * Emits "got-files" with a list of the unique_ids of the loaded files.
 */
@Component({
  components: {
    AuthStepBasic,
    AuthStepMFA,
    FileList
  }
})
export default class S3Reader extends Props {
  /** What error is currently shown, if any. Shared between stages. */
  error: string | null = null;

  /** Form required field rules. Maybe eventually expand to other stuff */
  req_rule = (v: string | null | undefined) =>
    (v || "").trim().length > 0 || "Field is Required";

  /** Passed from step 1 to step 2 (MFA) if necessary */
  /** State of all globally relevant fields */
  access_token: string = "";
  secret_token: string = "";
  mfa_serial: string = "";
  mfa_token: string = "";

  /** Our session information, generated by AWS STS */
  assumed_role: Auth | null = null;

  /** Current step */
  step: number = 1;

  /** Currently loaded file list from bucket */
  files: S3.Object[] = [];

  /**
   * Logs out of current auth stage
   */
  logout() {
    this.assumed_role = null;
    this.mfa_token = "";
  }

  get shown_error(): string {
    if (this.error) {
      return ` - ${this.error}`;
    } else {
      return "";
    }
  }

  /**
   * Handle a basic login.
   * Gets a session token
   */
  handle_basic() {
    // If we need another error, it will be set shortly. If not, the old one is probably not relevant
    this.error = null;

    // Attempt to assume role based on if we've determined 2fa necessary
    get_session_token(this.access_token, this.secret_token).then(
      // Success of get session token - now need to determine if MFA necessary
      success => {
        this.assumed_role = success;
        this.step = 3;
      },

      // Failure of initial get session token: want to set error normally
      failure => {
        this.handle_error(failure);
      }
    );
  }

  handle_goto_mfa() {
    this.step = 2;
  }

  handle_cancel_mfa() {
    this.step = 1;
    this.mfa_token = "";
    this.assumed_role = null; // Just in case
  }

  handle_exit_list() {
    this.step = 1;
    this.mfa_token = "";
    this.assumed_role = null;
    this.files = []; // Just in case
  }

  /** Handle an MFA login.
   * Determine whether further action is necessary
   */
  handle_mfa() {
    // If we need another error, it will be set here
    this.error = null;

    // Build our mfa params
    let mfa: MFA_Info = {
      SerialNumber: this.mfa_serial || null,
      TokenCode: this.mfa_token,
      DurationSeconds: AUTH_DURATION
    };

    // Attempt to assume role based on if we've determined 2fa necessary
    get_session_token(this.access_token, this.secret_token, mfa).then(
      success => {
        // Keep them
        this.assumed_role = success;
        this.step = 3;
      },
      failure => {
        this.handle_error(failure);
      }
    );
  }

  /** On mount, try to look up stored auth info */
  mounted() {
    // Load our session, if there is one
    this.assumed_role = local_session_information.get_default(null);
    if (this.assumed_role) {
      this.step = 3;
    }
  }

  /** Attempt to load.
   * Basically just wraps fetch_files with error handling
   */
  async load_bucket(name: string) {
    let s3 = new S3(this.assumed_role!.creds);
    await s3
      .listObjectsV2({
        Bucket: name,
        MaxKeys: 100
      })
      .promise()
      .then(success => {
        this.files = success.Contents || [];
      })
      .catch(failure => this.handle_error(failure));
  }

  /** Save the current credentials to local storage */
  save_creds() {
    local_session_information.set(this.assumed_role);
  }

  /** Callback to handle an AWS error.
   * Sets shown error.
   */
  handle_error(error: any): void {
    let t_error = error as AWSError;
    this.error = transcribe_error(t_error);
  }

  /** Callback on got files */
  got_files(files: Array<FileID>) {
    this.$emit("got-files", files);
  }
}
</script>
