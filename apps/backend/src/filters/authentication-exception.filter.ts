import {ArgumentsHost, Catch, ExceptionFilter} from '@nestjs/common';
import * as _ from 'lodash';
import {ConfigService} from '../config/config.service';

@Catch(Error)
export class AuthenticationExceptionFilter implements ExceptionFilter {
  configService = new ConfigService();
  constructor(
    readonly authenticationType?: 'oidc' | 'okta' // only OIDC based flows need the extra functionality
  ) {}
  catch(exception: Error, host: ArgumentsHost): void {
    const ctx = host.switchToHttp();
    const request = ctx.getRequest();
    const response = ctx.getResponse();
    const errInfo = {
      message: exception.message,
      stack: exception.stack,
      authInfo: _.get(request, 'authInfo'),
      query: request.query,
      headers: request.headers
    };
    console.error('Authentication Error', errInfo, JSON.stringify(errInfo, null, 2));
    // Restart OIDC auth flow if state fails to verify, this is a known bug with passport-openidconnect that occurs sometimes when logging in - restarting the flow will hopefully result in a state that does not contain an invalid character.
    // It is likely due to invalid characters being generated by the library when creating the 'state' handle.
    // See https://github.com/jaredhanson/passport-openidconnect/issues/76
    if (
      this.authenticationType &&
      _.get(request, 'authInfo.message') ===
      'Unable to verify authorization request state.'
    ) {
      return response.redirect(302, `/authn/${this.authenticationType}`);
    }
    const authError = `${_.get(request, 'authInfo.message')}\n${exception.message}`.trim()
    response.cookie('authenticationError', authError, {
      secure: this.configService.isInProductionMode()
    });
    response.redirect(302, '/');
  }
}
