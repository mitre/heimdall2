{
  "name": "docker-ce-cis-baseline",
  "title": "docker-ce-cis-baseline",
  "maintainer": "MITRE InSpec Team",
  "copyright": "The MITRE Corporation, 2018",
  "copyright_email": "inspec_support@mitre.org",
  "license": "Apache-2.0",
  "summary": "InSpec Validation Profile for CIS Docker CIS",
  "version": "1.1.1",
  "inspec_version": ">= 4.0",
  "inputs": [],
  "supports": [],
  "controls": [
    {
      "title": "5.14 Ensure 'on-failure' container restart policy is set to '5' (Scored)",
      "desc": "Using the --restart flag in the docker run command you can specify a restart\n  policy for how a container should or should not be restarted on exit. You should choose the\n  on-failure restart policy and limit the restart attempts to 5.\n  If you indefinitely keep trying to start the container, it could possibly\n  lead to a denial of service on the host. It could be an easy way to do a distributed denial of\n  service attack especially if you have many containers on the same host. Additionally,\n  ignoring the exit status of the container and always attempting to restart the container\n  leads to noninvestigation of the root cause behind containers getting\n  terminated. If a container gets terminated, you should investigate the reason behind it\n  instead of just attempting to restart it indefinitely. Thus, it is recommended to the\n  use on-failure restart policy and limit it to maximum of 5 restart attempts.",
      "descriptions": {
        "default": "Using the --restart flag in the docker run command you can specify a restart\n  policy for how a container should or should not be restarted on exit. You should choose the\n  on-failure restart policy and limit the restart attempts to 5.\n  If you indefinitely keep trying to start the container, it could possibly\n  lead to a denial of service on the host. It could be an easy way to do a distributed denial of\n  service attack especially if you have many containers on the same host. Additionally,\n  ignoring the exit status of the container and always attempting to restart the container\n  leads to noninvestigation of the root cause behind containers getting\n  terminated. If a container gets terminated, you should investigate the reason behind it\n  instead of just attempting to restart it indefinitely. Thus, it is recommended to the\n  use on-failure restart policy and limit it to maximum of 5 restart attempts."
      },
      "impact": 0,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/reference/commandline/cli/#restart-policies"
        }
      ],
      "tags": {
        "ref": "1.\n  https://docs.docker.com/engine/reference/commandline/run/#restart-policiesrestart",
        "severity": "medium",
        "cis_id": "5.14",
        "cis_control": [
          "18",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SI-1",
          "4"
        ],
        "check_text": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: RestartPolicyName={{ .HostConfig.RestartPolicy.Name }}\n  MaximumRetryCount={{.HostConfig.RestartPolicy.MaximumRetryCount }}' If\n  the above command returns RestartPolicyName=always, then the system is\n  not configured as desired and hence this recommendation is non-compliant. If\n  the above command returns RestartPolicyName=no or just\n  RestartPolicyName=, then the restart policies are not being used and the\n  container would never be restarted of its own. This recommendation is then Not\n  Applicable and can be assumed to be compliant. If the above command returns\n  RestartPolicyName=on-failure, then verify that the number of restart attempts\n  is set to 5 or less by looking at MaximumRetryCount.",
        "fix": "If a container is desired to be restarted of its own, then, for\n  example, you could start the container as below: docker run --detach\n  --restart=on-failure:5 nginx",
        "Default Value": "By default, containers are not configured with restart\n  policies. Hence, containers do not attempt to restart on their own."
      },
      "code": "control 'M-5.14' do\n  title \"5.14 Ensure 'on-failure' container restart policy is set to '5' (Scored)\"\n  desc  \"Using the --restart flag in the docker run command you can specify a restart\n  policy for how a container should or should not be restarted on exit. You should choose the\n  on-failure restart policy and limit the restart attempts to 5.\n  If you indefinitely keep trying to start the container, it could possibly\n  lead to a denial of service on the host. It could be an easy way to do a distributed denial of\n  service attack especially if you have many containers on the same host. Additionally,\n  ignoring the exit status of the container and always attempting to restart the container\n  leads to noninvestigation of the root cause behind containers getting\n  terminated. If a container gets terminated, you should investigate the reason behind it\n  instead of just attempting to restart it indefinitely. Thus, it is recommended to the\n  use on-failure restart policy and limit it to maximum of 5 restart attempts.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  https://docs.docker.com/engine/reference/commandline/run/#restart-policiesrestart\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.14'\n  tag \"cis_control\": ['18', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SI-1', '4']\n  tag \"check_text\": \"docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: RestartPolicyName={{ .HostConfig.RestartPolicy.Name }}\n  MaximumRetryCount={{.HostConfig.RestartPolicy.MaximumRetryCount }}' If\n  the above command returns RestartPolicyName=always, then the system is\n  not configured as desired and hence this recommendation is non-compliant. If\n  the above command returns RestartPolicyName=no or just\n  RestartPolicyName=, then the restart policies are not being used and the\n  container would never be restarted of its own. This recommendation is then Not\n  Applicable and can be assumed to be compliant. If the above command returns\n  RestartPolicyName=on-failure, then verify that the number of restart attempts\n  is set to 5 or less by looking at MaximumRetryCount.\"\n  tag \"fix\": \"If a container is desired to be restarted of its own, then, for\n  example, you could start the container as below: docker run --detach\n  --restart=on-failure:5 nginx\"\n  tag \"Default Value\": \"By default, containers are not configured with restart\n  policies. Hence, containers do not attempt to restart on their own.\"\n  ref url: 'https://docs.docker.com/engine/reference/commandline/cli/#restart-policies'\n\n  if docker.containers.running?.ids.empty?\n    impact 0.0\n    describe 'There are no running docker containers, therfore this control is N/A' do\n      skip 'There are no running docker containers, therfore this control is N/A'\n    end\n  end\n\n  if !docker.containers.running?.ids.empty?\n    docker.containers.running?.ids.each do |id|\n      describe.one do\n        describe docker.object(id) do\n          its(%w{HostConfig RestartPolicy Name}) { should eq 'no' }\n        end\n        describe docker.object(id) do\n          its(%w{HostConfig RestartPolicy Name}) { should eq 'on-failure' }\n          its(%w{HostConfig RestartPolicy MaximumRetryCount}) { should eq 5 }\n        end\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.14.rb",
        "line": 1
      },
      "id": "M-5.14"
    },
    {
      "title": "5.27 Ensure docker commands always get the latest version of the image (Not Scored)",
      "desc": "Always ensure that you are using the latest version of the image within\n  your repository and not the cached older versions.\n  Multiple docker commands such as docker pull, docker run, etc. are known to\n  have an issue that by default, they extract the local copy of the image, if\n  present, even though there is an updated version of the image with the \"same tag\" in the upstream\n  repository. This could lead to using older and vulnerable images.",
      "descriptions": {
        "default": "Always ensure that you are using the latest version of the image within\n  your repository and not the cached older versions.\n  Multiple docker commands such as docker pull, docker run, etc. are known to\n  have an issue that by default, they extract the local copy of the image, if\n  present, even though there is an updated version of the image with the \"same tag\" in the upstream\n  repository. This could lead to using older and vulnerable images."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "ref": "1. https://github.com/docker/docker/pull/16609",
        "severity": "medium",
        "cis_id": "5.27",
        "cis_control": [
          "18.1",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SI-2",
          "4"
        ],
        "check_text": "Step 1: Open your image repository and list the image version\n  history for the image you are inspecting. Step 2: Observe the status when the\n  docker pull command is triggered. If the status is shown as Image is up to\n  date, it means that you are getting the cached version of the image. Step 3:\n  Match the version of the image you are running with the latest version reported\n  in your repository which tells if you are running the cached version or the\n  latest copy.",
        "fix": "Use proper version pinning mechanisms (the latest tag which is\n  assigned by default is still vulnerable to caching attacks) to avoid\n  extracting the cached older versions. Version pinning mechanisms should be\n  used for base images, packages, and entire images too. You can customize\n  version pinning rules as per your requirements.",
        "Default Value": "By default, docker commands extract the local copy\n  unless version pinning mechanisms are used or the local cache is cleared."
      },
      "code": "control 'M-5.27' do\n  title '5.27 Ensure docker commands always get the latest version of the image (Not Scored)'\n  desc  \"Always ensure that you are using the latest version of the image within\n  your repository and not the cached older versions.\n  Multiple docker commands such as docker pull, docker run, etc. are known to\n  have an issue that by default, they extract the local copy of the image, if\n  present, even though there is an updated version of the image with the \\\"same tag\\\" in the upstream\n  repository. This could lead to using older and vulnerable images.\n  \"\n  impact 0.5\n  tag \"ref\": '1. https://github.com/docker/docker/pull/16609'\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.27'\n  tag \"cis_control\": ['18.1', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SI-2', '4']\n  tag \"check_text\": \"Step 1: Open your image repository and list the image version\n  history for the image you are inspecting. Step 2: Observe the status when the\n  docker pull command is triggered. If the status is shown as Image is up to\n  date, it means that you are getting the cached version of the image. Step 3:\n  Match the version of the image you are running with the latest version reported\n  in your repository which tells if you are running the cached version or the\n  latest copy.\"\n  tag \"fix\": \"Use proper version pinning mechanisms (the latest tag which is\n  assigned by default is still vulnerable to caching attacks) to avoid\n  extracting the cached older versions. Version pinning mechanisms should be\n  used for base images, packages, and entire images too. You can customize\n  version pinning rules as per your requirements.\"\n  tag \"Default Value\": \"By default, docker commands extract the local copy\n  unless version pinning mechanisms are used or the local cache is cleared.\"\n\n  describe 'A manual review is required to ensure docker commands always get the latest version of the image' do\n    skip 'A manual review is required to ensure docker commands always get the latest version of the image'\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.27.rb",
        "line": 1
      },
      "id": "M-5.27"
    },
    {
      "title": "7.8 Ensure node certificates are rotated as appropriate (Not Scored)",
      "desc": "Rotate swarm node certificates as appropriate.\n  Docker Swarm uses mutual TLS for clustering operations amongst its nodes.\n  Certificate rotation ensures that in an event such as a compromised node or key, it is\n  difficult to impersonate a node. By default, node certificates are rotated every 90\n  days. You should rotate them more often or as appropriate in your environment.",
      "descriptions": {
        "default": "Rotate swarm node certificates as appropriate.\n  Docker Swarm uses mutual TLS for clustering operations amongst its nodes.\n  Certificate rotation ensures that in an event such as a compromised node or key, it is\n  difficult to impersonate a node. By default, node certificates are rotated every 90\n  days. You should rotate them more often or as appropriate in your environment."
      },
      "impact": 0,
      "refs": [],
      "tags": {
        "ref": "1.\n  https://docs.docker.com/engine/reference/commandline/swarm_update/#examples",
        "severity": "medium",
        "cis_id": "7.8",
        "cis_control": [
          "14.2",
          "6.1"
        ],
        "cis_level": "Level 2 - Docker",
        "nist": [
          "SC-8",
          "4"
        ],
        "check_text": "Run the below command and ensure that the node certificate\n  Expiry Duration is set as appropriate. docker info | grep \"Expiry\n  Duration\"",
        "fix": "Run the below command to set the desired expiry time. For\n  example, docker swarm update --cert-expiry 48h",
        "Default Value": "By default, node certificates are rotated automatically every 90 days."
      },
      "code": "control 'M-7.8' do\n  title '7.8 Ensure node certificates are rotated as appropriate (Not Scored)'\n  desc  \"Rotate swarm node certificates as appropriate.\n  Docker Swarm uses mutual TLS for clustering operations amongst its nodes.\n  Certificate rotation ensures that in an event such as a compromised node or key, it is\n  difficult to impersonate a node. By default, node certificates are rotated every 90\n  days. You should rotate them more often or as appropriate in your environment.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  https://docs.docker.com/engine/reference/commandline/swarm_update/#examples\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '7.8'\n  tag \"cis_control\": ['14.2', '6.1']\n  tag \"cis_level\": 'Level 2 - Docker'\n  tag \"nist\": ['SC-8', '4']\n  tag \"check_text\": \"Run the below command and ensure that the node certificate\n  Expiry Duration is set as appropriate. docker info | grep \\\"Expiry\n  Duration\\\"\"\n  tag \"fix\": \"Run the below command to set the desired expiry time. For\n  example, docker swarm update --cert-expiry 48h\"\n  tag \"Default Value\": 'By default, node certificates are rotated automatically every 90 days.'\n\n  if attribute('swarm_mode') == 'active'\n    swarm_root_ca_expiry = command('docker info | grep \"Expiry Duration\" ').stdout.strip\n    describe \"A manual review of the swarm root ca certificate expiry duration : #{swarm_root_ca_expiry} is required to ensure it is rotated as appropriate\" do\n      skip \"A manual review of the swarm root ca certificate expiry duration : #{swarm_root_ca_expiry} is required to ensure it is rotated as appropriate\"\n    end\n  else\n    impact 0.0\n    describe 'The docker swarm mode is not being used, therefore this control is N/A' do\n      skip 'The docker swarm mode is not being used, therefore this control is N/A'\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-7.8.rb",
        "line": 1
      },
      "id": "M-7.8"
    },
    {
      "title": "1.1 Ensure a separate partition for containers has been created\n  (Scored)",
      "desc": "All Docker containers and their data and metadata is stored under\n  /var/lib/docker\n  directory. By default, /var/lib/docker would be mounted under / or /var\n  partitions based\n  on availability.\n  Docker depends on /var/lib/docker as the default directory where all Docker\n  related files,\n  including the images, are stored. This directory might fill up fast and\n  soon Docker and the\n  host could become unusable. So, it is advisable to create a separate\n  partition (logical\n  volume) for storing Docker files.",
      "descriptions": {
        "default": "All Docker containers and their data and metadata is stored under\n  /var/lib/docker\n  directory. By default, /var/lib/docker would be mounted under / or /var\n  partitions based\n  on availability.\n  Docker depends on /var/lib/docker as the default directory where all Docker\n  related files,\n  including the images, are stored. This directory might fill up fast and\n  soon Docker and the\n  host could become unusable. So, it is advisable to create a separate\n  partition (logical\n  volume) for storing Docker files."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "http://www.projectatomic.io/docs/docker-storage-recommendation/",
          "ref": "Docker storage recommendation"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "1.1",
        "cis_control": [
          "14",
          "6.1"
        ],
        "cis_level": "Level 1 - Linux Host OS",
        "nist": [
          "AC-6",
          "4"
        ],
        "check_text": "At the Docker host execute the below command: grep\n  /var/lib/docker /etc/fstab This should return the partition details for\n  /var/lib/docker mount point.",
        "fix": "For new installations, create a separate partition for\n  /var/lib/docker mount point. For systems that were previously installed, use\n  the Logical Volume Manager (LVM) to create partitions.",
        "Default Value": "By default, /var/lib/docker would be mounted under / or\n  /var partitions based on availability."
      },
      "code": "control 'M-1.1' do\n  title \"1.1 Ensure a separate partition for containers has been created\n  (Scored)\"\n  desc \"All Docker containers and their data and metadata is stored under\n  /var/lib/docker\n  directory. By default, /var/lib/docker would be mounted under / or /var\n  partitions based\n  on availability.\n  Docker depends on /var/lib/docker as the default directory where all Docker\n  related files,\n  including the images, are stored. This directory might fill up fast and\n  soon Docker and the\n  host could become unusable. So, it is advisable to create a separate\n  partition (logical\n  volume) for storing Docker files.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '1.1'\n  tag \"cis_control\": ['14', '6.1']\n  tag \"cis_level\": 'Level 1 - Linux Host OS'\n  tag \"nist\": ['AC-6', '4']\n  tag \"check_text\": \"At the Docker host execute the below command: grep\n  /var/lib/docker /etc/fstab This should return the partition details for\n  /var/lib/docker mount point.\"\n  tag \"fix\": \"For new installations, create a separate partition for\n  /var/lib/docker mount point. For systems that were previously installed, use\n  the Logical Volume Manager (LVM) to create partitions.\"\n  tag \"Default Value\": \"By default, /var/lib/docker would be mounted under / or\n  /var partitions based on availability.\"\n  ref 'Docker storage recommendation', url: 'http://www.projectatomic.io/docs/docker-storage-recommendation/'\n\n  describe mount('/var/lib/docker') do\n    it { should be_mounted }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-1.1.rb",
        "line": 1
      },
      "id": "M-1.1"
    },
    {
      "title": "3.12 Ensure that the Docker server certificate file permissions are set to 444 or more restrictive (Scored)",
      "desc": "Verify that the Docker server certificate file (the file that is passed\n  along with the --tlscert parameter) has permissions of 444 or more restrictive.\n  The Docker server certificate file should be protected from any tampering.\n  It is used to the authenticate Docker server based on the given server certificate. Hence, it\n  must have permissions of 444 to maintain the integrity of the certificate.",
      "descriptions": {
        "default": "Verify that the Docker server certificate file (the file that is passed\n  along with the --tlscert parameter) has permissions of 444 or more restrictive.\n  The Docker server certificate file should be protected from any tampering.\n  It is used to the authenticate Docker server based on the given server certificate. Hence, it\n  must have permissions of 444 to maintain the integrity of the certificate."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/security/certificates/"
        },
        {
          "url": "https://docs.docker.com/engine/security/https/"
        }
      ],
      "tags": {
        "ref": "1. https://docs.docker.com/registry/insecure/2.\n  https://docs.docker.com/engine/security/https/",
        "severity": "medium",
        "cis_id": "3.12",
        "cis_control": [
          "14.4",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-3 (3)",
          "4"
        ],
        "check_text": "Execute the below command to verify that the Docker server\n  certificate file has permissions of 444 or more restrictive: stat -c %a <path\n  to the Docker server certificate file>",
        "fix": "chmod 444 <path to the Docker server certificate file> This would\n  set the file permissions of the Docker server file to 444.",
        "Default Value": "By default, the permissions for Docker server\n  certificate file might not be 444. The default file permissions are governed\n  by the system or user specific umask values."
      },
      "code": "control 'M-3.12' do\n  title '3.12 Ensure that the Docker server certificate file permissions are set to 444 or more restrictive (Scored)'\n  desc  \"Verify that the Docker server certificate file (the file that is passed\n  along with the --tlscert parameter) has permissions of 444 or more restrictive.\n  The Docker server certificate file should be protected from any tampering.\n  It is used to the authenticate Docker server based on the given server certificate. Hence, it\n  must have permissions of 444 to maintain the integrity of the certificate.\n  \"\n  impact 0.5\n  tag \"ref\": \"1. https://docs.docker.com/registry/insecure/2.\n  https://docs.docker.com/engine/security/https/\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '3.12'\n  tag \"cis_control\": ['14.4', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-3 (3)', '4']\n  tag \"check_text\": \"Execute the below command to verify that the Docker server\n  certificate file has permissions of 444 or more restrictive: stat -c %a <path\n  to the Docker server certificate file>\"\n  tag \"fix\": \"chmod 444 <path to the Docker server certificate file> This would\n  set the file permissions of the Docker server file to 444.\"\n  tag \"Default Value\": \"By default, the permissions for Docker server\n  certificate file might not be 444. The default file permissions are governed\n  by the system or user specific umask values.\"\n  ref url: 'https://docs.docker.com/engine/security/certificates/'\n  ref url: 'https://docs.docker.com/engine/security/https/'\n\n  describe file(json('/etc/docker/daemon.json').params['tlscert']) do\n    it { should exist }\n    it { should be_file }\n    it { should be_readable }\n    it { should_not be_executable }\n    it { should_not be_writable }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-3.12.rb",
        "line": 1
      },
      "id": "M-3.12"
    },
    {
      "title": "1.6 Ensure auditing is configured for Docker files and directories\n  /var/lib/docker (Scored)",
      "desc": "Audit /var/lib/docker.\n  Apart from auditing your regular Linux file system and system calls, audit\n  all Docker related files and directories. Docker daemon runs with root privileges. Its\n  behavior depends on some key files and directories. /var/lib/docker is one such\n  directory. It holds all the information about containers. It must be audited.",
      "descriptions": {
        "default": "Audit /var/lib/docker.\n  Apart from auditing your regular Linux file system and system calls, audit\n  all Docker related files and directories. Docker daemon runs with root privileges. Its\n  behavior depends on some key files and directories. /var/lib/docker is one such\n  directory. It holds all the information about containers. It must be audited."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html",
          "ref": "System auditing"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "1.6",
        "cis_control": [
          "14.6",
          "6.1"
        ],
        "cis_level": "Level 1 - Linux Host OS",
        "nist": [
          "AU-2",
          "4"
        ],
        "check_text": "Verify that there is an audit rule corresponding to\n  /var/lib/docker directory. For example, execute below command: auditctl -l |\n  grep /var/lib/docker This should list a rule for /var/lib/docker directory.",
        "fix": "Add a rule for /var/lib/docker directory. For example, Add the\n  line as below in /etc/audit/audit.rules file: -w /var/lib/docker -k\n  docker Then, restart the audit daemon. For example, service auditd restart",
        "Default Value": "By default, Docker related files and directories are\n  not audited."
      },
      "code": "control 'M-1.6' do\n  title \"1.6 Ensure auditing is configured for Docker files and directories\n  /var/lib/docker (Scored)\"\n  desc  \"Audit /var/lib/docker.\n  Apart from auditing your regular Linux file system and system calls, audit\n  all Docker related files and directories. Docker daemon runs with root privileges. Its\n  behavior depends on some key files and directories. /var/lib/docker is one such\n  directory. It holds all the information about containers. It must be audited.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '1.6'\n  tag \"cis_control\": ['14.6', '6.1']\n  tag \"cis_level\": 'Level 1 - Linux Host OS'\n  tag \"nist\": ['AU-2', '4']\n  tag \"check_text\": \"Verify that there is an audit rule corresponding to\n  /var/lib/docker directory. For example, execute below command: auditctl -l |\n  grep /var/lib/docker This should list a rule for /var/lib/docker directory.\"\n  tag \"fix\": \"Add a rule for /var/lib/docker directory. For example, Add the\n  line as below in /etc/audit/audit.rules file: -w /var/lib/docker -k\n  docker Then, restart the audit daemon. For example, service auditd restart\"\n  tag \"Default Value\": \"By default, Docker related files and directories are\n  not audited.\"\n  ref 'System auditing', url: 'https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html'\n\n  describe auditd do\n    its('lines') { should include '-w /var/lib/docker/ -p rwxa -k docker' }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-1.6.rb",
        "line": 1
      },
      "id": "M-1.6"
    },
    {
      "title": "2.3 Ensure Docker is allowed to make changes to iptables (Scored)",
      "desc": "Iptables are used to set up, maintain, and inspect the tables of IP packet\n  filter rules in the Linux kernel. Allow the Docker daemon to make changes to the iptables.\n  Docker will never make changes to your system iptables rules if you choose\n  to do so. Docker server would automatically make the needed changes to iptables based\n  on how you choose your networking options for the containers if it is allowed to do\n  so. It is recommended to let Docker server make changes to iptables automatically to\n  avoid networking misconfiguration that might hamper the communication between\n  containers and to the outside world. Additionally, it would save you hassles of\n  updating iptables every time you choose to run the containers or modify networking\n  options.",
      "descriptions": {
        "default": "Iptables are used to set up, maintain, and inspect the tables of IP packet\n  filter rules in the Linux kernel. Allow the Docker daemon to make changes to the iptables.\n  Docker will never make changes to your system iptables rules if you choose\n  to do so. Docker server would automatically make the needed changes to iptables based\n  on how you choose your networking options for the containers if it is allowed to do\n  so. It is recommended to let Docker server make changes to iptables automatically to\n  avoid networking misconfiguration that might hamper the communication between\n  containers and to the outside world. Additionally, it would save you hassles of\n  updating iptables every time you choose to run the containers or modify networking\n  options."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/v1.8/articles/networking/",
          "ref": "networking"
        },
        {
          "url": "https://docs.docker.com/engine/userguide/networking/default_network/container-communication/",
          "ref": "container-communication"
        },
        {
          "url": "https://fralef.me/docker-and-iptables.html",
          "ref": "docker-and-iptables"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "2.3",
        "cis_control": [
          "5",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-6",
          "4"
        ],
        "check_text": "ps -ef | grep dockerd Ensure that the --iptables parameter is\n  either not present or not set to false.",
        "fix": "Do not run the Docker daemon with --iptables=false parameter. For\n  example, do not start the Docker daemon as below: dockerd --iptables=false",
        "Default Value": "By default, iptables is set to true."
      },
      "code": "control 'M-2.3' do\n  title '2.3 Ensure Docker is allowed to make changes to iptables (Scored)'\n  desc  \"Iptables are used to set up, maintain, and inspect the tables of IP packet\n  filter rules in the Linux kernel. Allow the Docker daemon to make changes to the iptables.\n  Docker will never make changes to your system iptables rules if you choose\n  to do so. Docker server would automatically make the needed changes to iptables based\n  on how you choose your networking options for the containers if it is allowed to do\n  so. It is recommended to let Docker server make changes to iptables automatically to\n  avoid networking misconfiguration that might hamper the communication between\n  containers and to the outside world. Additionally, it would save you hassles of\n  updating iptables every time you choose to run the containers or modify networking\n  options.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '2.3'\n  tag \"cis_control\": ['5', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-6', '4']\n  tag \"check_text\": \"ps -ef | grep dockerd Ensure that the --iptables parameter is\n  either not present or not set to false.\"\n  tag \"fix\": \"Do not run the Docker daemon with --iptables=false parameter. For\n  example, do not start the Docker daemon as below: dockerd --iptables=false\"\n  tag \"Default Value\": 'By default, iptables is set to true.'\n  ref 'networking', url: 'https://docs.docker.com/v1.8/articles/networking/'\n  ref 'container-communication', url: 'https://docs.docker.com/engine/userguide/networking/default_network/container-communication/'\n  ref 'docker-and-iptables', url: 'https://fralef.me/docker-and-iptables.html'\n\n  describe json('/etc/docker/daemon.json') do\n    its(['iptables']) { should eq(true) }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-2.3.rb",
        "line": 1
      },
      "id": "M-2.3"
    },
    {
      "title": "5.25 Ensure the container is restricted from acquiring additional privileges (Scored)",
      "desc": "Restrict the container from acquiring additional privileges via suid or\n  sgid bits. A process can set the no_new_priv bit in the kernel. It persists across\n  fork, clone and execve. The no_new_priv bit ensures that the process or its children\n  processes do not gain any additional privileges via suid or sgid bits. This way a lot of\n  dangerous operations become a lot less dangerous because there is no possibility of subverting\n  privileged binaries.",
      "descriptions": {
        "default": "Restrict the container from acquiring additional privileges via suid or\n  sgid bits. A process can set the no_new_priv bit in the kernel. It persists across\n  fork, clone and execve. The no_new_priv bit ensures that the process or its children\n  processes do not gain any additional privileges via suid or sgid bits. This way a lot of\n  dangerous operations become a lot less dangerous because there is no possibility of subverting\n  privileged binaries."
      },
      "impact": 0,
      "refs": [
        {
          "url": "https://github.com/projectatomic/atomic-site/issues/269"
        },
        {
          "url": "https://github.com/docker/docker/pull/20727"
        },
        {
          "url": "https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt"
        },
        {
          "url": "https://lwn.net/Articles/475678/"
        },
        {
          "url": "https://lwn.net/Articles/475362/"
        }
      ],
      "tags": {
        "ref": "1.\n  https://github.com/projectatomic/atomic-site/issues/2692.3.4.5. https://github.com/docker/docker/pull/20727 https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt https://lwn.net/Articles/475678/ https://lwn.net/Articles/475362/",
        "severity": "medium",
        "cis_id": "5.25",
        "cis_control": [
          "5",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-6",
          "4"
        ],
        "check_text": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: SecurityOpt={{ .HostConfig.SecurityOpt }}' The above command should\n  return all the security options currently configured for the containers.\n  no-new-privileges should also be one of them.",
        "fix": "For example, you should start your container as below: docker\n  run --rm -it --security-opt=no-new-privileges ubuntu bash",
        "Default Value": "By default, new privileges are not restricted."
      },
      "code": "control 'M-5.25' do\n  title '5.25 Ensure the container is restricted from acquiring additional privileges (Scored)'\n  desc  \"Restrict the container from acquiring additional privileges via suid or\n  sgid bits. A process can set the no_new_priv bit in the kernel. It persists across\n  fork, clone and execve. The no_new_priv bit ensures that the process or its children\n  processes do not gain any additional privileges via suid or sgid bits. This way a lot of\n  dangerous operations become a lot less dangerous because there is no possibility of subverting\n  privileged binaries.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  https://github.com/projectatomic/atomic-site/issues/2692.3.4.5. https://github.com/docker/docker/pull/20727 https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt https://lwn.net/Articles/475678/ https://lwn.net/Articles/475362/\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.25'\n  tag \"cis_control\": ['5', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-6', '4']\n  tag \"check_text\": \"docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: SecurityOpt={{ .HostConfig.SecurityOpt }}' The above command should\n  return all the security options currently configured for the containers.\n  no-new-privileges should also be one of them.\"\n  tag \"fix\": \"For example, you should start your container as below: docker\n  run --rm -it --security-opt=no-new-privileges ubuntu bash\"\n  tag \"Default Value\": 'By default, new privileges are not restricted.'\n  ref url: 'https://github.com/projectatomic/atomic-site/issues/269'\n  ref url: 'https://github.com/docker/docker/pull/20727'\n  ref url: 'https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt'\n  ref url: 'https://lwn.net/Articles/475678/'\n  ref url: 'https://lwn.net/Articles/475362/'\n\n  if docker.containers.running?.ids.empty?\n    impact 0.0\n    describe 'There are no running docker containers, therfore this control is N/A' do\n      skip 'There are no running docker containers, therfore this control is N/A'\n    end\n  end\n\n  if !docker.containers.running?.ids.empty?\n    docker.containers.running?.ids.each do |id|\n      describe docker.object(id) do\n        its(%w{HostConfig SecurityOpt}) { should include(/no-new-privileges/) }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.25.rb",
        "line": 1
      },
      "id": "M-5.25"
    },
    {
      "title": "5.29 Ensure Docker's default bridge docker0 is not used (Not Scored)",
      "desc": "Do not use Docker's default bridge docker0. Use docker's user-defined\n  networks for container networking.\n  Docker connects virtual interfaces created in the bridge mode to a common\n  bridge called docker0. This default networking model is vulnerable to ARP spoofing and\n  MAC flooding attacks since there is no filtering applied.",
      "descriptions": {
        "default": "Do not use Docker's default bridge docker0. Use docker's user-defined\n  networks for container networking.\n  Docker connects virtual interfaces created in the bridge mode to a common\n  bridge called docker0. This default networking model is vulnerable to ARP spoofing and\n  MAC flooding attacks since there is no filtering applied."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "ref": "1. https://github.com/nyantec/narwhal2.\n  https://arxiv.org/pdf/1501.029673.\n  https://docs.docker.com/engine/userguide/networking/",
        "severity": "medium",
        "cis_id": "5.29",
        "cis_control": [
          "9",
          "6.1"
        ],
        "cis_level": "Level 2 - Docker",
        "nist": [
          "SC-7",
          "4"
        ],
        "check_text": "Run the below command, and verify that containers are on a\n  user-defined network and not the default docker0 bridge. The docker network ls\n  --quiet | xargs xargs docker network inspect --format '{{.Name }}: {{\n  .Options }}'",
        "fix": "Follow the Docker documentation and setup a user-defined network. Run\n  all of the containers in the defined network.",
        "Default Value": "By default, docker runs containers on its docker0\n  bridge."
      },
      "code": "control 'M-5.29' do\n  title \"5.29 Ensure Docker's default bridge docker0 is not used (Not Scored)\"\n  desc  \"Do not use Docker's default bridge docker0. Use docker's user-defined\n  networks for container networking.\n  Docker connects virtual interfaces created in the bridge mode to a common\n  bridge called docker0. This default networking model is vulnerable to ARP spoofing and\n  MAC flooding attacks since there is no filtering applied.\n  \"\n  impact 0.5\n  tag \"ref\": \"1. https://github.com/nyantec/narwhal2.\n  https://arxiv.org/pdf/1501.029673.\n  https://docs.docker.com/engine/userguide/networking/\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.29'\n  tag \"cis_control\": ['9', '6.1']\n  tag \"cis_level\": 'Level 2 - Docker'\n  tag \"nist\": ['SC-7', '4']\n  tag \"check_text\": \"Run the below command, and verify that containers are on a\n  user-defined network and not the default docker0 bridge. The docker network ls\n  --quiet | xargs xargs docker network inspect --format '{{.Name }}: {{\n  .Options }}'\"\n  tag \"fix\": \"Follow the Docker documentation and setup a user-defined network. Run\n  all of the containers in the defined network.\"\n  tag \"Default Value\": \"By default, docker runs containers on its docker0\n  bridge.\"\n\n  describe docker.containers do\n    its('networks') { should_not include 'bridge' }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.29.rb",
        "line": 1
      },
      "id": "M-5.29"
    },
    {
      "title": "1.7 Ensure auditing is configured for Docker files and directories\n  /etc/docker (Scored)",
      "desc": "Audit /etc/docker.\n  Apart from auditing your regular Linux file system and system calls, audit\n  all Docker related files and directories. Docker daemon runs with root privileges. Its\n  behavior depends on some key files and directories. /etc/docker is one such\n  directory. It holds various certificates and keys used for TLS communication between Docker\n  daemon and Docker client. It must be audited.",
      "descriptions": {
        "default": "Audit /etc/docker.\n  Apart from auditing your regular Linux file system and system calls, audit\n  all Docker related files and directories. Docker daemon runs with root privileges. Its\n  behavior depends on some key files and directories. /etc/docker is one such\n  directory. It holds various certificates and keys used for TLS communication between Docker\n  daemon and Docker client. It must be audited."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html",
          "ref": "System auditing"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "1.7",
        "cis_control": [
          "14.6",
          "6.1"
        ],
        "cis_level": "Level 1 - Linux Host OS",
        "nist": [
          "AU-2",
          "4"
        ],
        "check_text": "Verify that there is an audit rule corresponding to /etc/docker\n  directory. For example, execute below command: auditctl -l | grep\n  /etc/docker This should list a rule for /etc/docker directory.",
        "fix": "Add a rule for /etc/docker directory. For example, Add the line\n  as below in /etc/audit/audit.rules file: -w /etc/docker -k docker Then,\n  restart the audit daemon. For example, service auditd restart",
        "Default Value": "By default, Docker related files and directories are\n  not audited."
      },
      "code": "control 'M-1.7' do\n  title \"1.7 Ensure auditing is configured for Docker files and directories\n  /etc/docker (Scored)\"\n  desc  \"Audit /etc/docker.\n  Apart from auditing your regular Linux file system and system calls, audit\n  all Docker related files and directories. Docker daemon runs with root privileges. Its\n  behavior depends on some key files and directories. /etc/docker is one such\n  directory. It holds various certificates and keys used for TLS communication between Docker\n  daemon and Docker client. It must be audited.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '1.7'\n  tag \"cis_control\": ['14.6', '6.1']\n  tag \"cis_level\": 'Level 1 - Linux Host OS'\n  tag \"nist\": ['AU-2', '4']\n  tag \"check_text\": \"Verify that there is an audit rule corresponding to /etc/docker\n  directory. For example, execute below command: auditctl -l | grep\n  /etc/docker This should list a rule for /etc/docker directory.\"\n  tag \"fix\": \"Add a rule for /etc/docker directory. For example, Add the line\n  as below in /etc/audit/audit.rules file: -w /etc/docker -k docker Then,\n  restart the audit daemon. For example, service auditd restart\"\n  tag \"Default Value\": \"By default, Docker related files and directories are\n  not audited.\"\n  ref 'System auditing', url: 'https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html'\n\n  describe auditd  do\n    its('lines') { should include '-w /etc/docker/ -p rwxa -k docker' }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-1.7.rb",
        "line": 1
      },
      "id": "M-1.7"
    },
    {
      "title": "5.10 Ensure memory usage for container is limited (Scored)",
      "desc": "By default, all containers on a Docker host share the resources equally. By\n  using the resource management capabilities of Docker host, such as memory limit, you\n  can control the amount of memory that a container may consume.\n  By default, the container can use all of the memory on the host. You can use the\n  memory limit mechanism to prevent a denial of service arising from one container\n  consuming all of the hosts resources such that other containers on the same host cannot perform\n  their intended functions. Having no limit on memory can lead to issues where one container\n  can easily make the whole system unstable and as a result unusable.",
      "descriptions": {
        "default": "By default, all containers on a Docker host share the resources equally. By\n  using the resource management capabilities of Docker host, such as memory limit, you\n  can control the amount of memory that a container may consume.\n  By default, the container can use all of the memory on the host. You can use the\n  memory limit mechanism to prevent a denial of service arising from one container\n  consuming all of the hosts resources such that other containers on the same host cannot perform\n  their intended functions. Having no limit on memory can lead to issues where one container\n  can easily make the whole system unstable and as a result unusable."
      },
      "impact": 0,
      "refs": [
        {
          "url": "https://goldmann.pl/blog/2014/09/11/resource-management-in-docker/"
        },
        {
          "url": "https://docs.docker.com/engine/reference/commandline/cli/#run"
        },
        {
          "url": "https://docs.docker.com/v1.8/articles/runmetrics/"
        }
      ],
      "tags": {
        "ref": "1.\n  https://goldmann.pl/blog/2014/09/11/resource-management-in-docker/2.\n  https://docs.docker.com/engine/reference/commandline/run/#options3.\n  https://docs.docker.com/engine/admin/runmetrics/",
        "severity": "medium",
        "cis_id": "5.10",
        "cis_control": [
          "18",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SI-1",
          "4"
        ],
        "check_text": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: Memory={{.HostConfig.Memory }}' If the above command returns 0, it means\n  the memory limits are not in place. If the above command returns a non-zero\n  value, it means memory limits are in place.",
        "fix": "Run the container with only as much memory as required. Always\n  run the container using the --memory argument. For example, you could run a\n  container as below: docker run --interactive --tty --memory 256m centos\n  /bin/bash In the above example, the container is started with a memory limit\n  of 256 MB. Note: Please note that the output of the below command would return\n  values in scientific notation if memory limits are in place. docker inspect\n  --format='{{.Config.Memory}}' 7c5a2d4c7fe0 For example, if the memory limit is\n  set to 256 MB for the above container instance, the output of the above\n  command would be 2.68435456e+08 and NOT 256m. You should convert this value\n  using a scientific calculator or programmatic methods.",
        "Default Value": "By default, all containers on a Docker host share the\n  resources equally. No memory limits are enforced."
      },
      "code": "control 'M-5.10' do\n  title '5.10 Ensure memory usage for container is limited (Scored)'\n  desc  \"By default, all containers on a Docker host share the resources equally. By\n  using the resource management capabilities of Docker host, such as memory limit, you\n  can control the amount of memory that a container may consume.\n  By default, the container can use all of the memory on the host. You can use the\n  memory limit mechanism to prevent a denial of service arising from one container\n  consuming all of the hosts resources such that other containers on the same host cannot perform\n  their intended functions. Having no limit on memory can lead to issues where one container\n  can easily make the whole system unstable and as a result unusable.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  https://goldmann.pl/blog/2014/09/11/resource-management-in-docker/2.\n  https://docs.docker.com/engine/reference/commandline/run/#options3.\n  https://docs.docker.com/engine/admin/runmetrics/\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.10'\n  tag \"cis_control\": ['18', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SI-1', '4']\n  tag \"check_text\": \"docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: Memory={{.HostConfig.Memory }}' If the above command returns 0, it means\n  the memory limits are not in place. If the above command returns a non-zero\n  value, it means memory limits are in place.\"\n  tag \"fix\": \"Run the container with only as much memory as required. Always\n  run the container using the --memory argument. For example, you could run a\n  container as below: docker run --interactive --tty --memory 256m centos\n  /bin/bash In the above example, the container is started with a memory limit\n  of 256 MB. Note: Please note that the output of the below command would return\n  values in scientific notation if memory limits are in place. docker inspect\n  --format='{{.Config.Memory}}' 7c5a2d4c7fe0 For example, if the memory limit is\n  set to 256 MB for the above container instance, the output of the above\n  command would be 2.68435456e+08 and NOT 256m. You should convert this value\n  using a scientific calculator or programmatic methods.\"\n  tag \"Default Value\": \"By default, all containers on a Docker host share the\n  resources equally. No memory limits are enforced.\"\n  ref url: 'https://goldmann.pl/blog/2014/09/11/resource-management-in-docker/'\n  ref url: 'https://docs.docker.com/engine/reference/commandline/cli/#run'\n  ref url: 'https://docs.docker.com/v1.8/articles/runmetrics/'\n\n  if docker.containers.running?.ids.empty?\n    impact 0.0\n    describe 'There are no running docker containers, therfore this control is N/A' do\n      skip 'There are no running docker containers, therfore this control is N/A'\n    end\n  end\n\n  if !docker.containers.running?.ids.empty?\n    docker.containers.running?.ids.each do |id|\n      describe docker.object(id) do\n        its(%w{HostConfig Memory}) { should_not eq 0 }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.10.rb",
        "line": 1
      },
      "id": "M-5.10"
    },
    {
      "title": "2.9 Ensure the default cgroup usage has been confirmed (Scored)",
      "desc": "The --cgroup-parent option allows you to set the default cgroup parent to\n  used for all the containers. If there is no specific use case, this setting should be left\n  at its default. System administrators typically define cgroups under which containers are\n  supposed to run. Even if cgroups are not explicitly defined by the system\n  administrators, containers run under docker cgroup by default.\n  It is possible to attach to a different cgroup other than the default. This usage should\n  be monitored and confirmed. By attaching to a different cgroup than the default,\n  it is possible to share resources unevenly and thus might starve\n  the host for resources.",
      "descriptions": {
        "default": "The --cgroup-parent option allows you to set the default cgroup parent to\n  used for all the containers. If there is no specific use case, this setting should be left\n  at its default. System administrators typically define cgroups under which containers are\n  supposed to run. Even if cgroups are not explicitly defined by the system\n  administrators, containers run under docker cgroup by default.\n  It is possible to attach to a different cgroup other than the default. This usage should\n  be monitored and confirmed. By attaching to a different cgroup than the default,\n  it is possible to share resources unevenly and thus might starve\n  the host for resources."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/reference/commandline/daemon/",
          "ref": "Docker daemon configuration"
        },
        {
          "url": "https://docs.docker.com/engine/reference/commandline/dockerd/#defaultcgroup-parent",
          "ref": "defaultcgroup-parent"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "2.9",
        "cis_control": [
          "18",
          "6.1"
        ],
        "cis_level": "Level 2 - Docker",
        "nist": [
          "SI-1",
          "4"
        ],
        "check_text": "ps -ef | grep dockerd Ensure that the --cgroup-parent\n  parameter is either not set or is set as the appropriate nondefault cgroup.",
        "fix": "The default setting is good enough and can be left as-is. If you\n  want to specifically set a nondefault cgroup, pass --cgroup-parent parameter to\n  the docker daemon when starting it. For Example, dockerd\n  --cgroup-parent=/foobar",
        "Default Value": "By default, docker daemon uses /docker for fs cgroup\n  driver and system.slice for systemd cgroup driver."
      },
      "code": "control 'M-2.9' do\n  title '2.9 Ensure the default cgroup usage has been confirmed (Scored)'\n  desc  \"The --cgroup-parent option allows you to set the default cgroup parent to\n  used for all the containers. If there is no specific use case, this setting should be left\n  at its default. System administrators typically define cgroups under which containers are\n  supposed to run. Even if cgroups are not explicitly defined by the system\n  administrators, containers run under docker cgroup by default.\n  It is possible to attach to a different cgroup other than the default. This usage should\n  be monitored and confirmed. By attaching to a different cgroup than the default,\n  it is possible to share resources unevenly and thus might starve\n  the host for resources.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '2.9'\n  tag \"cis_control\": ['18', '6.1']\n  tag \"cis_level\": 'Level 2 - Docker'\n  tag \"nist\": ['SI-1', '4']\n  tag \"check_text\": \"ps -ef | grep dockerd Ensure that the --cgroup-parent\n  parameter is either not set or is set as the appropriate nondefault cgroup.\"\n  tag \"fix\": \"The default setting is good enough and can be left as-is. If you\n  want to specifically set a nondefault cgroup, pass --cgroup-parent parameter to\n  the docker daemon when starting it. For Example, dockerd\n  --cgroup-parent=/foobar\"\n  tag \"Default Value\": \"By default, docker daemon uses /docker for fs cgroup\n  driver and system.slice for systemd cgroup driver.\"\n  ref 'Docker daemon configuration', url: 'https://docs.docker.com/engine/reference/commandline/daemon/'\n  ref 'defaultcgroup-parent', url: 'https://docs.docker.com/engine/reference/commandline/dockerd/#defaultcgroup-parent'\n\n  describe json('/etc/docker/daemon.json') do\n    its(['cgroup-parent']) { should eq('docker') }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-2.9.rb",
        "line": 1
      },
      "id": "M-2.9"
    },
    {
      "title": "7.3 Ensure swarm services are binded to a specific host interface(Scored)",
      "desc": "By default, the docker swarm services will listen on all interfaces on the\n  host, which may not be necessary for the operation of the swarm where the host has multiple\n  network interfaces. When a swarm is initialized the default value for the --listen-addr flag is\n  0.0.0.0:2377 which means that the swarm services will listen on all interfaces on the\n  host. If a host has multiple network interfaces this may be undesirable as it may expose the\n  docker swarm services to networks which are not involved in the operation of the swarm.\n  By passing a specific IP address to the --listen-addr, a specific network\n  interface can be specified limiting this exposure.",
      "descriptions": {
        "default": "By default, the docker swarm services will listen on all interfaces on the\n  host, which may not be necessary for the operation of the swarm where the host has multiple\n  network interfaces. When a swarm is initialized the default value for the --listen-addr flag is\n  0.0.0.0:2377 which means that the swarm services will listen on all interfaces on the\n  host. If a host has multiple network interfaces this may be undesirable as it may expose the\n  docker swarm services to networks which are not involved in the operation of the swarm.\n  By passing a specific IP address to the --listen-addr, a specific network\n  interface can be specified limiting this exposure."
      },
      "impact": 0,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/reference/commandline/swarm_init/#--listen- addr",
          "ref": "#--listen- addr"
        },
        {
          "url": "https://docs.docker.com/engine/swarm/admin_guide/#recover-from-disaster",
          "ref": "recover-from-disaster"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "7.3",
        "cis_control": [
          "9",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SC-7",
          "4"
        ],
        "check_text": "List the network listener on port 2377/TCP (the default for\n  docker swarm) and confirm that it is only listening on specific interfaces.\n  For example, using ubuntu this could be done with the following\n  command: netstat -lt | grep -i 2377",
        "fix": "Remediation of this requires re-initialization of the swarm\n  specifying a specific interface for the --listen-addr parameter.",
        "Default Value": "By default, docker swarm services listen on all\n  available host interfaces."
      },
      "code": "control 'M-7.3' do\n  title '7.3 Ensure swarm services are binded to a specific host interface(Scored)'\n  desc  \"By default, the docker swarm services will listen on all interfaces on the\n  host, which may not be necessary for the operation of the swarm where the host has multiple\n  network interfaces. When a swarm is initialized the default value for the --listen-addr flag is\n  0.0.0.0:2377 which means that the swarm services will listen on all interfaces on the\n  host. If a host has multiple network interfaces this may be undesirable as it may expose the\n  docker swarm services to networks which are not involved in the operation of the swarm.\n  By passing a specific IP address to the --listen-addr, a specific network\n  interface can be specified limiting this exposure.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '7.3'\n  tag \"cis_control\": ['9', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SC-7', '4']\n  tag \"check_text\": \"List the network listener on port 2377/TCP (the default for\n  docker swarm) and confirm that it is only listening on specific interfaces.\n  For example, using ubuntu this could be done with the following\n  command: netstat -lt | grep -i 2377\"\n  tag \"fix\": \"Remediation of this requires re-initialization of the swarm\n  specifying a specific interface for the --listen-addr parameter.\"\n  tag \"Default Value\": \"By default, docker swarm services listen on all\n  available host interfaces.\"\n  ref '#--listen- addr', url: 'https://docs.docker.com/engine/reference/commandline/swarm_init/#--listen- addr'\n  ref 'recover-from-disaster', url: 'https://docs.docker.com/engine/swarm/admin_guide/#recover-from-disaster'\n  if attribute('swarm_mode') == 'active'\n    describe port(attribute('swarm_port')) do\n      its('addresses') { should_not include '0.0.0.0' }\n      its('addresses') { should_not include '::' }\n    end\n  else\n    impact 0.0\n    describe 'The docker swarm mode is not being used, therefore this control is N/A' do\n      skip 'The docker swarm mode is not being used, therefore this control is N/A'\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-7.3.rb",
        "line": 1
      },
      "id": "M-7.3"
    },
    {
      "title": "3.5 Ensure that /etc/docker directory ownership is set to root:root(Scored)",
      "desc": "Verify that the /etc/docker directory ownership and group-ownership is\n  correctly set to root. The /etc/docker directory contains certificates and keys in\n  addition to various sensitive files. Hence, it should be owned and group-owned by root to\n  maintain the integrity of the directory.",
      "descriptions": {
        "default": "Verify that the /etc/docker directory ownership and group-ownership is\n  correctly set to root. The /etc/docker directory contains certificates and keys in\n  addition to various sensitive files. Hence, it should be owned and group-owned by root to\n  maintain the integrity of the directory."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/security/certificates/",
          "ref": "certificates"
        },
        {
          "url": "https://docs.docker.com/engine/security/https/",
          "ref": "https"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "3.5",
        "cis_control": [
          "5.1",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-6(9)",
          "4"
        ],
        "check_text": "Execute the below command to verify that the directory is owned\n  and group-owned by root: stat -c %U:%G /etc/docker | grep -v root:root The\n  above command should not return anything.",
        "fix": "chown root:root /etc/docker This would set the ownership and\n  group-ownership for the directory to root.",
        "Default Value": "By default, the ownership and group-ownership for this\n  directory is correctly set to root."
      },
      "code": "control 'M-3.5' do\n  title '3.5 Ensure that /etc/docker directory ownership is set to root:root(Scored)'\n  desc  \"Verify that the /etc/docker directory ownership and group-ownership is\n  correctly set to root. The /etc/docker directory contains certificates and keys in\n  addition to various sensitive files. Hence, it should be owned and group-owned by root to\n  maintain the integrity of the directory.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '3.5'\n  tag \"cis_control\": ['5.1', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-6(9)', '4']\n  tag \"check_text\": \"Execute the below command to verify that the directory is owned\n  and group-owned by root: stat -c %U:%G /etc/docker | grep -v root:root The\n  above command should not return anything.\"\n  tag \"fix\": \"chown root:root /etc/docker This would set the ownership and\n  group-ownership for the directory to root.\"\n  tag \"Default Value\": \"By default, the ownership and group-ownership for this\n  directory is correctly set to root.\"\n  ref 'certificates', url: 'https://docs.docker.com/engine/security/certificates/'\n  ref 'https', url: 'https://docs.docker.com/engine/security/https/'\n\n  describe file('/etc/docker') do\n    it { should exist }\n    it { should be_directory }\n    it { should be_owned_by 'root' }\n    it { should be_grouped_into 'root' }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-3.5.rb",
        "line": 1
      },
      "id": "M-3.5"
    },
    {
      "title": "1.3 Ensure Docker is up to date (Not Scored)",
      "desc": "There are frequent releases for Docker software that address security vulnerabilities,\nproduct bugs and bring in new functionality. Keep a tab on these product\nupdates and upgrade as frequently as when new security vulnerabilities are fixed or\ndeemed correct for your organization.\nBy staying up to date on Docker updates, vulnerabilities in the Docker\nsoftware can be mitigated. An educated attacker may exploit known vulnerabilities when\nattempting to attain access or elevate privileges. Not installing regular Docker updates\nmay leave you running vulnerable Docker software. It might lead to elevation\nprivileges, unauthorized access or other security breaches. Keep a track of new\nreleases and update as necessary.",
      "descriptions": {
        "default": "There are frequent releases for Docker software that address security vulnerabilities,\nproduct bugs and bring in new functionality. Keep a tab on these product\nupdates and upgrade as frequently as when new security vulnerabilities are fixed or\ndeemed correct for your organization.\nBy staying up to date on Docker updates, vulnerabilities in the Docker\nsoftware can be mitigated. An educated attacker may exploit known vulnerabilities when\nattempting to attain access or elevate privileges. Not installing regular Docker updates\nmay leave you running vulnerable Docker software. It might lead to elevation\nprivileges, unauthorized access or other security breaches. Keep a track of new\nreleases and update as necessary."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/installation/",
          "ref": "installation"
        },
        {
          "url": "https://github.com/moby/moby/releases/latest",
          "ref": "latest"
        },
        {
          "url": "https://github.com/docker/docker-ce/releases/latest",
          "ref": "latest"
        },
        {
          "url": "https://docs.docker.com/installation/",
          "ref": "Docker installation"
        },
        {
          "url": "https://github.com/docker/docker/releases/latest",
          "ref": "Docker releases"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "1.3",
        "cis_control": [
          "4",
          "6.1"
        ],
        "cis_level": "Level 1 - Linux Host OS",
        "nist": [
          "RA-5",
          "4"
        ],
        "check_text": "Execute the below command and verify that the Docker version is\n  up to date as deemed necessary. It is not a mandate to be on the latest one,\n  though. docker version",
        "fix": "Keep a track of Docker releases and update as necessary.",
        "Default Value": "Not Applicable"
      },
      "code": "control 'M-1.3' do\n  title '1.3 Ensure Docker is up to date (Not Scored)'\n  desc  \"\n  There are frequent releases for Docker software that address security vulnerabilities,\n  product bugs and bring in new functionality. Keep a tab on these product\n  updates and upgrade as frequently as when new security vulnerabilities are fixed or\n  deemed correct for your organization.\n  By staying up to date on Docker updates, vulnerabilities in the Docker\n  software can be mitigated. An educated attacker may exploit known vulnerabilities when\n  attempting to attain access or elevate privileges. Not installing regular Docker updates\n  may leave you running vulnerable Docker software. It might lead to elevation\n  privileges, unauthorized access or other security breaches. Keep a track of new\n  releases and update as necessary.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '1.3'\n  tag \"cis_control\": ['4', '6.1']\n  tag \"cis_level\": 'Level 1 - Linux Host OS'\n  tag \"nist\": ['RA-5', '4']\n  tag \"check_text\": \"Execute the below command and verify that the Docker version is\n  up to date as deemed necessary. It is not a mandate to be on the latest one,\n  though. docker version\"\n  tag \"fix\": 'Keep a track of Docker releases and update as necessary.'\n  tag \"Default Value\": 'Not Applicable'\n  ref 'installation', url: 'https://docs.docker.com/engine/installation/'\n  ref 'latest', url: 'https://github.com/moby/moby/releases/latest'\n  ref 'latest', url: 'https://github.com/docker/docker-ce/releases/latest'\n  ref 'Docker installation', url: 'https://docs.docker.com/installation/'\n  ref 'Docker releases', url: 'https://github.com/docker/docker/releases/latest'\n\n  describe docker.version do\n    its('Client.Version') { should cmp >= '17.03' }\n    its('Server.Version') { should cmp >= '17.03' }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-1.3.rb",
        "line": 1
      },
      "id": "M-1.3"
    },
    {
      "title": "5.23 Ensure docker exec commands are not used with user option(Scored)",
      "desc": "Do not use docker exec with the --user option.\n  Using the --user option in docker exec executes the command within the\n  container as that user. This could potentially be insecure and unsafe to do especially when\n  you are running containers with dropped capabilities or with enhanced restrictions.\n  For example, suppose your container is running as tomcat user (or any other\n  non-root user), it would be possible to run a command through docker exec as\n  root with the --user=root option. This could potentially be dangerous.",
      "descriptions": {
        "default": "Do not use docker exec with the --user option.\n  Using the --user option in docker exec executes the command within the\n  container as that user. This could potentially be insecure and unsafe to do especially when\n  you are running containers with dropped capabilities or with enhanced restrictions.\n  For example, suppose your container is running as tomcat user (or any other\n  non-root user), it would be possible to run a command through docker exec as\n  root with the --user=root option. This could potentially be dangerous."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/reference/commandline/exec/"
        }
      ],
      "tags": {
        "ref": "1. https://docs.docker.com/engine/reference/commandline/exec/",
        "severity": "medium",
        "cis_id": "5.23",
        "cis_control": [
          "5",
          "6.1"
        ],
        "cis_level": "Level 2 - Docker",
        "nist": [
          "AC-6",
          "4"
        ],
        "check_text": "If you have auditing enabled as prescribed in Section 1, you\n  can use the below command to filter out the docker exec commands that used the --user\n  option. ausearch -k docker | grep exec | grep user",
        "fix": "Do not use the --user option in the docker exec command.",
        "Default Value": "By default, the docker exec command runs without the --user\n  option."
      },
      "code": "control 'M-5.23' do\n  title '5.23 Ensure docker exec commands are not used with user option(Scored)'\n  desc  \"Do not use docker exec with the --user option.\n  Using the --user option in docker exec executes the command within the\n  container as that user. This could potentially be insecure and unsafe to do especially when\n  you are running containers with dropped capabilities or with enhanced restrictions.\n  For example, suppose your container is running as tomcat user (or any other\n  non-root user), it would be possible to run a command through docker exec as\n  root with the --user=root option. This could potentially be dangerous.\n  \"\n  impact 0.5\n  tag \"ref\": '1. https://docs.docker.com/engine/reference/commandline/exec/'\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.23'\n  tag \"cis_control\": ['5', '6.1']\n  tag \"cis_level\": 'Level 2 - Docker'\n  tag \"nist\": ['AC-6', '4']\n  tag \"check_text\": \"If you have auditing enabled as prescribed in Section 1, you\n  can use the below command to filter out the docker exec commands that used the --user\n  option. ausearch -k docker | grep exec | grep user\"\n  tag \"fix\": 'Do not use the --user option in the docker exec command.'\n  tag \"Default Value\": \"By default, the docker exec command runs without the --user\n  option.\"\n  ref url: 'https://docs.docker.com/engine/reference/commandline/exec/'\n\n  describe command('ausearch --input-logs -k docker | grep exec | grep user').stdout do\n    it { should be_empty }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.23.rb",
        "line": 1
      },
      "id": "M-5.23"
    },
    {
      "title": "3.10 Ensure that TLS CA certificate file permissions are set to 444 or more restrictive (Scored)",
      "desc": "Verify that the TLS CA certificate file (the file that is passed along with the --tlscacert\n  parameter) has permissions of 444 or more restrictive.\n  The TLS CA certificate file should be protected from any tampering. It is\n  used to authenticate the Docker server based on a given CA certificate. Hence, it must\n  have permissions of 444 to maintain the integrity of the CA certificate.",
      "descriptions": {
        "default": "Verify that the TLS CA certificate file (the file that is passed along with the --tlscacert\n  parameter) has permissions of 444 or more restrictive.\n  The TLS CA certificate file should be protected from any tampering. It is\n  used to authenticate the Docker server based on a given CA certificate. Hence, it must\n  have permissions of 444 to maintain the integrity of the CA certificate."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/security/certificates/"
        },
        {
          "url": "https://docs.docker.com/engine/security/https/"
        }
      ],
      "tags": {
        "ref": "1. https://docs.docker.com/registry/insecure/2.\n  https://docs.docker.com/engine/security/https/",
        "severity": "medium",
        "cis_id": "3.10",
        "cis_control": [
          "14.4",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-3 (3)",
          "4"
        ],
        "check_text": "Execute the below command to verify that the TLS CA certificate\n  file has permissions of 444 or more restrictive: stat -c %a <path to TLS CA\n  certificate file>",
        "fix": "chmod 444 <path to the TLS CA certificate file> This would set the\n  file permissions of the TLS CA file to 444.",
        "Default Value": "By default, the permissions for the TLS CA certificate file\n  might not be 444. The default file permissions are governed by the system or user specific umask values."
      },
      "code": "control 'M-3.10' do\n  title '3.10 Ensure that TLS CA certificate file permissions are set to 444 or more restrictive (Scored)'\n  desc  \"Verify that the TLS CA certificate file (the file that is passed along with the --tlscacert\n  parameter) has permissions of 444 or more restrictive.\n  The TLS CA certificate file should be protected from any tampering. It is\n  used to authenticate the Docker server based on a given CA certificate. Hence, it must\n  have permissions of 444 to maintain the integrity of the CA certificate.\n  \"\n  impact 0.5\n  tag \"ref\": \"1. https://docs.docker.com/registry/insecure/2.\n  https://docs.docker.com/engine/security/https/\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '3.10'\n  tag \"cis_control\": ['14.4', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-3 (3)', '4']\n  tag \"check_text\": \"Execute the below command to verify that the TLS CA certificate\n  file has permissions of 444 or more restrictive: stat -c %a <path to TLS CA\n  certificate file>\"\n  tag \"fix\": \"chmod 444 <path to the TLS CA certificate file> This would set the\n  file permissions of the TLS CA file to 444.\"\n  tag \"Default Value\": \"By default, the permissions for the TLS CA certificate file\n  might not be 444. The default file permissions are governed by the system or user specific umask values.\"\n  ref url: 'https://docs.docker.com/engine/security/certificates/'\n  ref url: 'https://docs.docker.com/engine/security/https/'\n\n  describe file(json('/etc/docker/daemon.json').params['tlscacert']) do\n    it { should exist }\n    it { should be_file }\n    it { should be_readable }\n    it { should_not be_executable }\n    it { should_not be_writable }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-3.10.rb",
        "line": 1
      },
      "id": "M-3.10"
    },
    {
      "title": "1.11 Ensure auditing is configured for Docker files and directories\n  /etc/docker/daemon.json (Scored)",
      "desc": "Audit /etc/docker/daemon.json, if applicable.\n  Apart from auditing your regular Linux file system and system calls, audit\n  all Docker related files and directories. Docker daemon runs with root privileges. Its\n  behavior depends on some key files and directories. /etc/docker/daemon.json is one\n  such file. It holds various parameters for Docker daemon. It must be audited, if\n  applicable.",
      "descriptions": {
        "default": "Audit /etc/docker/daemon.json, if applicable.\n  Apart from auditing your regular Linux file system and system calls, audit\n  all Docker related files and directories. Docker daemon runs with root privileges. Its\n  behavior depends on some key files and directories. /etc/docker/daemon.json is one\n  such file. It holds various parameters for Docker daemon. It must be audited, if\n  applicable."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html",
          "ref": "System auditing"
        },
        {
          "url": "https://docs.docker.com/engine/reference/commandline/dockerd/#daemonconfiguration-file",
          "ref": "daemonconfiguration-file"
        },
        {
          "url": "https://docs.docker.com/engine/reference/commandline/daemon/#daemon-configuration-file",
          "ref": "Daemon configuration"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "1.11",
        "cis_control": [
          "14.6",
          "6.1"
        ],
        "cis_level": "Level 1 - Linux Host OS",
        "nist": [
          "AU-2",
          "4"
        ],
        "check_text": "Verify that there is an audit rule corresponding to\n  /etc/docker/daemon.json file. For example, execute below command: auditctl -l\n  | grep /etc/docker/daemon.json This should list a rule for\n  /etc/docker/daemon.json file.",
        "fix": "Add a rule for /etc/docker/daemon.json file. For example, Add\n  the line as below in /etc/audit/audit.rules file: -w /etc/docker/daemon.json\n  -k docker Then, restart the audit daemon. For example, service auditd restart",
        "Default Value": "By default, Docker related files and directories are\n  not audited. The file /etc/docker/daemon.json may not be available on the\n  system. In that case, this recommendation is not applicable."
      },
      "code": "control 'M-1.11' do\n  title \"1.11 Ensure auditing is configured for Docker files and directories\n  /etc/docker/daemon.json (Scored)\"\n  desc  \"Audit /etc/docker/daemon.json, if applicable.\n  Apart from auditing your regular Linux file system and system calls, audit\n  all Docker related files and directories. Docker daemon runs with root privileges. Its\n  behavior depends on some key files and directories. /etc/docker/daemon.json is one\n  such file. It holds various parameters for Docker daemon. It must be audited, if\n  applicable.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '1.11'\n  tag \"cis_control\": ['14.6', '6.1']\n  tag \"cis_level\": 'Level 1 - Linux Host OS'\n  tag \"nist\": ['AU-2', '4']\n  tag \"check_text\": \"Verify that there is an audit rule corresponding to\n  /etc/docker/daemon.json file. For example, execute below command: auditctl -l\n  | grep /etc/docker/daemon.json This should list a rule for\n  /etc/docker/daemon.json file.\"\n  tag \"fix\": \"Add a rule for /etc/docker/daemon.json file. For example, Add\n  the line as below in /etc/audit/audit.rules file: -w /etc/docker/daemon.json\n  -k docker Then, restart the audit daemon. For example, service auditd restart\"\n  tag \"Default Value\": \"By default, Docker related files and directories are\n  not audited. The file /etc/docker/daemon.json may not be available on the\n  system. In that case, this recommendation is not applicable.\"\n  ref 'System auditing', url: 'https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html'\n  ref 'daemonconfiguration-file', url: 'https://docs.docker.com/engine/reference/commandline/dockerd/#daemonconfiguration-file'\n  ref 'Daemon configuration', url: 'https://docs.docker.com/engine/reference/commandline/daemon/#daemon-configuration-file'\n\n  describe auditd do\n    its('lines') { should include '-w /etc/docker/daemon.json -p rwxa -k docker' }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-1.11.rb",
        "line": 1
      },
      "id": "M-1.11"
    },
    {
      "title": "3.11 Ensure that Docker server certificate file ownership is set to root:root (Scored)",
      "desc": "Verify that the Docker server certificate file (the file that is passed along with the --tlscert\n  parameter) is owned and group-owned by root.\n  The Docker server certificate file should be protected from any tampering.\n  It is used to authenticate the Docker server based on the given server certificate. Hence, it\n  must be owned and group-owned by root to maintain the integrity of the certificate.",
      "descriptions": {
        "default": "Verify that the Docker server certificate file (the file that is passed along with the --tlscert\n  parameter) is owned and group-owned by root.\n  The Docker server certificate file should be protected from any tampering.\n  It is used to authenticate the Docker server based on the given server certificate. Hence, it\n  must be owned and group-owned by root to maintain the integrity of the certificate."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/security/certificates/"
        },
        {
          "url": "https://docs.docker.com/engine/security/https/"
        }
      ],
      "tags": {
        "ref": "1. https://docs.docker.com/registry/insecure/2.\n  https://docs.docker.com/engine/security/https/",
        "severity": "medium",
        "cis_id": "3.11",
        "cis_control": [
          "5.1",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-6(9)",
          "4"
        ],
        "check_text": "Execute the below command to verify that the Docker server\n  certificate file is owned and group-owned by root: stat -c %U:%G <path to\n  Docker server certificate file> | grep -v root:root The above command should\n  not return anything.",
        "fix": "chown root:root <path to Docker server certificate file> This\n  would set the ownership and group-ownership for the Docker server certificate\n  file to root.",
        "Default Value": "By default, the ownership and group-ownership for\n  Docker server certificate file is correctly set to root."
      },
      "code": "control 'M-3.11' do\n  title '3.11 Ensure that Docker server certificate file ownership is set to root:root (Scored)'\n  desc  \"Verify that the Docker server certificate file (the file that is passed along with the --tlscert\n  parameter) is owned and group-owned by root.\n  The Docker server certificate file should be protected from any tampering.\n  It is used to authenticate the Docker server based on the given server certificate. Hence, it\n  must be owned and group-owned by root to maintain the integrity of the certificate.\n  \"\n  impact 0.5\n  tag \"ref\": \"1. https://docs.docker.com/registry/insecure/2.\n  https://docs.docker.com/engine/security/https/\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '3.11'\n  tag \"cis_control\": ['5.1', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-6(9)', '4']\n  tag \"check_text\": \"Execute the below command to verify that the Docker server\n  certificate file is owned and group-owned by root: stat -c %U:%G <path to\n  Docker server certificate file> | grep -v root:root The above command should\n  not return anything.\"\n  tag \"fix\": \"chown root:root <path to Docker server certificate file> This\n  would set the ownership and group-ownership for the Docker server certificate\n  file to root.\"\n  tag \"Default Value\": \"By default, the ownership and group-ownership for\n  Docker server certificate file is correctly set to root.\"\n  ref url: 'https://docs.docker.com/engine/security/certificates/'\n  ref url: 'https://docs.docker.com/engine/security/https/'\n\n  describe file(json('/etc/docker/daemon.json').params['tlscert']) do\n    it { should exist }\n    it { should be_file }\n    it { should be_owned_by 'root' }\n    it { should be_grouped_into 'root' }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-3.11.rb",
        "line": 1
      },
      "id": "M-3.11"
    },
    {
      "title": "1.10 Ensure auditing is configured for Docker files and directories\n  /etc/default/docker (Scored)",
      "desc": "Audit /etc/default/docker, if applicable.\n  Apart from auditing your regular Linux file system and system calls, audit\n  all Docker related files and directories. Docker daemon runs with root privileges. Its\n  behavior depends on some key files and directories. /etc/default/docker is one such\n  file. It holds various parameters for Docker daemon. It must be audited, if applicable.",
      "descriptions": {
        "default": "Audit /etc/default/docker, if applicable.\n  Apart from auditing your regular Linux file system and system calls, audit\n  all Docker related files and directories. Docker daemon runs with root privileges. Its\n  behavior depends on some key files and directories. /etc/default/docker is one such\n  file. It holds various parameters for Docker daemon. It must be audited, if applicable."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html",
          "ref": "System auditing"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "1.10",
        "cis_control": [
          "14.6",
          "6.1"
        ],
        "cis_level": "Level 1 - Linux Host OS",
        "nist": [
          "AU-2",
          "4"
        ],
        "check_text": "Verify that there is an audit rule corresponding to\n  /etc/default/docker file. For example, execute below command: auditctl -l |\n  grep /etc/default/docker This should list a rule for /etc/default/docker\n  file.",
        "fix": "Add a rule for /etc/default/docker file. For example, Add the\n  line as below in /etc/audit/audit.rules file: -w /etc/default/docker -k\n  docker Then, restart the audit daemon. For example, service auditd restart",
        "Default Value": "By default, Docker related files and directories are\n  not audited. The file /etc/default/docker may not be available on the system.\n  In that case, this recommendation is not applicable."
      },
      "code": "control 'M-1.10' do\n  title \"1.10 Ensure auditing is configured for Docker files and directories\n  /etc/default/docker (Scored)\"\n  desc  \"Audit /etc/default/docker, if applicable.\n  Apart from auditing your regular Linux file system and system calls, audit\n  all Docker related files and directories. Docker daemon runs with root privileges. Its\n  behavior depends on some key files and directories. /etc/default/docker is one such\n  file. It holds various parameters for Docker daemon. It must be audited, if applicable.\"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '1.10'\n  tag \"cis_control\": ['14.6', '6.1']\n  tag \"cis_level\": 'Level 1 - Linux Host OS'\n  tag \"nist\": ['AU-2', '4']\n  tag \"check_text\": \"Verify that there is an audit rule corresponding to\n  /etc/default/docker file. For example, execute below command: auditctl -l |\n  grep /etc/default/docker This should list a rule for /etc/default/docker\n  file.\"\n  tag \"fix\": \"Add a rule for /etc/default/docker file. For example, Add the\n  line as below in /etc/audit/audit.rules file: -w /etc/default/docker -k\n  docker Then, restart the audit daemon. For example, service auditd restart\"\n  tag \"Default Value\": \"By default, Docker related files and directories are\n  not audited. The file /etc/default/docker may not be available on the system.\n  In that case, this recommendation is not applicable.\"\n  ref 'System auditing', url: 'https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html'\n\n  describe auditd do\n    its('lines') { should include '-w /etc/default/docker -p rwxa -k docker' }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-1.10.rb",
        "line": 1
      },
      "id": "M-1.10"
    },
    {
      "title": "7.9 Ensure CA certificates are rotated as appropriate (Not Scored)",
      "desc": "Rotate root CA certificates as appropriate.\n  Docker Swarm uses mutual TLS for clustering operations amongst its nodes.\n  Certificate rotation ensures that in an event such as a compromised node or key, it is\n  difficult to impersonate a node. Node certificates depend upon root CA certificates. For\n  operational security, it is important to rotate these frequently. Currently, root CA\n  certificates are not rotated automatically. You should thus establish a process to rotate it at\n  the desired frequency.",
      "descriptions": {
        "default": "Rotate root CA certificates as appropriate.\n  Docker Swarm uses mutual TLS for clustering operations amongst its nodes.\n  Certificate rotation ensures that in an event such as a compromised node or key, it is\n  difficult to impersonate a node. Node certificates depend upon root CA certificates. For\n  operational security, it is important to rotate these frequently. Currently, root CA\n  certificates are not rotated automatically. You should thus establish a process to rotate it at\n  the desired frequency."
      },
      "impact": 0,
      "refs": [],
      "tags": {
        "ref": "1.\n  https://docs.docker.com/engine/swarm/how-swarm-mode-works/pki/#rotatingthe-ca-certificate",
        "severity": "medium",
        "cis_id": "7.9",
        "cis_control": [
          "14.2",
          "6.1"
        ],
        "cis_level": "Level 2 - Docker",
        "nist": [
          "SC-8",
          "4"
        ],
        "check_text": "Based on your installation path, check the time stamp on the\n  root CA certificate file. For example, ls -l\n  /var/lib/docker/swarm/certificates/swarm-root-ca.crt The certificate should\n  have been rotated at the established frequency.",
        "fix": "Run the below command to rotate the certificate. docker swarm ca --rotate",
        "Default Value": "By default, root CA certificates are not rotated."
      },
      "code": "control 'M-7.9' do\n  title '7.9 Ensure CA certificates are rotated as appropriate (Not Scored)'\n  desc  \"Rotate root CA certificates as appropriate.\n  Docker Swarm uses mutual TLS for clustering operations amongst its nodes.\n  Certificate rotation ensures that in an event such as a compromised node or key, it is\n  difficult to impersonate a node. Node certificates depend upon root CA certificates. For\n  operational security, it is important to rotate these frequently. Currently, root CA\n  certificates are not rotated automatically. You should thus establish a process to rotate it at\n  the desired frequency.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  https://docs.docker.com/engine/swarm/how-swarm-mode-works/pki/#rotatingthe-ca-certificate\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '7.9'\n  tag \"cis_control\": ['14.2', '6.1']\n  tag \"cis_level\": 'Level 2 - Docker'\n  tag \"nist\": ['SC-8', '4']\n  tag \"check_text\": \"Based on your installation path, check the time stamp on the\n  root CA certificate file. For example, ls -l\n  /var/lib/docker/swarm/certificates/swarm-root-ca.crt The certificate should\n  have been rotated at the established frequency.\"\n  tag \"fix\": 'Run the below command to rotate the certificate. docker swarm ca --rotate'\n  tag \"Default Value\": 'By default, root CA certificates are not rotated.'\n\n  if attribute('swarm_mode') == 'active'\n    swarm_root_ca_crt = command('ls -l /var/lib/docker/swarm/certificates/swarm-root-ca.crt').stdout.strip\n    describe \"A manual review of the swarm root ca certificate: #{swarm_root_ca_crt} is required to ensure it is rotated as appropriate\" do\n      skip \"A manual review of the swarm root ca certificate: #{swarm_root_ca_crt} is required to ensure it is rotated as appropriate\"\n    end\n  else\n    impact 0.0\n    describe 'The docker swarm mode is not being used, therefore this control is N/A' do\n      skip 'The docker swarm mode is not being used, therefore this control is N/A'\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-7.9.rb",
        "line": 7
      },
      "id": "M-7.9"
    },
    {
      "title": "7.6 Ensure swarm manager is run in auto-lock mode (Scored)",
      "desc": "Run the docker swarm manager in auto-lock mode.\n  When Docker restarts, both the TLS key used to encrypt communication among\n  swarm nodes, and the key used to encrypt and decrypt Raft logs on disk, are\n  loaded into each manager node's memory. You should protect the mutual TLS encryption key and\n  the key used to encrypt and decrypt Raft logs at rest. This protection could be\n  enabled by initializing the swarm with the --autolock flag.\n  With the --autolock parameter enabled, when Docker restarts, you must unlock the swarm\n  first, using an encryption key generated by Docker when the swarm was initialized.",
      "descriptions": {
        "default": "Run the docker swarm manager in auto-lock mode.\n  When Docker restarts, both the TLS key used to encrypt communication among\n  swarm nodes, and the key used to encrypt and decrypt Raft logs on disk, are\n  loaded into each manager node's memory. You should protect the mutual TLS encryption key and\n  the key used to encrypt and decrypt Raft logs at rest. This protection could be\n  enabled by initializing the swarm with the --autolock flag.\n  With the --autolock parameter enabled, when Docker restarts, you must unlock the swarm\n  first, using an encryption key generated by Docker when the swarm was initialized."
      },
      "impact": 0,
      "refs": [],
      "tags": {
        "ref": "1. https://docs.docker.com/engine/swarm/swarm_manager_locking/",
        "severity": "medium",
        "cis_id": "7.6",
        "cis_control": [
          "14.2",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SC-8",
          "4"
        ],
        "check_text": "Run the below command. If it outputs the key, it means the swarm\n  was initialized with the -autolock flag. If the output is no unlock key is set,\n  it means that the swarm was NOT initialized with the --autolock flag and is\n  non-compliant with respect to this recommendation. docker swarm unlock-key",
        "fix": "If you are initializing swarm, use the below command. docker\n  swarm init --autolock If you want to set --autolock on an existing swarm\n  manager node, use the below command. docker swarm update --autolock",
        "Default Value": "By default, swarm manager does not run in auto-lock mode."
      },
      "code": "control 'M-7.6' do\n  title '7.6 Ensure swarm manager is run in auto-lock mode (Scored)'\n  desc  \"Run the docker swarm manager in auto-lock mode.\n  When Docker restarts, both the TLS key used to encrypt communication among\n  swarm nodes, and the key used to encrypt and decrypt Raft logs on disk, are\n  loaded into each manager node's memory. You should protect the mutual TLS encryption key and\n  the key used to encrypt and decrypt Raft logs at rest. This protection could be\n  enabled by initializing the swarm with the --autolock flag.\n  With the --autolock parameter enabled, when Docker restarts, you must unlock the swarm\n  first, using an encryption key generated by Docker when the swarm was initialized.\n  \"\n  impact 0.5\n  tag \"ref\": '1. https://docs.docker.com/engine/swarm/swarm_manager_locking/'\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '7.6'\n  tag \"cis_control\": ['14.2', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SC-8', '4']\n  tag \"check_text\": \"Run the below command. If it outputs the key, it means the swarm\n  was initialized with the -autolock flag. If the output is no unlock key is set,\n  it means that the swarm was NOT initialized with the --autolock flag and is\n  non-compliant with respect to this recommendation. docker swarm unlock-key\"\n  tag \"fix\": \"If you are initializing swarm, use the below command. docker\n  swarm init --autolock If you want to set --autolock on an existing swarm\n  manager node, use the below command. docker swarm update --autolock\"\n  tag \"Default Value\": 'By default, swarm manager does not run in auto-lock mode.'\n  if attribute('swarm_mode') == 'active'\n    autolock_mode = command('docker swarm unlock-key').stdout.chomp.length\n\n    describe 'The swarn mananager auto-lock mode' do\n      subject { autolock_mode }\n      it { should be > 0 }\n    end\n  else\n    impact 0.0\n    describe 'The docker swarm mode is not being used, therefore this control is N/A' do\n      skip 'The docker swarm mode is not being used, therefore this control is N/A'\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-7.6.rb",
        "line": 1
      },
      "id": "M-7.6"
    },
    {
      "title": "7.7 Ensure swarm manager auto-lock key is rotated periodically (Not Scored)",
      "desc": "Rotate the swarm manager auto-lock key periodically.\n  The swarm manager auto-lock key is not automatically rotated. You should rotate\n  them periodically as a best practice.",
      "descriptions": {
        "default": "Rotate the swarm manager auto-lock key periodically.\n  The swarm manager auto-lock key is not automatically rotated. You should rotate\n  them periodically as a best practice."
      },
      "impact": 0,
      "refs": [],
      "tags": {
        "ref": "1.\n  https://docs.docker.com/engine/reference/commandline/swarm_unlock-key/",
        "severity": "medium",
        "cis_id": "7.7",
        "cis_control": [
          "14.2",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SC-8",
          "4"
        ],
        "check_text": "Currently, there is no mechanism to find out when the key was\n  last rotated on a swarm manager node. You should check with the system\n  administrator to see if there is a key rotation record and whether the keys were rotated at a\n  pre-defined frequency.",
        "fix": "Run the below command to rotate the keys. docker swarm\n  unlock-key --rotate Additionally, to facilitate an audit for this recommendation,\n  maintain key rotation records and ensure that you establish a pre-defined\n  frequency for key rotation.",
        "Default Value": "By default, keys are not rotated automatically."
      },
      "code": "control 'M-7.7' do\n  title '7.7 Ensure swarm manager auto-lock key is rotated periodically (Not Scored)'\n  desc  \"Rotate the swarm manager auto-lock key periodically.\n  The swarm manager auto-lock key is not automatically rotated. You should rotate\n  them periodically as a best practice.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  https://docs.docker.com/engine/reference/commandline/swarm_unlock-key/\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '7.7'\n  tag \"cis_control\": ['14.2', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SC-8', '4']\n  tag \"check_text\": \"Currently, there is no mechanism to find out when the key was\n  last rotated on a swarm manager node. You should check with the system\n  administrator to see if there is a key rotation record and whether the keys were rotated at a\n  pre-defined frequency.\"\n  tag \"fix\": \"Run the below command to rotate the keys. docker swarm\n  unlock-key --rotate Additionally, to facilitate an audit for this recommendation,\n  maintain key rotation records and ensure that you establish a pre-defined\n  frequency for key rotation.\"\n  tag \"Default Value\": 'By default, keys are not rotated automatically.'\n  if attribute('swarm_mode') == 'active'\n    describe 'A manual review is required to ensure the swarm manager auto-lock key is rotated periodically' do\n      skip 'A manual review is required to ensure the swarm manager auto-lock key is rotated periodically'\n    end\n  else\n    impact 0.0\n    describe 'The docker swarm mode is not being used, therefore this control is N/A' do\n      skip 'The docker swarm mode is not being used, therefore this control is N/A'\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-7.7.rb",
        "line": 1
      },
      "id": "M-7.7"
    },
    {
      "title": "2.15 Ensure Userland Proxy is Disabled (Scored)",
      "desc": "The docker daemon starts a userland proxy service for port forwarding\n  whenever a port is exposed. Where hairpin NAT is available, this service is generally\n  superfluous to requirements and can be disabled.\n  Docker engine provides two mechanisms for forwarding ports from the host to\n  containers, hairpin NAT, and a userland proxy. In most circumstances, the hairpin NAT\n  mode is preferred as it improves performance and makes use of native Linux iptables\n  functionality instead of an additional component.\n  Where hairpin NAT is available, the userland proxy should be disabled on\n  startup to reduce the attack surface of the installation.",
      "descriptions": {
        "default": "The docker daemon starts a userland proxy service for port forwarding\n  whenever a port is exposed. Where hairpin NAT is available, this service is generally\n  superfluous to requirements and can be disabled.\n  Docker engine provides two mechanisms for forwarding ports from the host to\n  containers, hairpin NAT, and a userland proxy. In most circumstances, the hairpin NAT\n  mode is preferred as it improves performance and makes use of native Linux iptables\n  functionality instead of an additional component.\n  Where hairpin NAT is available, the userland proxy should be disabled on\n  startup to reduce the attack surface of the installation."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "http://windsock.io/the-docker-proxy/",
          "ref": "the-docker-proxy"
        },
        {
          "url": "https://github.com/docker/docker/issues/14856",
          "ref": "issues 14856"
        },
        {
          "url": "https://github.com/docker/docker/issues/22741",
          "ref": "issues 22741"
        },
        {
          "url": "https://docs.docker.com/engine/userguide/networking/default_network/binding/",
          "ref": "binding"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "2.15",
        "cis_control": [
          "9.1",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "CM-7(1)",
          "4"
        ],
        "check_text": "ps -ef | grep dockerd Ensure that the --userland-proxy\n  parameter is set to false.",
        "fix": "Run the Docker daemon as below: dockerd --userland-proxy=false",
        "Default Value": "By default, the userland proxy is enabled."
      },
      "code": "control 'M-2.15' do\n  title '2.15 Ensure Userland Proxy is Disabled (Scored)'\n  desc  \"The docker daemon starts a userland proxy service for port forwarding\n  whenever a port is exposed. Where hairpin NAT is available, this service is generally\n  superfluous to requirements and can be disabled.\n  Docker engine provides two mechanisms for forwarding ports from the host to\n  containers, hairpin NAT, and a userland proxy. In most circumstances, the hairpin NAT\n  mode is preferred as it improves performance and makes use of native Linux iptables\n  functionality instead of an additional component.\n  Where hairpin NAT is available, the userland proxy should be disabled on\n  startup to reduce the attack surface of the installation.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '2.15'\n  tag \"cis_control\": ['9.1', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['CM-7(1)', '4']\n  tag \"check_text\": \"ps -ef | grep dockerd Ensure that the --userland-proxy\n  parameter is set to false.\"\n  tag \"fix\": 'Run the Docker daemon as below: dockerd --userland-proxy=false'\n  tag \"Default Value\": 'By default, the userland proxy is enabled.'\n  ref 'the-docker-proxy', url: 'http://windsock.io/the-docker-proxy/'\n  ref 'issues 14856', url: 'https://github.com/docker/docker/issues/14856'\n  ref 'issues 22741', url: 'https://github.com/docker/docker/issues/22741'\n  ref 'binding', url: 'https://docs.docker.com/engine/userguide/networking/default_network/binding/'\n\n  describe json('/etc/docker/daemon.json') do\n    its(['userland-proxy']) { should eq(false) }\n  end\n  describe processes('dockerd').commands do\n    it { should include 'userland-proxy=false' }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-2.15.rb",
        "line": 1
      },
      "id": "M-2.15"
    },
    {
      "title": "4.1 Ensure a user for the container has been created (Scored)",
      "desc": "Create a non-root user for the container in the Dockerfile for the\n  container image. It is a good practice to run the container as a non-root user, if possible.\n  Though user namespace mapping is now available, if a user is already defined in the\n  container image, the container is run as that user by default and specific user namespace\n  remapping is not required.",
      "descriptions": {
        "default": "Create a non-root user for the container in the Dockerfile for the\n  container image. It is a good practice to run the container as a non-root user, if possible.\n  Though user namespace mapping is now available, if a user is already defined in the\n  container image, the container is run as that user by default and specific user namespace\n  remapping is not required."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://github.com/docker/docker/issues/2918"
        },
        {
          "url": "https://github.com/docker/docker/pull/4572"
        },
        {
          "url": "https://github.com/docker/docker/issues/7906"
        },
        {
          "url": "https://www.altiscale.com/blog/making-docker-work-yarn/"
        }
      ],
      "tags": {
        "ref": "1. https://github.com/docker/docker/issues/29182.\n  https://github.com/docker/docker/pull/45723.\n  https://github.com/docker/docker/issues/7906",
        "severity": "medium",
        "cis_id": "4.1",
        "cis_control": [
          "5.1",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-6(9)",
          "4"
        ],
        "check_text": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: User={{.Config.User }}' The above command should return container\n  username or user ID. If it is blank it means, the container is running as\n  root.",
        "fix": "Ensure that the Dockerfile for the container image contains below\n  instruction: USER <username or ID> where username or ID refers to the user\n  that could be found in the container base image. If there is no specific user\n  created in the container base image, then add a useradd command to add the\n  specific user before USER instruction. For example, add the below lines in the\n  Dockerfile to create a user in the container: RUN useradd -d /home/username -m\n  -s /bin/bash username USER username Note: If there are users in the image\n  that the containers do not need, consider deleting them. After deleting those\n  users, commit the image and then generate new instances of containers for\n  use.",
        "Default Value": "By default, the containers are run with root privileges\n  and as user root inside the container."
      },
      "code": "control 'M-4.1' do\n  title '4.1 Ensure a user for the container has been created (Scored)'\n  desc  \"Create a non-root user for the container in the Dockerfile for the\n  container image. It is a good practice to run the container as a non-root user, if possible.\n  Though user namespace mapping is now available, if a user is already defined in the\n  container image, the container is run as that user by default and specific user namespace\n  remapping is not required.\n  \"\n  impact 0.5\n  tag \"ref\": \"1. https://github.com/docker/docker/issues/29182.\n  https://github.com/docker/docker/pull/45723.\n  https://github.com/docker/docker/issues/7906\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '4.1'\n  tag \"cis_control\": ['5.1', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-6(9)', '4']\n  tag \"check_text\": \"docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: User={{.Config.User }}' The above command should return container\n  username or user ID. If it is blank it means, the container is running as\n  root.\"\n  tag \"fix\": \"Ensure that the Dockerfile for the container image contains below\n  instruction: USER <username or ID> where username or ID refers to the user\n  that could be found in the container base image. If there is no specific user\n  created in the container base image, then add a useradd command to add the\n  specific user before USER instruction. For example, add the below lines in the\n  Dockerfile to create a user in the container: RUN useradd -d /home/username -m\n  -s /bin/bash username USER username Note: If there are users in the image\n  that the containers do not need, consider deleting them. After deleting those\n  users, commit the image and then generate new instances of containers for\n  use.\"\n  tag \"Default Value\": \"By default, the containers are run with root privileges\n  and as user root inside the container.\"\n  ref url: 'https://github.com/docker/docker/issues/2918'\n  ref url: 'https://github.com/docker/docker/pull/4572'\n  ref url: 'https://github.com/docker/docker/issues/7906'\n  ref url: 'https://www.altiscale.com/blog/making-docker-work-yarn/'\n  describe 'A manual review is required to ensure a user for the container has been created' do\n    skip 'A manual review is required to ensure a user for the container has been created'\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-4.1.rb",
        "line": 1
      },
      "id": "M-4.1"
    },
    {
      "title": "3.16 Ensure that the docker socket file permissions are set to 660 or more restrictive (Scored)",
      "desc": "Verify that the Docker socket file has permissions of 660 or more restrictive.\n  Only root and members of the docker group should be allowed to read and write\n  to the default Docker Unix socket. Hence, the Docker socket file must have permissions of\n  660 or more restrictive.",
      "descriptions": {
        "default": "Verify that the Docker socket file has permissions of 660 or more restrictive.\n  Only root and members of the docker group should be allowed to read and write\n  to the default Docker Unix socket. Hence, the Docker socket file must have permissions of\n  660 or more restrictive."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/reference/commandline/cli/#daemon-socket-option"
        },
        {
          "url": "https://docs.docker.com/engine/quickstart/"
        }
      ],
      "tags": {
        "ref": "1.\n  https://docs.docker.com/engine/reference/commandline/dockerd/#daemonsocket-option2.\n  https://docs.docker.com/engine/reference/commandline/dockerd/#bind-dockerto-another-hostport-or-a-unix-socket",
        "severity": "medium",
        "cis_id": "3.16",
        "cis_control": [
          "14.4",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-3 (3)",
          "4"
        ],
        "check_text": "Execute the below command to verify that the Docker socket file\n  has permissions of 660 or more restrictive: stat -c %a /var/run/docker.sock",
        "fix": "chmod 660 /var/run/docker.sock This would set the file\n  permissions of the Docker socket file to 660.",
        "Default Value": "By default, the permissions for the Docker socket file is\n  correctly set to 660."
      },
      "code": "control 'M-3.16' do\n  title '3.16 Ensure that the docker socket file permissions are set to 660 or more restrictive (Scored)'\n  desc  \"Verify that the Docker socket file has permissions of 660 or more restrictive.\n  Only root and members of the docker group should be allowed to read and write\n  to the default Docker Unix socket. Hence, the Docker socket file must have permissions of\n  660 or more restrictive.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  https://docs.docker.com/engine/reference/commandline/dockerd/#daemonsocket-option2.\n  https://docs.docker.com/engine/reference/commandline/dockerd/#bind-dockerto-another-hostport-or-a-unix-socket\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '3.16'\n  tag \"cis_control\": ['14.4', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-3 (3)', '4']\n  tag \"check_text\": \"Execute the below command to verify that the Docker socket file\n  has permissions of 660 or more restrictive: stat -c %a /var/run/docker.sock\"\n  tag \"fix\": \"chmod 660 /var/run/docker.sock This would set the file\n  permissions of the Docker socket file to 660.\"\n  tag \"Default Value\": \"By default, the permissions for the Docker socket file is\n  correctly set to 660.\"\n  ref url: 'https://docs.docker.com/engine/reference/commandline/cli/#daemon-socket-option'\n  ref url: 'https://docs.docker.com/engine/quickstart/'\n\n  describe file('/var/run/docker.sock') do\n    it { should exist }\n    it { should be_socket }\n    it { should be_readable.by('owner') }\n    it { should be_writable.by('owner') }\n    it { should_not be_executable.by('owner') }\n    it { should be_readable.by('group') }\n    it { should be_writable.by('group') }\n    it { should_not be_executable.by('group') }\n    it { should_not be_readable.by('other') }\n    it { should_not be_writable.by('other') }\n    it { should_not be_executable.by('other') }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-3.16.rb",
        "line": 1
      },
      "id": "M-3.16"
    },
    {
      "title": "5.20 Ensure the host's UTS namespace is not shared (Scored)",
      "desc": "The UTS namespaces provide isolation of two system identifiers: the hostname\n  and the NIS domain name. It is used for setting the hostname and the domain that is\n  visible to running processes in that namespace. Processes running within containers are not\n  typically requiredto know the hostname and domain name. Hence, the namespace should not be shared\n  with the host. Sharing the UTS namespace with the host provides full permissions to the\n  container to change the hostname of the host. This is insecure and should not be allowed.",
      "descriptions": {
        "default": "The UTS namespaces provide isolation of two system identifiers: the hostname\n  and the NIS domain name. It is used for setting the hostname and the domain that is\n  visible to running processes in that namespace. Processes running within containers are not\n  typically requiredto know the hostname and domain name. Hence, the namespace should not be shared\n  with the host. Sharing the UTS namespace with the host provides full permissions to the\n  container to change the hostname of the host. This is insecure and should not be allowed."
      },
      "impact": 0,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/reference/run/"
        },
        {
          "url": "http://man7.org/linux/man-pages/man7/pid_namespaces.7.html"
        }
      ],
      "tags": {
        "ref": "1.\n  https://docs.docker.com/engine/reference/run/#uts-settings-uts2.\n  http://man7.org/linux/man-pages/man7/namespaces.7.html",
        "severity": "medium",
        "cis_id": "5.20",
        "cis_control": [
          "18",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SI-1",
          "4"
        ],
        "check_text": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: UTSMode={{ .HostConfig.UTSMode }}' If the above command returns host, it\n  means the host UTS namespace is shared with the container and this\n  recommendation is non-compliant. If the above command returns nothing, then\n  the host's UTS namespace is not shared. This recommendation is\n  then compliant.",
        "fix": "Do not start a container with --uts=host argument. For example,\n  do not start a container as below: docker run --rm --interactive --tty\n  --uts=host rhel7.2",
        "Default Value": "By default, all containers have the UTS namespace\n  enabled and host UTS namespace is not shared with any container."
      },
      "code": "control 'M-5.20' do\n  title \"5.20 Ensure the host's UTS namespace is not shared (Scored)\"\n  desc  \"The UTS namespaces provide isolation of two system identifiers: the hostname\n  and the NIS domain name. It is used for setting the hostname and the domain that is\n  visible to running processes in that namespace. Processes running within containers are not\n  typically requiredto know the hostname and domain name. Hence, the namespace should not be shared\n  with the host. Sharing the UTS namespace with the host provides full permissions to the\n  container to change the hostname of the host. This is insecure and should not be allowed.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  https://docs.docker.com/engine/reference/run/#uts-settings-uts2.\n  http://man7.org/linux/man-pages/man7/namespaces.7.html\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.20'\n  tag \"cis_control\": ['18', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SI-1', '4']\n  tag \"check_text\": \"docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: UTSMode={{ .HostConfig.UTSMode }}' If the above command returns host, it\n  means the host UTS namespace is shared with the container and this\n  recommendation is non-compliant. If the above command returns nothing, then\n  the host's UTS namespace is not shared. This recommendation is\n  then compliant.\"\n  tag \"fix\": \"Do not start a container with --uts=host argument. For example,\n  do not start a container as below: docker run --rm --interactive --tty\n  --uts=host rhel7.2\"\n  tag \"Default Value\": \"By default, all containers have the UTS namespace\n  enabled and host UTS namespace is not shared with any container.\"\n  ref url: 'https://docs.docker.com/engine/reference/run/'\n  ref url: 'http://man7.org/linux/man-pages/man7/pid_namespaces.7.html'\n\n  if docker.containers.running?.ids.empty?\n    impact 0.0\n    describe 'There are no running docker containers, therfore this control is N/A' do\n      skip 'There are no running docker containers, therfore this control is N/A'\n    end\n  end\n\n  if !docker.containers.running?.ids.empty?\n    docker.containers.running?.ids.each do |id|\n      describe docker.object(id) do\n        its(%w{HostConfig UTSMode}) { should_not eq 'host' }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.20.rb",
        "line": 1
      },
      "id": "M-5.20"
    },
    {
      "title": "5.26 Ensure container health is checked at runtime (Scored)",
      "desc": "If the container image does not have a HEALTHCHECK instruction defined,\n  use the --health-cmd parameter at container runtime for checking container health.\n  One of the important security triads is availability. If the container\n  image you are using does not have a pre-defined HEALTHCHECK instruction, use the --health-cmd\n  parameter to check the container health at runtime.\n  Based on the reported health status, you could take necessary actions.",
      "descriptions": {
        "default": "If the container image does not have a HEALTHCHECK instruction defined,\n  use the --health-cmd parameter at container runtime for checking container health.\n  One of the important security triads is availability. If the container\n  image you are using does not have a pre-defined HEALTHCHECK instruction, use the --health-cmd\n  parameter to check the container health at runtime.\n  Based on the reported health status, you could take necessary actions."
      },
      "impact": 0,
      "refs": [],
      "tags": {
        "ref": "1. https://docs.docker.com/engine/reference/run/#healthcheck",
        "severity": "medium",
        "cis_id": "5.26",
        "cis_control": [
          "18",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SI-1",
          "4"
        ],
        "check_text": "Run the below command and ensure that all the containers are\n  reporting health status: docker ps --quiet | xargs docker inspect --format '{{\n  .Id }}: Health={{.State.Health.Status }}'",
        "fix": "Run the container using the --health-cmd and the other\n  parameters. For example, docker run -d --health-cmd='stat /etc/passwd || exit\n  1' nginx",
        "Default Value": "By default, health checks are not done at container\n  runtime."
      },
      "code": "control 'M-5.26' do\n  title '5.26 Ensure container health is checked at runtime (Scored)'\n  desc  \"If the container image does not have a HEALTHCHECK instruction defined,\n  use the --health-cmd parameter at container runtime for checking container health.\n  One of the important security triads is availability. If the container\n  image you are using does not have a pre-defined HEALTHCHECK instruction, use the --health-cmd\n  parameter to check the container health at runtime.\n  Based on the reported health status, you could take necessary actions.\n  \"\n  impact 0.5\n  tag \"ref\": '1. https://docs.docker.com/engine/reference/run/#healthcheck'\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.26'\n  tag \"cis_control\": ['18', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SI-1', '4']\n  tag \"check_text\": \"Run the below command and ensure that all the containers are\n  reporting health status: docker ps --quiet | xargs docker inspect --format '{{\n  .Id }}: Health={{.State.Health.Status }}'\"\n  tag \"fix\": \"Run the container using the --health-cmd and the other\n  parameters. For example, docker run -d --health-cmd='stat /etc/passwd || exit\n  1' nginx\"\n  tag \"Default Value\": \"By default, health checks are not done at container\n  runtime.\"\n\n  if !docker.containers.running?.ids.empty?\n    docker.containers.running?.ids.each do |id|\n      get_health = command(\"docker inspect --format='{{json .State.Health.Status}}' #{id}\").stdout.strip.split('\"')\n\n      describe \"The docker container health check status\" do\n        subject {get_health}\n        it { should_not be_empty }\n      end\n      if !get_health.empty?\n        get_health.each do |health_status|\n          health_status.chomp('\"\\\\\"')\n          describe \"The docker container health check for container #{id}\" do\n            subject { health_status }\n            it { should cmp 'healthy' }\n          end\n        end\n      end\n    end\n  end\n  if docker.containers.running?.ids.empty?\n    impact 0.0\n    describe 'There are no docker containers running, therefore this control is N/A' do\n      skip 'There are no docker containers running, therefore this control is N/A'\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.26.rb",
        "line": 1
      },
      "id": "M-5.26"
    },
    {
      "title": "5.22 Ensure docker exec commands are not used with privileged option(Scored)",
      "desc": "Do not use docker exec with the --privileged option.\n  Using the --privileged option in docker exec gives extended Linux capabilities\n  to the command. This could potentially be insecure and unsafe to do especially\n  when you are running containers with dropped capabilities or with enhanced restrictions.",
      "descriptions": {
        "default": "Do not use docker exec with the --privileged option.\n  Using the --privileged option in docker exec gives extended Linux capabilities\n  to the command. This could potentially be insecure and unsafe to do especially\n  when you are running containers with dropped capabilities or with enhanced restrictions."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/reference/commandline/exec/"
        }
      ],
      "tags": {
        "ref": "1. https://docs.docker.com/engine/reference/commandline/exec/\n",
        "severity": "medium",
        "cis_id": "5.22",
        "cis_control": [
          "5.1",
          "6.1"
        ],
        "cis_level": "Level 2 - Docker",
        "nist": [
          "AC-6(9)",
          "4"
        ],
        "check_text": "If you have auditing enabled as prescribed in Section 1, you\n  can use the below command to filter out docker exec commands that used\n  the --privileged option. ausearch -k docker | grep exec | grep privileged",
        "fix": "Do not use the --privileged option in the docker exec command.",
        "Default Value": "By default, the docker exec command runs without the\n  --privileged option."
      },
      "code": "control 'M-5.22' do\n  title '5.22 Ensure docker exec commands are not used with privileged option(Scored)'\n  desc  \"Do not use docker exec with the --privileged option.\n  Using the --privileged option in docker exec gives extended Linux capabilities\n  to the command. This could potentially be insecure and unsafe to do especially\n  when you are running containers with dropped capabilities or with enhanced restrictions.\n  \"\n  impact 0.5\n  tag \"ref\": \"1. https://docs.docker.com/engine/reference/commandline/exec/\\n\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.22'\n  tag \"cis_control\": ['5.1', '6.1']\n  tag \"cis_level\": 'Level 2 - Docker'\n  tag \"nist\": ['AC-6(9)', '4']\n  tag \"check_text\": \"If you have auditing enabled as prescribed in Section 1, you\n  can use the below command to filter out docker exec commands that used\n  the --privileged option. ausearch -k docker | grep exec | grep privileged\"\n  tag \"fix\": 'Do not use the --privileged option in the docker exec command.'\n  tag \"Default Value\": \"By default, the docker exec command runs without the\n  --privileged option.\"\n  ref url: 'https://docs.docker.com/engine/reference/commandline/exec/'\n\n  describe command('ausearch --input-logs -k docker | grep exec | grep privileged').stdout do\n    it { should be_empty }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.22.rb",
        "line": 1
      },
      "id": "M-5.22"
    },
    {
      "title": "7.10 Ensure management plane traffic has been separated from data plane traffic (Not Scored)",
      "desc": "Separate management plane traffic from data plane traffic.\n  Separating the management plane traffic from data plane traffic ensures\n  that these traffics are on their respective paths. These paths could then be individually\n  monitored and could be tied to different traffic control policies and monitoring. It also\n  ensures that the management plane is always reachable despite the huge volume of data flow.",
      "descriptions": {
        "default": "Separate management plane traffic from data plane traffic.\n  Separating the management plane traffic from data plane traffic ensures\n  that these traffics are on their respective paths. These paths could then be individually\n  monitored and could be tied to different traffic control policies and monitoring. It also\n  ensures that the management plane is always reachable despite the huge volume of data flow."
      },
      "impact": 0,
      "refs": [],
      "tags": {
        "ref": "1.\n  https://docs.docker.com/engine/reference/commandline/swarm_init/#--datapath-addr2.\n  https://github.com/moby/moby/issues/339383.\n  https://github.com/moby/moby/pull/32717",
        "severity": "medium",
        "cis_id": "7.10",
        "cis_control": [
          "18",
          "6.1"
        ],
        "cis_level": "Level 2 - Docker",
        "nist": [
          "SI-1",
          "4"
        ],
        "check_text": "Run the below command on each swarm node and ensure that the\n  management plane address is different from data plane address. docker node\n  inspect --format '{{ .Status.Addr }}' self Note: At the time of writing of\n  this benchmark, there is no way to inspect the data plane address. An issue has\n  been raised and is in the reference link.",
        "fix": "Initialize Swarm with dedicated interfaces for management and\n  data planes respectively. For example, docker swarm init\n  --advertise-addr=192.168.0.1 --data-path-addr=17.1.0.3",
        "Default Value": "By default, the data plane traffic is not separated\n  from management plane traffic."
      },
      "code": "control 'M-7.10' do\n  title '7.10 Ensure management plane traffic has been separated from data plane traffic (Not Scored)'\n  desc  \"Separate management plane traffic from data plane traffic.\n  Separating the management plane traffic from data plane traffic ensures\n  that these traffics are on their respective paths. These paths could then be individually\n  monitored and could be tied to different traffic control policies and monitoring. It also\n  ensures that the management plane is always reachable despite the huge volume of data flow.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  https://docs.docker.com/engine/reference/commandline/swarm_init/#--datapath-addr2.\n  https://github.com/moby/moby/issues/339383.\n  https://github.com/moby/moby/pull/32717\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '7.10'\n  tag \"cis_control\": ['18', '6.1']\n  tag \"cis_level\": 'Level 2 - Docker'\n  tag \"nist\": ['SI-1', '4']\n  tag \"check_text\": \"Run the below command on each swarm node and ensure that the\n  management plane address is different from data plane address. docker node\n  inspect --format '{{ .Status.Addr }}' self Note: At the time of writing of\n  this benchmark, there is no way to inspect the data plane address. An issue has\n  been raised and is in the reference link.\"\n  tag \"fix\": \"Initialize Swarm with dedicated interfaces for management and\n  data planes respectively. For example, docker swarm init\n  --advertise-addr=192.168.0.1 --data-path-addr=17.1.0.3\"\n  tag \"Default Value\": \"By default, the data plane traffic is not separated\n  from management plane traffic.\"\n\n  if attribute('swarm_mode') == 'active'\n    describe 'A manual review is required to ensure management plane traffic has been separated from data plane traffic' do\n      skip 'A manual review is required to ensure management plane traffic has been separated from data plane traffic'\n    end\n  else\n    impact 0.0\n    describe 'The docker swarm mode is not being used, therefore this control is N/A' do\n      skip 'The docker swarm mode is not being used, therefore this control is N/A'\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-7.10.rb",
        "line": 7
      },
      "id": "M-7.10"
    },
    {
      "title": "4.8 Ensure setuid and setgid permissions are removed in the images(Not Scored)",
      "desc": "Removing setuid and setgid permissions in the images would prevent\n  privilege escalation attacks in the containers.\n  Setuid and setgid permissions could be used for elevating privileges. While\n  these permissions are at times legitimately needed, these could potentially be\n  used in privilege escalation attacks. Thus, you should consider dropping these permissions\n  for the packages which do not need them within the images.",
      "descriptions": {
        "default": "Removing setuid and setgid permissions in the images would prevent\n  privilege escalation attacks in the containers.\n  Setuid and setgid permissions could be used for elevating privileges. While\n  these permissions are at times legitimately needed, these could potentially be\n  used in privilege escalation attacks. Thus, you should consider dropping these permissions\n  for the packages which do not need them within the images."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://github.com/dev-sec/linux-baseline"
        }
      ],
      "tags": {
        "ref": "1.\n  http://www.oreilly.com/webops-perf/free/files/docker-security.pdf2.\n  http://containersolutions.com/content/uploads/2015/06/15.06.15_DockerCheatSheet_A2.pdf3.\n  http://man7.org/linux/man-pages/man2/setuid.2.html4.\n  http://man7.org/linux/man-pages/man2/setgid.2.html",
        "severity": "medium",
        "cis_id": "4.8",
        "cis_control": [
          "5.1",
          "6.1"
        ],
        "cis_level": "Level 2 - Docker",
        "nist": [
          "AC-6(9)",
          "4"
        ],
        "check_text": "Run the below command on the image to list the executables\n  having setuid and setgid permissions: docker run <Image_ID> find / -perm\n  +6000 -type f -exec ls -ld {} \\; 2> /dev/null Carefully, review the list and\n  ensure that it is legitimate.",
        "fix": "Allow setuid and setgid permissions only on executables which\n  need them. You could remove these permissions during build time by adding the\n  following command in your Dockerfile, preferably towards the end of the\n  Dockerfile: RUN find / -perm +6000 -type f -exec chmod a-s {} \\; || true",
        "Default Value": "Not Applicable"
      },
      "code": "control 'M-4.8' do\n  title '4.8 Ensure setuid and setgid permissions are removed in the images(Not Scored)'\n  desc  \"Removing setuid and setgid permissions in the images would prevent\n  privilege escalation attacks in the containers.\n  Setuid and setgid permissions could be used for elevating privileges. While\n  these permissions are at times legitimately needed, these could potentially be\n  used in privilege escalation attacks. Thus, you should consider dropping these permissions\n  for the packages which do not need them within the images.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  http://www.oreilly.com/webops-perf/free/files/docker-security.pdf2.\n  http://containersolutions.com/content/uploads/2015/06/15.06.15_DockerCheatSheet_A2.pdf3.\n  http://man7.org/linux/man-pages/man2/setuid.2.html4.\n  http://man7.org/linux/man-pages/man2/setgid.2.html\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '4.8'\n  tag \"cis_control\": ['5.1', '6.1']\n  tag \"cis_level\": 'Level 2 - Docker'\n  tag \"nist\": ['AC-6(9)', '4']\n  tag \"check_text\": \"Run the below command on the image to list the executables\n  having setuid and setgid permissions: docker run <Image_ID> find / -perm\n  +6000 -type f -exec ls -ld {} \\\\; 2> /dev/null Carefully, review the list and\n  ensure that it is legitimate.\"\n  tag \"fix\": \"Allow setuid and setgid permissions only on executables which\n  need them. You could remove these permissions during build time by adding the\n  following command in your Dockerfile, preferably towards the end of the\n  Dockerfile: RUN find / -perm +6000 -type f -exec chmod a-s {} \\\\; || true\"\n  tag \"Default Value\": 'Not Applicable'\n  ref url: 'https://github.com/dev-sec/linux-baseline'\n\n  describe 'docker-test' do\n    skip 'Use DevSec Linux Baseline in Container'\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-4.8.rb",
        "line": 1
      },
      "id": "M-4.8"
    },
    {
      "title": "5.16 Ensure the host's IPC namespace is not shared (Scored)",
      "desc": "The IPC (POSIX/SysV IPC) namespace provides separation of named shared memory\n  segments, semaphores and message queues. IPC namespace on the host thus should not be\n  shared with the containers and should remain isolated.\n  The IPC namespace provides separation of the IPC between the host and containers.\n  If the host's IPC namespace is shared with the container, it would basically allow\n  processes within the container to see all of the IPC on the host system. This breaks the benefit\n  of IPC level isolation between the host and the containers. Someone having access to the\n  container can eventually manipulate the host IPC. This can be catastrophic. Hence, do not\n  share the host's IPC namespace with the containers.",
      "descriptions": {
        "default": "The IPC (POSIX/SysV IPC) namespace provides separation of named shared memory\n  segments, semaphores and message queues. IPC namespace on the host thus should not be\n  shared with the containers and should remain isolated.\n  The IPC namespace provides separation of the IPC between the host and containers.\n  If the host's IPC namespace is shared with the container, it would basically allow\n  processes within the container to see all of the IPC on the host system. This breaks the benefit\n  of IPC level isolation between the host and the containers. Someone having access to the\n  container can eventually manipulate the host IPC. This can be catastrophic. Hence, do not\n  share the host's IPC namespace with the containers."
      },
      "impact": 0,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/reference/run/#ipc-settings"
        },
        {
          "url": "http://man7.org/linux/man-pages/man7/pid_namespaces.7.html"
        }
      ],
      "tags": {
        "ref": "1.\n  https://docs.docker.com/engine/reference/run/#ipc-settings-ipc2.\n  http://man7.org/linux/man-pages/man7/namespaces.7.html",
        "severity": "medium",
        "cis_id": "5.16",
        "cis_control": [
          "18",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SI-1",
          "4"
        ],
        "check_text": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}:IpcMode={{ .HostConfig.IpcMode }}' If the above command returns host, it\n  means the host IPC namespace is shared with the container. If the above\n  command returns nothing, then the host's IPC namespace is not shared. This\n  recommendation is then compliant.",
        "fix": "Do not start a container with --ipc=host argument. For example,\n  do not start a container as below: docker run --interactive --tty --ipc=host\n  centos /bin/bash",
        "Default Value": "By default, all containers have the IPC namespace\n  enabled and host IPC namespace is not shared with any container."
      },
      "code": "control 'M-5.16' do\n  title \"5.16 Ensure the host's IPC namespace is not shared (Scored)\"\n  desc  \"The IPC (POSIX/SysV IPC) namespace provides separation of named shared memory\n  segments, semaphores and message queues. IPC namespace on the host thus should not be\n  shared with the containers and should remain isolated.\n  The IPC namespace provides separation of the IPC between the host and containers.\n  If the host's IPC namespace is shared with the container, it would basically allow\n  processes within the container to see all of the IPC on the host system. This breaks the benefit\n  of IPC level isolation between the host and the containers. Someone having access to the\n  container can eventually manipulate the host IPC. This can be catastrophic. Hence, do not\n  share the host's IPC namespace with the containers.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  https://docs.docker.com/engine/reference/run/#ipc-settings-ipc2.\n  http://man7.org/linux/man-pages/man7/namespaces.7.html\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.16'\n  tag \"cis_control\": ['18', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SI-1', '4']\n  tag \"check_text\": \"docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}:IpcMode={{ .HostConfig.IpcMode }}' If the above command returns host, it\n  means the host IPC namespace is shared with the container. If the above\n  command returns nothing, then the host's IPC namespace is not shared. This\n  recommendation is then compliant.\"\n  tag \"fix\": \"Do not start a container with --ipc=host argument. For example,\n  do not start a container as below: docker run --interactive --tty --ipc=host\n  centos /bin/bash\"\n  tag \"Default Value\": \"By default, all containers have the IPC namespace\n  enabled and host IPC namespace is not shared with any container.\"\n  ref url: 'https://docs.docker.com/engine/reference/run/#ipc-settings'\n  ref url: 'http://man7.org/linux/man-pages/man7/pid_namespaces.7.html'\n\n  if docker.containers.running?.ids.empty?\n    impact 0.0\n    describe 'There are no running docker containers, therfore this control is N/A' do\n      skip 'There are no running docker containers, therfore this control is N/A'\n    end\n  end\n\n  if !docker.containers.running?.ids.empty?\n    docker.containers.running?.ids.each do |id|\n      describe docker.object(id) do\n        its(%w{HostConfig IpcMode}) { should_not eq 'host' }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.16.rb",
        "line": 1
      },
      "id": "M-5.16"
    },
    {
      "title": "5.11 Ensure CPU priority is set appropriately on the container (Scored)",
      "desc": "By default, all containers on a Docker host share the resources equally. By\n  using the resource management capabilities of Docker host, such as CPU shares, you\n  can control the host CPU resources that a container may consume.\n  By default, CPU time is divided between containers equally. If it is\n  desired, to control the CPU time amongst the container instances, you can use the CPU sharing feature.\n  CPU sharing allows you to prioritize one container over the other and forbids the lower\n  priority container to claim CPU resources more often. This ensures that the high priority\n  containers are served better.",
      "descriptions": {
        "default": "By default, all containers on a Docker host share the resources equally. By\n  using the resource management capabilities of Docker host, such as CPU shares, you\n  can control the host CPU resources that a container may consume.\n  By default, CPU time is divided between containers equally. If it is\n  desired, to control the CPU time amongst the container instances, you can use the CPU sharing feature.\n  CPU sharing allows you to prioritize one container over the other and forbids the lower\n  priority container to claim CPU resources more often. This ensures that the high priority\n  containers are served better."
      },
      "impact": 0,
      "refs": [
        {
          "url": "https://goldmann.pl/blog/2014/09/11/resource-management-in-docker/"
        },
        {
          "url": "https://docs.docker.com/engine/reference/commandline/cli/#run"
        },
        {
          "url": "https://docs.docker.com/v1.8/articles/runmetrics/"
        }
      ],
      "tags": {
        "ref": "1.\n  https://goldmann.pl/blog/2014/09/11/resource-management-in-docker/\n2.\n  https://docs.docker.com/engine/reference/commandline/run/#options\n3.\n  https://docs.docker.com/engine/admin/runmetrics/\n",
        "severity": "medium",
        "cis_id": "5.11",
        "cis_control": [
          "18",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SI-1",
          "4"
        ],
        "check_text": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: CpuShares={{ .HostConfig.CpuShares }}' If the above command returns 0 or\n  1024, it means the CPU shares are not in place. If the above command returns a\n  non-zero value other than 1024, it means CPU shares are in place.",
        "fix": "Manage the CPU shares between your containers. To do so start the\n  container using the -cpu-shares argument. For example, you could run a\n  container as below: docker run --interactive --tty --cpu-shares 512 centos\n  /bin/bash In the above example, the container is started with CPU shares of\n  50% of what the other containers use. So, if the other container has CPU\n  shares of 80%, this container will have CPU shares of 40%. Note: Every new\n  container will have 1024 shares of CPU by default. However, this value\n  is shown as 0 if you run the command mentioned in the audit\n  section. Alternatively, 1. Navigate to /sys/fs/cgroup/cpu/system.slice/\n  directory. 2. Check your container instance ID using docker ps. 3. Now,\n  inside the above directory (in step 1), you would have a directory by\n  name docker-<Instance ID>.scope. For example,\n  docker4acae729e8659c6be696ee35b2237cc1fe4edd2672e9186434c5116e1a6fbed6.scope. Navigate\n  to this directory. 4. You will find a file named cpu.shares. Execute cat\n  cpu.shares. This will always give you the CPU share value based on the system.\n  So, even if there is no CPU shares configured using -c or --cpu-shares\n  argument in the docker run command, this file will have a value of 1024. If\n  we set one containers CPU shares to 512 it will receive half of the CPU time\n  compared to the other container. So, take 1024 as 100% and then do quick math\n  to derive the number that you should set for respective CPU shares. For\n  example, use 512 if you want to set 50% and 256 if you want to set 25%.",
        "Default Value": "By default, all containers on a Docker host share the\n  resources equally. No CPU shares are enforced."
      },
      "code": "control 'M-5.11' do\n  title '5.11 Ensure CPU priority is set appropriately on the container (Scored)'\n  desc  \"By default, all containers on a Docker host share the resources equally. By\n  using the resource management capabilities of Docker host, such as CPU shares, you\n  can control the host CPU resources that a container may consume.\n  By default, CPU time is divided between containers equally. If it is\n  desired, to control the CPU time amongst the container instances, you can use the CPU sharing feature.\n  CPU sharing allows you to prioritize one container over the other and forbids the lower\n  priority container to claim CPU resources more often. This ensures that the high priority\n  containers are served better.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  https://goldmann.pl/blog/2014/09/11/resource-management-in-docker/\\n2.\n  https://docs.docker.com/engine/reference/commandline/run/#options\\n3.\n  https://docs.docker.com/engine/admin/runmetrics/\\n\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.11'\n  tag \"cis_control\": ['18', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SI-1', '4']\n  tag \"check_text\": \"docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: CpuShares={{ .HostConfig.CpuShares }}' If the above command returns 0 or\n  1024, it means the CPU shares are not in place. If the above command returns a\n  non-zero value other than 1024, it means CPU shares are in place.\"\n  tag \"fix\": \"Manage the CPU shares between your containers. To do so start the\n  container using the -cpu-shares argument. For example, you could run a\n  container as below: docker run --interactive --tty --cpu-shares 512 centos\n  /bin/bash In the above example, the container is started with CPU shares of\n  50% of what the other containers use. So, if the other container has CPU\n  shares of 80%, this container will have CPU shares of 40%. Note: Every new\n  container will have 1024 shares of CPU by default. However, this value\n  is shown as 0 if you run the command mentioned in the audit\n  section. Alternatively, 1. Navigate to /sys/fs/cgroup/cpu/system.slice/\n  directory. 2. Check your container instance ID using docker ps. 3. Now,\n  inside the above directory (in step 1), you would have a directory by\n  name docker-<Instance ID>.scope. For example,\n  docker4acae729e8659c6be696ee35b2237cc1fe4edd2672e9186434c5116e1a6fbed6.scope. Navigate\n  to this directory. 4. You will find a file named cpu.shares. Execute cat\n  cpu.shares. This will always give you the CPU share value based on the system.\n  So, even if there is no CPU shares configured using -c or --cpu-shares\n  argument in the docker run command, this file will have a value of 1024. If\n  we set one containers CPU shares to 512 it will receive half of the CPU time\n  compared to the other container. So, take 1024 as 100% and then do quick math\n  to derive the number that you should set for respective CPU shares. For\n  example, use 512 if you want to set 50% and 256 if you want to set 25%.\"\n  tag \"Default Value\": \"By default, all containers on a Docker host share the\n  resources equally. No CPU shares are enforced.\"\n  ref url: 'https://goldmann.pl/blog/2014/09/11/resource-management-in-docker/'\n  ref url: 'https://docs.docker.com/engine/reference/commandline/cli/#run'\n  ref url: 'https://docs.docker.com/v1.8/articles/runmetrics/'\n\n  if docker.containers.running?.ids.empty?\n    impact 0.0\n    describe 'There are no running docker containers, therfore this control is N/A' do\n      skip 'There are no running docker containers, therfore this control is N/A'\n    end\n  end\n\n  if !docker.containers.running?.ids.empty?\n    docker.containers.running?.ids.each do |id|\n      describe docker.object(id) do\n        its(%w{HostConfig CpuShares}) { should_not eq 0 }\n        its(%w{HostConfig CpuShares}) { should_not eq 1024 }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.11.rb",
        "line": 1
      },
      "id": "M-5.11"
    },
    {
      "title": "5.15 Ensure the host's process namespace is not shared (Scored)",
      "desc": "Process ID (PID) namespaces isolate the process ID number space, meaning\n  that processes in different PID namespaces can have the same PID. This is a process level\n  isolation between containers and the host.\n  PID namespace provides separation of processes. The PID Namespace removes\n  the view of the system processes, and allows process ids to be reused including PID 1.\n  If the host's PID namespace is shared with the container, it would basically allow processes\n  within the container to see all of the processes on the host system. This breaks the\n  benefit of process level isolation between the host and the containers. Someone having access\n  to the container can eventually know all the processes running on the host system\n  and can even kill the host system processes from within the container. This can be\n  catastrophic. Hence, do not share the host's process namespace with the containers.",
      "descriptions": {
        "default": "Process ID (PID) namespaces isolate the process ID number space, meaning\n  that processes in different PID namespaces can have the same PID. This is a process level\n  isolation between containers and the host.\n  PID namespace provides separation of processes. The PID Namespace removes\n  the view of the system processes, and allows process ids to be reused including PID 1.\n  If the host's PID namespace is shared with the container, it would basically allow processes\n  within the container to see all of the processes on the host system. This breaks the\n  benefit of process level isolation between the host and the containers. Someone having access\n  to the container can eventually know all the processes running on the host system\n  and can even kill the host system processes from within the container. This can be\n  catastrophic. Hence, do not share the host's process namespace with the containers."
      },
      "impact": 0,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/reference/run/#pid-settings"
        },
        {
          "url": "http://man7.org/linux/man-pages/man7/pid_namespaces.7.html"
        }
      ],
      "tags": {
        "ref": "1.\n  https://docs.docker.com/engine/reference/run/#pid-settings-pid2.\n  http://man7.org/linux/man-pages/man7/pid_namespaces.7.html",
        "severity": "medium",
        "cis_id": "5.15",
        "cis_control": [
          "18",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SI-1",
          "4"
        ],
        "check_text": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: PidMode={{ .HostConfig.PidMode }}' If the above command returns host, it\n  means the host PID namespace is shared with the container else this\n  recommendation is compliant.",
        "fix": "Do not start a container with --pid=host argument. For example,\n  do not start a container as below: docker run --interactive --tty --pid=host\n  centos /bin/bash",
        "Default Value": "By default, all containers have the PID namespace\n  enabled and the host's process namespace is not shared with the containers."
      },
      "code": "control 'M-5.15' do\n  title \"5.15 Ensure the host's process namespace is not shared (Scored)\"\n  desc  \"Process ID (PID) namespaces isolate the process ID number space, meaning\n  that processes in different PID namespaces can have the same PID. This is a process level\n  isolation between containers and the host.\n  PID namespace provides separation of processes. The PID Namespace removes\n  the view of the system processes, and allows process ids to be reused including PID 1.\n  If the host's PID namespace is shared with the container, it would basically allow processes\n  within the container to see all of the processes on the host system. This breaks the\n  benefit of process level isolation between the host and the containers. Someone having access\n  to the container can eventually know all the processes running on the host system\n  and can even kill the host system processes from within the container. This can be\n  catastrophic. Hence, do not share the host's process namespace with the containers.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  https://docs.docker.com/engine/reference/run/#pid-settings-pid2.\n  http://man7.org/linux/man-pages/man7/pid_namespaces.7.html\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.15'\n  tag \"cis_control\": ['18', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SI-1', '4']\n  tag \"check_text\": \"docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: PidMode={{ .HostConfig.PidMode }}' If the above command returns host, it\n  means the host PID namespace is shared with the container else this\n  recommendation is compliant.\"\n  tag \"fix\": \"Do not start a container with --pid=host argument. For example,\n  do not start a container as below: docker run --interactive --tty --pid=host\n  centos /bin/bash\"\n  tag \"Default Value\": \"By default, all containers have the PID namespace\n  enabled and the host's process namespace is not shared with the containers.\"\n  ref url: 'https://docs.docker.com/engine/reference/run/#pid-settings'\n  ref url: 'http://man7.org/linux/man-pages/man7/pid_namespaces.7.html'\n\n  if docker.containers.running?.ids.empty?\n    impact 0.0\n    describe 'There are no running docker containers, therfore this control is N/A' do\n      skip 'There are no running docker containers, therfore this control is N/A'\n    end\n  end\n\n  if !docker.containers.running?.ids.empty?\n    docker.containers.running?.ids.each do |id|\n      describe docker.object(id) do\n        its(%w{HostConfig PidMode}) { should_not eq 'host' }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.15.rb",
        "line": 1
      },
      "id": "M-5.15"
    },
    {
      "title": "7.2 Ensure the minimum number of manager nodes have been created in a swarm (Scored)",
      "desc": "Ensure that the minimum number of required manager nodes is created in a\n  swarm. Manager nodes within a swarm have control over the swarm and change its\n  configuration modifying security parameters. Having excessive manager nodes could render\n  the swarm more susceptible to compromise.\n  If fault tolerance is not required in the manager nodes, a single node\n  should be elected as a manger. If fault tolerance is required then the smallest practical odd\n  number to achieve the appropriate level of tolerance should be configured.",
      "descriptions": {
        "default": "Ensure that the minimum number of required manager nodes is created in a\n  swarm. Manager nodes within a swarm have control over the swarm and change its\n  configuration modifying security parameters. Having excessive manager nodes could render\n  the swarm more susceptible to compromise.\n  If fault tolerance is not required in the manager nodes, a single node\n  should be elected as a manger. If fault tolerance is required then the smallest practical odd\n  number to achieve the appropriate level of tolerance should be configured."
      },
      "impact": 0,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/swarm/manage-nodes/",
          "ref": "manage-nodes"
        },
        {
          "url": "https://docs.docker.com/engine/swarm/admin_guide/#/add-manager-nodes-forfault-tolerance",
          "ref": "add-manager-nodes-forfault-tolerance"
        }
      ],
      "tags": {
        "ref": "1. https://docs.docker.com/engine/swarm/manage-nodes/2.\n  https://docs.docker.com/engine/swarm/admin_guide/#/add-manager-nodes-forfault-tolerance",
        "severity": "medium",
        "cis_id": "7.2",
        "cis_control": [
          "5",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-6",
          "4"
        ],
        "check_text": "Run docker info and verify the number of managers. docker info\n  --format '{{ .Swarm.Managers }}' Alternatively run the below command. docker\n  node ls | grep 'Leader'",
        "fix": "If an excessive number of managers is configured, the excess can\n  be demoted as workers using the following command: docker node demote\n  <ID> Where ID the node ID value of the manager to be demoted.",
        "Default Value": "A single manager is all that is required to start a given cluster."
      },
      "code": "control 'M-7.2' do\n  title '7.2 Ensure the minimum number of manager nodes have been created in a swarm (Scored)'\n  desc  \"Ensure that the minimum number of required manager nodes is created in a\n  swarm. Manager nodes within a swarm have control over the swarm and change its\n  configuration modifying security parameters. Having excessive manager nodes could render\n  the swarm more susceptible to compromise.\n  If fault tolerance is not required in the manager nodes, a single node\n  should be elected as a manger. If fault tolerance is required then the smallest practical odd\n  number to achieve the appropriate level of tolerance should be configured.\n  \"\n  impact 0.5\n  tag \"ref\": \"1. https://docs.docker.com/engine/swarm/manage-nodes/2.\n  https://docs.docker.com/engine/swarm/admin_guide/#/add-manager-nodes-forfault-tolerance\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '7.2'\n  tag \"cis_control\": ['5', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-6', '4']\n  tag \"check_text\": \"Run docker info and verify the number of managers. docker info\n  --format '{{ .Swarm.Managers }}' Alternatively run the below command. docker\n  node ls | grep 'Leader'\"\n  tag \"fix\": \"If an excessive number of managers is configured, the excess can\n  be demoted as workers using the following command: docker node demote\n  <ID> Where ID the node ID value of the manager to be demoted.\"\n  tag \"Default Value\": 'A single manager is all that is required to start a given cluster.'\n  ref 'manage-nodes', url: 'https://docs.docker.com/engine/swarm/manage-nodes/'\n  ref 'add-manager-nodes-forfault-tolerance', url: 'https://docs.docker.com/engine/swarm/admin_guide/#/add-manager-nodes-forfault-tolerance'\n  if attribute('swarm_mode') == 'active'\n    describe docker.info do\n      its('Swarm.Managers') { should cmp <= attribute('swarm_max_manager_nodes') }\n    end\n  else\n    impact 0.0\n    describe 'The docker swarm mode is not being used, therefore this control is N/A' do\n      skip 'The docker swarm mode is not being used, therefore this control is N/A'\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-7.2.rb",
        "line": 1
      },
      "id": "M-7.2"
    },
    {
      "title": "2.6 Ensure TLS authentication for Docker daemon is configured (Scored)",
      "desc": "It is possible to make the Docker daemon to listen on a specific IP and\n  port and any other Unix socket other than default Unix socket. Configure TLS authentication to\n  restrict access to Docker daemon via IP and port.\n  By default, Docker daemon binds to a non-networked Unix socket and runs\n  with root privileges. If you change the default docker daemon binding to a TCP port\n  or any other Unix socket, anyone with access to that port or socket can have full access to\n  Docker daemon and in turn to the host system. Hence, you should not bind the Docker\n  daemon to another IP/port or a Unix socket.\n  If you must expose the Docker daemon via a network socket, configure TLS authentication\n  for the daemon and Docker Swarm APIs (if using). This would restrict the\n  connections to your Docker daemon over the network to a limited number of clients who could\n  successfully authenticate over TLS.",
      "descriptions": {
        "default": "It is possible to make the Docker daemon to listen on a specific IP and\n  port and any other Unix socket other than default Unix socket. Configure TLS authentication to\n  restrict access to Docker daemon via IP and port.\n  By default, Docker daemon binds to a non-networked Unix socket and runs\n  with root privileges. If you change the default docker daemon binding to a TCP port\n  or any other Unix socket, anyone with access to that port or socket can have full access to\n  Docker daemon and in turn to the host system. Hence, you should not bind the Docker\n  daemon to another IP/port or a Unix socket.\n  If you must expose the Docker daemon via a network socket, configure TLS authentication\n  for the daemon and Docker Swarm APIs (if using). This would restrict the\n  connections to your Docker daemon over the network to a limited number of clients who could\n  successfully authenticate over TLS."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/security/https/",
          "ref": "Protect Docker deamon socket"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "2.6",
        "cis_control": [
          "9.1",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "CM-7(1)",
          "4"
        ],
        "check_text": "ps -ef | grep dockerd Ensure that the below parameters are\n  present: --tlsverify --tlscacert --tlscert --tlskey ",
        "fix": "Follow the steps mentioned in the Docker documentation or other\n  references.",
        "Default Value": "By default, TLS authentication is not configured."
      },
      "code": "control 'M-2.6' do\n  title '2.6 Ensure TLS authentication for Docker daemon is configured (Scored)'\n  desc  \"It is possible to make the Docker daemon to listen on a specific IP and\n  port and any other Unix socket other than default Unix socket. Configure TLS authentication to\n  restrict access to Docker daemon via IP and port.\n  By default, Docker daemon binds to a non-networked Unix socket and runs\n  with root privileges. If you change the default docker daemon binding to a TCP port\n  or any other Unix socket, anyone with access to that port or socket can have full access to\n  Docker daemon and in turn to the host system. Hence, you should not bind the Docker\n  daemon to another IP/port or a Unix socket.\n  If you must expose the Docker daemon via a network socket, configure TLS authentication\n  for the daemon and Docker Swarm APIs (if using). This would restrict the\n  connections to your Docker daemon over the network to a limited number of clients who could\n  successfully authenticate over TLS.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '2.6'\n  tag \"cis_control\": ['9.1', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['CM-7(1)', '4']\n  tag \"check_text\": \"ps -ef | grep dockerd Ensure that the below parameters are\n  present: --tlsverify --tlscacert --tlscert --tlskey \"\n  tag \"fix\": \"Follow the steps mentioned in the Docker documentation or other\n  references.\"\n  tag \"Default Value\": 'By default, TLS authentication is not configured.'\n  ref 'Protect Docker deamon socket', url: 'https://docs.docker.com/engine/security/https/'\n\n  describe json('/etc/docker/daemon.json') do\n    its(['tls']) { should eq(true) }\n    its(['tlsverify']) { should eq(true) }\n    its(['tlscacert']) { should eq attribute('daemon_tlscacert') }\n    its(['tlscert']) { should eq attribute('daemon_tlscert') }\n    its(['tlskey']) { should eq attribute('daemon_tlskey') }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-2.6.rb",
        "line": 1
      },
      "id": "M-2.6"
    },
    {
      "title": "4.3 Ensure unnecessary packages are not installed in the container (Not Scored)",
      "desc": "Containers tend to be minimal and slim down versions of the Operating\n  System. Do not install anything that does not justify the purpose of container.\n  Bloating containers with unnecessary software could possibly increase the\n  attack surface of the container. This also voids the concept of minimal and slim down\n  versions of container images. Hence, do not install anything else apart from what is\n  truly needed for the purpose of the container.",
      "descriptions": {
        "default": "Containers tend to be minimal and slim down versions of the Operating\n  System. Do not install anything that does not justify the purpose of container.\n  Bloating containers with unnecessary software could possibly increase the\n  attack surface of the container. This also voids the concept of minimal and slim down\n  versions of container images. Hence, do not install anything else apart from what is\n  truly needed for the purpose of the container."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/userguide/containers/dockerimages/"
        },
        {
          "url": "http://www.livewyer.com/blog/2015/02/24/slimming-down-your-docker-containers-alpine-linux"
        },
        {
          "url": "https://github.com/progrium/busybox"
        }
      ],
      "tags": {
        "ref": "1. https://docs.docker.com/userguide/dockerimages/2.\n  http://www.livewyer.com/blog/2015/02/24/slimming-down-your-dockercontainers-alpine-linux3.\n  https://github.com/progrium/busybox",
        "severity": "medium",
        "cis_id": "4.3",
        "cis_control": [
          "18",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SI-1",
          "4"
        ],
        "check_text": "Step 1: List all the running instances of containers by\n  executing below command: docker ps --quiet Step 2: For each container\n  instance, execute the below or equivalent command: docker exec $INSTANCE_ID\n  rpm -qa The above command would list the packages installed on the container.\n  Review the list and ensure that it is legitimate.",
        "fix": "At the outset, do not install anything on the container that does\n  not justify the purpose. If the image had some packages that your container\n  does not use, uninstall them. Consider using a minimal base image rather than\n  the standard Redhat/Centos/Debian images if you can. Some of the options\n  include BusyBox and Alpine. Not only does this trim your image size from\n  >150Mb to ~20 Mb, there are also fewer tools and paths to escalate privileges.\n  You can even remove the package installer as a final hardening measure for\n  leaf/production containers.",
        "Default Value": "Not Applicable."
      },
      "code": "control 'M-4.3' do\n  title '4.3 Ensure unnecessary packages are not installed in the container (Not Scored)'\n  desc  \"Containers tend to be minimal and slim down versions of the Operating\n  System. Do not install anything that does not justify the purpose of container.\n  Bloating containers with unnecessary software could possibly increase the\n  attack surface of the container. This also voids the concept of minimal and slim down\n  versions of container images. Hence, do not install anything else apart from what is\n  truly needed for the purpose of the container.\n  \"\n  impact 0.5\n  tag \"ref\": \"1. https://docs.docker.com/userguide/dockerimages/2.\n  http://www.livewyer.com/blog/2015/02/24/slimming-down-your-dockercontainers-alpine-linux3.\n  https://github.com/progrium/busybox\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '4.3'\n  tag \"cis_control\": ['18', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SI-1', '4']\n  tag \"check_text\": \"Step 1: List all the running instances of containers by\n  executing below command: docker ps --quiet Step 2: For each container\n  instance, execute the below or equivalent command: docker exec $INSTANCE_ID\n  rpm -qa The above command would list the packages installed on the container.\n  Review the list and ensure that it is legitimate.\"\n  tag \"fix\": \"At the outset, do not install anything on the container that does\n  not justify the purpose. If the image had some packages that your container\n  does not use, uninstall them. Consider using a minimal base image rather than\n  the standard Redhat/Centos/Debian images if you can. Some of the options\n  include BusyBox and Alpine. Not only does this trim your image size from\n  >150Mb to ~20 Mb, there are also fewer tools and paths to escalate privileges.\n  You can even remove the package installer as a final hardening measure for\n  leaf/production containers.\"\n  tag \"Default Value\": 'Not Applicable.'\n  ref url: 'https://docs.docker.com/engine/userguide/containers/dockerimages/'\n  ref url: 'http://www.livewyer.com/blog/2015/02/24/slimming-down-your-docker-containers-alpine-linux'\n  ref url: 'https://github.com/progrium/busybox'\n  describe 'A manual review is required to ensure unnecessary packages are not installed in the container' do\n    skip 'A manual review is required to ensure unnecessary packages are not installed in the container'\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-4.3.rb",
        "line": 1
      },
      "id": "M-4.3"
    },
    {
      "title": "5.30 Ensure the host's user namespaces is not shared (Scored)",
      "desc": "Do not share the host's user namespaces with the containers.\n  User namespaces ensure that a root process inside the container will be\n  mapped to a nonroot process outside the container. Sharing the user namespaces\n  of the host with the container thus does not isolate users on the host with users on the\n  containers.",
      "descriptions": {
        "default": "Do not share the host's user namespaces with the containers.\n  User namespaces ensure that a root process inside the container will be\n  mapped to a nonroot process outside the container. Sharing the user namespaces\n  of the host with the container thus does not isolate users on the host with users on the\n  containers."
      },
      "impact": 0,
      "refs": [],
      "tags": {
        "ref": "1. https://docs.docker.com/engine/security/userns-remap/2.\n  https://docs.docker.com/engine/reference/commandline/run/#options3.\n  https://github.com/docker/docker/pull/126484.\n  https://events.linuxfoundation.org/sites/events/files/slides/User%20Namespaces%20-%20ContainerCon%202015%20-%2016-9-final_0.pdf",
        "severity": "medium",
        "cis_id": "5.30",
        "cis_control": [
          "12",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SC-7",
          "4"
        ],
        "check_text": "Run the below command and ensure that it does not return any\n  value for UsernsMode. If it returns a value of host, it means the host user\n  namespace is shared with the containers. docker ps --quiet --all | xargs\n  docker inspect --format '{{ .Id }}: UsernsMode={{ .HostConfig.UsernsMode }}'",
        "fix": "Do not share user namespaces between host and containers. For\n  example, do not run a container as below: docker run --rm -it --userns=host\n  ubuntu bash",
        "Default Value": "By default, the host user namespace is shared with the\n  containers until user namespace support is enabled."
      },
      "code": "control 'M-5.30' do\n  title \"5.30 Ensure the host's user namespaces is not shared (Scored)\"\n  desc  \"Do not share the host's user namespaces with the containers.\n  User namespaces ensure that a root process inside the container will be\n  mapped to a nonroot process outside the container. Sharing the user namespaces\n  of the host with the container thus does not isolate users on the host with users on the\n  containers.\n  \"\n  impact 0.5\n  tag \"ref\": \"1. https://docs.docker.com/engine/security/userns-remap/2.\n  https://docs.docker.com/engine/reference/commandline/run/#options3.\n  https://github.com/docker/docker/pull/126484.\n  https://events.linuxfoundation.org/sites/events/files/slides/User%20Namespaces%20-%20ContainerCon%202015%20-%2016-9-final_0.pdf\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.30'\n  tag \"cis_control\": ['12', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SC-7', '4']\n  tag \"check_text\": \"Run the below command and ensure that it does not return any\n  value for UsernsMode. If it returns a value of host, it means the host user\n  namespace is shared with the containers. docker ps --quiet --all | xargs\n  docker inspect --format '{{ .Id }}: UsernsMode={{ .HostConfig.UsernsMode }}'\"\n  tag \"fix\": \"Do not share user namespaces between host and containers. For\n  example, do not run a container as below: docker run --rm -it --userns=host\n  ubuntu bash\"\n  tag \"Default Value\": \"By default, the host user namespace is shared with the\n  containers until user namespace support is enabled.\"\n\n  if docker.containers.running?.ids.empty?\n    impact 0.0\n    describe 'There are no running docker containers, therfore this control is N/A' do\n      skip 'There are no running docker containers, therfore this control is N/A'\n    end\n  end\n\n  if !docker.containers.running?.ids.empty?\n    docker.containers.running?.ids.each do |id|\n      describe docker.object(id) do\n        its('HostConfig.UsernsMode') { should eq '' }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.30.rb",
        "line": 1
      },
      "id": "M-5.30"
    },
    {
      "title": "5.18 Ensure the default ulimit is overwritten at runtime, only if needed (Not Scored)",
      "desc": "The default ulimit is set at the Docker daemon level. However, you may\n  override the default ulimit setting, if needed, during container runtime.\n  The ulimit provides control over the resources available to the shell and to\n  processes started by it. Setting system resource limits judiciously saves you from many\n  disasters such as a fork bomb. Sometimes, even friendly users and legitimate processes can\n  overuse system resources and in-turn can make the system unusable.\n  The default ulimit set at the Docker daemon level should be honored. If the\n  default ulimit settings are not appropriate for a particular container instance, you may\n  override them as an exception. But, do not make this a practice. If most of the container\n  instances are overriding the default ulimit settings, consider changing the default ulimit\n  settings to something that is appropriate for your needs.",
      "descriptions": {
        "default": "The default ulimit is set at the Docker daemon level. However, you may\n  override the default ulimit setting, if needed, during container runtime.\n  The ulimit provides control over the resources available to the shell and to\n  processes started by it. Setting system resource limits judiciously saves you from many\n  disasters such as a fork bomb. Sometimes, even friendly users and legitimate processes can\n  overuse system resources and in-turn can make the system unusable.\n  The default ulimit set at the Docker daemon level should be honored. If the\n  default ulimit settings are not appropriate for a particular container instance, you may\n  override them as an exception. But, do not make this a practice. If most of the container\n  instances are overriding the default ulimit settings, consider changing the default ulimit\n  settings to something that is appropriate for your needs."
      },
      "impact": 0,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/reference/commandline/cli/#setting-ulimits-in-a-container"
        }
      ],
      "tags": {
        "ref": "1.\n  https://docs.docker.com/engine/reference/commandline/run/#set-ulimits-incontainer-ulimit2.\n  http://www.oreilly.com/webops-perf/free/files/docker-security.pdf",
        "severity": "medium",
        "cis_id": "5.18",
        "cis_control": [
          "18",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SI-1",
          "4"
        ],
        "check_text": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}:Ulimits={{ .HostConfig.Ulimits }}' The above command should return\n  Ulimits=<no value> for each container instance until and unless there is an\n  exception and a need to override the default ulimit settings.",
        "fix": "Only override the default ulimit settings if needed. For\n  example, to override default ulimit settings start a container as\n  below: docker run --ulimit nofile=1024:1024 --interactive --tty centos\n  /bin/bash",
        "Default Value": "Container instances inherit the default ulimit settings\n  set at the Docker daemon level."
      },
      "code": "control 'M-5.18' do\n  title '5.18 Ensure the default ulimit is overwritten at runtime, only if needed (Not Scored)'\n  desc  \"The default ulimit is set at the Docker daemon level. However, you may\n  override the default ulimit setting, if needed, during container runtime.\n  The ulimit provides control over the resources available to the shell and to\n  processes started by it. Setting system resource limits judiciously saves you from many\n  disasters such as a fork bomb. Sometimes, even friendly users and legitimate processes can\n  overuse system resources and in-turn can make the system unusable.\n  The default ulimit set at the Docker daemon level should be honored. If the\n  default ulimit settings are not appropriate for a particular container instance, you may\n  override them as an exception. But, do not make this a practice. If most of the container\n  instances are overriding the default ulimit settings, consider changing the default ulimit\n  settings to something that is appropriate for your needs.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  https://docs.docker.com/engine/reference/commandline/run/#set-ulimits-incontainer-ulimit2.\n  http://www.oreilly.com/webops-perf/free/files/docker-security.pdf\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.18'\n  tag \"cis_control\": ['18', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SI-1', '4']\n  tag \"check_text\": \"docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}:Ulimits={{ .HostConfig.Ulimits }}' The above command should return\n  Ulimits=<no value> for each container instance until and unless there is an\n  exception and a need to override the default ulimit settings.\"\n  tag \"fix\": \"Only override the default ulimit settings if needed. For\n  example, to override default ulimit settings start a container as\n  below: docker run --ulimit nofile=1024:1024 --interactive --tty centos\n  /bin/bash\"\n  tag \"Default Value\": \"Container instances inherit the default ulimit settings\n  set at the Docker daemon level.\"\n  ref url: 'https://docs.docker.com/engine/reference/commandline/cli/#setting-ulimits-in-a-container'\n\n  if docker.containers.running?.ids.empty?\n    impact 0.0\n    describe 'There are no running docker containers, therfore this control is N/A' do\n      skip 'There are no running docker containers, therfore this control is N/A'\n    end\n  end\n\n  if !docker.containers.running?.ids.empty?\n    docker.containers.running?.ids.each do |id|\n      describe docker.object(id) do\n        its(%w{HostConfig Ulimits}) { should eq nil }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.18.rb",
        "line": 1
      },
      "id": "M-5.18"
    },
    {
      "title": "3.6 Ensure that /etc/docker directory permissions are set to 755 or more restrictive (Scored)",
      "desc": "Verify that the /etc/docker directory permissions are correctly set to 755 or more restrictive.\n  The /etc/docker directory contains certificates and keys in addition to various\n  sensitive files. Hence, it should only be writable by root to maintain the integrity of the directory.",
      "descriptions": {
        "default": "Verify that the /etc/docker directory permissions are correctly set to 755 or more restrictive.\n  The /etc/docker directory contains certificates and keys in addition to various\n  sensitive files. Hence, it should only be writable by root to maintain the integrity of the directory."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/security/certificates/"
        }
      ],
      "tags": {
        "ref": "1. https://docs.docker.com/engine/security/https/",
        "severity": "medium",
        "cis_id": "3.6",
        "cis_control": [
          "14.4",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-3 (3)",
          "4"
        ],
        "check_text": "Execute the below command to verify that the directory has\n  permissions of 755 or more restrictive: stat -c %a /etc/docker",
        "fix": "chmod 755 /etc/docker This would set the permissions for the\n  directory to 755.",
        "Default Value": "By default, the permissions for this directory are\n  correctly set to 755."
      },
      "code": "control 'M-3.6' do\n  title '3.6 Ensure that /etc/docker directory permissions are set to 755 or more restrictive (Scored)'\n  desc  \"Verify that the /etc/docker directory permissions are correctly set to 755 or more restrictive.\n  The /etc/docker directory contains certificates and keys in addition to various\n  sensitive files. Hence, it should only be writable by root to maintain the integrity of the directory.\n  \"\n  impact 0.5\n  tag \"ref\": '1. https://docs.docker.com/engine/security/https/'\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '3.6'\n  tag \"cis_control\": ['14.4', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-3 (3)', '4']\n  tag \"check_text\": \"Execute the below command to verify that the directory has\n  permissions of 755 or more restrictive: stat -c %a /etc/docker\"\n  tag \"fix\": \"chmod 755 /etc/docker This would set the permissions for the\n  directory to 755.\"\n  tag \"Default Value\": \"By default, the permissions for this directory are\n  correctly set to 755.\"\n  ref url: 'https://docs.docker.com/engine/security/certificates/'\n\n  describe file('/etc/docker') do\n    it { should exist }\n    it { should be_directory }\n    it { should be_readable.by('owner') }\n    it { should be_writable.by('owner') }\n    it { should be_executable.by('owner') }\n    it { should be_readable.by('group') }\n    it { should_not be_writable.by('group') }\n    it { should be_executable.by('group') }\n    it { should be_readable.by('other') }\n    it { should_not be_writable.by('other') }\n    it { should be_executable.by('other') }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-3.6.rb",
        "line": 1
      },
      "id": "M-3.6"
    },
    {
      "title": "1.2 Ensure the container host has been Hardened (Not Scored)",
      "desc": "Containers run on a Linux host. A container host can run one or more\ncontainers. It is of utmost importance to harden the host to mitigate host security misconfiguration.\nYou should follow infrastructure security best practices and harden your host OS. Keeping\nthe host system hardened would ensure that the host vulnerabilities are\nmitigated. Not hardening the host system could lead to security exposures and breaches.",
      "descriptions": {
        "default": "Containers run on a Linux host. A container host can run one or more\ncontainers. It is of utmost importance to harden the host to mitigate host security misconfiguration.\nYou should follow infrastructure security best practices and harden your host OS. Keeping\nthe host system hardened would ensure that the host vulnerabilities are\nmitigated. Not hardening the host system could lead to security exposures and breaches."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "http://dev-sec.io",
          "ref": "Hardening Framework dev-sec.io"
        },
        {
          "url": "https://docs.docker.com/engine/security/security/",
          "ref": "Docker security article"
        },
        {
          "url": "https://benchmarks.cisecurity.org/downloads/multiform/index.cfm",
          "ref": "CIS Benchmarks"
        },
        {
          "url": "https://docs.docker.com/engine/security/security/",
          "ref": "security"
        },
        {
          "url": "https://learn.cisecurity.org/benchmarks",
          "ref": "benchmarks"
        },
        {
          "url": "https://docs.docker.com/engine/security/security/#other-kernel-security-features",
          "ref": "other-kernel-security-features"
        },
        {
          "url": "https://grsecurity.net/",
          "ref": "grsecurity"
        },
        {
          "url": "https://en.wikibooks.org/wiki/Grsecurity",
          "ref": "grsecurity Wiki"
        },
        {
          "url": "https://pax.grsecurity.net/",
          "ref": "Homepage of The PaX Team"
        },
        {
          "url": "http://en.wikipedia.org/wiki/PaX",
          "ref": "PAX Wiki"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "1.2",
        "cis_control": [
          "3",
          "6.1"
        ],
        "cis_level": "Level 1 - Linux Host OS",
        "nist": [
          "CM-6",
          "4"
        ],
        "check_text": "Ensure that the host specific security guidelines are followed.\n  Ask the system administrators which security benchmark the current host\n  system complies with. Ensure that the host systems actually complies with that\n  host specific security benchmark.",
        "fix": "You may consider various CIS Security Benchmarks for your\n  container host. If you have other security guidelines or regulatory\n  requirements to adhere to, please follow them as suitable in your\n  environment. Additionally, you can run a kernel with grsecurity and PaX. This\n  would add many safety checks, both at compile-time and run-time. It is also\n  designed to defeat many exploits and has powerful security features. These\n  features do not require Docker-specific configuration, since those security\n  features apply system-wide, independent of containers.",
        "Default Value": "By default, host has factory settings. It is not\n  hardened."
      },
      "code": "control 'M-1.2' do\n  title '1.2 Ensure the container host has been Hardened (Not Scored)'\n  desc  \"\n  Containers run on a Linux host. A container host can run one or more\n  containers. It is of utmost importance to harden the host to mitigate host security misconfiguration.\n  You should follow infrastructure security best practices and harden your host OS. Keeping\n  the host system hardened would ensure that the host vulnerabilities are\n  mitigated. Not hardening the host system could lead to security exposures and breaches.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '1.2'\n  tag \"cis_control\": ['3', '6.1']\n  tag \"cis_level\": 'Level 1 - Linux Host OS'\n  tag \"nist\": ['CM-6', '4']\n  tag \"check_text\": \"Ensure that the host specific security guidelines are followed.\n  Ask the system administrators which security benchmark the current host\n  system complies with. Ensure that the host systems actually complies with that\n  host specific security benchmark.\"\n  tag \"fix\": \"You may consider various CIS Security Benchmarks for your\n  container host. If you have other security guidelines or regulatory\n  requirements to adhere to, please follow them as suitable in your\n  environment. Additionally, you can run a kernel with grsecurity and PaX. This\n  would add many safety checks, both at compile-time and run-time. It is also\n  designed to defeat many exploits and has powerful security features. These\n  features do not require Docker-specific configuration, since those security\n  features apply system-wide, independent of containers.\"\n  tag \"Default Value\": \"By default, host has factory settings. It is not\n  hardened.\"\n  ref 'Hardening Framework dev-sec.io', url: 'http://dev-sec.io'\n  ref 'Docker security article', url: 'https://docs.docker.com/engine/security/security/'\n  ref 'CIS Benchmarks', url: 'https://benchmarks.cisecurity.org/downloads/multiform/index.cfm'\n  ref 'security', url: 'https://docs.docker.com/engine/security/security/'\n  ref 'benchmarks', url: 'https://learn.cisecurity.org/benchmarks'\n  ref 'other-kernel-security-features', url: 'https://docs.docker.com/engine/security/security/#other-kernel-security-features'\n  ref 'grsecurity', url: 'https://grsecurity.net/'\n  ref 'grsecurity Wiki', url: 'https://en.wikibooks.org/wiki/Grsecurity'\n  ref 'Homepage of The PaX Team', url: 'https://pax.grsecurity.net/'\n  ref 'PAX Wiki', url: 'http://en.wikipedia.org/wiki/PaX'\n  describe 'A manual review is required to ensure the container host has been hardened' do\n    skip 'A manual review is required to ensure the container host has been hardened'\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-1.2.rb",
        "line": 1
      },
      "id": "M-1.2"
    },
    {
      "title": "4.2 Ensure that containers use trusted base images (Not Scored)",
      "desc": "Ensure that the container image is written either from scratch or is based\n  on another established and trusted base image downloaded over a secure channel.\n  Official repositories are Docker images curated and optimized by the Docker\n  community or the vendor. There could be other potentially unsafe public repositories.\n  Caution should be exercised when obtaining container images from Docker and third parties to\n  how they will be used for your organization's data.",
      "descriptions": {
        "default": "Ensure that the container image is written either from scratch or is based\n  on another established and trusted base image downloaded over a secure channel.\n  Official repositories are Docker images curated and optimized by the Docker\n  community or the vendor. There could be other potentially unsafe public repositories.\n  Caution should be exercised when obtaining container images from Docker and third parties to\n  how they will be used for your organization's data."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://titanous.com/posts/docker-insecurity"
        },
        {
          "url": "https://hub.docker.com/"
        },
        {
          "url": "https://blog.docker.com/2014/10/docker-1-3-signed-images-process-injection-security-options-mac-shared-directories/"
        },
        {
          "url": "https://github.com/docker/docker/issues/8093"
        },
        {
          "url": "https://docs.docker.com/engine/reference/commandline/cli/#pull"
        },
        {
          "url": "https://github.com/docker/docker/pull/11109"
        },
        {
          "url": "https://blog.docker.com/2015/11/docker-trusted-registry-1-4/"
        }
      ],
      "tags": {
        "ref": "1. https://titanous.com/posts/docker-insecurity2.\n  https://registry.hub.docker.com/3.\n  http://blog.docker.com/2014/10/docker-1-3-signed-images-process-injectionsecurity-options-mac-shared-directories/4.\n  https://github.com/docker/docker/issues/80935.\n  https://docs.docker.com/engine/reference/commandline/pull/6.\n  https://github.com/docker/docker/pull/111097.\n  https://blog.docker.com/2015/11/docker-trusted-registry-1-4/",
        "severity": "medium",
        "cis_id": "4.2",
        "cis_control": [
          "3",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "CM-6",
          "4"
        ],
        "check_text": "Step 1 - Inspect the Docker host for Docker images used by\n  executing the below command: docker images This would list all the container\n  images that are currently available for use on the Docker host. Interview the\n  system administrator and obtain a proof of evidence that the list of images\n  was obtained from trusted source over a secure channel or from a trusted,\n  secure private Docker registry. Step 2 - For each Docker image found on the\n  Docker host, inspect the image for how it was built to verify if from trusted\n  sources and hardened configuration: docker history <imageName>",
        "fix": "Configure and use Docker Content trust. Inspect Docker\n  image history to evaluate their risk to operate on your network. Scan Docker\n  images for vulnerabilities in their dependencies and configurations they will\n  impose upon your network.",
        "Default Value": "Not Applicable."
      },
      "code": "control 'M-4.2' do\n  title '4.2 Ensure that containers use trusted base images (Not Scored)'\n  desc  \"Ensure that the container image is written either from scratch or is based\n  on another established and trusted base image downloaded over a secure channel.\n  Official repositories are Docker images curated and optimized by the Docker\n  community or the vendor. There could be other potentially unsafe public repositories.\n  Caution should be exercised when obtaining container images from Docker and third parties to\n  how they will be used for your organization's data.\n  \"\n  impact 0.5\n  tag \"ref\": \"1. https://titanous.com/posts/docker-insecurity2.\n  https://registry.hub.docker.com/3.\n  http://blog.docker.com/2014/10/docker-1-3-signed-images-process-injectionsecurity-options-mac-shared-directories/4.\n  https://github.com/docker/docker/issues/80935.\n  https://docs.docker.com/engine/reference/commandline/pull/6.\n  https://github.com/docker/docker/pull/111097.\n  https://blog.docker.com/2015/11/docker-trusted-registry-1-4/\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '4.2'\n  tag \"cis_control\": ['3', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['CM-6', '4']\n  tag \"check_text\": \"Step 1 - Inspect the Docker host for Docker images used by\n  executing the below command: docker images This would list all the container\n  images that are currently available for use on the Docker host. Interview the\n  system administrator and obtain a proof of evidence that the list of images\n  was obtained from trusted source over a secure channel or from a trusted,\n  secure private Docker registry. Step 2 - For each Docker image found on the\n  Docker host, inspect the image for how it was built to verify if from trusted\n  sources and hardened configuration: docker history <imageName>\"\n  tag \"fix\": \"Configure and use Docker Content trust. Inspect Docker\n  image history to evaluate their risk to operate on your network. Scan Docker\n  images for vulnerabilities in their dependencies and configurations they will\n  impose upon your network.\"\n  tag \"Default Value\": 'Not Applicable.'\n  ref url: 'https://titanous.com/posts/docker-insecurity'\n  ref url: 'https://hub.docker.com/'\n  ref url: 'https://blog.docker.com/2014/10/docker-1-3-signed-images-process-injection-security-options-mac-shared-directories/'\n  ref url: 'https://github.com/docker/docker/issues/8093'\n  ref url: 'https://docs.docker.com/engine/reference/commandline/cli/#pull'\n  ref url: 'https://github.com/docker/docker/pull/11109'\n  ref url: 'https://blog.docker.com/2015/11/docker-trusted-registry-1-4/'\n  describe 'A manual review is required to ensure hat containers use trusted base images' do\n    skip 'A manual review is required to ensure hat containers use trusted base images'\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-4.2.rb",
        "line": 1
      },
      "id": "M-4.2"
    },
    {
      "title": "3.8 Ensure that registry certificate file permissions are set to 444 or more restrictive (Scored)",
      "desc": "Verify that all the registry certificate files (usually found under /etc/docker/certs.d/<registry-name> directory) have permissions of 444 or\n  more restrictive. The /etc/docker/certs.d/<registry-name> directory contains Docker registry\n  certificates. These certificate files must have permissions of 444 to maintain the\n  integrity of the certificates.",
      "descriptions": {
        "default": "Verify that all the registry certificate files (usually found under /etc/docker/certs.d/<registry-name> directory) have permissions of 444 or\n  more restrictive. The /etc/docker/certs.d/<registry-name> directory contains Docker registry\n  certificates. These certificate files must have permissions of 444 to maintain the\n  integrity of the certificates."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/security/certificates/"
        },
        {
          "url": "docs.docker.com/reference/commandline/cli/#insecure-registries"
        }
      ],
      "tags": {
        "ref": "1. https://docs.docker.com/registry/insecure/",
        "severity": "medium",
        "cis_id": "3.8",
        "cis_control": [
          "14.4",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-3 (3)",
          "4"
        ],
        "check_text": "Execute the below command to verify that the registry\n  certificate files have permissions of 444 or more restrictive: stat -c %a\n  /etc/docker/certs.d/<registry-name>/*",
        "fix": "chmod 444 /etc/docker/certs.d/<registry-name>/*This would set\n  the permissions for registry certificate files to 444.",
        "Default Value": "By default, the permissions for registry certificate\n  files might not be 444. The default file permissions are governed by the\n  system or user specific umaskvalues."
      },
      "code": "control 'M-3.8' do\n  title '3.8 Ensure that registry certificate file permissions are set to 444 or more restrictive (Scored)'\n  desc  \"Verify that all the registry certificate files (usually found under /etc/docker/certs.d/<registry-name> directory) have permissions of 444 or\n  more restrictive. The /etc/docker/certs.d/<registry-name> directory contains Docker registry\n  certificates. These certificate files must have permissions of 444 to maintain the\n  integrity of the certificates.\n  \"\n  impact 0.5\n  tag \"ref\": '1. https://docs.docker.com/registry/insecure/'\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '3.8'\n  tag \"cis_control\": ['14.4', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-3 (3)', '4']\n  tag \"check_text\": \"Execute the below command to verify that the registry\n  certificate files have permissions of 444 or more restrictive: stat -c %a\n  /etc/docker/certs.d/<registry-name>/*\"\n  tag \"fix\": \"chmod 444 /etc/docker/certs.d/<registry-name>/*This would set\n  the permissions for registry certificate files to 444.\"\n  tag \"Default Value\": \"By default, the permissions for registry certificate\n  files might not be 444. The default file permissions are governed by the\n  system or user specific umaskvalues.\"\n  ref url: 'https://docs.docker.com/engine/security/certificates/'\n  ref url: 'docs.docker.com/reference/commandline/cli/#insecure-registries'\n\n  describe file(attribute('registry_ca_file')) do\n    it { should exist }\n    it { should be_file }\n    it { should be_readable }\n    it { should_not be_executable }\n    it { should_not be_writable }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-3.8.rb",
        "line": 1
      },
      "id": "M-3.8"
    },
    {
      "title": "2.17 Ensure experimental features are avoided in production (Scored)",
      "desc": "Avoid experimental features in production.\n  Experimental is now a runtime docker daemon flag instead of a separate\n  build. Passing -experimental as a runtime flag to the docker daemon, activates experimental features.\n  Experimental is now considered a stable release, but with a couple of features which might\n  not have tested and guaranteed API stability.",
      "descriptions": {
        "default": "Avoid experimental features in production.\n  Experimental is now a runtime docker daemon flag instead of a separate\n  build. Passing -experimental as a runtime flag to the docker daemon, activates experimental features.\n  Experimental is now considered a stable release, but with a couple of features which might\n  not have tested and guaranteed API stability."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "ref": "1.\n  https://docs.docker.com/edge/engine/reference/commandline/dockerd/#options\n",
        "severity": "medium",
        "cis_id": "2.17",
        "cis_control": [
          "18",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SI-1",
          "4"
        ],
        "check_text": "Run the below command and ensure that the Experimental property\n  is set to false in the Server section docker version --format '{{\n  .Server.Experimental }}'",
        "fix": "Do not pass --experimental as a runtime parameter to the docker daemon.",
        "Default Value": "By default, experimental features are not activated on\n  the docker daemon."
      },
      "code": "control 'M-2.17' do\n  title '2.17 Ensure experimental features are avoided in production (Scored)'\n  desc  \"Avoid experimental features in production.\n  Experimental is now a runtime docker daemon flag instead of a separate\n  build. Passing -experimental as a runtime flag to the docker daemon, activates experimental features.\n  Experimental is now considered a stable release, but with a couple of features which might\n  not have tested and guaranteed API stability.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  https://docs.docker.com/edge/engine/reference/commandline/dockerd/#options\\n\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '2.17'\n  tag \"cis_control\": ['18', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SI-1', '4']\n  tag \"check_text\": \"Run the below command and ensure that the Experimental property\n  is set to false in the Server section docker version --format '{{\n  .Server.Experimental }}'\"\n  tag \"fix\": 'Do not pass --experimental as a runtime parameter to the docker daemon.'\n  tag \"Default Value\": \"By default, experimental features are not activated on\n  the docker daemon.\"\n  experimental_parameter = command(\"docker version --format '{{.Server.Experimental }}'\").stdout.strip\n\n  describe 'The docker experimental parameter' do\n    subject { experimental_parameter }\n    it { should_not cmp 'false' }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-2.17.rb",
        "line": 1
      },
      "id": "M-2.17"
    },
    {
      "title": "5.2 Ensure SELinux security options are set, if applicable (Scored)",
      "desc": "SELinux is an effective and easy-to-use Linux application security system.\n  It is available on quite a few Linux distributions by default such as Red Hat and Fedora.\n  SELinux provides a Mandatory Access Control (MAC) system that greatly augments the\n  default Discretionary Access Control (DAC) model. You can thus add an extra\n  layer of safety by enabling SELinux on your Linux host, if applicable.",
      "descriptions": {
        "default": "SELinux is an effective and easy-to-use Linux application security system.\n  It is available on quite a few Linux distributions by default such as Red Hat and Fedora.\n  SELinux provides a Mandatory Access Control (MAC) system that greatly augments the\n  default Discretionary Access Control (DAC) model. You can thus add an extra\n  layer of safety by enabling SELinux on your Linux host, if applicable."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://github.com/docker/docker/issues/22826",
          "ref": "Bug: Wrong SELinux label for devmapper device"
        },
        {
          "url": "https://bugzilla.redhat.com/show_bug.cgi?id=1312665",
          "ref": "Bug: selinux break docker user namespace"
        },
        {
          "url": "https://docs.docker.com/engine/security/security/"
        },
        {
          "url": "https://docs.docker.com/engine/reference/run/#security-configuration"
        },
        {
          "url": "https://docs.fedoraproject.org/en-US/Fedora/13/html/Security-Enhanced_Linux/"
        }
      ],
      "tags": {
        "ref": "1.2.3.4. https://docs.docker.com/engine/security/security/#other-kernel-security-features https://docs.docker.com/engine/reference/run/#security-configuration http://docs.fedoraproject.org/en-US/Fedora/13/html/Security-Enhanced_Linux/ https://access.redhat.com/documentation/enus/red_hat_enterprise_linux_atomic_host/7/html/container_security_guide/docker_selinux_security_policy",
        "severity": "medium",
        "cis_id": "5.2",
        "cis_control": [
          "14.4",
          "6.1"
        ],
        "cis_level": "Level 2 - Docker",
        "nist": [
          "AC-3 (3)",
          "4"
        ],
        "check_text": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: SecurityOpt={{ .HostConfig.SecurityOpt }}' The above command should\n  return all the security options currently configured for the containers.",
        "fix": "If SELinux is applicable for your Linux OS, use it. You may have\n  to follow below set of steps: Set the SELinux State. Set the\n  SELinux Policy. Create or import a SELinux policy template for Docker\n  containers. Start Docker in daemon mode with SELinux enabled. For\n  example, docker daemon --selinux-enabled. Start your Docker container using\n  the security options. For example, docker run --interactive --tty\n  --security-opt label=level:TopSecret centos /bin/bash",
        "Default Value": "By default, no SELinux security options are applied on\n  containers."
      },
      "code": "control 'M-5.2' do\n  title '5.2 Ensure SELinux security options are set, if applicable (Scored)'\n  desc  \"SELinux is an effective and easy-to-use Linux application security system.\n  It is available on quite a few Linux distributions by default such as Red Hat and Fedora.\n  SELinux provides a Mandatory Access Control (MAC) system that greatly augments the\n  default Discretionary Access Control (DAC) model. You can thus add an extra\n  layer of safety by enabling SELinux on your Linux host, if applicable.\n  \"\n  impact 0.5\n  tag \"ref\":\n  '1.2.3.4. https://docs.docker.com/engine/security/security/#other-kernel-security-features https://docs.docker.com/engine/reference/run/#security-configuration http://docs.fedoraproject.org/en-US/Fedora/13/html/Security-Enhanced_Linux/ https://access.redhat.com/documentation/enus/red_hat_enterprise_linux_atomic_host/7/html/container_security_guide/docker_selinux_security_policy'\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.2'\n  tag \"cis_control\": ['14.4', '6.1']\n  tag \"cis_level\": 'Level 2 - Docker'\n  tag \"nist\": ['AC-3 (3)', '4']\n  tag \"check_text\": \"docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: SecurityOpt={{ .HostConfig.SecurityOpt }}' The above command should\n  return all the security options currently configured for the containers.\"\n  tag \"fix\": \"If SELinux is applicable for your Linux OS, use it. You may have\n  to follow below set of steps: Set the SELinux State. Set the\n  SELinux Policy. Create or import a SELinux policy template for Docker\n  containers. Start Docker in daemon mode with SELinux enabled. For\n  example, docker daemon --selinux-enabled. Start your Docker container using\n  the security options. For example, docker run --interactive --tty\n  --security-opt label=level:TopSecret centos /bin/bash\"\n  tag \"Default Value\": \"By default, no SELinux security options are applied on\n  containers.\"\n  ref 'Bug: Wrong SELinux label for devmapper device', url: 'https://github.com/docker/docker/issues/22826'\n  ref 'Bug: selinux break docker user namespace', url: 'https://bugzilla.redhat.com/show_bug.cgi?id=1312665'\n  ref url: 'https://docs.docker.com/engine/security/security/'\n  ref url: 'https://docs.docker.com/engine/reference/run/#security-configuration'\n  ref url: 'https://docs.fedoraproject.org/en-US/Fedora/13/html/Security-Enhanced_Linux/'\n\n  only_if { %w{centos redhat}.include? os[:name] }\n  describe json('/etc/docker/daemon.json') do\n    its(['selinux-enabled']) { should eq(true) }\n  end\n\n  docker.containers.running?.ids.each do |id|\n    describe docker.object(id) do\n      its(%w{HostConfig SecurityOpt}) { should_not eq nil }\n      its(%w{HostConfig SecurityOpt}) { should include attribute('selinux_profile') }\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.2.rb",
        "line": 1
      },
      "id": "M-5.2"
    },
    {
      "title": "3.20 Ensure that /etc/default/docker file permissions are set to 644 or more restrictive (Scored)",
      "desc": "Verify that the /etc/default/docker file permissions are correctly set to\n  644 or more restrictive. The /etc/default/docker file contains sensitive parameters that may alter the\n  behavior of the docker daemon. Hence, it should be writable only by root to maintain the\n  integrity of the file.",
      "descriptions": {
        "default": "Verify that the /etc/default/docker file permissions are correctly set to\n  644 or more restrictive. The /etc/default/docker file contains sensitive parameters that may alter the\n  behavior of the docker daemon. Hence, it should be writable only by root to maintain the\n  integrity of the file."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/admin/configuring/"
        }
      ],
      "tags": {
        "ref": "1. https://docs.docker.com/engine/admin/configuring/",
        "severity": "medium",
        "cis_id": "3.20",
        "cis_control": [
          "14.4",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-3 (3)",
          "4"
        ],
        "check_text": "Execute the below command to verify that the file permissions\n  are correctly set to 644 or more restrictive: stat -c %a\n  /etc/default/docker",
        "fix": "chmod 644 /etc/default/docker This would set the file\n  permissions for this file to 644.",
        "Default Value": "This file may not be present on the system. In that\n  case, this recommendation is not applicable."
      },
      "code": "control 'M-3.20' do\n  title '3.20 Ensure that /etc/default/docker file permissions are set to 644 or more restrictive (Scored)'\n  desc  \"Verify that the /etc/default/docker file permissions are correctly set to\n  644 or more restrictive. The /etc/default/docker file contains sensitive parameters that may alter the\n  behavior of the docker daemon. Hence, it should be writable only by root to maintain the\n  integrity of the file.\n  \"\n  impact 0.5\n  tag \"ref\": '1. https://docs.docker.com/engine/admin/configuring/'\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '3.20'\n  tag \"cis_control\": ['14.4', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-3 (3)', '4']\n  tag \"check_text\": \"Execute the below command to verify that the file permissions\n  are correctly set to 644 or more restrictive: stat -c %a\n  /etc/default/docker\"\n  tag \"fix\": \"chmod 644 /etc/default/docker This would set the file\n  permissions for this file to 644.\"\n  tag \"Default Value\": \"This file may not be present on the system. In that\n  case, this recommendation is not applicable.\"\n  ref url: 'https://docs.docker.com/engine/admin/configuring/'\n\n  only_if { os[:family] != 'centos' }\n  describe file('/etc/default/docker') do\n    it { should exist }\n    it { should be_file }\n    it { should be_readable.by('owner') }\n    it { should be_writable.by('owner') }\n    it { should_not be_executable.by('owner') }\n    it { should be_readable.by('group') }\n    it { should_not be_writable.by('group') }\n    it { should_not be_executable.by('group') }\n    it { should be_readable.by('other') }\n    it { should_not be_writable.by('other') }\n    it { should_not be_executable.by('other') }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-3.20.rb",
        "line": 1
      },
      "id": "M-3.20"
    },
    {
      "title": "3.14 Ensure that Docker server certificate key file permissions are set to 400 (Scored)",
      "desc": "Verify that the Docker server certificate key file (the file that is passed\n  along with the --tlskey parameter) has permissions of 400.\n  The Docker server certificate key file should be protected from any\n  tampering or unneeded reads. It holds the private key for the Docker server certificate. Hence,\n  it must have permissions of 400 to maintain the integrity of the Docker server certificate.",
      "descriptions": {
        "default": "Verify that the Docker server certificate key file (the file that is passed\n  along with the --tlskey parameter) has permissions of 400.\n  The Docker server certificate key file should be protected from any\n  tampering or unneeded reads. It holds the private key for the Docker server certificate. Hence,\n  it must have permissions of 400 to maintain the integrity of the Docker server certificate."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/security/certificates/"
        },
        {
          "url": "https://docs.docker.com/engine/security/https/"
        }
      ],
      "tags": {
        "ref": "1. https://docs.docker.com/registry/insecure/2.\n  https://docs.docker.com/engine/security/https/",
        "severity": "medium",
        "cis_id": "3.14",
        "cis_control": [
          "14.4",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-3 (3)",
          "4"
        ],
        "check_text": "Execute the below command to verify that the Docker server\n  certificate key file has permissions of 400: stat -c %a <path to Docker\n  server certificate key file>",
        "fix": "chmod 400 <path to Docker server certificate key file> This\n  would set the Docker server certificate key file permissions to 400.",
        "Default Value": "By default, the permissions for the Docker server\n  certificate key file might not be 400. The default file permissions are\n  governed by the system or user specific umask values."
      },
      "code": "control 'M-3.14' do\n  title '3.14 Ensure that Docker server certificate key file permissions are set to 400 (Scored)'\n  desc  \"Verify that the Docker server certificate key file (the file that is passed\n  along with the --tlskey parameter) has permissions of 400.\n  The Docker server certificate key file should be protected from any\n  tampering or unneeded reads. It holds the private key for the Docker server certificate. Hence,\n  it must have permissions of 400 to maintain the integrity of the Docker server certificate.\n  \"\n  impact 0.5\n  tag \"ref\": \"1. https://docs.docker.com/registry/insecure/2.\n  https://docs.docker.com/engine/security/https/\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '3.14'\n  tag \"cis_control\": ['14.4', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-3 (3)', '4']\n  tag \"check_text\": \"Execute the below command to verify that the Docker server\n  certificate key file has permissions of 400: stat -c %a <path to Docker\n  server certificate key file>\"\n  tag \"fix\": \"chmod 400 <path to Docker server certificate key file> This\n  would set the Docker server certificate key file permissions to 400.\"\n  tag \"Default Value\": \"By default, the permissions for the Docker server\n  certificate key file might not be 400. The default file permissions are\n  governed by the system or user specific umask values.\"\n  ref url: 'https://docs.docker.com/engine/security/certificates/'\n  ref url: 'https://docs.docker.com/engine/security/https/'\n\n  describe file(json('/etc/docker/daemon.json').params['tlskey']) do\n    it { should exist }\n    it { should be_file }\n    it { should be_readable }\n    it { should_not be_executable }\n    it { should_not be_writable }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-3.14.rb",
        "line": 1
      },
      "id": "M-3.14"
    },
    {
      "title": "2.14 Ensure live restore is Enabled (Scored)",
      "desc": "The --live-restore enables full support of daemon-less containers in\n  docker. It ensures that docker does not stop containers on shutdown or restore and properly\n  reconnects to the container when restarted.\n  One of the important security triads is availability. Setting --live-restore flag in the\n  docker daemon ensures that container execution is not interrupted when the\n  docker daemon is not available. This also means that it is now easier to update\n  and patch the docker daemon without execution downtime.",
      "descriptions": {
        "default": "The --live-restore enables full support of daemon-less containers in\n  docker. It ensures that docker does not stop containers on shutdown or restore and properly\n  reconnects to the container when restarted.\n  One of the important security triads is availability. Setting --live-restore flag in the\n  docker daemon ensures that container execution is not interrupted when the\n  docker daemon is not available. This also means that it is now easier to update\n  and patch the docker daemon without execution downtime."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/admin/live-restore/",
          "ref": "live-restore"
        },
        {
          "url": "https://github.com/docker/docker/pull/23213",
          "ref": "Add --live-restore flag"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "2.14",
        "cis_control": [
          "18",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SI-1",
          "4"
        ],
        "check_text": "Run docker info and ensure that the Live Restore Enabled\n  property is set to true. docker info --format '{{ .LiveRestoreEnabled\n  }}' Alternatively run the below command and ensure that --live-restore is\n  used. ps -ef | grep dockerd",
        "fix": "Run the docker in daemon mode and pass --live-restore as an\n  argument. For Example, dockerd --live-restore",
        "Default Value": "By default, --live-restore is not enabled."
      },
      "code": "control 'M-2.14' do\n  title '2.14 Ensure live restore is Enabled (Scored)'\n  desc  \"The --live-restore enables full support of daemon-less containers in\n  docker. It ensures that docker does not stop containers on shutdown or restore and properly\n  reconnects to the container when restarted.\n  One of the important security triads is availability. Setting --live-restore flag in the\n  docker daemon ensures that container execution is not interrupted when the\n  docker daemon is not available. This also means that it is now easier to update\n  and patch the docker daemon without execution downtime.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '2.14'\n  tag \"cis_control\": ['18', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SI-1', '4']\n  tag \"check_text\": \"Run docker info and ensure that the Live Restore Enabled\n  property is set to true. docker info --format '{{ .LiveRestoreEnabled\n  }}' Alternatively run the below command and ensure that --live-restore is\n  used. ps -ef | grep dockerd\"\n  tag \"fix\": \"Run the docker in daemon mode and pass --live-restore as an\n  argument. For Example, dockerd --live-restore\"\n  tag \"Default Value\": 'By default, --live-restore is not enabled.'\n  ref 'live-restore', url: 'https://docs.docker.com/engine/admin/live-restore/'\n  ref 'Add --live-restore flag', url: 'https://github.com/docker/docker/pull/23213'\n\n  describe json('/etc/docker/daemon.json') do\n    its(['live-restore']) { should eq(true) }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-2.14.rb",
        "line": 1
      },
      "id": "M-2.14"
    },
    {
      "title": "4.10 Ensure secrets are not stored in Dockerfiles (Not Scored)",
      "desc": "Do not store any secrets in Dockerfiles.\n  Dockerfiles could be backtracked easily by using native Docker commands\n  such as docker history and various tools and utilities. Also, as a general practice, image\n  publishers provide Dockerfiles to build the credibility for their images. Hence, the\n  secrets within these Dockerfiles could be easily exposed and potentially be exploited.",
      "descriptions": {
        "default": "Do not store any secrets in Dockerfiles.\n  Dockerfiles could be backtracked easily by using native Docker commands\n  such as docker history and various tools and utilities. Also, as a general practice, image\n  publishers provide Dockerfiles to build the credibility for their images. Hence, the\n  secrets within these Dockerfiles could be easily exposed and potentially be exploited."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "ref": "1. https://github.com/docker/docker/issues/134902.\n  http://12factor.net/config3.\n  https://avicoder.me/2016/07/22/Twitter-Vine-Source-code-dump/",
        "severity": "medium",
        "cis_id": "4.10",
        "cis_control": [
          "14",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-6",
          "4"
        ],
        "check_text": "Step 1: Run the below command to get the list of\n  images: docker images Step 2: Run the below command for each image in the\n  list above, and look for any secrets: docker history\n  <Image_ID> Alternatively, if you have access to Dockerfile for the image,\n  verify that there are no secrets as described above.",
        "fix": "Do not store any kind of secrets within Dockerfiles.",
        "Default Value": "By default, there are no restrictions on storing config\n  secrets in the Dockerfiles."
      },
      "code": "control 'M-4.10' do\n  title '4.10 Ensure secrets are not stored in Dockerfiles (Not Scored)'\n  desc  \"Do not store any secrets in Dockerfiles.\n  Dockerfiles could be backtracked easily by using native Docker commands\n  such as docker history and various tools and utilities. Also, as a general practice, image\n  publishers provide Dockerfiles to build the credibility for their images. Hence, the\n  secrets within these Dockerfiles could be easily exposed and potentially be exploited.\n  \"\n  impact 0.5\n  tag \"ref\": \"1. https://github.com/docker/docker/issues/134902.\n  http://12factor.net/config3.\n  https://avicoder.me/2016/07/22/Twitter-Vine-Source-code-dump/\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '4.10'\n  tag \"cis_control\": ['14', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-6', '4']\n  tag \"check_text\": \"Step 1: Run the below command to get the list of\n  images: docker images Step 2: Run the below command for each image in the\n  list above, and look for any secrets: docker history\n  <Image_ID> Alternatively, if you have access to Dockerfile for the image,\n  verify that there are no secrets as described above.\"\n  tag \"fix\": 'Do not store any kind of secrets within Dockerfiles.'\n  tag \"Default Value\": \"By default, there are no restrictions on storing config\n  secrets in the Dockerfiles.\"\n\n  describe 'docker-test' do\n    skip 'Manually verify that you have not used secrets in images'\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-4.10.rb",
        "line": 1
      },
      "id": "M-4.10"
    },
    {
      "title": "2.11 Ensure that authorization for Docker client commands is enabled(Scored)",
      "desc": "Use native Docker authorization plugins or a third party authorization\n  mechanism with Docker daemon to manage access to Docker client commands.\n  Dockers out-of-the-box authorization model is all or nothing. Any user\n  with permission to access the Docker daemon can run any Docker client command. The same is\n  true for callers using Dockers remote API to contact the daemon. If you require greater\n  access control, you can create authorization plugins and add them to your Docker daemon\n  configuration. Using an authorization plugin, a Docker administrator can configure granular\n  access policies for managing access to Docker daemon.\n  Third party integrations of Docker may implement their own authorization\n  models to require authorization with the Docker daemon outside of docker's native\n  authorization plugin (i.e. Kubernetes, Cloud Foundry, Openshift).",
      "descriptions": {
        "default": "Use native Docker authorization plugins or a third party authorization\n  mechanism with Docker daemon to manage access to Docker client commands.\n  Dockers out-of-the-box authorization model is all or nothing. Any user\n  with permission to access the Docker daemon can run any Docker client command. The same is\n  true for callers using Dockers remote API to contact the daemon. If you require greater\n  access control, you can create authorization plugins and add them to your Docker daemon\n  configuration. Using an authorization plugin, a Docker administrator can configure granular\n  access policies for managing access to Docker daemon.\n  Third party integrations of Docker may implement their own authorization\n  models to require authorization with the Docker daemon outside of docker's native\n  authorization plugin (i.e. Kubernetes, Cloud Foundry, Openshift)."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/reference/commandline/daemon/#access-authorization",
          "ref": "Access authorization"
        },
        {
          "url": "https://docs.docker.com/engine/reference/commandline/dockerd/#access- authorization",
          "ref": "access-authorization"
        },
        {
          "url": "https://docs.docker.com/engine/extend/plugins_authorization/",
          "ref": "Auhtorization plugins"
        },
        {
          "url": "https://github.com/twistlock/authz",
          "ref": "Twistlock authorization plugin"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "2.11",
        "cis_control": [
          "16",
          "6.1"
        ],
        "cis_level": "Level 2 - Docker",
        "nist": [
          "AC-2",
          "4"
        ],
        "check_text": "ps -ef | grep dockerd Ensure that the --authorization-plugin\n  parameter is set as appropriate if using docker native authorization. docker\n  search hello-world Ensure that docker daemon requires authorization to perform the above command.",
        "fix": "Step 1: Install/Create an authorization plugin. Step 2:\n  Configure the authorization policy as desired. Step 3: Start the docker daemon\n  as below: dockerd --authorization-plugin=<PLUGIN_ID>",
        "Default Value": "By default, authorization plugins are not set up."
      },
      "code": "control 'M-2.11' do\n  title '2.11 Ensure that authorization for Docker client commands is enabled(Scored)'\n  desc  \"Use native Docker authorization plugins or a third party authorization\n  mechanism with Docker daemon to manage access to Docker client commands.\n  Dockers out-of-the-box authorization model is all or nothing. Any user\n  with permission to access the Docker daemon can run any Docker client command. The same is\n  true for callers using Dockers remote API to contact the daemon. If you require greater\n  access control, you can create authorization plugins and add them to your Docker daemon\n  configuration. Using an authorization plugin, a Docker administrator can configure granular\n  access policies for managing access to Docker daemon.\n  Third party integrations of Docker may implement their own authorization\n  models to require authorization with the Docker daemon outside of docker's native\n  authorization plugin (i.e. Kubernetes, Cloud Foundry, Openshift).\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '2.11'\n  tag \"cis_control\": ['16', '6.1']\n  tag \"cis_level\": 'Level 2 - Docker'\n  tag \"nist\": ['AC-2', '4']\n  tag \"check_text\": \"ps -ef | grep dockerd Ensure that the --authorization-plugin\n  parameter is set as appropriate if using docker native authorization. docker\n  search hello-world Ensure that docker daemon requires authorization to perform the above command.\"\n  tag \"fix\": \"Step 1: Install/Create an authorization plugin. Step 2:\n  Configure the authorization policy as desired. Step 3: Start the docker daemon\n  as below: dockerd --authorization-plugin=<PLUGIN_ID>\"\n  tag \"Default Value\": 'By default, authorization plugins are not set up.'\n  ref 'Access authorization', url: 'https://docs.docker.com/engine/reference/commandline/daemon/#access-authorization'\n  ref 'access-authorization', url: 'https://docs.docker.com/engine/reference/commandline/dockerd/#access- authorization'\n  ref 'Auhtorization plugins', url: 'https://docs.docker.com/engine/extend/plugins_authorization/'\n  ref 'Twistlock authorization plugin', url: 'https://github.com/twistlock/authz'\n\n  describe json('/etc/docker/daemon.json') do\n    its(['authorization-plugins']) { should_not be_empty }\n    its(['authorization-plugins']) { should eq attribute('authorization_plugin') }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-2.11.rb",
        "line": 1
      },
      "id": "M-2.11"
    },
    {
      "title": "5.17 Ensure host devices are not directly exposed to containers (Not Scored)",
      "desc": "Host devices can be directly exposed to containers at runtime. Do not\n  directly expose host devices to containers especially for containers that are not trusted.\n  The --device option exposes the host devices to the containers and\n  consequently, the containers can directly access such host devices. You would not require the\n  container to run in privileged mode to access and manipulate the host devices. By\n  default, the container will be able to read, write and mknod these devices.\n  Additionally, it is possible for containers to remove block devices from the host.\n  Hence, do not expose host devices to the containers directly.\n  If at all, you would want to expose the host device to a container, use the\n  sharing permissions appropriately:\n  r - read only\n  w - writable\n  m - mknod allowed",
      "descriptions": {
        "default": "Host devices can be directly exposed to containers at runtime. Do not\n  directly expose host devices to containers especially for containers that are not trusted.\n  The --device option exposes the host devices to the containers and\n  consequently, the containers can directly access such host devices. You would not require the\n  container to run in privileged mode to access and manipulate the host devices. By\n  default, the container will be able to read, write and mknod these devices.\n  Additionally, it is possible for containers to remove block devices from the host.\n  Hence, do not expose host devices to the containers directly.\n  If at all, you would want to expose the host device to a container, use the\n  sharing permissions appropriately:\n  r - read only\n  w - writable\n  m - mknod allowed"
      },
      "impact": 0,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/reference/commandline/cli/#run"
        }
      ],
      "tags": {
        "ref": "1.\n  https://docs.docker.com/engine/reference/commandline/run/#options",
        "severity": "medium",
        "cis_id": "5.17",
        "cis_control": [
          "14",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-6",
          "4"
        ],
        "check_text": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}:Devices={{ .HostConfig.Devices }}'The above command would list out each\n  device with below information:CgroupPermissions - For example,\n  rwm PathInContainer - Device path within the container PathOnHost - Device\n  path on the host Verify that the host device is needed to be accessed from\n  within the container and the permissions required are correctly set. If the\n  above command returns [], then the container does not have access to host\n  devices. This recommendation can be assumed to be compliant.",
        "fix": "Do not directly expose the host devices to containers. If at all,\n  you need to expose the host devices to containers, use the correct set of\n  permissions: For example, do not start a container as below: docker run\n  --interactive --tty --device=/dev/tty0:/dev/tty0:rwm\n  -device=/dev/temp_sda:/dev/temp_sda:rwm centos bash For example, share the\n  host device with correct permissions: docker run --interactive --tty\n  --device=/dev/tty0:/dev/tty0:rw -device=/dev/temp_sda:/dev/temp_sda:r centos\n  bash",
        "Default Value": "By default, no host devices are exposed to containers.\n  If you do not provide sharing permissions and choose to expose a host device\n  to a container, the host device would be exposed with read, write and mknod\n  permissions."
      },
      "code": "control 'M-5.17' do\n  title '5.17 Ensure host devices are not directly exposed to containers (Not Scored)'\n  desc  \"Host devices can be directly exposed to containers at runtime. Do not\n  directly expose host devices to containers especially for containers that are not trusted.\n  The --device option exposes the host devices to the containers and\n  consequently, the containers can directly access such host devices. You would not require the\n  container to run in privileged mode to access and manipulate the host devices. By\n  default, the container will be able to read, write and mknod these devices.\n  Additionally, it is possible for containers to remove block devices from the host.\n  Hence, do not expose host devices to the containers directly.\n  If at all, you would want to expose the host device to a container, use the\n  sharing permissions appropriately:\n  r - read only\n  w - writable\n  m - mknod allowed\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  https://docs.docker.com/engine/reference/commandline/run/#options\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.17'\n  tag \"cis_control\": ['14', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-6', '4']\n  tag \"check_text\": \"docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}:Devices={{ .HostConfig.Devices }}'The above command would list out each\n  device with below information:CgroupPermissions - For example,\n  rwm PathInContainer - Device path within the container PathOnHost - Device\n  path on the host Verify that the host device is needed to be accessed from\n  within the container and the permissions required are correctly set. If the\n  above command returns [], then the container does not have access to host\n  devices. This recommendation can be assumed to be compliant.\"\n  tag \"fix\": \"Do not directly expose the host devices to containers. If at all,\n  you need to expose the host devices to containers, use the correct set of\n  permissions: For example, do not start a container as below: docker run\n  --interactive --tty --device=/dev/tty0:/dev/tty0:rwm\n  -device=/dev/temp_sda:/dev/temp_sda:rwm centos bash For example, share the\n  host device with correct permissions: docker run --interactive --tty\n  --device=/dev/tty0:/dev/tty0:rw -device=/dev/temp_sda:/dev/temp_sda:r centos\n  bash\"\n  tag \"Default Value\": \"By default, no host devices are exposed to containers.\n  If you do not provide sharing permissions and choose to expose a host device\n  to a container, the host device would be exposed with read, write and mknod\n  permissions.\"\n  ref url: 'https://docs.docker.com/engine/reference/commandline/cli/#run'\n\n  if docker.containers.running?.ids.empty?\n    impact 0.0\n    describe 'There are no running docker containers, therfore this control is N/A' do\n      skip 'There are no running docker containers, therfore this control is N/A'\n    end\n  end\n\n  if !docker.containers.running?.ids.empty?\n    docker.containers.running?.ids.each do |id|\n      describe docker.object(id) do\n        its(%w{HostConfig Devices}) { should be_empty }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.17.rb",
        "line": 1
      },
      "id": "M-5.17"
    },
    {
      "title": "4.9 Ensure COPY is used instead of ADD in Dockerfile (Not Scored)",
      "desc": "Use COPY instruction instead of ADD instruction in the Dockerfile.\n  COPY instruction just copies the files from the local host machine to the\n  container file system. ADD instruction potentially could retrieve files from remote URLs\n  and perform operations such as unpacking. Thus, ADD instruction introduces risks such\n  as adding malicious files from URLs without scanning and unpacking procedure\n  vulnerabilities.",
      "descriptions": {
        "default": "Use COPY instruction instead of ADD instruction in the Dockerfile.\n  COPY instruction just copies the files from the local host machine to the\n  container file system. ADD instruction potentially could retrieve files from remote URLs\n  and perform operations such as unpacking. Thus, ADD instruction introduces risks such\n  as adding malicious files from URLs without scanning and unpacking procedure\n  vulnerabilities."
      },
      "impact": 0,
      "refs": [],
      "tags": {
        "ref": "1.\n  https://docs.docker.com/engine/userguide/eng-image/dockerfile_bestpractices/#add-or-copy",
        "severity": "medium",
        "cis_id": "4.9",
        "cis_control": [
          "18",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SI-1",
          "4"
        ],
        "check_text": "Step 1: Run the below command to get the list of\n  images: docker images Step 2: Run the below command for each image in the\n  list above and look for any ADD instructions: docker history\n  <Image_ID> Alternatively, if you have access to Dockerfile for the image,\n  verify that there are no ADD instructions.",
        "fix": "Use COPY instructions in Dockerfiles.",
        "Default Value": "Not Applicable"
      },
      "code": "control 'M-4.9' do\n  title '4.9 Ensure COPY is used instead of ADD in Dockerfile (Not Scored)'\n  desc  \"Use COPY instruction instead of ADD instruction in the Dockerfile.\n  COPY instruction just copies the files from the local host machine to the\n  container file system. ADD instruction potentially could retrieve files from remote URLs\n  and perform operations such as unpacking. Thus, ADD instruction introduces risks such\n  as adding malicious files from URLs without scanning and unpacking procedure\n  vulnerabilities.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  https://docs.docker.com/engine/userguide/eng-image/dockerfile_bestpractices/#add-or-copy\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '4.9'\n  tag \"cis_control\": ['18', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SI-1', '4']\n  tag \"check_text\": \"Step 1: Run the below command to get the list of\n  images: docker images Step 2: Run the below command for each image in the\n  list above and look for any ADD instructions: docker history\n  <Image_ID> Alternatively, if you have access to Dockerfile for the image,\n  verify that there are no ADD instructions.\"\n  tag \"fix\": 'Use COPY instructions in Dockerfiles.'\n  tag \"Default Value\": 'Not Applicable'\n\n  if docker.images.ids.empty?\n    impact 0.0\n    describe 'There are no docker images, therfore this control is N/A' do\n      skip 'There are no docker images, therfore this control is N/A'\n    end\n  end\n\n  if !docker.images.repositories.empty?\n    docker.images.repositories.each do |repo|\n      describe command(`docker history #{repo}| grep ADD`) do\n        its('stdout') { should eq '' }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-4.9.rb",
        "line": 1
      },
      "id": "M-4.9"
    },
    {
      "title": "1.4 Ensure only trusted users are allowed to control Docker daemon (Scored)",
      "desc": "The Docker daemon currently requires root privileges. A user added to the\n  docker group gives him full root access rights.\n  Docker allows you to share a directory between the Docker host and a guest container\n  without limiting the access rights of the container. This means that you\n  can start a container and map the / directory on your host to the container. The\n  container will then be able to alter your host file system without any restrictions. In simple\n  terms, it means that you can attain elevated privileges with just being a member of the docker\n  group and then start a container with the mapped / directory on the host.",
      "descriptions": {
        "default": "The Docker daemon currently requires root privileges. A user added to the\n  docker group gives him full root access rights.\n  Docker allows you to share a directory between the Docker host and a guest container\n  without limiting the access rights of the container. This means that you\n  can start a container and map the / directory on your host to the container. The\n  container will then be able to alter your host file system without any restrictions. In simple\n  terms, it means that you can attain elevated privileges with just being a member of the docker\n  group and then start a container with the mapped / directory on the host."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/security/security/#docker-daemon-attacksurface",
          "ref": "docker-daemon-attacksurface"
        },
        {
          "url": "https://www.andreas-jung.com/contents/on-docker-security-docker-group-considered-harmful",
          "ref": "On Docker security: docker group considered harmful"
        },
        {
          "url": "http://www.projectatomic.io/blog/2015/08/why-we-dont-let-non-root-users-run-docker-in-centos-fedora-or-rhel/",
          "ref": "Why we do not let non-root users run Docker in CentOS, Fedora, or RHEL"
        }
      ],
      "tags": {
        "ref": "1.\n  https://docs.docker.com/engine/security/security/#docker-daemon-attacksurface2.\n  https://www.andreas-jung.com/contents/on-docker-security-docker-groupconsidered-harmful3.\n  http://www.projectatomic.io/blog/2015/08/why-we-dont-let-non-root-users-rundocker-in-centos-fedora-or-rhel/\n",
        "severity": "medium",
        "cis_id": "1.4",
        "cis_control": [
          "5.1",
          "6.1"
        ],
        "cis_level": "Level 1 - Linux Host OS",
        "nist": [
          "AC-6(9)",
          "4"
        ],
        "check_text": "Execute the below command on the docker host and ensure that\n  only trusted users are members of the docker group. getent group docker",
        "fix": "Remove any users from the docker group that are not trusted.\n  Additionally, do not create a mapping of sensitive directories on host to container volumes.",
        "Default Value": "Not Applicable"
      },
      "code": "control 'M-1.4' do\n  title '1.4 Ensure only trusted users are allowed to control Docker daemon (Scored)'\n  desc  \"The Docker daemon currently requires root privileges. A user added to the\n  docker group gives him full root access rights.\n  Docker allows you to share a directory between the Docker host and a guest container\n  without limiting the access rights of the container. This means that you\n  can start a container and map the / directory on your host to the container. The\n  container will then be able to alter your host file system without any restrictions. In simple\n  terms, it means that you can attain elevated privileges with just being a member of the docker\n  group and then start a container with the mapped / directory on the host.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  https://docs.docker.com/engine/security/security/#docker-daemon-attacksurface2.\n  https://www.andreas-jung.com/contents/on-docker-security-docker-groupconsidered-harmful3.\n  http://www.projectatomic.io/blog/2015/08/why-we-dont-let-non-root-users-rundocker-in-centos-fedora-or-rhel/\\n\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '1.4'\n  tag \"cis_control\": ['5.1', '6.1']\n  tag \"cis_level\": 'Level 1 - Linux Host OS'\n  tag \"nist\": ['AC-6(9)', '4']\n  tag \"check_text\": \"Execute the below command on the docker host and ensure that\n  only trusted users are members of the docker group. getent group docker\"\n  tag \"fix\": \"Remove any users from the docker group that are not trusted.\n  Additionally, do not create a mapping of sensitive directories on host to container volumes.\"\n  tag \"Default Value\": 'Not Applicable'\n  ref 'docker-daemon-attacksurface', url: 'https://docs.docker.com/engine/security/security/#docker-daemon-attacksurface'\n  ref 'On Docker security: docker group considered harmful', url: 'https://www.andreas-jung.com/contents/on-docker-security-docker-group-considered-harmful'\n  ref 'Why we do not let non-root users run Docker in CentOS, Fedora, or RHEL', url: 'http://www.projectatomic.io/blog/2015/08/why-we-dont-let-non-root-users-run-docker-in-centos-fedora-or-rhel/'\n\n  describe group('docker') do\n    it { should exist }\n  end\n\n  describe etc_group.where(group_name: 'docker') do\n    its('users') { should include attribute('trusted_user') }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-1.4.rb",
        "line": 1
      },
      "id": "M-1.4"
    },
    {
      "title": "5.1 Ensure AppArmor Profile is Enabled (Scored)",
      "desc": "AppArmor is an effective and easy-to-use Linux application security system.\n  It is available on quite a few Linux distributions by default such as Debian and Ubuntu.\n  AppArmor protects the Linux OS and applications from various threats by\n  enforcing a security policy which is also known as AppArmor profile. You can create\n  your own AppArmor profile for containers or use the Docker's default AppArmor\n  profile. This would enforce security policies on the containers as defined in the profile.",
      "descriptions": {
        "default": "AppArmor is an effective and easy-to-use Linux application security system.\n  It is available on quite a few Linux distributions by default such as Debian and Ubuntu.\n  AppArmor protects the Linux OS and applications from various threats by\n  enforcing a security policy which is also known as AppArmor profile. You can create\n  your own AppArmor profile for containers or use the Docker's default AppArmor\n  profile. This would enforce security policies on the containers as defined in the profile."
      },
      "impact": 0,
      "refs": [
        {
          "ref": "https://docs.docker.com/engine/security/security/"
        },
        {
          "ref": "https://docs.docker.com/engine/reference/run/#security-configuration"
        },
        {
          "ref": "http://wiki.apparmor.net/index.php/Main_Page"
        }
      ],
      "tags": {
        "ref": "1. https://docs.docker.com/engine/security/apparmor/2.\n  https://docs.docker.com/engine/reference/run/#security-configuration3.\n  https://docs.docker.com/engine/security/security/#other-kernel-security-features",
        "severity": "medium",
        "cis_id": "5.1",
        "cis_control": [
          "14.4",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-3 (3)",
          "4"
        ],
        "check_text": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: AppArmorProfile={{ .AppArmorProfile }}' The above command should return a\n  valid AppArmor Profile for each container instance.",
        "fix": "If AppArmor is applicable for your Linux OS, use it. You may have\n  to follow below set of steps: Verify if AppArmor is\n  installed. If not, install it. Create or import a AppArmor profile for Docker\n  containers. Put this profile in enforcing mode. Start your Docker container\n  using the customized AppArmor profile. For example, docker run --interactive\n  --tty --security-opt=\"apparmor:PROFILENAME\" centos/bin/bash Alternatively,\n  you can keep the docker's default apparmor profile.",
        "Default Value": "By default, docker-default AppArmor profile is applied\n  for running containers and this profile can be found at\n  /etc/apparmor.d/docker."
      },
      "code": "control 'M-5.1' do\n  title '5.1 Ensure AppArmor Profile is Enabled (Scored)'\n  desc  \"AppArmor is an effective and easy-to-use Linux application security system.\n  It is available on quite a few Linux distributions by default such as Debian and Ubuntu.\n  AppArmor protects the Linux OS and applications from various threats by\n  enforcing a security policy which is also known as AppArmor profile. You can create\n  your own AppArmor profile for containers or use the Docker's default AppArmor\n  profile. This would enforce security policies on the containers as defined in the profile.\n  \"\n  impact 0.5\n  tag \"ref\": \"1. https://docs.docker.com/engine/security/apparmor/2.\n  https://docs.docker.com/engine/reference/run/#security-configuration3.\n  https://docs.docker.com/engine/security/security/#other-kernel-security-features\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.1'\n  tag \"cis_control\": ['14.4', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-3 (3)', '4']\n  tag \"check_text\": \"docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: AppArmorProfile={{ .AppArmorProfile }}' The above command should return a\n  valid AppArmor Profile for each container instance.\"\n  tag \"fix\": \"If AppArmor is applicable for your Linux OS, use it. You may have\n  to follow below set of steps: Verify if AppArmor is\n  installed. If not, install it. Create or import a AppArmor profile for Docker\n  containers. Put this profile in enforcing mode. Start your Docker container\n  using the customized AppArmor profile. For example, docker run --interactive\n  --tty --security-opt=\\\"apparmor:PROFILENAME\\\" centos/bin/bash Alternatively,\n  you can keep the docker's default apparmor profile.\"\n  tag \"Default Value\": \"By default, docker-default AppArmor profile is applied\n  for running containers and this profile can be found at\n  /etc/apparmor.d/docker.\"\n  ref 'https://docs.docker.com/engine/security/security/'\n  ref 'https://docs.docker.com/engine/reference/run/#security-configuration'\n  ref 'http://wiki.apparmor.net/index.php/Main_Page'\n\n  only_if { %w{ubuntu debian}.include? os[:name] }\n\n  if docker.containers.running?.ids.empty?\n    impact 0.0\n    describe 'There are no running docker containers, therfore this control is N/A' do\n      skip 'There are no running docker containers, therfore this control is N/A'\n    end\n  end\n\n  if !docker.containers.running?.ids.empty?\n    docker.containers.running?.ids.each do |id|\n      describe docker.object(id) do\n        its(['AppArmorProfile']) { should include attribute('app_armor_profile') }\n        its(['AppArmorProfile']) { should_not eq nil }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.1.rb",
        "line": 1
      },
      "id": "M-5.1"
    },
    {
      "title": "3.7 Ensure that registry certificate file ownership is set to root:root(Scored)",
      "desc": "Verify that all the registry certificate files (usually found under\n  the /etc/docker/certs.d/<registry-name> directory) are owned and group-owned by root.\n  The /etc/docker/certs.d/<registry-name> directory contains Docker registry certificates.\n  These certificate files must be owned and group-owned by root to maintain\n  the integrity of the certificates.",
      "descriptions": {
        "default": "Verify that all the registry certificate files (usually found under\n  the /etc/docker/certs.d/<registry-name> directory) are owned and group-owned by root.\n  The /etc/docker/certs.d/<registry-name> directory contains Docker registry certificates.\n  These certificate files must be owned and group-owned by root to maintain\n  the integrity of the certificates."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/security/certificates/"
        },
        {
          "url": "docs.docker.com/reference/commandline/cli/#insecure-registries"
        }
      ],
      "tags": {
        "ref": "1. https://docs.docker.com/registry/insecure/",
        "severity": "medium",
        "cis_id": "3.7",
        "cis_control": [
          "5.1",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-6(9)",
          "4"
        ],
        "check_text": "Execute the below command to verify that the registry\n  certificate files are owned and group-owned by root: stat -c %U:%G\n  /etc/docker/certs.d/* | grep -v root:root The above command should not return\n  anything.",
        "fix": "chown root:root /etc/docker/certs.d/<registry-name>/* This would\n  set the ownership and group-ownership for the registry certificate files to root.",
        "Default Value": "By default, the ownership and group-ownership for\n  registry certificate files is correctly set to root."
      },
      "code": "control 'M-3.7' do\n  title '3.7 Ensure that registry certificate file ownership is set to root:root(Scored)'\n  desc  \"Verify that all the registry certificate files (usually found under\n  the /etc/docker/certs.d/<registry-name> directory) are owned and group-owned by root.\n  The /etc/docker/certs.d/<registry-name> directory contains Docker registry certificates.\n  These certificate files must be owned and group-owned by root to maintain\n  the integrity of the certificates.\n  \"\n  impact 0.5\n  tag \"ref\": '1. https://docs.docker.com/registry/insecure/'\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '3.7'\n  tag \"cis_control\": ['5.1', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-6(9)', '4']\n  tag \"check_text\": \"Execute the below command to verify that the registry\n  certificate files are owned and group-owned by root: stat -c %U:%G\n  /etc/docker/certs.d/* | grep -v root:root The above command should not return\n  anything.\"\n  tag \"fix\": \"chown root:root /etc/docker/certs.d/<registry-name>/* This would\n  set the ownership and group-ownership for the registry certificate files to root.\"\n  tag \"Default Value\": \"By default, the ownership and group-ownership for\n  registry certificate files is correctly set to root.\"\n  ref url: 'https://docs.docker.com/engine/security/certificates/'\n  ref url: 'docs.docker.com/reference/commandline/cli/#insecure-registries'\n\n  describe file(attribute('registry_cert_path')) do\n    it { should exist }\n    it { should be_directory }\n    it { should be_owned_by 'root' }\n    it { should be_grouped_into 'root' }\n  end\n\n  describe file(attribute('registry_name')) do\n    it { should exist }\n    it { should be_directory }\n    it { should be_owned_by 'root' }\n    it { should be_grouped_into 'root' }\n  end\n\n  describe file(attribute('registry_ca_file')) do\n    it { should exist }\n    it { should be_file }\n    it { should be_owned_by 'root' }\n    it { should be_grouped_into 'root' }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-3.7.rb",
        "line": 1
      },
      "id": "M-3.7"
    },
    {
      "title": "2.4 Ensure insecure registries are not used (Scored)",
      "desc": "Docker considers a private registry either secure or insecure. By default,\n  registries are considered secure.\n  A secure registry uses TLS. A copy of registry's CA certificate is placed\n  on the Docker host at /etc/docker/certs.d/<registry-name>/ directory. An insecure registry is the\n  one not having either valid registry certificate or is not using TLS. You should\n  not be using any insecure registries in the production environment. Insecure registries can\n  be tampered with leading to possible compromise to your production system.\n  Additionally, If a registry is marked as insecure then docker pull, docker\n  push, and docker search commands will not result in an error message and the user\n  might be indefinitely working with insecure registries without ever being notified\n  of the potential danger.",
      "descriptions": {
        "default": "Docker considers a private registry either secure or insecure. By default,\n  registries are considered secure.\n  A secure registry uses TLS. A copy of registry's CA certificate is placed\n  on the Docker host at /etc/docker/certs.d/<registry-name>/ directory. An insecure registry is the\n  one not having either valid registry certificate or is not using TLS. You should\n  not be using any insecure registries in the production environment. Insecure registries can\n  be tampered with leading to possible compromise to your production system.\n  Additionally, If a registry is marked as insecure then docker pull, docker\n  push, and docker search commands will not result in an error message and the user\n  might be indefinitely working with insecure registries without ever being notified\n  of the potential danger."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/registry/insecure/",
          "ref": "Insecure registry"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "2.4",
        "cis_control": [
          "14.2",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SC-8",
          "4"
        ],
        "check_text": "Run docker info or execute the below command to find out if any\n  insecure registries are used: ps -ef | grep dockerd Ensure that the\n  --insecure-registry parameter is not present.",
        "fix": "Do not use any insecure registries. For example, do not start\n  the Docker daemon as below: dockerd --insecure-registry 10.1.0.0/16",
        "Default Value": "By default, Docker assumes all, but local, registries are secure."
      },
      "code": "control 'M-2.4' do\n  title '2.4 Ensure insecure registries are not used (Scored)'\n  desc  \"Docker considers a private registry either secure or insecure. By default,\n  registries are considered secure.\n  A secure registry uses TLS. A copy of registry's CA certificate is placed\n  on the Docker host at /etc/docker/certs.d/<registry-name>/ directory. An insecure registry is the\n  one not having either valid registry certificate or is not using TLS. You should\n  not be using any insecure registries in the production environment. Insecure registries can\n  be tampered with leading to possible compromise to your production system.\n  Additionally, If a registry is marked as insecure then docker pull, docker\n  push, and docker search commands will not result in an error message and the user\n  might be indefinitely working with insecure registries without ever being notified\n  of the potential danger.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '2.4'\n  tag \"cis_control\": ['14.2', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SC-8', '4']\n  tag \"check_text\": \"Run docker info or execute the below command to find out if any\n  insecure registries are used: ps -ef | grep dockerd Ensure that the\n  --insecure-registry parameter is not present.\"\n  tag \"fix\": \"Do not use any insecure registries. For example, do not start\n  the Docker daemon as below: dockerd --insecure-registry 10.1.0.0/16\"\n  tag \"Default Value\": 'By default, Docker assumes all, but local, registries are secure.'\n  ref 'Insecure registry', url: 'https://docs.docker.com/registry/insecure/'\n\n  describe json('/etc/docker/daemon.json') do\n    its(['insecure-registries']) { should be_empty }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-2.4.rb",
        "line": 1
      },
      "id": "M-2.4"
    },
    {
      "title": "7.4 Ensure data exchanged between containers are encrypted on different nodes on the overlay network (Scored)",
      "desc": "Encrypt data exchanged between containers on different nodes on the overlay\n  network. By default, data exchanged between containers on different nodes on the\n  overlay network is not encrypted. This could potentially expose traffic between the\n  container nodes.",
      "descriptions": {
        "default": "Encrypt data exchanged between containers on different nodes on the overlay\n  network. By default, data exchanged between containers on different nodes on the\n  overlay network is not encrypted. This could potentially expose traffic between the\n  container nodes."
      },
      "impact": 0,
      "refs": [],
      "tags": {
        "ref": "1.\n  https://docs.docker.com/engine/userguide/networking/overlay-security-model/2.\n  https://github.com/docker/docker/issues/24253",
        "severity": "medium",
        "cis_id": "7.4",
        "cis_control": [
          "14.2",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SC-8",
          "4"
        ],
        "check_text": "Run the below command and ensure that each overlay network has\n  been encrypted. docker network ls --filter driver=overlay --quiet | xargs\n  docker network inspect --format '{{.Name}} {{ .Options }}'",
        "fix": "Create overlay network with --opt encrypted flag.",
        "Default Value": "By default, data exchanged between containers on\n  different nodes on the overlay network are not encrypted in the Docker swarm\n  mode."
      },
      "code": "control 'M-7.4' do\n  title '7.4 Ensure data exchanged between containers are encrypted on different nodes on the overlay network (Scored)'\n  desc  \"Encrypt data exchanged between containers on different nodes on the overlay\n  network. By default, data exchanged between containers on different nodes on the\n  overlay network is not encrypted. This could potentially expose traffic between the\n  container nodes.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  https://docs.docker.com/engine/userguide/networking/overlay-security-model/2.\n  https://github.com/docker/docker/issues/24253\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '7.4'\n  tag \"cis_control\": ['14.2', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SC-8', '4']\n  tag \"check_text\": \"Run the below command and ensure that each overlay network has\n  been encrypted. docker network ls --filter driver=overlay --quiet | xargs\n  docker network inspect --format '{{.Name}} {{ .Options }}'\"\n  tag \"fix\": 'Create overlay network with --opt encrypted flag.'\n  tag \"Default Value\": \"By default, data exchanged between containers on\n  different nodes on the overlay network are not encrypted in the Docker swarm\n  mode.\"\n  if attribute('swarm_mode') == 'active'\n    describe 'A manual review is required to ensure data exchanged between containers are encrypted on different nodes on the overlay network' do\n      skip 'A manual review is required to ensure data exchanged between containers are encrypted on different nodes on the overlay network'\n    end\n  else\n    impact 0.0\n    describe 'The docker swarm mode is not being used, therefore this control is N/A' do\n      skip 'The docker swarm mode is not being used, therefore this control is N/A'\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-7.4.rb",
        "line": 1
      },
      "id": "M-7.4"
    },
    {
      "title": "5.24 Ensure cgroup usage is confirmed (Scored)",
      "desc": "It is possible to attach to a particular cgroup on a container run.\n  Confirming cgroup usage would ensure that containers are running under defined cgroups.\n  System administrators typically define cgroups under which containers are\n  supposed to run. Even if cgroups are not explicitly defined by the system\n  administrators, containers run under the docker cgroup by default.\n  At run-time, it is possible to attach to a different cgroup other than the\n  one that was expected to be used. This usage should be monitored and confirmed. By\n  attaching to a different cgroup than the one that is expected, excess permissions and\n  resources might be granted to the container and thus, can prove to be unsafe.",
      "descriptions": {
        "default": "It is possible to attach to a particular cgroup on a container run.\n  Confirming cgroup usage would ensure that containers are running under defined cgroups.\n  System administrators typically define cgroups under which containers are\n  supposed to run. Even if cgroups are not explicitly defined by the system\n  administrators, containers run under the docker cgroup by default.\n  At run-time, it is possible to attach to a different cgroup other than the\n  one that was expected to be used. This usage should be monitored and confirmed. By\n  attaching to a different cgroup than the one that is expected, excess permissions and\n  resources might be granted to the container and thus, can prove to be unsafe."
      },
      "impact": 0,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/reference/run/#specifying-custom-cgroups"
        },
        {
          "url": "https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Resource_Management_Guide/ch01.html"
        }
      ],
      "tags": {
        "ref": "1.\n  https://docs.docker.com/engine/reference/run/#specify-custom-cgroups2.\n  https://access.redhat.com/documentation/enUS/Red_Hat_Enterprise_Linux/6/html/Resource_Management_Guide/ch01.html",
        "severity": "medium",
        "cis_id": "5.24",
        "cis_control": [
          "18",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SI-1",
          "4"
        ],
        "check_text": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: CgroupParent={{ .HostConfig.CgroupParent }}' The above command would\n  return the cgroup under which the containers are running. If it is blank, it\n  means containers are running under the default docker cgroup. In that case,\n  this recommendation is compliant. If the containers are found to be running\n  under a cgroup other than the one that was expected, this recommendation is\n  non-compliant.",
        "fix": "Do not use the --cgroup-parent option in the docker run command unless needed.",
        "Default Value": "By default, containers run under docker cgroup."
      },
      "code": "control 'M-5.24' do\n  title '5.24 Ensure cgroup usage is confirmed (Scored)'\n  desc  \"It is possible to attach to a particular cgroup on a container run.\n  Confirming cgroup usage would ensure that containers are running under defined cgroups.\n  System administrators typically define cgroups under which containers are\n  supposed to run. Even if cgroups are not explicitly defined by the system\n  administrators, containers run under the docker cgroup by default.\n  At run-time, it is possible to attach to a different cgroup other than the\n  one that was expected to be used. This usage should be monitored and confirmed. By\n  attaching to a different cgroup than the one that is expected, excess permissions and\n  resources might be granted to the container and thus, can prove to be unsafe.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  https://docs.docker.com/engine/reference/run/#specify-custom-cgroups2.\n  https://access.redhat.com/documentation/enUS/Red_Hat_Enterprise_Linux/6/html/Resource_Management_Guide/ch01.html\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.24'\n  tag \"cis_control\": ['18', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SI-1', '4']\n  tag \"check_text\": \"docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: CgroupParent={{ .HostConfig.CgroupParent }}' The above command would\n  return the cgroup under which the containers are running. If it is blank, it\n  means containers are running under the default docker cgroup. In that case,\n  this recommendation is compliant. If the containers are found to be running\n  under a cgroup other than the one that was expected, this recommendation is\n  non-compliant.\"\n  tag \"fix\": 'Do not use the --cgroup-parent option in the docker run command unless needed.'\n  tag \"Default Value\": 'By default, containers run under docker cgroup.'\n  ref url: 'https://docs.docker.com/engine/reference/run/#specifying-custom-cgroups'\n  ref url: 'https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Resource_Management_Guide/ch01.html'\n\n  if docker.containers.running?.ids.empty?\n    impact 0.0\n    describe 'There are no running docker containers, therfore this control is N/A' do\n      skip 'There are no running docker containers, therfore this control is N/A'\n    end\n  end\n\n  if !docker.containers.running?.ids.empty?\n    docker.containers.running?.ids.each do |id|\n      describe docker.object(id) do\n        its(%w{HostConfig CgroupParent}) { should be_empty }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.24.rb",
        "line": 1
      },
      "id": "M-5.24"
    },
    {
      "title": "5.13 Ensure incoming container traffic is binded to a specific host interface (Scored)",
      "desc": "By default, Docker containers can make connections to the outside world,\n  but the outside world cannot connect to the containers. Each outgoing connection will appear to\n  originate from one of the host machine's own IP addresses. Only allow container\n  services to be contacted through a specific external interface on the host machine.\n  If you have multiple network interfaces on your host machine, the container\n  can accept connections on the exposed ports on any network interface. This might not\n  be desired and may not be secured. Many a times a particular interface is exposed\n  externally and services such as intrusion detection, intrusion prevention, firewall, load\n  balancing, etc. are run on those interfaces to screen incoming public traffic. Hence, you should not\n  accept incoming connections on any interface. You should only allow incoming connections\n  from a particular external interface.",
      "descriptions": {
        "default": "By default, Docker containers can make connections to the outside world,\n  but the outside world cannot connect to the containers. Each outgoing connection will appear to\n  originate from one of the host machine's own IP addresses. Only allow container\n  services to be contacted through a specific external interface on the host machine.\n  If you have multiple network interfaces on your host machine, the container\n  can accept connections on the exposed ports on any network interface. This might not\n  be desired and may not be secured. Many a times a particular interface is exposed\n  externally and services such as intrusion detection, intrusion prevention, firewall, load\n  balancing, etc. are run on those interfaces to screen incoming public traffic. Hence, you should not\n  accept incoming connections on any interface. You should only allow incoming connections\n  from a particular external interface."
      },
      "impact": 0,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/userguide/networking/default_network/binding/"
        }
      ],
      "tags": {
        "ref": "1. https://docs.docker.com/engine/userguide/networking/",
        "severity": "medium",
        "cis_id": "5.13",
        "cis_control": [
          "9",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SC-7",
          "4"
        ],
        "check_text": "List all the running instances of containers and their port\n  mapping by executing the below command: docker ps --quiet | xargs docker\n  inspect --format '{{ .Id }}: Ports={{.NetworkSettings.Ports }}' Review the\n  list and ensure that the exposed container ports are tied to a\n  particular interface and not to the wildcard IP address - 0.0.0.0. For\n  example, if the above command returns as below, then this is non-compliant and\n  the container can accept connections on any host interface on the specified\n  port 49153. Ports=map[443/tcp:<nil> 80/tcp:[map[HostPort:49153\n  HostIp:0.0.0.0]]] However, if the exposed port is tied to a particular\n  interface on the host as below, then this recommendation is configured as\n  desired and is compliant. Ports=map[443/tcp:<nil> 80/tcp:[map[HostIp:10.2.3.4\n  HostPort:49153]]]",
        "fix": "Bind the container port to a specific host interface on the\n  desired host port. For example, docker run --detach --publish\n  10.2.3.4:49153:80 nginx In the example above, the container port 80 is bound\n  to the host port on 49153 and would accept incoming connection only from\n  10.2.3.4 external interface.",
        "Default Value": "By default, Docker exposes the container ports on\n  0.0.0.0, the wildcard IP address that will match any possible incoming network\n  interface on the host machine."
      },
      "code": "control 'M-5.13' do\n  title '5.13 Ensure incoming container traffic is binded to a specific host interface (Scored)'\n  desc  \"By default, Docker containers can make connections to the outside world,\n  but the outside world cannot connect to the containers. Each outgoing connection will appear to\n  originate from one of the host machine's own IP addresses. Only allow container\n  services to be contacted through a specific external interface on the host machine.\n  If you have multiple network interfaces on your host machine, the container\n  can accept connections on the exposed ports on any network interface. This might not\n  be desired and may not be secured. Many a times a particular interface is exposed\n  externally and services such as intrusion detection, intrusion prevention, firewall, load\n  balancing, etc. are run on those interfaces to screen incoming public traffic. Hence, you should not\n  accept incoming connections on any interface. You should only allow incoming connections\n  from a particular external interface.\n  \"\n  impact 0.5\n  tag \"ref\": '1. https://docs.docker.com/engine/userguide/networking/'\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.13'\n  tag \"cis_control\": ['9', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SC-7', '4']\n  tag \"check_text\": \"List all the running instances of containers and their port\n  mapping by executing the below command: docker ps --quiet | xargs docker\n  inspect --format '{{ .Id }}: Ports={{.NetworkSettings.Ports }}' Review the\n  list and ensure that the exposed container ports are tied to a\n  particular interface and not to the wildcard IP address - 0.0.0.0. For\n  example, if the above command returns as below, then this is non-compliant and\n  the container can accept connections on any host interface on the specified\n  port 49153. Ports=map[443/tcp:<nil> 80/tcp:[map[HostPort:49153\n  HostIp:0.0.0.0]]] However, if the exposed port is tied to a particular\n  interface on the host as below, then this recommendation is configured as\n  desired and is compliant. Ports=map[443/tcp:<nil> 80/tcp:[map[HostIp:10.2.3.4\n  HostPort:49153]]]\"\n  tag \"fix\": \"Bind the container port to a specific host interface on the\n  desired host port. For example, docker run --detach --publish\n  10.2.3.4:49153:80 nginx In the example above, the container port 80 is bound\n  to the host port on 49153 and would accept incoming connection only from\n  10.2.3.4 external interface.\"\n  tag \"Default Value\": \"By default, Docker exposes the container ports on\n  0.0.0.0, the wildcard IP address that will match any possible incoming network\n  interface on the host machine.\"\n  ref url: 'https://docs.docker.com/engine/userguide/networking/default_network/binding/'\n  if !docker.containers.running?.ids.empty?\n    docker.containers.running?.ids.each do |id|\n      container_info = docker.object(id)\n      next if container_info['NetworkSettings']['Ports'].nil?\n\n      container_info['NetworkSettings']['Ports'].each do |_, hosts|\n        if !hosts.nil?\n          hosts.each do |host|\n            describe host['HostIp'].to_i.between?(1, 1024) do\n              it { should_not eq '0.0.0.0' }\n            end\n          end\n        else\n          describe \"There are no docker container port hosts defined for container #{id}, therefore this control is N/A\" do\n            skip \"There are no docker container port hosts defined for container #{id}, therefore this control is N/A\"\n          end\n        end\n      end\n    end\n  else\n    impact 0.0\n    describe 'There are no docker containers running, therefore this control is N/A' do\n      skip 'There are no docker containers running, therefore this control is N/A'\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.13.rb",
        "line": 1
      },
      "id": "M-5.13"
    },
    {
      "title": "4.5 Ensure Content trust for Docker is Enabled (Scored)",
      "desc": "Content trust is disabled by default. You should enable it.\n  Content trust provides the ability to use digital signatures for data sent\n  to and received from remote Docker registries. These signatures allow client-side\n  verification of the integrity and publisher of specific image tags. This ensures provenance of\n  container images.",
      "descriptions": {
        "default": "Content trust is disabled by default. You should enable it.\n  Content trust provides the ability to use digital signatures for data sent\n  to and received from remote Docker registries. These signatures allow client-side\n  verification of the integrity and publisher of specific image tags. This ensures provenance of\n  container images."
      },
      "impact": 0.5,
      "refs": [
        {
          "ref": "https://docs.docker.com/engine/reference/commandline/cli/#notary"
        },
        {
          "ref": "https://docs.docker.com/engine/reference/commandline/cli/#environment-variables"
        },
        {
          "ref": "https://docs.docker.com/engine/security/trust/content_trust/"
        }
      ],
      "tags": {
        "ref": "1.\n  https://docs.docker.com/engine/security/trust/content_trust/2.\n  https://docs.docker.com/engine/reference/commandline/cli/#notary3.\n  https://docs.docker.com/engine/reference/commandline/cli/#environmentvariables",
        "severity": "medium",
        "cis_id": "4.5",
        "cis_control": [
          "18",
          "6.1"
        ],
        "cis_level": "Level 2 - Docker",
        "nist": [
          "SI-1",
          "4"
        ],
        "check_text": "echo $DOCKER_CONTENT_TRUST This should return 1.",
        "fix": "To enable content trust in a bash shell, enter the following\n  command: export DOCKER_CONTENT_TRUST=1 Alternatively, set this environment\n  variable in your profile file so that content trust is nenabled on every\n  login.",
        "Default Value": "By default, content trust is disabled."
      },
      "code": "control 'M-4.5' do\n  title '4.5 Ensure Content trust for Docker is Enabled (Scored)'\n  desc  \"Content trust is disabled by default. You should enable it.\n  Content trust provides the ability to use digital signatures for data sent\n  to and received from remote Docker registries. These signatures allow client-side\n  verification of the integrity and publisher of specific image tags. This ensures provenance of\n  container images.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  https://docs.docker.com/engine/security/trust/content_trust/2.\n  https://docs.docker.com/engine/reference/commandline/cli/#notary3.\n  https://docs.docker.com/engine/reference/commandline/cli/#environmentvariables\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '4.5'\n  tag \"cis_control\": ['18', '6.1']\n  tag \"cis_level\": 'Level 2 - Docker'\n  tag \"nist\": ['SI-1', '4']\n  tag \"check_text\": 'echo $DOCKER_CONTENT_TRUST This should return 1.'\n  tag \"fix\": \"To enable content trust in a bash shell, enter the following\n  command: export DOCKER_CONTENT_TRUST=1 Alternatively, set this environment\n  variable in your profile file so that content trust is nenabled on every\n  login.\"\n  tag \"Default Value\": 'By default, content trust is disabled.'\n  ref 'https://docs.docker.com/engine/reference/commandline/cli/#notary'\n  ref 'https://docs.docker.com/engine/reference/commandline/cli/#environment-variables'\n  ref 'https://docs.docker.com/engine/security/trust/content_trust/'\n\n  describe os_env('DOCKER_CONTENT_TRUST') do\n    its('content') { should eq '1' }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-4.5.rb",
        "line": 1
      },
      "id": "M-4.5"
    },
    {
      "title": "3.2 Ensure that the docker.service file permissions are set to 644 or more restrictive (Scored)",
      "desc": "Verify that the docker.service file permissions are correctly set to 644 or\n  more restrictive. The docker.service file contains sensitive parameters that may alter the\n  behavior of the Docker daemon. Hence, it should not be writable by any other user other than root\n  to maintain the integrity of the file.",
      "descriptions": {
        "default": "Verify that the docker.service file permissions are correctly set to 644 or\n  more restrictive. The docker.service file contains sensitive parameters that may alter the\n  behavior of the Docker daemon. Hence, it should not be writable by any other user other than root\n  to maintain the integrity of the file."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/articles/systemd/",
          "ref": "systemd"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "3.2",
        "cis_control": [
          "14.4",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-3 (3)",
          "4"
        ],
        "check_text": "Step 1: Find out the file location: systemctl show -p\n  FragmentPath docker.service Step 2: If the file does not exist, this\n  recommendation is not applicable. If the file exists, execute the below\n  command with the correct file path to verify that the file permissions are set\n  to 644 or more restrictive. For example, stat -c %a\n  /usr/lib/systemd/system/docker.service",
        "fix": "Step 1: Find out the file location: systemctl show -p\n  FragmentPath docker.service Step 2: If the file does not exist, this\n  recommendation is not applicable. If the file exists, execute the below\n  command with the correct file path to set the file permissions to 644. For\n  example, chmod 644 /usr/lib/systemd/system/docker.service",
        "Default Value": "This file may not be present on the system. In that\n  case, this recommendation is not applicable. By default, if the file is\n  present, the file permissions are correctly set to 644."
      },
      "code": "control 'M-3.2' do\n  title '3.2 Ensure that the docker.service file permissions are set to 644 or more restrictive (Scored)'\n  desc  \"Verify that the docker.service file permissions are correctly set to 644 or\n  more restrictive. The docker.service file contains sensitive parameters that may alter the\n  behavior of the Docker daemon. Hence, it should not be writable by any other user other than root\n  to maintain the integrity of the file.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '3.2'\n  tag \"cis_control\": ['14.4', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-3 (3)', '4']\n  tag \"check_text\": \"Step 1: Find out the file location: systemctl show -p\n  FragmentPath docker.service Step 2: If the file does not exist, this\n  recommendation is not applicable. If the file exists, execute the below\n  command with the correct file path to verify that the file permissions are set\n  to 644 or more restrictive. For example, stat -c %a\n  /usr/lib/systemd/system/docker.service\"\n  tag \"fix\": \"Step 1: Find out the file location: systemctl show -p\n  FragmentPath docker.service Step 2: If the file does not exist, this\n  recommendation is not applicable. If the file exists, execute the below\n  command with the correct file path to set the file permissions to 644. For\n  example, chmod 644 /usr/lib/systemd/system/docker.service\"\n  tag \"Default Value\": \"This file may not be present on the system. In that\n  case, this recommendation is not applicable. By default, if the file is\n  present, the file permissions are correctly set to 644.\"\n  ref 'systemd', url: 'https://docs.docker.com/articles/systemd/'\n  docker_service_file = command('systemctl show -p FragmentPath docker.service').stdout.strip\n\n  equal_sign = docker_service_file.index('=')\n\n  docker_service_file = docker_service_file[equal_sign+1..-1]\n\n  if file(docker_service_file.to_s).exist?\n\n    describe file(docker_service_file.to_s) do\n      it { should exist }\n      it { should be_file }\n      its('mode') { should cmp <= '0644' }\n    end\n\n  else\n    impact 0.0\n    describe 'The docker service file does not exist, therefore this control is N/A' do\n      skip 'The docker service file does not exist, therefore this control is N/A'\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-3.2.rb",
        "line": 1
      },
      "id": "M-3.2"
    },
    {
      "title": "1.8 Ensure auditing is configured for Docker files and directories\n  docker.service (Scored)",
      "desc": "Audit docker.service, if applicable.\n  Apart from auditing your regular Linux file system and system calls, audit\n  all Docker related files and directories. Docker daemon runs with root privileges. Its\n  behavior depends on some key files and directories. docker.service is one such file.\n  The docker.service file might be present if the daemon parameters have been\n  changed by an administrator. It holds various parameters for Docker daemon. It must be\n  audited, if applicable.",
      "descriptions": {
        "default": "Audit docker.service, if applicable.\n  Apart from auditing your regular Linux file system and system calls, audit\n  all Docker related files and directories. Docker daemon runs with root privileges. Its\n  behavior depends on some key files and directories. docker.service is one such file.\n  The docker.service file might be present if the daemon parameters have been\n  changed by an administrator. It holds various parameters for Docker daemon. It must be\n  audited, if applicable."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html",
          "ref": "System auditing"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "1.8",
        "cis_control": [
          "14.6",
          "6.1"
        ],
        "cis_level": "Level 1 - Linux Host OS",
        "nist": [
          "AU-2",
          "4"
        ],
        "check_text": "Step 1: Find out the file location: systemctl show -p\n  FragmentPath docker.service Step 2: If the file does not exist, this\n  recommendation is not applicable. If the file exists, verify that there is an\n  audit rule corresponding to the file: For example, execute the below\n  command: auditctl -l | grep docker.service This should list a rule for\n  docker.service as per its location.",
        "fix": "If the file exists, add a rule for it. For example, Add the\n  line as below in /etc/audit/audit.rules file: -w\n  /usr/lib/systemd/system/docker.service -k docker Then, restart the audit\n  daemon. For example, service auditd restart",
        "Default Value": "By default, Docker related files and directories are\n  not audited. The file docker.service may not be available on the system."
      },
      "code": "control 'M-1.8' do\n  title \"1.8 Ensure auditing is configured for Docker files and directories\n  docker.service (Scored)\"\n  desc  \"Audit docker.service, if applicable.\n  Apart from auditing your regular Linux file system and system calls, audit\n  all Docker related files and directories. Docker daemon runs with root privileges. Its\n  behavior depends on some key files and directories. docker.service is one such file.\n  The docker.service file might be present if the daemon parameters have been\n  changed by an administrator. It holds various parameters for Docker daemon. It must be\n  audited, if applicable.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '1.8'\n  tag \"cis_control\": ['14.6', '6.1']\n  tag \"cis_level\": 'Level 1 - Linux Host OS'\n  tag \"nist\": ['AU-2', '4']\n  tag \"check_text\": \"Step 1: Find out the file location: systemctl show -p\n  FragmentPath docker.service Step 2: If the file does not exist, this\n  recommendation is not applicable. If the file exists, verify that there is an\n  audit rule corresponding to the file: For example, execute the below\n  command: auditctl -l | grep docker.service This should list a rule for\n  docker.service as per its location.\"\n  tag \"fix\": \"If the file exists, add a rule for it. For example, Add the\n  line as below in /etc/audit/audit.rules file: -w\n  /usr/lib/systemd/system/docker.service -k docker Then, restart the audit\n  daemon. For example, service auditd restart\"\n  tag \"Default Value\": \"By default, Docker related files and directories are\n  not audited. The file docker.service may not be available on the system.\"\n  ref 'System auditing', url: 'https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html'\n  docker_service_file = command('systemctl show -p FragmentPath docker.service').stdout.strip\n\n  equal_sign = docker_service_file.index('=')\n\n  docker_service_file = docker_service_file[equal_sign+1..-1]\n\n  if file(docker_service_file.to_s).exist?\n\n    describe auditd  do\n      its('lines') { should include \"-w #{docker_service_file} -k docker\" }\n    end\n\n  else\n    impact 0.0\n    describe 'The docker service file does not exist, therefore this control is N/A' do\n      skip 'The docker service file does not exist, therefore this control is N/A'\n    end\n  end\n\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-1.8.rb",
        "line": 1
      },
      "id": "M-1.8"
    },
    {
      "title": "3.9 Ensure that TLS CA certificate file ownership is set to\n  root:root(Scored)",
      "desc": "Verify that the TLS CA certificate file (the file that is passed along with the\n  --tlscacert parameter) is owned and group-owned by root.\n  The TLS CA certificate file should be protected from any tampering. It is\n  used to authenticate the Docker server based on given CA certificate. Hence, it must be\n  owned and group-owned by root to maintain the integrity of the CA certificate.",
      "descriptions": {
        "default": "Verify that the TLS CA certificate file (the file that is passed along with the\n  --tlscacert parameter) is owned and group-owned by root.\n  The TLS CA certificate file should be protected from any tampering. It is\n  used to authenticate the Docker server based on given CA certificate. Hence, it must be\n  owned and group-owned by root to maintain the integrity of the CA certificate."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/security/certificates/"
        },
        {
          "url": "https://docs.docker.com/engine/security/https/"
        }
      ],
      "tags": {
        "ref": "1. https://docs.docker.com/registry/insecure/2.\n  https://docs.docker.com/engine/security/https/",
        "severity": "medium",
        "cis_id": "3.9",
        "cis_control": [
          "5.1",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-6(9)",
          "4"
        ],
        "check_text": "Execute the below command to verify that the TLS CA certificate\n  file is owned and group owned by root: stat -c %U:%G <path to the TLS CA\n  certificate file> | grep -v root:root The above command should not return\n  anything.",
        "fix": "chown root:root <path to the TLS CA certificate file> This would set\n  the ownership and group-ownership for the TLS CA certificate file to root.",
        "Default Value": "By default, the ownership and group-ownership for the TLS\n  CA certificate file is correctly set to root."
      },
      "code": "control 'M-3.9' do\n  title \"3.9 Ensure that TLS CA certificate file ownership is set to\n  root:root(Scored)\"\n  desc \"Verify that the TLS CA certificate file (the file that is passed along with the\n  --tlscacert parameter) is owned and group-owned by root.\n  The TLS CA certificate file should be protected from any tampering. It is\n  used to authenticate the Docker server based on given CA certificate. Hence, it must be\n  owned and group-owned by root to maintain the integrity of the CA certificate.\n  \"\n  impact 0.5\n  tag \"ref\": \"1. https://docs.docker.com/registry/insecure/2.\n  https://docs.docker.com/engine/security/https/\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '3.9'\n  tag \"cis_control\": ['5.1', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-6(9)', '4']\n  tag \"check_text\": \"Execute the below command to verify that the TLS CA certificate\n  file is owned and group owned by root: stat -c %U:%G <path to the TLS CA\n  certificate file> | grep -v root:root The above command should not return\n  anything.\"\n  tag \"fix\": \"chown root:root <path to the TLS CA certificate file> This would set\n  the ownership and group-ownership for the TLS CA certificate file to root.\"\n  tag \"Default Value\": \"By default, the ownership and group-ownership for the TLS\n  CA certificate file is correctly set to root.\"\n  ref url: 'https://docs.docker.com/engine/security/certificates/'\n  ref url: 'https://docs.docker.com/engine/security/https/'\n\n  json('/etc/docker/daemon.json').params['tlscacert']\n\n  describe file(json('/etc/docker/daemon.json').params['tlscacert']) do\n    it { should exist }\n    it { should be_file }\n    it { should be_owned_by 'root' }\n    it { should be_grouped_into 'root' }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-3.9.rb",
        "line": 1
      },
      "id": "M-3.9"
    },
    {
      "title": "5.7 Ensure privileged ports are not mapped within containers (Scored)",
      "desc": "The TCP/IP port numbers below 1024 are considered privileged ports. Normal\n  users and processes are not allowed to use them for various security reasons. Docker\n  allows a container port to be mapped to a privileged port.\n  By default, if the user does not specifically declare the container port to\n  host port mapping, Docker automatically and correctly maps the container port to one available\n  in the 4915365535 block on the host. But, Docker allows a container port to be\n  mapped to a privileged port on the host if the user explicitly declared it. This is so because\n  containers are executed with the NET_BIND_SERVICE Linux kernel capability that does not restrict the\n  privileged port mapping. The privileged ports receive and transmit various sensitive and\n  privileged data. Allowing containers to use them can bring serious implications.",
      "descriptions": {
        "default": "The TCP/IP port numbers below 1024 are considered privileged ports. Normal\n  users and processes are not allowed to use them for various security reasons. Docker\n  allows a container port to be mapped to a privileged port.\n  By default, if the user does not specifically declare the container port to\n  host port mapping, Docker automatically and correctly maps the container port to one available\n  in the 4915365535 block on the host. But, Docker allows a container port to be\n  mapped to a privileged port on the host if the user explicitly declared it. This is so because\n  containers are executed with the NET_BIND_SERVICE Linux kernel capability that does not restrict the\n  privileged port mapping. The privileged ports receive and transmit various sensitive and\n  privileged data. Allowing containers to use them can bring serious implications."
      },
      "impact": 0,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/userguide/networking/default_network/binding/"
        },
        {
          "url": "https://www.adayinthelifeof.nl/2012/03/12/why-putting-ssh-on-another-port-than-22-is-bad-idea/"
        }
      ],
      "tags": {
        "ref": "1. https://docs.docker.com/engine/userguide/networking/",
        "severity": "medium",
        "cis_id": "5.7",
        "cis_control": [
          "9.1",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "CM-7(1)",
          "4"
        ],
        "check_text": "List all running containers instances and their port mapping by\n  executing the below command: docker ps --quiet | xargs docker inspect\n  --format '{{ .Id }}: Ports={{.NetworkSettings.Ports }}'Review the list and\n  ensure that container ports are not mapped to host port numbers below 1024.",
        "fix": "Do not map the container ports to privileged host ports when\n  starting a container. Also, ensure that there is no such container to host\n  privileged port mapping declarations in the Dockerfile.",
        "Default Value": "By default, mapping a container port to a privileged\n  port on the host is allowed. Note: There might be certain cases where you want\n  to map privileged ports, because if you forbid it, then the corresponding\n  application has to run outside of a container. For example: HTTP and HTTPS\n  load balancers have to bind 80/tcp and 443/tcp respectively. Forbidding to map\n  privileged ports effectively forbids from running those in a container, and\n  mandates using an external load balancer. In such cases, those\n  containers instances should be marked as exceptions for this recommendation."
      },
      "code": "control 'M-5.7' do\n  title '5.7 Ensure privileged ports are not mapped within containers (Scored)'\n  desc  \"The TCP/IP port numbers below 1024 are considered privileged ports. Normal\n  users and processes are not allowed to use them for various security reasons. Docker\n  allows a container port to be mapped to a privileged port.\n  By default, if the user does not specifically declare the container port to\n  host port mapping, Docker automatically and correctly maps the container port to one available\n  in the 4915365535 block on the host. But, Docker allows a container port to be\n  mapped to a privileged port on the host if the user explicitly declared it. This is so because\n  containers are executed with the NET_BIND_SERVICE Linux kernel capability that does not restrict the\n  privileged port mapping. The privileged ports receive and transmit various sensitive and\n  privileged data. Allowing containers to use them can bring serious implications.\n  \"\n  impact 0.5\n  tag \"ref\": '1. https://docs.docker.com/engine/userguide/networking/'\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.7'\n  tag \"cis_control\": ['9.1', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['CM-7(1)', '4']\n  tag \"check_text\": \"List all running containers instances and their port mapping by\n  executing the below command: docker ps --quiet | xargs docker inspect\n  --format '{{ .Id }}: Ports={{.NetworkSettings.Ports }}'Review the list and\n  ensure that container ports are not mapped to host port numbers below 1024.\"\n  tag \"fix\": \"Do not map the container ports to privileged host ports when\n  starting a container. Also, ensure that there is no such container to host\n  privileged port mapping declarations in the Dockerfile.\"\n  tag \"Default Value\": \"By default, mapping a container port to a privileged\n  port on the host is allowed. Note: There might be certain cases where you want\n  to map privileged ports, because if you forbid it, then the corresponding\n  application has to run outside of a container. For example: HTTP and HTTPS\n  load balancers have to bind 80/tcp and 443/tcp respectively. Forbidding to map\n  privileged ports effectively forbids from running those in a container, and\n  mandates using an external load balancer. In such cases, those\n  containers instances should be marked as exceptions for this recommendation.\"\n  ref url: 'https://docs.docker.com/engine/userguide/networking/default_network/binding/'\n  ref url: 'https://www.adayinthelifeof.nl/2012/03/12/why-putting-ssh-on-another-port-than-22-is-bad-idea/'\n\n  if !docker.containers.running?.ids.empty?\n    docker.containers.running?.ids.each do |id|\n      container_info = docker.object(id)\n      next if container_info['NetworkSettings']['Ports'].nil?\n\n      container_info['NetworkSettings']['Ports'].each do |_, hosts|\n        if !hosts.nil?\n          hosts.each do |host|\n            describe host['HostPort'].to_i.between?(1, 1024) do\n              it { should eq false }\n            end\n          end\n        else\n          describe 'There are no docker container port hosts defined, therefore this control is N/A' do\n            skip 'There are no docker container port hosts defined, therefore this control is N/A'\n          end\n        end\n      end\n    end\n  else\n    impact 0.0\n    describe 'There are no docker containers running, therefore this control is N/A' do\n      skip 'There are no docker containers running, therefore this control is N/A'\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.7.rb",
        "line": 1
      },
      "id": "M-5.7"
    },
    {
      "title": "6.2 Ensure container sprawl is avoided (Not Scored)",
      "desc": "Do not keep a large number of containers on the same host.\n  The flexibility of containers makes it easy to run multiple instances of\n  applications and indirectly leads to Docker images that exist at varying security patch\n  levels. It also means that you are consuming host resources that otherwise could have been used\n  for running 'useful' containers. Having more than just the manageable number of\n  containers on a particular host makes the situation vulnerable to mishandling,\n  misconfiguration and fragmentation. Thus, avoid container sprawl and keep the number of\n  containers on a host to a manageable total.",
      "descriptions": {
        "default": "Do not keep a large number of containers on the same host.\n  The flexibility of containers makes it easy to run multiple instances of\n  applications and indirectly leads to Docker images that exist at varying security patch\n  levels. It also means that you are consuming host resources that otherwise could have been used\n  for running 'useful' containers. Having more than just the manageable number of\n  containers on a particular host makes the situation vulnerable to mishandling,\n  misconfiguration and fragmentation. Thus, avoid container sprawl and keep the number of\n  containers on a host to a manageable total."
      },
      "impact": 0.5,
      "refs": [
        {
          "ref": "https://zeltser.com/security-risks-and-benefits-of-docker-application/"
        },
        {
          "ref": "http://searchsdn.techtarget.com/feature/Docker-networking-How-Linux-containers-will-change-your-network"
        }
      ],
      "tags": {
        "ref": "1.\n  https://zeltser.com/security-risks-and-benefits-of-docker-application/2.\n  http://searchsdn.techtarget.com/feature/Docker-networking-How-Linuxcontainers-will-change-your-network",
        "severity": "medium",
        "cis_id": "6.2",
        "cis_control": [
          "18",
          "6.1"
        ],
        "cis_level": "Level 1 - Linux Host OS",
        "nist": [
          "SI-1",
          "4"
        ],
        "check_text": "Step 1 - Find the total number of containers you have on the\n  host: docker info --format '{{ .Containers }}' Step 2 - Execute the below\n  commands to find the total number of containers that are actually running or\n  in the stopped state on the host. docker info --format '{{ .ContainersStopped\n  }}' docker info --format '{{ .ContainersRunning }}' If the difference between\n  the number of containers that are stopped on the host and the number of\n  containers that are actually running on the host is large (say 25 or more),\n  then perhaps, the containers are sprawled on the host.",
        "fix": "Periodically check your container inventory per host and clean up\n  the stopped containers using the below command: docker container prune",
        "Default Value": "By default, Docker does not restrict the number of\n  containers you may have on a host."
      },
      "code": "control 'M-6.2' do\n  title '6.2 Ensure container sprawl is avoided (Not Scored)'\n  desc  \"Do not keep a large number of containers on the same host.\n  The flexibility of containers makes it easy to run multiple instances of\n  applications and indirectly leads to Docker images that exist at varying security patch\n  levels. It also means that you are consuming host resources that otherwise could have been used\n  for running 'useful' containers. Having more than just the manageable number of\n  containers on a particular host makes the situation vulnerable to mishandling,\n  misconfiguration and fragmentation. Thus, avoid container sprawl and keep the number of\n  containers on a host to a manageable total.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  https://zeltser.com/security-risks-and-benefits-of-docker-application/2.\n  http://searchsdn.techtarget.com/feature/Docker-networking-How-Linuxcontainers-will-change-your-network\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '6.2'\n  tag \"cis_control\": ['18', '6.1']\n  tag \"cis_level\": 'Level 1 - Linux Host OS'\n  tag \"nist\": ['SI-1', '4']\n  tag \"check_text\": \"Step 1 - Find the total number of containers you have on the\n  host: docker info --format '{{ .Containers }}' Step 2 - Execute the below\n  commands to find the total number of containers that are actually running or\n  in the stopped state on the host. docker info --format '{{ .ContainersStopped\n  }}' docker info --format '{{ .ContainersRunning }}' If the difference between\n  the number of containers that are stopped on the host and the number of\n  containers that are actually running on the host is large (say 25 or more),\n  then perhaps, the containers are sprawled on the host.\"\n  tag \"fix\": \"Periodically check your container inventory per host and clean up\n  the stopped containers using the below command: docker container prune\"\n  tag \"Default Value\": \"By default, Docker does not restrict the number of\n  containers you may have on a host.\"\n  ref 'https://zeltser.com/security-risks-and-benefits-of-docker-application/'\n  ref 'http://searchsdn.techtarget.com/feature/Docker-networking-How-Linux-containers-will-change-your-network'\n\n  total_on_host = command('docker info').stdout.split[1].to_i\n  total_running = command('docker ps -q').stdout.split.length\n  diff = total_on_host - total_running\n\n  describe diff do\n    it { should be <= attribute('managable_container_number') }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-6.2.rb",
        "line": 1
      },
      "id": "M-6.2"
    },
    {
      "title": "3.17 Ensure that the daemon.json file ownership is set to root:root(Scored)",
      "desc": "Verify that the daemon.json file ownership and group-ownership is correctly set to root.\n  The daemon.json file contains sensitive parameters that may alter the behavior of the docker\n  daemon. Hence, it should be owned and group-owned by root to maintain the integrity of the file.",
      "descriptions": {
        "default": "Verify that the daemon.json file ownership and group-ownership is correctly set to root.\n  The daemon.json file contains sensitive parameters that may alter the behavior of the docker\n  daemon. Hence, it should be owned and group-owned by root to maintain the integrity of the file."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/reference/commandline/daemon/#daemon-configuration-file"
        }
      ],
      "tags": {
        "ref": "1.\n  https://docs.docker.com/engine/reference/commandline/dockerd/#daemonconfiguration-file",
        "severity": "medium",
        "cis_id": "3.17",
        "cis_control": [
          "5.1",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-6(9)",
          "4"
        ],
        "check_text": "Execute the below command to verify that the file is owned and\n  group-owned by root: stat -c %U:%G /etc/docker/daemon.json | grep -v\n  root:root The above command should not return anything.",
        "fix": "chown root:root /etc/docker/daemon.json This would set the\n  ownership and group-ownership for the file to root.",
        "Default Value": "This file may not be present on the system. In that\n  case, this recommendation is not applicable."
      },
      "code": "control 'M-3.17' do\n  title '3.17 Ensure that the daemon.json file ownership is set to root:root(Scored)'\n  desc  \"Verify that the daemon.json file ownership and group-ownership is correctly set to root.\n  The daemon.json file contains sensitive parameters that may alter the behavior of the docker\n  daemon. Hence, it should be owned and group-owned by root to maintain the integrity of the file.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  https://docs.docker.com/engine/reference/commandline/dockerd/#daemonconfiguration-file\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '3.17'\n  tag \"cis_control\": ['5.1', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-6(9)', '4']\n  tag \"check_text\": \"Execute the below command to verify that the file is owned and\n  group-owned by root: stat -c %U:%G /etc/docker/daemon.json | grep -v\n  root:root The above command should not return anything.\"\n  tag \"fix\": \"chown root:root /etc/docker/daemon.json This would set the\n  ownership and group-ownership for the file to root.\"\n  tag \"Default Value\": \"This file may not be present on the system. In that\n  case, this recommendation is not applicable.\"\n  ref url: 'https://docs.docker.com/engine/reference/commandline/daemon/#daemon-configuration-file'\n\n  describe file('/etc/docker/daemon.json') do\n    it { should exist }\n    it { should be_file }\n    it { should be_owned_by 'root' }\n    it { should be_grouped_into 'root' }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-3.17.rb",
        "line": 1
      },
      "id": "M-3.17"
    },
    {
      "title": "4.7 Ensure update instructions are not use alone in the Dockerfile (Not Scored)",
      "desc": "Do not use update instructions such as apt-get update alone or in a single\n  line in the Dockerfile.\n  Adding the update instructions in a single line on the Dockerfile will\n  cache the update layer. Thus, when you build any image later using the same instruction,\n  previously cached update layer will be used.\n  This could potentially deny any fresh updates to go in the later builds.",
      "descriptions": {
        "default": "Do not use update instructions such as apt-get update alone or in a single\n  line in the Dockerfile.\n  Adding the update instructions in a single line on the Dockerfile will\n  cache the update layer. Thus, when you build any image later using the same instruction,\n  previously cached update layer will be used.\n  This could potentially deny any fresh updates to go in the later builds."
      },
      "impact": 0,
      "refs": [],
      "tags": {
        "severity": "medium",
        "cis_id": "4.7",
        "cis_control": [
          "18",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SI-1",
          "4"
        ],
        "check_text": "Step 1: Run the below command to get the list of\n  images: docker images Step 2: Run the below command for each image in the\n  list above, and look for any update instructions being in a single\n  line: docker history Image_ID Alternatively, if you have access to the\n  Dockerfile for the image, verify that there are no update instructions as\n  described above.",
        "fix": "Use update instructions along with install instructions (or any\n  other) and version pinning for packages while installing them. This would bust\n  the cache and force to extract the required versions. Alternatively, you\n  could use no-cache flag during docker build process to avoid using cached\n  layers.",
        "Default Value": "By default, docker does not enforce any restrictions on\n  using update instructions."
      },
      "code": "control 'M-4.7' do\n  title '4.7 Ensure update instructions are not use alone in the Dockerfile (Not Scored)'\n  desc  \"Do not use update instructions such as apt-get update alone or in a single\n  line in the Dockerfile.\n  Adding the update instructions in a single line on the Dockerfile will\n  cache the update layer. Thus, when you build any image later using the same instruction,\n  previously cached update layer will be used.\n  This could potentially deny any fresh updates to go in the later builds.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '4.7'\n  tag \"cis_control\": ['18', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SI-1', '4']\n  tag \"check_text\": \"Step 1: Run the below command to get the list of\n  images: docker images Step 2: Run the below command for each image in the\n  list above, and look for any update instructions being in a single\n  line: docker history Image_ID Alternatively, if you have access to the\n  Dockerfile for the image, verify that there are no update instructions as\n  described above.\"\n  tag \"fix\": \"Use update instructions along with install instructions (or any\n  other) and version pinning for packages while installing them. This would bust\n  the cache and force to extract the required versions. Alternatively, you\n  could use no-cache flag during docker build process to avoid using cached\n  layers.\"\n  tag \"Default Value\": \"By default, docker does not enforce any restrictions on\n  using update instructions.\"\n\n  if docker.images.ids.empty?\n    impact 0.0\n    describe 'There are no running docker containers, therfore this control is N/A' do\n      skip 'There are no running docker containers, therfore this control is N/A'\n    end\n  end\n\n  if !docker.images.ids.empty?\n    docker.images.ids.each do |id|\n      describe command(`docker history #{id} | grep 'update'`) do\n        its('stdout') { should eq '' }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-4.7.rb",
        "line": 1
      },
      "id": "M-4.7"
    },
    {
      "title": "1.9 Ensure auditing is configured for Docker files and directories\n  docker.socket (Scored)",
      "desc": "Audit docker.socket, if applicable.\nApart from auditing your regular Linux file system and system calls, audit\nall Docker related files and directories. Docker daemon runs with root privileges. Its\nbehavior depends on some key files and directories. docker.socket is one such file.\nIt holds various parameters for Docker daemon socket. It must be audited, if applicable.",
      "descriptions": {
        "default": "Audit docker.socket, if applicable.\nApart from auditing your regular Linux file system and system calls, audit\nall Docker related files and directories. Docker daemon runs with root privileges. Its\nbehavior depends on some key files and directories. docker.socket is one such file.\nIt holds various parameters for Docker daemon socket. It must be audited, if applicable."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html",
          "ref": "System auditing"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "1.9",
        "cis_control": [
          "14.6",
          "6.1"
        ],
        "cis_level": "Level 1 - Linux Host OS",
        "nist": [
          "AU-2",
          "4"
        ],
        "check_text": "Step 1: Find out the file location: systemctl show -p\n  FragmentPath docker.socket Step 2: If the file does not exist, this\n  recommendation is not applicable. If the file exists, verify that there is an\n  audit rule corresponding to the file: For example, execute the below\n  command: auditctl -l | grep docker.socket This should list a rule for\n  docker.socket as per its location.",
        "fix": "If the file exists, add a rule for it. For example, Add the\n  line as below in /etc/audit/audit.rules file: -w\n  /usr/lib/systemd/system/docker.socket -k docker Then, restart the audit\n  daemon. For example, service auditd restart",
        "Default Value": "By default, Docker related files and directories are\n  not audited. The file docker.socket may not be available on the system."
      },
      "code": "control 'M-1.9' do\n  title \"1.9 Ensure auditing is configured for Docker files and directories\n  docker.socket (Scored)\"\n  desc  \"\n  Audit docker.socket, if applicable.\n  Apart from auditing your regular Linux file system and system calls, audit\n  all Docker related files and directories. Docker daemon runs with root privileges. Its\n  behavior depends on some key files and directories. docker.socket is one such file.\n  It holds various parameters for Docker daemon socket. It must be audited, if applicable.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '1.9'\n  tag \"cis_control\": ['14.6', '6.1']\n  tag \"cis_level\": 'Level 1 - Linux Host OS'\n  tag \"nist\": ['AU-2', '4']\n  tag \"check_text\": \"Step 1: Find out the file location: systemctl show -p\n  FragmentPath docker.socket Step 2: If the file does not exist, this\n  recommendation is not applicable. If the file exists, verify that there is an\n  audit rule corresponding to the file: For example, execute the below\n  command: auditctl -l | grep docker.socket This should list a rule for\n  docker.socket as per its location.\"\n  tag \"fix\": \"If the file exists, add a rule for it. For example, Add the\n  line as below in /etc/audit/audit.rules file: -w\n  /usr/lib/systemd/system/docker.socket -k docker Then, restart the audit\n  daemon. For example, service auditd restart\"\n  tag \"Default Value\": \"By default, Docker related files and directories are\n  not audited. The file docker.socket may not be available on the system.\"\n  ref 'System auditing', url: 'https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html'\n\n  docker_socket_file = command('systemctl show -p FragmentPath docker.socket').stdout.strip\n\n  equal_sign = docker_socket_file.index('=')\n\n  docker_socket_file = docker_socket_file[equal_sign+1..-1]\n\n  if file(docker_socket_file.to_s).exist?\n\n    describe auditd  do\n      its('lines') { should include \"-w #{docker_socket_file} -k docker\" }\n    end\n\n  else\n    impact 0.0\n    describe 'The docker socket file does not exist, therefore this control is N/A' do\n      skip 'The docker socket file does not exist, therefore this control is N/A'\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-1.9.rb",
        "line": 1
      },
      "id": "M-1.9"
    },
    {
      "title": "2.2 Ensure the logging level is set to 'info' (Scored)",
      "desc": "Set Docker daemon log level to info.\n  Setting up an appropriate log level, configures the Docker daemon to log events that you would want to review later.\n  A base log level of info and above would capture all logs except debug logs.\n  Until and unless required, you should not run Docker daemon at debug log level.",
      "descriptions": {
        "default": "Set Docker daemon log level to info.\n  Setting up an appropriate log level, configures the Docker daemon to log events that you would want to review later.\n  A base log level of info and above would capture all logs except debug logs.\n  Until and unless required, you should not run Docker daemon at debug log level."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/edge/engine/reference/commandline/dockerd/",
          "ref": "dockerd"
        },
        {
          "url": "https://docs.docker.com/engine/reference/commandline/daemon/",
          "ref": "Docker daemon"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "2.1",
        "cis_control": [
          "6.2",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AU-3",
          "4"
        ],
        "check_text": "ps -ef | grep docker\n  Ensure that either the --log-level parameter is not present or if present, then it is set to info.",
        "fix": "Run the Docker daemon as below: dockerd --log-level=\"info\"",
        "Default Value": "By default, Docker daemon is set to log level of info."
      },
      "code": "control 'M-2.2' do\n  title \"2.2 Ensure the logging level is set to 'info' (Scored)\"\n  desc  \"Set Docker daemon log level to info.\n  Setting up an appropriate log level, configures the Docker daemon to log events that you would want to review later.\n  A base log level of info and above would capture all logs except debug logs.\n  Until and unless required, you should not run Docker daemon at debug log level.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '2.1'\n  tag \"cis_control\": ['6.2', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AU-3', '4']\n  tag \"check_text\": \"ps -ef | grep docker\n  Ensure that either the --log-level parameter is not present or if present, then it is set to info.\"\n  tag \"fix\": 'Run the Docker daemon as below: dockerd --log-level=\"info\"'\n  tag \"Default Value\": 'By default, Docker daemon is set to log level of info.'\n  ref 'dockerd', url: 'https://docs.docker.com/edge/engine/reference/commandline/dockerd/'\n  ref 'Docker daemon', url: 'https://docs.docker.com/engine/reference/commandline/daemon/'\n\n  describe json('/etc/docker/daemon.json') do\n    its(['log-level']) { should eq('info') }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-2.2.rb",
        "line": 1
      },
      "id": "M-2.2"
    },
    {
      "title": "2.12 Ensure centralized and remote logging is configured (Scored)",
      "desc": "Docker now supports various log drivers. A preferable way to store logs is\n  the one that supports centralized and remote logging.\n  Centralized and remote logging ensures that all important log records are\n  safe despite catastrophic events. Docker now supports various such logging drivers. Use\n  the one that suits your environment the best.",
      "descriptions": {
        "default": "Docker now supports various log drivers. A preferable way to store logs is\n  the one that supports centralized and remote logging.\n  Centralized and remote logging ensures that all important log records are\n  safe despite catastrophic events. Docker now supports various such logging drivers. Use\n  the one that suits your environment the best."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/admin/logging/overview/",
          "ref": "Logging overview"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "2.12",
        "cis_control": [
          "6.6",
          "6.1"
        ],
        "cis_level": "Level 2 - Docker",
        "nist": [
          "SI-4(2)",
          "4"
        ],
        "check_text": "Run docker info and ensure that the LoggingDriver property is set\n  as appropriate. docker info --format '{{ .LoggingDriver }}' Alternatively,\n  the below command would give you the --log-driver setting, if\n  configured. Ensure that it is set as appropriate. ps -ef | grep dockerd",
        "fix": "Step 1: Setup the desired log driver by following its\n  documentation. Step 2: Start the docker daemon with that logging driver. For\n  example, dockerd --log-driver=syslog --log-opt\n  syslog-address=tcp://192.xxx.xxx.xxx",
        "Default Value": "By default, container logs are maintained as json\n  files"
      },
      "code": "control 'M-2.12' do\n  title '2.12 Ensure centralized and remote logging is configured (Scored)'\n  desc  \"Docker now supports various log drivers. A preferable way to store logs is\n  the one that supports centralized and remote logging.\n  Centralized and remote logging ensures that all important log records are\n  safe despite catastrophic events. Docker now supports various such logging drivers. Use\n  the one that suits your environment the best.\"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '2.12'\n  tag \"cis_control\": ['6.6', '6.1']\n  tag \"cis_level\": 'Level 2 - Docker'\n  tag \"nist\": ['SI-4(2)', '4']\n  tag \"check_text\": \"Run docker info and ensure that the LoggingDriver property is set\n  as appropriate. docker info --format '{{ .LoggingDriver }}' Alternatively,\n  the below command would give you the --log-driver setting, if\n  configured. Ensure that it is set as appropriate. ps -ef | grep dockerd\"\n  tag \"fix\": \"Step 1: Setup the desired log driver by following its\n  documentation. Step 2: Start the docker daemon with that logging driver. For\n  example, dockerd --log-driver=syslog --log-opt\n  syslog-address=tcp://192.xxx.xxx.xxx\"\n  tag \"Default Value\": \"By default, container logs are maintained as json\n  files\"\n  ref 'Logging overview', url: 'https://docs.docker.com/engine/admin/logging/overview/'\n\n  describe json('/etc/docker/daemon.json') do\n    its(['log-driver']) { should_not be_empty }\n    its(['log-driver']) { should eq attribute('log_driver') }\n    its(['log-opts']) { should include attribute('log_opts') }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-2.12.rb",
        "line": 1
      },
      "id": "M-2.12"
    },
    {
      "title": "4.6 Ensure HEALTHCHECK instructions have been added to the container image (Scored)",
      "desc": "Add HEALTHCHECK instruction in your docker container images to perform the\n  health check on running containers. One of the important security triads is availability.\n  Adding HEALTHCHECK instruction to your container image ensures that the docker engine\n  periodically checks the running container instances against that instruction to ensure\n  that the instances are still working.\n  Based on the reported health status, the docker engine could then exit\n  non-working containers and instantiate new ones.",
      "descriptions": {
        "default": "Add HEALTHCHECK instruction in your docker container images to perform the\n  health check on running containers. One of the important security triads is availability.\n  Adding HEALTHCHECK instruction to your container image ensures that the docker engine\n  periodically checks the running container instances against that instruction to ensure\n  that the instances are still working.\n  Based on the reported health status, the docker engine could then exit\n  non-working containers and instantiate new ones."
      },
      "impact": 0,
      "refs": [],
      "tags": {
        "ref": "1. https://docs.docker.com/engine/reference/builder/#healthcheck",
        "severity": "medium",
        "cis_id": "4.6",
        "cis_control": [
          "18",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SI-1",
          "4"
        ],
        "check_text": "Run the below command and ensure that the docker image has\n  appropriate HEALTHCHECK instruction set up. docker inspect --format='{{\n  .Config.Healthcheck }}' <IMAGE>",
        "fix": "Follow Docker documentation and rebuild your container image with\n  HEALTHCHECK instruction.",
        "Default Value": "By default, HEALTHCHECK is not set."
      },
      "code": "control 'M-4.6' do\n  title '4.6 Ensure HEALTHCHECK instructions have been added to the container image (Scored)'\n  desc  \"Add HEALTHCHECK instruction in your docker container images to perform the\n  health check on running containers. One of the important security triads is availability.\n  Adding HEALTHCHECK instruction to your container image ensures that the docker engine\n  periodically checks the running container instances against that instruction to ensure\n  that the instances are still working.\n  Based on the reported health status, the docker engine could then exit\n  non-working containers and instantiate new ones.\n  \"\n  impact 0.5\n  tag \"ref\": '1. https://docs.docker.com/engine/reference/builder/#healthcheck'\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '4.6'\n  tag \"cis_control\": ['18', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SI-1', '4']\n  tag \"check_text\": \"Run the below command and ensure that the docker image has\n  appropriate HEALTHCHECK instruction set up. docker inspect --format='{{\n  .Config.Healthcheck }}' <IMAGE>\"\n  tag \"fix\": \"Follow Docker documentation and rebuild your container image with\n  HEALTHCHECK instruction.\"\n  tag \"Default Value\": 'By default, HEALTHCHECK is not set.'\n\n  if docker.containers.running?.ids.empty?\n    impact 0.0\n    describe 'There are no running docker containers, therfore this control is N/A' do\n      skip 'There are no running docker containers, therfore this control is N/A'\n    end\n  end\n\n  if !docker.containers.running?.ids.empty?\n    docker.containers.running?.ids.each do |id|\n      describe docker.object(id) do\n        its(%w{Config Healthcheck}) { should_not eq nil }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-4.6.rb",
        "line": 1
      },
      "id": "M-4.6"
    },
    {
      "title": "5.28 Ensure PIDs cgroup limit is used (Scored)",
      "desc": "Use the --pids-limit flag at container runtime.\n  Attackers could launch a fork bomb with a single command inside the\n  container. This fork bomb can crash the entire system and requires a restart of the host to make\n  the system functional again. The PIDs cgroup --pids-limit will prevent this kind of\n  attack by restricting the number of forks that can happen inside a container at a given time.",
      "descriptions": {
        "default": "Use the --pids-limit flag at container runtime.\n  Attackers could launch a fork bomb with a single command inside the\n  container. This fork bomb can crash the entire system and requires a restart of the host to make\n  the system functional again. The PIDs cgroup --pids-limit will prevent this kind of\n  attack by restricting the number of forks that can happen inside a container at a given time."
      },
      "impact": 0,
      "refs": [],
      "tags": {
        "ref": "1. https://github.com/docker/docker/pull/186972.\n  https://docs.docker.com/engine/reference/commandline/run/#options",
        "severity": "medium",
        "cis_id": "5.28",
        "cis_control": [
          "18",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SI-1",
          "4"
        ],
        "check_text": "Run the below command and ensure that PidsLimit is not set to 0\n  or -1. A PidsLimit of 0 or -1 means that any number of processes can be forked\n  inside the container concurrently. docker ps --quiet --all | xargs docker\n  inspect --format '{{ .Id }}: PidsLimit={{ .HostConfig.PidsLimit }}'",
        "fix": "Use the --pids-limit flag while launching the container with an\n  appropriate value. For example, docker run -it --pids-limit 100\n  <Image_ID> In the above example, the number of processes allowed to run at any\n  given time is set to 100. After a limit of 100 concurrently running processes\n  is reached, docker would restrict any new process creation.",
        "Default Value": "The Default value for the --pids-limit is 0 which means\n  there is no restriction on the number of forks. Also, note that the PIDs cgroup\n  limit works only for the kernel versions 4.3+."
      },
      "code": "control 'M-5.28' do\n  title '5.28 Ensure PIDs cgroup limit is used (Scored)'\n  desc  \"Use the --pids-limit flag at container runtime.\n  Attackers could launch a fork bomb with a single command inside the\n  container. This fork bomb can crash the entire system and requires a restart of the host to make\n  the system functional again. The PIDs cgroup --pids-limit will prevent this kind of\n  attack by restricting the number of forks that can happen inside a container at a given time.\n  \"\n  impact 0.5\n  tag \"ref\": \"1. https://github.com/docker/docker/pull/186972.\n  https://docs.docker.com/engine/reference/commandline/run/#options\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.28'\n  tag \"cis_control\": ['18', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SI-1', '4']\n  tag \"check_text\": \"Run the below command and ensure that PidsLimit is not set to 0\n  or -1. A PidsLimit of 0 or -1 means that any number of processes can be forked\n  inside the container concurrently. docker ps --quiet --all | xargs docker\n  inspect --format '{{ .Id }}: PidsLimit={{ .HostConfig.PidsLimit }}'\"\n  tag \"fix\": \"Use the --pids-limit flag while launching the container with an\n  appropriate value. For example, docker run -it --pids-limit 100\n  <Image_ID> In the above example, the number of processes allowed to run at any\n  given time is set to 100. After a limit of 100 concurrently running processes\n  is reached, docker would restrict any new process creation.\"\n  tag \"Default Value\": \"The Default value for the --pids-limit is 0 which means\n  there is no restriction on the number of forks. Also, note that the PIDs cgroup\n  limit works only for the kernel versions 4.3+.\"\n  if docker.containers.running?.ids.empty?\n    impact 0.0\n    describe 'There are no running docker containers, therfore this control is N/A' do\n      skip 'There are no running docker containers, therfore this control is N/A'\n    end\n  end\n\n  if !docker.containers.running?.ids.empty?\n    docker.containers.running?.ids.each do |id|\n      describe docker.object(id) do\n        its('HostConfig.PidsLimit') { should_not cmp 0 }\n        its('HostConfig.PidsLimit') { should_not cmp(-1) }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.28.rb",
        "line": 1
      },
      "id": "M-5.28"
    },
    {
      "title": "3.4 Ensure that docker.socket file permissions are set to 644 or more restrictive (Scored)",
      "desc": "Verify that the docker.socket file permissions are correctly set to 644 or more restrictive.\n  The docker.socket file contains sensitive parameters that may alter the behavior of the Docker remote API.\n  Hence, it should be writable only by root to maintain the integrity of the file.",
      "descriptions": {
        "default": "Verify that the docker.socket file permissions are correctly set to 644 or more restrictive.\n  The docker.socket file contains sensitive parameters that may alter the behavior of the Docker remote API.\n  Hence, it should be writable only by root to maintain the integrity of the file."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/quickstart/",
          "ref": "quickstart"
        },
        {
          "url": "https://docs.docker.com/engine/reference/commandline/dockerd/#bind-dockerto-another-hostport-or-a-unix-socket",
          "ref": "bind-dockerto-another-hostport-or-a-unix-socket"
        },
        {
          "url": "https://github.com/YungSang/fedora-atomic-packer/blob/master/oem/docker.socket",
          "ref": "docker.socker"
        },
        {
          "url": "https://daviddaeschler.com/2014/12/14/centos-7rhel-7-and-docker-containers-on-boot/",
          "ref": "centos-7rhel-7-and-docker-containers-on-boot"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "3.4",
        "cis_control": [
          "14.4",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-3 (3)",
          "4"
        ],
        "check_text": "Step 1: Find out the file location: systemctl show -p\n  FragmentPath docker.socket Step 2: If the file does not exist, this\n  recommendation is not applicable. If the file exists, execute the below\n  command with the correct file path to verify that the file permissions are set\n  to 644 or more restrictive. For example, stat -c %a\n  /usr/lib/systemd/system/docker.socket",
        "fix": "Step 1: Find out the file location: systemctl show -p\n  FragmentPath docker.socket Step 2: If the file does not exist, this\n  recommendation is not applicable. If the file exists, execute the below\n  command with the correct file path to set the file permissions to 644. For\n  example, chmod 644 /usr/lib/systemd/system/docker.socket",
        "Default Value": "This file may not be present on the system. In that\n  case, this recommendation is not applicable. By default, if the file is\n  present, the file permissions for this file are correctly set to 644."
      },
      "code": "control 'M-3.4' do\n  title '3.4 Ensure that docker.socket file permissions are set to 644 or more restrictive (Scored)'\n  desc  \"Verify that the docker.socket file permissions are correctly set to 644 or more restrictive.\n  The docker.socket file contains sensitive parameters that may alter the behavior of the Docker remote API.\n  Hence, it should be writable only by root to maintain the integrity of the file.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '3.4'\n  tag \"cis_control\": ['14.4', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-3 (3)', '4']\n  tag \"check_text\": \"Step 1: Find out the file location: systemctl show -p\n  FragmentPath docker.socket Step 2: If the file does not exist, this\n  recommendation is not applicable. If the file exists, execute the below\n  command with the correct file path to verify that the file permissions are set\n  to 644 or more restrictive. For example, stat -c %a\n  /usr/lib/systemd/system/docker.socket\"\n  tag \"fix\": \"Step 1: Find out the file location: systemctl show -p\n  FragmentPath docker.socket Step 2: If the file does not exist, this\n  recommendation is not applicable. If the file exists, execute the below\n  command with the correct file path to set the file permissions to 644. For\n  example, chmod 644 /usr/lib/systemd/system/docker.socket\"\n  tag \"Default Value\": \"This file may not be present on the system. In that\n  case, this recommendation is not applicable. By default, if the file is\n  present, the file permissions for this file are correctly set to 644.\"\n  ref 'quickstart', url: 'https://docs.docker.com/engine/quickstart/'\n  ref 'bind-dockerto-another-hostport-or-a-unix-socket', url: 'https://docs.docker.com/engine/reference/commandline/dockerd/#bind-dockerto-another-hostport-or-a-unix-socket'\n  ref 'docker.socker', url: 'https://github.com/YungSang/fedora-atomic-packer/blob/master/oem/docker.socket'\n  ref 'centos-7rhel-7-and-docker-containers-on-boot', url: 'https://daviddaeschler.com/2014/12/14/centos-7rhel-7-and-docker-containers-on-boot/'\n\n  docker_socket_file = command('systemctl show -p FragmentPath docker.socket').stdout.strip\n\n  equal_sign = docker_socket_file.index('=')\n\n  docker_socket_file = docker_socket_file[equal_sign+1..-1]\n\n  if file(docker_socket_file.to_s).exist?\n\n    describe file('docker_socket_file') do\n      it { should exist }\n      it { should be_file }\n      its('mode') { should cmp <= 0644 }\n    end\n\n  else\n    impact 0.0\n    describe 'The docker socket file does not exist, therefore this control is N/A' do\n      skip 'The docker socket file does not exist, therefore this control is N/A'\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-3.4.rb",
        "line": 1
      },
      "id": "M-3.4"
    },
    {
      "title": "5.9 Ensure the host's network namespace is not shared (Scored)",
      "desc": "The networking mode on a container when set to --net=host, skips placing\n  the container inside a separate network stack. In essence, this choice tells Docker to not\n  containerize the container's networking. This would network-wise mean that the container\n  lives \"outside\" in the main Docker host and has full access to its network interfaces.\n  This is potentially dangerous. It allows the container process to open\n  low-numbered ports like any other root process. It also allows the container to access network\n  services like Dbus on the Docker host. Thus, a container process can\n  potentially do unexpected things such as shutting down the Docker host. You should not use this option.",
      "descriptions": {
        "default": "The networking mode on a container when set to --net=host, skips placing\n  the container inside a separate network stack. In essence, this choice tells Docker to not\n  containerize the container's networking. This would network-wise mean that the container\n  lives \"outside\" in the main Docker host and has full access to its network interfaces.\n  This is potentially dangerous. It allows the container process to open\n  low-numbered ports like any other root process. It also allows the container to access network\n  services like Dbus on the Docker host. Thus, a container process can\n  potentially do unexpected things such as shutting down the Docker host. You should not use this option."
      },
      "impact": 0,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/userguide/networking/dockernetworks/"
        },
        {
          "url": "https://github.com/docker/docker/issues/6401"
        }
      ],
      "tags": {
        "ref": "1. https://docs.docker.com/engine/userguide/networking/2.\n  https://docs.docker.com/engine/reference/run/#network-settings",
        "severity": "medium",
        "cis_id": "5.9",
        "cis_control": [
          "12",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SC-7",
          "4"
        ],
        "check_text": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: NetworkMode={{ .HostConfig.NetworkMode }}' If the above command returns\n  NetworkMode=host, it means that --net=host option was passed when the container\n  was started. This would be non-compliant.",
        "fix": "Do not pass --net=host option when starting the container.",
        "Default Value": "By default, container connects to Docker bridge."
      },
      "code": "control 'M-5.9' do\n  title \"5.9 Ensure the host's network namespace is not shared (Scored)\"\n  desc  \"The networking mode on a container when set to --net=host, skips placing\n  the container inside a separate network stack. In essence, this choice tells Docker to not\n  containerize the container's networking. This would network-wise mean that the container\n  lives \\\"outside\\\" in the main Docker host and has full access to its network interfaces.\n  This is potentially dangerous. It allows the container process to open\n  low-numbered ports like any other root process. It also allows the container to access network\n  services like Dbus on the Docker host. Thus, a container process can\n  potentially do unexpected things such as shutting down the Docker host. You should not use this option.\n  \"\n  impact 0.5\n  tag \"ref\": \"1. https://docs.docker.com/engine/userguide/networking/2.\n  https://docs.docker.com/engine/reference/run/#network-settings\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.9'\n  tag \"cis_control\": ['12', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SC-7', '4']\n  tag \"check_text\": \"docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: NetworkMode={{ .HostConfig.NetworkMode }}' If the above command returns\n  NetworkMode=host, it means that --net=host option was passed when the container\n  was started. This would be non-compliant.\"\n  tag \"fix\": 'Do not pass --net=host option when starting the container.'\n  tag \"Default Value\": 'By default, container connects to Docker bridge.'\n  ref url: 'https://docs.docker.com/engine/userguide/networking/dockernetworks/'\n  ref url: 'https://github.com/docker/docker/issues/6401'\n\n  if docker.containers.running?.ids.empty?\n    impact 0.0\n    describe 'There are no running docker containers, therfore this control is N/A' do\n      skip 'There are no running docker containers, therfore this control is N/A'\n    end\n  end\n\n  if !docker.containers.running?.ids.empty?\n    docker.containers.running?.ids.each do |id|\n      describe docker.object(id) do\n        its(%w{HostConfig NetworkMode}) { should_not eq 'host' }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.9.rb",
        "line": 1
      },
      "id": "M-5.9"
    },
    {
      "title": "2.8 Enable user namespace support (Scored)",
      "desc": "Enable user namespace support in Docker daemon to utilize container user to\n host user remapping. This recommendation is beneficial where the containers you are\n using do not have an explicit container user defined in the container image. If container images\n that you are using have a pre-defined non-root user, this recommendation may be skipped\n since this feature is still in its infancy and might give you unpredictable issues and complexities.\n The Linux kernel user namespace support in Docker daemon provides additional security\n for the Docker host system. It allows a container to have a unique range of\n user and group IDs which are outside the traditional user and group range utilized by the\n host system. For example, the root user will have expected administrative privilege\n inside the container but can effectively be mapped to an unprivileged UID on the host system.",
      "descriptions": {
        "default": "Enable user namespace support in Docker daemon to utilize container user to\n host user remapping. This recommendation is beneficial where the containers you are\n using do not have an explicit container user defined in the container image. If container images\n that you are using have a pre-defined non-root user, this recommendation may be skipped\n since this feature is still in its infancy and might give you unpredictable issues and complexities.\n The Linux kernel user namespace support in Docker daemon provides additional security\n for the Docker host system. It allows a container to have a unique range of\n user and group IDs which are outside the traditional user and group range utilized by the\n host system. For example, the root user will have expected administrative privilege\n inside the container but can effectively be mapped to an unprivileged UID on the host system."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "http://man7.org/linux/man-pages/man7/user_namespaces.7.html",
          "ref": "User namespeces"
        },
        {
          "url": "https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-usernamespace-options",
          "ref": "daemon-usernamespace-options"
        },
        {
          "url": "https://docs.docker.com/engine/reference/commandline/daemon/",
          "ref": "Docker daemon configuration"
        },
        {
          "url": "http://events.linuxfoundation.org/sites/events/files/slides/User%20Namespaces%20-%20ContainerCon%202015%20-%2016-9-final_0.pdf",
          "ref": "Routing out root: user namespaces in docker"
        },
        {
          "url": "https://github.com/docker/docker/issues/21050",
          "ref": "Docker images vanish when using user namespaces "
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "2.8",
        "cis_control": [
          "18",
          "6.1"
        ],
        "cis_level": "Level 2 - Docker",
        "nist": [
          "SI-1",
          "4"
        ],
        "check_text": "ps -p $(docker inspect --format='{{ .State.Pid }}' <CONTAINER\n  ID>) -o pid,user The above command would find the PID of the container and\n  then would list the host user associated with the container process. If the\n  container process is running as root, then this recommendation is non-compliant.\n  Alternatively, you can run docker info to ensure that the\n  user is listed under Security Options: docker info --format '{{ .SecurityOptions }}'",
        "fix": "Please consult Docker documentation for various ways in which\n  this can be configured depending upon your requirements. Your steps might also\n  vary based on platform - For example, on Red Hat, sub-UIDs and sub-GIDs\n  mapping creation does not work automatically. You might have to create your\n  own mapping. However, the high-level steps are as below: Step 1: Ensure that\n  the files /etc/subuid and /etc/subgid exist. touch /etc/subuid\n  /etc/subgid Step 2: Start the docker daemon with --userns-remap flag dockerd\n  --userns-remap=default",
        "Default Value": "By default, user namespace is not remapped."
      },
      "code": "control 'M-2.8' do\n  title '2.8 Enable user namespace support (Scored)'\n  desc  \"Enable user namespace support in Docker daemon to utilize container user to\n host user remapping. This recommendation is beneficial where the containers you are\n using do not have an explicit container user defined in the container image. If container images\n that you are using have a pre-defined non-root user, this recommendation may be skipped\n since this feature is still in its infancy and might give you unpredictable issues and complexities.\n The Linux kernel user namespace support in Docker daemon provides additional security\n for the Docker host system. It allows a container to have a unique range of\n user and group IDs which are outside the traditional user and group range utilized by the\n host system. For example, the root user will have expected administrative privilege\n inside the container but can effectively be mapped to an unprivileged UID on the host system.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '2.8'\n  tag \"cis_control\": ['18', '6.1']\n  tag \"cis_level\": 'Level 2 - Docker'\n  tag \"nist\": ['SI-1', '4']\n  tag \"check_text\": \"ps -p $(docker inspect --format='{{ .State.Pid }}' <CONTAINER\n  ID>) -o pid,user The above command would find the PID of the container and\n  then would list the host user associated with the container process. If the\n  container process is running as root, then this recommendation is non-compliant.\n  Alternatively, you can run docker info to ensure that the\n  user is listed under Security Options: docker info --format '{{ .SecurityOptions }}'\"\n  tag \"fix\": \"Please consult Docker documentation for various ways in which\n  this can be configured depending upon your requirements. Your steps might also\n  vary based on platform - For example, on Red Hat, sub-UIDs and sub-GIDs\n  mapping creation does not work automatically. You might have to create your\n  own mapping. However, the high-level steps are as below: Step 1: Ensure that\n  the files /etc/subuid and /etc/subgid exist. touch /etc/subuid\n  /etc/subgid Step 2: Start the docker daemon with --userns-remap flag dockerd\n  --userns-remap=default\"\n  tag \"Default Value\": 'By default, user namespace is not remapped.'\n  ref 'User namespeces', url: 'http://man7.org/linux/man-pages/man7/user_namespaces.7.html'\n  ref 'daemon-usernamespace-options', url: 'https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-usernamespace-options'\n  ref 'Docker daemon configuration', url: 'https://docs.docker.com/engine/reference/commandline/daemon/'\n  ref 'Routing out root: user namespaces in docker', url: 'http://events.linuxfoundation.org/sites/events/files/slides/User%20Namespaces%20-%20ContainerCon%202015%20-%2016-9-final_0.pdf'\n  ref 'Docker images vanish when using user namespaces ', url: 'https://github.com/docker/docker/issues/21050'\n\n  describe json('/etc/docker/daemon.json') do\n    its(['userns-remap']) { should eq('default') }\n  end\n  describe file('/etc/subuid') do\n    it { should exist }\n    it { should be_file }\n  end\n  describe file('/etc/subgid') do\n    it { should exist }\n    it { should be_file }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-2.8.rb",
        "line": 1
      },
      "id": "M-2.8"
    },
    {
      "title": "2.10 Ensure base device size is not changed until needed (Scored)",
      "desc": "In certain circumstances, you might need containers bigger than 10G in\n  size. In these cases, carefully choose the base device size.\n  The base device size can be increased at daemon restart. Increasing the\n  base device size allows all future images and containers to be of the new base device size.\n  A user can use this option to expand the base device size however shrinking is not\n  permitted. This value affects the system-wide base empty filesystem that may already be\n  initialized and inherited by pulled images.\n  Though the file system does not allot the increased size if it is empty, it\n  will use more space for the empty case depending upon the device size. This may cause a denial\n  of service by ending up in file system being over-allocated or full.",
      "descriptions": {
        "default": "In certain circumstances, you might need containers bigger than 10G in\n  size. In these cases, carefully choose the base device size.\n  The base device size can be increased at daemon restart. Increasing the\n  base device size allows all future images and containers to be of the new base device size.\n  A user can use this option to expand the base device size however shrinking is not\n  permitted. This value affects the system-wide base empty filesystem that may already be\n  initialized and inherited by pulled images.\n  Though the file system does not allot the increased size if it is empty, it\n  will use more space for the empty case depending upon the device size. This may cause a denial\n  of service by ending up in file system being over-allocated or full."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/reference/commandline/daemon/#storage-driver-options",
          "ref": "Docker daemon storage driver options"
        },
        {
          "url": "https://docs.docker.com/engine/reference/commandline/dockerd/#storagedriver-options",
          "ref": "storagedriver-options"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "2.10",
        "cis_control": [
          "18",
          "6.1"
        ],
        "cis_level": "Level 2 - Docker",
        "nist": [
          "SI-1",
          "4"
        ],
        "check_text": "ps -ef | grep dockerd Execute the above command and it should\n  not show any --storage-opt dm.basesize parameters.",
        "fix": "Do not set --storage-opt dm.basesize until needed.\n",
        "Default Value": "The default base device size is 10G.\n"
      },
      "code": "control 'M-2.10' do\n  title '2.10 Ensure base device size is not changed until needed (Scored)'\n  desc  \"In certain circumstances, you might need containers bigger than 10G in\n  size. In these cases, carefully choose the base device size.\n  The base device size can be increased at daemon restart. Increasing the\n  base device size allows all future images and containers to be of the new base device size.\n  A user can use this option to expand the base device size however shrinking is not\n  permitted. This value affects the system-wide base empty filesystem that may already be\n  initialized and inherited by pulled images.\n  Though the file system does not allot the increased size if it is empty, it\n  will use more space for the empty case depending upon the device size. This may cause a denial\n  of service by ending up in file system being over-allocated or full.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '2.10'\n  tag \"cis_control\": ['18', '6.1']\n  tag \"cis_level\": 'Level 2 - Docker'\n  tag \"nist\": ['SI-1', '4']\n  tag \"check_text\": \"ps -ef | grep dockerd Execute the above command and it should\n  not show any --storage-opt dm.basesize parameters.\"\n  tag \"fix\": \"Do not set --storage-opt dm.basesize until needed.\\n\"\n  tag \"Default Value\": \"The default base device size is 10G.\\n\"\n  ref 'Docker daemon storage driver options', url: 'https://docs.docker.com/engine/reference/commandline/daemon/#storage-driver-options'\n  ref 'storagedriver-options', url: 'https://docs.docker.com/engine/reference/commandline/dockerd/#storagedriver-options'\n\n  describe json('/etc/docker/daemon.json') do\n    its(['storage-opts']) { should eq(['dm.basesize=10G']) }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-2.10.rb",
        "line": 1
      },
      "id": "M-2.10"
    },
    {
      "title": "2.18 Ensure containers are restricted from acquiring new privileges(Scored)",
      "desc": "Restrict containers from acquiring additional privileges via suid or sgid bits, by default.\n  A process can set the no_new_priv bit in the kernel. It persists across\n  fork, clone and execve. The no_new_priv bit ensures that the process or its children\n  processes do not gain any additional privileges via suid or sgid bits. This way a lot of\n  dangerous operations become a lot less dangerous because there is no possibility of subverting\n  privileged binaries. Setting this at the daemon level ensures that by default all new containers\n  are restricted from acquiring new privileges.",
      "descriptions": {
        "default": "Restrict containers from acquiring additional privileges via suid or sgid bits, by default.\n  A process can set the no_new_priv bit in the kernel. It persists across\n  fork, clone and execve. The no_new_priv bit ensures that the process or its children\n  processes do not gain any additional privileges via suid or sgid bits. This way a lot of\n  dangerous operations become a lot less dangerous because there is no possibility of subverting\n  privileged binaries. Setting this at the daemon level ensures that by default all new containers\n  are restricted from acquiring new privileges."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "ref": "1. https://github.com/moby/moby/pull/299842.\n  https://github.com/moby/moby/pull/20727",
        "severity": "medium",
        "cis_id": "2.18",
        "cis_control": [
          "5",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-6",
          "4"
        ],
        "check_text": "ps -ef | grep dockerd Ensure that the --no-new-privileges\n  parameter is present and is not set to false.",
        "fix": "Run the Docker daemon as below: dockerd --no-new-privileges",
        "Default Value": "By default, containers are not restricted from acquiring new privileges."
      },
      "code": "control 'M-2.18' do\n  title '2.18 Ensure containers are restricted from acquiring new privileges(Scored)'\n  desc  \"Restrict containers from acquiring additional privileges via suid or sgid bits, by default.\n  A process can set the no_new_priv bit in the kernel. It persists across\n  fork, clone and execve. The no_new_priv bit ensures that the process or its children\n  processes do not gain any additional privileges via suid or sgid bits. This way a lot of\n  dangerous operations become a lot less dangerous because there is no possibility of subverting\n  privileged binaries. Setting this at the daemon level ensures that by default all new containers\n  are restricted from acquiring new privileges.\n  \"\n  impact 0.5\n  tag \"ref\": \"1. https://github.com/moby/moby/pull/299842.\n  https://github.com/moby/moby/pull/20727\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '2.18'\n  tag \"cis_control\": ['5', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-6', '4']\n  tag \"check_text\": \"ps -ef | grep dockerd Ensure that the --no-new-privileges\n  parameter is present and is not set to false.\"\n  tag \"fix\": 'Run the Docker daemon as below: dockerd --no-new-privileges'\n  tag \"Default Value\": 'By default, containers are not restricted from acquiring new privileges.'\n  describe 'A manaul review is required to ensure containers are restricted from acquiring new privileges' do\n    skip 'A manaul review is required to ensure containers are restricted from acquiring new privileges'\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-2.18.rb",
        "line": 1
      },
      "id": "M-2.18"
    },
    {
      "title": "1.12 Ensure auditing is configured for Docker files and directories\n  /usr/bin/docker-containerd (Scored)",
      "desc": "Audit /usr/bin/docker-containerd, if applicable.\n  Apart from auditing your regular Linux file system and system calls, audit\n  all Docker related files and directories. Docker daemon runs with root privileges. Its\n  behavior depends on some key files and directories. /usr/bin/docker-containerd is\n  one such file.\n  Docker now relies on containerd and runC to spawn containers. It must be audited, if applicable.",
      "descriptions": {
        "default": "Audit /usr/bin/docker-containerd, if applicable.\n  Apart from auditing your regular Linux file system and system calls, audit\n  all Docker related files and directories. Docker daemon runs with root privileges. Its\n  behavior depends on some key files and directories. /usr/bin/docker-containerd is\n  one such file.\n  Docker now relies on containerd and runC to spawn containers. It must be audited, if applicable."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html",
          "ref": "System auditing"
        },
        {
          "url": "https://github.com/docker/docker/pull/20662",
          "ref": "Containerd integration"
        },
        {
          "url": "https://containerd.tools/",
          "ref": "Containerd tools"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "1.12",
        "cis_control": [
          "14.6",
          "6.1"
        ],
        "cis_level": "Level 1 - Linux Host OS",
        "nist": [
          "AU-2",
          "4"
        ],
        "check_text": "Verify that there is an audit rule corresponding to\n  /usr/bin/docker-containerd file. For example, execute below command: auditctl\n  -l | grep /usr/bin/docker-containerd This should list a rule for\n  /usr/bin/docker-containerd file.",
        "fix": "Add a rule for /usr/bin/docker-containerd file. For\n  example, Add the line as below in /etc/audit/audit.rules file: -w\n  /usr/bin/docker-containerd -k docker Then, restart the audit daemon. For\n  example, service auditd restart",
        "Default Value": "By default, Docker related files and directories are\n  not audited. The file /usr/bin/dockercontainerd may not be available on the\n  system. In that case, this recommendation is not applicable."
      },
      "code": "control 'M-1.12' do\n  title \"1.12 Ensure auditing is configured for Docker files and directories\n  /usr/bin/docker-containerd (Scored)\"\n  desc  \"Audit /usr/bin/docker-containerd, if applicable.\n  Apart from auditing your regular Linux file system and system calls, audit\n  all Docker related files and directories. Docker daemon runs with root privileges. Its\n  behavior depends on some key files and directories. /usr/bin/docker-containerd is\n  one such file.\n  Docker now relies on containerd and runC to spawn containers. It must be audited, if applicable.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '1.12'\n  tag \"cis_control\": ['14.6', '6.1']\n  tag \"cis_level\": 'Level 1 - Linux Host OS'\n  tag \"nist\": ['AU-2', '4']\n  tag \"check_text\": \"Verify that there is an audit rule corresponding to\n  /usr/bin/docker-containerd file. For example, execute below command: auditctl\n  -l | grep /usr/bin/docker-containerd This should list a rule for\n  /usr/bin/docker-containerd file.\"\n  tag \"fix\": \"Add a rule for /usr/bin/docker-containerd file. For\n  example, Add the line as below in /etc/audit/audit.rules file: -w\n  /usr/bin/docker-containerd -k docker Then, restart the audit daemon. For\n  example, service auditd restart\"\n  tag \"Default Value\": \"By default, Docker related files and directories are\n  not audited. The file /usr/bin/dockercontainerd may not be available on the\n  system. In that case, this recommendation is not applicable.\"\n  ref 'System auditing', url: 'https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html'\n  ref 'Containerd integration', url: 'https://github.com/docker/docker/pull/20662'\n  ref 'Containerd tools', url: 'https://containerd.tools/'\n\n  describe auditd do\n    its('lines') { should include '-w /usr/bin/docker-containerd -p rwxa -k docker' }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-1.12.rb",
        "line": 1
      },
      "id": "M-1.12"
    },
    {
      "title": "2.5 Ensure aufs storage driver is not used (Scored)",
      "desc": "Do not use aufs as storage driver for your Docker instance.\n  The aufs storage driver is the oldest storage driver. It is based on a\n  Linux kernel patch-set that is unlikely to be merged into the main Linux kernel. aufs driver is\n  also known to cause some serious kernel crashes. aufs just has legacy support from Docker. Most\n  importantly, aufs is not a supported driver in many Linux distributions using latest Linux kernels.",
      "descriptions": {
        "default": "Do not use aufs as storage driver for your Docker instance.\n  The aufs storage driver is the oldest storage driver. It is based on a\n  Linux kernel patch-set that is unlikely to be merged into the main Linux kernel. aufs driver is\n  also known to cause some serious kernel crashes. aufs just has legacy support from Docker. Most\n  importantly, aufs is not a supported driver in many Linux distributions using latest Linux kernels."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/userguide/storagedriver/selectadriver/#supported-backing-filesystems",
          "ref": "supported-backing-filesystems"
        },
        {
          "url": "https://docs.docker.com/engine/userguide/storagedriver/",
          "ref": "storagedriver"
        },
        {
          "url": "https://docs.docker.com/engine/reference/commandline/cli/#daemon-storage-driver-option",
          "ref": "Docker daemon storage driver options"
        },
        {
          "url": "https://github.com/docker/docker/issues/6047",
          "ref": "permission denied if chown after chmod"
        },
        {
          "url": "http://muehe.org/posts/switching-docker-from-aufs-to-devicemapper/",
          "ref": "Switch from aufs to devicemapper"
        },
        {
          "url": "http://jpetazzo.github.io/assets/2015-03-05-deep-dive-into-docker-storage-drivers.html#1",
          "ref": "Deep dive into docker storage drivers"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "2.5",
        "cis_control": [
          "18",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SI-1",
          "4"
        ],
        "check_text": "Execute the below command and verify that aufs is not used as\n  storage driver: docker info | grep -e \"^Storage Driver:\\s*aufs\\s*$\" The\n  above command should not return anything.",
        "fix": "Do not explicitly use aufs as storage driver. For example, do\n  not start Docker daemon as below: dockerd --storage-driver aufs",
        "Default Value": "By default, Docker uses devicemapper as the storage\n  driver on most of the platforms. Default storage driver can vary based on your\n  OS vendor. You should use the storage driver that is best supported by your\n  preferred vendor."
      },
      "code": "control 'M-2.5' do\n  title '2.5 Ensure aufs storage driver is not used (Scored)'\n  desc  \"Do not use aufs as storage driver for your Docker instance.\n  The aufs storage driver is the oldest storage driver. It is based on a\n  Linux kernel patch-set that is unlikely to be merged into the main Linux kernel. aufs driver is\n  also known to cause some serious kernel crashes. aufs just has legacy support from Docker. Most\n  importantly, aufs is not a supported driver in many Linux distributions using latest Linux kernels.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '2.5'\n  tag \"cis_control\": ['18', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SI-1', '4']\n  tag \"check_text\": \"Execute the below command and verify that aufs is not used as\n  storage driver: docker info | grep -e \\\"^Storage Driver:\\\\s*aufs\\\\s*$\\\" The\n  above command should not return anything.\"\n  tag \"fix\": \"Do not explicitly use aufs as storage driver. For example, do\n  not start Docker daemon as below: dockerd --storage-driver aufs\"\n  tag \"Default Value\": \"By default, Docker uses devicemapper as the storage\n  driver on most of the platforms. Default storage driver can vary based on your\n  OS vendor. You should use the storage driver that is best supported by your\n  preferred vendor.\"\n  ref 'supported-backing-filesystems', url: 'https://docs.docker.com/engine/userguide/storagedriver/selectadriver/#supported-backing-filesystems'\n  ref 'storagedriver', url: 'https://docs.docker.com/engine/userguide/storagedriver/'\n  ref 'Docker daemon storage driver options', url: 'https://docs.docker.com/engine/reference/commandline/cli/#daemon-storage-driver-option'\n  ref 'permission denied if chown after chmod', url: 'https://github.com/docker/docker/issues/6047'\n  ref 'Switch from aufs to devicemapper', url: 'http://muehe.org/posts/switching-docker-from-aufs-to-devicemapper/'\n  ref 'Deep dive into docker storage drivers', url: 'http://jpetazzo.github.io/assets/2015-03-05-deep-dive-into-docker-storage-drivers.html#1'\n\n  describe json('/etc/docker/daemon.json') do\n    its(['storage-driver']) { should_not eq('aufs') }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-2.5.rb",
        "line": 1
      },
      "id": "M-2.5"
    },
    {
      "title": "4.11 Ensure verified packages are only Installed (Not Scored)",
      "desc": "Verify authenticity of the packages before installing them in the image.\n  Verifying authenticity of the packages is essential for building a secure\n  container image. Tampered packages could potentially be malicious or have some known\n  vulnerabilities that could be exploited.",
      "descriptions": {
        "default": "Verify authenticity of the packages before installing them in the image.\n  Verifying authenticity of the packages is essential for building a secure\n  container image. Tampered packages could potentially be malicious or have some known\n  vulnerabilities that could be exploited."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "ref": "1.\n  http://www.oreilly.com/webops-perf/free/files/docker-security.pdf2.\n  https://github.com/dockerlibrary/httpd/blob/12bf8c8883340c98b3988a7bade8ef2d0d6dcf8a/2.4/Dockerfile3.\n  https://github.com/dockerlibrary/php/blob/d8a4ccf4d620ec866d5b42335b699742df08c5f0/7.0/alpine/Dockerfile4.\n  https://access.redhat.com/security/team/key",
        "severity": "medium",
        "cis_id": "4.11",
        "cis_control": [
          "18.1",
          "6.1"
        ],
        "cis_level": "Level 2 - Docker",
        "nist": [
          "SI-2",
          "4"
        ],
        "check_text": "Step 1: Run the below command to get the list of\n  images: docker images Step 2: Run the below command for each image in the\n  list above, and look for how the authenticity of the packages is determined.\n  This could be via the use of GPG keys or other secure package distribution\n  mechanisms docker history <Image_ID> Alternatively, if you have access to\n  Dockerfile for the image, verify that the authenticity of the packages is\n  checked.",
        "fix": "Use GPG keys for downloading and verifying packages or any other\n  secure package distribution mechanism of your choice.",
        "Default Value": "Not Applicable"
      },
      "code": "control 'M-4.11' do\n  title '4.11 Ensure verified packages are only Installed (Not Scored)'\n  desc  \"Verify authenticity of the packages before installing them in the image.\n  Verifying authenticity of the packages is essential for building a secure\n  container image. Tampered packages could potentially be malicious or have some known\n  vulnerabilities that could be exploited.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  http://www.oreilly.com/webops-perf/free/files/docker-security.pdf2.\n  https://github.com/dockerlibrary/httpd/blob/12bf8c8883340c98b3988a7bade8ef2d0d6dcf8a/2.4/Dockerfile3.\n  https://github.com/dockerlibrary/php/blob/d8a4ccf4d620ec866d5b42335b699742df08c5f0/7.0/alpine/Dockerfile4.\n  https://access.redhat.com/security/team/key\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '4.11'\n  tag \"cis_control\": ['18.1', '6.1']\n  tag \"cis_level\": 'Level 2 - Docker'\n  tag \"nist\": ['SI-2', '4']\n  tag \"check_text\": \"Step 1: Run the below command to get the list of\n  images: docker images Step 2: Run the below command for each image in the\n  list above, and look for how the authenticity of the packages is determined.\n  This could be via the use of GPG keys or other secure package distribution\n  mechanisms docker history <Image_ID> Alternatively, if you have access to\n  Dockerfile for the image, verify that the authenticity of the packages is\n  checked.\"\n  tag \"fix\": \"Use GPG keys for downloading and verifying packages or any other\n  secure package distribution mechanism of your choice.\"\n  tag \"Default Value\": 'Not Applicable'\n  describe 'A manual review is required to ensure verified packages are only installed' do\n    skip 'A manual review is required to ensure verified packages are only installed'\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-4.11.rb",
        "line": 1
      },
      "id": "M-4.11"
    },
    {
      "title": "5.8 Ensure only needed ports are open on the container (Scored)",
      "desc": "The Dockerfile for a container image defines the ports to be opened by default\n  on a container instance. The list of ports may or may not be relevant to the application\n  you are running within the container. A container can be run just with the ports\n  defined in the Dockerfile for its image or it can be arbitrarily passed run time parameters to\n  open a list of ports. Additionally, overtime, the Dockerfile may undergo various changes and\n  the list of exposed ports may or may not be relevant to the application you are running within\n  the container. Opening unneeded ports sincrease the attack surface of the container\n  and the containerized application. As a recommended practice, do not open unneeded ports.",
      "descriptions": {
        "default": "The Dockerfile for a container image defines the ports to be opened by default\n  on a container instance. The list of ports may or may not be relevant to the application\n  you are running within the container. A container can be run just with the ports\n  defined in the Dockerfile for its image or it can be arbitrarily passed run time parameters to\n  open a list of ports. Additionally, overtime, the Dockerfile may undergo various changes and\n  the list of exposed ports may or may not be relevant to the application you are running within\n  the container. Opening unneeded ports sincrease the attack surface of the container\n  and the containerized application. As a recommended practice, do not open unneeded ports."
      },
      "impact": 0,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/userguide/networking/default_network/binding/",
          "ref": "binding"
        }
      ],
      "tags": {
        "ref": "1. https://docs.docker.com/engine/userguide/networking/",
        "severity": "medium",
        "cis_id": "5.8",
        "cis_control": [
          "9.1",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "CM-7(1)",
          "4"
        ],
        "check_text": "List all the running instances of containers and their port\n  mapping by executing the below command: docker ps --quiet | xargs docker\n  inspect --format '{{ .Id }}: Ports={{.NetworkSettings.Ports }}' Review the\n  list and ensure that the ports mapped are the ones that are really needed\n  for the container. ",
        "fix": "Fix the Dockerfile of the container image to expose only needed\n  ports by your containerized application. You can also completely ignore the\n  list of ports defined in the Dockerfile by NOT using -P (UPPERCASE) or\n  --publish-all flag when starting the container. Use the -p (lowercase) or\n  --publish flag to explicitly define the ports that you need for a particular\n  container instance. For example, docker run --interactive --tty --publish\n  5000 --publish 5001 --publish 5002 centos /bin/bash",
        "Default Value": "By default, all the ports that are listed in the\n  Dockerfile under EXPOSE instruction for an image are opened when a container\n  is run with -P or --publish-all flag."
      },
      "code": "control 'M-5.8' do\n  title '5.8 Ensure only needed ports are open on the container (Scored)'\n  desc  \"The Dockerfile for a container image defines the ports to be opened by default\n  on a container instance. The list of ports may or may not be relevant to the application\n  you are running within the container. A container can be run just with the ports\n  defined in the Dockerfile for its image or it can be arbitrarily passed run time parameters to\n  open a list of ports. Additionally, overtime, the Dockerfile may undergo various changes and\n  the list of exposed ports may or may not be relevant to the application you are running within\n  the container. Opening unneeded ports sincrease the attack surface of the container\n  and the containerized application. As a recommended practice, do not open unneeded ports.\n  \"\n  impact 0.5\n  tag \"ref\": '1. https://docs.docker.com/engine/userguide/networking/'\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.8'\n  tag \"cis_control\": ['9.1', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['CM-7(1)', '4']\n  tag \"check_text\": \"List all the running instances of containers and their port\n  mapping by executing the below command: docker ps --quiet | xargs docker\n  inspect --format '{{ .Id }}: Ports={{.NetworkSettings.Ports }}' Review the\n  list and ensure that the ports mapped are the ones that are really needed\n  for the container. \"\n  tag \"fix\": \"Fix the Dockerfile of the container image to expose only needed\n  ports by your containerized application. You can also completely ignore the\n  list of ports defined in the Dockerfile by NOT using -P (UPPERCASE) or\n  --publish-all flag when starting the container. Use the -p (lowercase) or\n  --publish flag to explicitly define the ports that you need for a particular\n  container instance. For example, docker run --interactive --tty --publish\n  5000 --publish 5001 --publish 5002 centos /bin/bash\"\n  tag \"Default Value\": \"By default, all the ports that are listed in the\n  Dockerfile under EXPOSE instruction for an image are opened when a container\n  is run with -P or --publish-all flag.\"\n  ref 'binding', url: 'https://docs.docker.com/engine/userguide/networking/default_network/binding/'\n\n  if !docker.containers.running?.ids.empty?\n    docker.containers.running?.ids.each do |id|\n      container_info = docker.object(id)\n      next if container_info['NetworkSettings']['Ports'].nil?\n\n      container_info['NetworkSettings']['Ports'].each do |_, hosts|\n        if !hosts.nil?\n          hosts.each do |host|\n            hostport = host['HostPort']\n            describe \"The docker container host port #{hostport} for container #{id}\" do\n              subject { hostport }\n              it { should be_in attribute('allowed_ports') }\n            end\n          end\n        else\n          describe \"There are no docker container port hosts defined for container #{id}, therefore this control is N/A\" do\n            skip \"There are no docker container port hosts defined for container #{id}, therefore this control is N/A\"\n          end\n        end\n      end\n    end\n  else\n    impact 0.0\n    describe 'There are no docker containers running, therefore this control is N/A' do\n      skip 'There are no docker containers running, therefore this control is N/A'\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.8.rb",
        "line": 1
      },
      "id": "M-5.8"
    },
    {
      "title": "3.18 Ensure that the daemon.json file permissions are set to 644 or more restrictive (Scored)",
      "desc": "Verify that the daemon.json file permissions are correctly set to 644 or more restrictive.\n  The daemon.json file contains sensitive parameters that may alter the behavior\n  of the docker daemon. Hence, it should be writable only by root to maintain the integrity\n  of the file.",
      "descriptions": {
        "default": "Verify that the daemon.json file permissions are correctly set to 644 or more restrictive.\n  The daemon.json file contains sensitive parameters that may alter the behavior\n  of the docker daemon. Hence, it should be writable only by root to maintain the integrity\n  of the file."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/reference/commandline/cli/#daemon-socket-option"
        },
        {
          "url": "https://docs.docker.com/engine/quickstart/"
        }
      ],
      "tags": {
        "ref": "1.\n  https://docs.docker.com/engine/reference/commandline/dockerd/#daemonconfiguration-file",
        "severity": "medium",
        "cis_id": "3.18",
        "cis_control": [
          "14.4",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-3 (3)",
          "4"
        ],
        "check_text": "Execute the below command to verify that the file permissions\n  are correctly set to 644 or more restrictive: stat -c %a\n  /etc/docker/daemon.json",
        "fix": "chmod 644 /etc/docker/daemon.json This would set the file\n  permissions for this file to 644.",
        "Default Value": "This file may not be present on the system. In that\n  case, this recommendation is not applicable."
      },
      "code": "control 'M-3.18' do\n  title '3.18 Ensure that the daemon.json file permissions are set to 644 or more restrictive (Scored)'\n  desc  \"Verify that the daemon.json file permissions are correctly set to 644 or more restrictive.\n  The daemon.json file contains sensitive parameters that may alter the behavior\n  of the docker daemon. Hence, it should be writable only by root to maintain the integrity\n  of the file.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  https://docs.docker.com/engine/reference/commandline/dockerd/#daemonconfiguration-file\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '3.18'\n  tag \"cis_control\": ['14.4', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-3 (3)', '4']\n  tag \"check_text\": \"Execute the below command to verify that the file permissions\n  are correctly set to 644 or more restrictive: stat -c %a\n  /etc/docker/daemon.json\"\n  tag \"fix\": \"chmod 644 /etc/docker/daemon.json This would set the file\n  permissions for this file to 644.\"\n  tag \"Default Value\": \"This file may not be present on the system. In that\n  case, this recommendation is not applicable.\"\n  ref url: 'https://docs.docker.com/engine/reference/commandline/cli/#daemon-socket-option'\n  ref url: 'https://docs.docker.com/engine/quickstart/'\n\n  describe file('/etc/docker/daemon.json') do\n    it { should exist }\n    it { should be_file }\n    it { should be_readable.by('owner') }\n    it { should be_writable.by('owner') }\n    it { should_not be_executable.by('owner') }\n    it { should be_readable.by('group') }\n    it { should_not be_writable.by('group') }\n    it { should_not be_executable.by('group') }\n    it { should be_readable.by('other') }\n    it { should_not be_writable.by('other') }\n    it { should_not be_executable.by('other') }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-3.18.rb",
        "line": 1
      },
      "id": "M-3.18"
    },
    {
      "title": "3.3 Ensure that the docker.socket file ownership is set to root:root(Scored)",
      "desc": "Verify that the docker.socket file ownership and group ownership is\n  correctly set to root. The docker.socket file contains sensitive parameters that may alter the\n  behavior of the Docker remote API. Hence, it should be owned and group-owned by root to maintain\n  the integrity of the file.",
      "descriptions": {
        "default": "Verify that the docker.socket file ownership and group ownership is\n  correctly set to root. The docker.socket file contains sensitive parameters that may alter the\n  behavior of the Docker remote API. Hence, it should be owned and group-owned by root to maintain\n  the integrity of the file."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/reference/commandline/dockerd/#daemonsocket-option",
          "ref": "daemonsocket-option"
        },
        {
          "url": "https://github.com/docker/dockerce/blob/master/components/packaging/deb/systemd/docker.socket",
          "ref": "docker.socket"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "3.3",
        "cis_control": [
          "5.1",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-6(9)",
          "4"
        ],
        "check_text": "Step 1: Find out the file location: systemctl show -p\n  FragmentPath docker.socket Step 2: If the file does not exist, this\n  recommendation is not applicable. If the file exists, execute the below\n  command with the correct file path to verify that the file is owned\n  and group-owned by root. For example, stat -c %U:%G\n  /usr/lib/systemd/system/docker.socket | grep -v root:root The above command\n  should not return anything.",
        "fix": "Step 1: Find out the file location: systemctl show -p\n  FragmentPath docker.socket Step 2: If the file does not exist, this\n  recommendation is not applicable. If the file exists, execute the below\n  command with the correct file path to set the ownership and group ownership\n  for the file to root. For example, chown root:root /usr/lib/systemd/system/docker.socket",
        "Default Value": "This file may not be present on the system. In that\n  case, this recommendation is not applicable. By default, if the file is\n  present, the ownership and group-ownership for this file is correctly set to root."
      },
      "code": "control 'M-3.3' do\n  title '3.3 Ensure that the docker.socket file ownership is set to root:root(Scored)'\n  desc  \"Verify that the docker.socket file ownership and group ownership is\n  correctly set to root. The docker.socket file contains sensitive parameters that may alter the\n  behavior of the Docker remote API. Hence, it should be owned and group-owned by root to maintain\n  the integrity of the file.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '3.3'\n  tag \"cis_control\": ['5.1', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-6(9)', '4']\n  tag \"check_text\": \"Step 1: Find out the file location: systemctl show -p\n  FragmentPath docker.socket Step 2: If the file does not exist, this\n  recommendation is not applicable. If the file exists, execute the below\n  command with the correct file path to verify that the file is owned\n  and group-owned by root. For example, stat -c %U:%G\n  /usr/lib/systemd/system/docker.socket | grep -v root:root The above command\n  should not return anything.\"\n  tag \"fix\": \"Step 1: Find out the file location: systemctl show -p\n  FragmentPath docker.socket Step 2: If the file does not exist, this\n  recommendation is not applicable. If the file exists, execute the below\n  command with the correct file path to set the ownership and group ownership\n  for the file to root. For example, chown root:root /usr/lib/systemd/system/docker.socket\"\n  tag \"Default Value\": \"This file may not be present on the system. In that\n  case, this recommendation is not applicable. By default, if the file is\n  present, the ownership and group-ownership for this file is correctly set to root.\"\n  ref 'daemonsocket-option', url: 'https://docs.docker.com/engine/reference/commandline/dockerd/#daemonsocket-option'\n  ref 'docker.socket', url: 'https://github.com/docker/dockerce/blob/master/components/packaging/deb/systemd/docker.socket'\n\n  docker_socket_file = command('systemctl show -p FragmentPath docker.socket').stdout.strip\n\n  equal_sign = docker_socket_file.index('=')\n\n  docker_socket_file = docker_socket_file[equal_sign+1..-1]\n\n  if file(docker_socket_file.to_s).exist?\n\n    describe file('docker_socket_file') do\n      it { should exist }\n      it { should be_file }\n      it { should be_owned_by 'root' }\n      it { should be_grouped_into 'root' }\n    end\n\n  else\n    impact 0.0\n    describe 'The docker socket file does not exist, therefore this control is N/A' do\n      skip 'The docker socket file does not exist, therefore this control is N/A'\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-3.3.rb",
        "line": 1
      },
      "id": "M-3.3"
    },
    {
      "title": "5.21 Ensure the default seccomp profile is not Disabled (Scored)",
      "desc": "Seccomp filtering provides a means for a process to specify a filter for\n  incoming system calls. The default Docker seccomp profile works on whitelist basis and\n  allows 311 system calls and blocks all others. It should not be disabled unless it hinders your\n  container application usage. A large number of system calls are exposed to every user and process with\n  many of them going unused for the entire lifetime of the process. Most of the\n  applications do not need all the system calls and thus benefit by having a reduced set of available\n  system calls. The reduced set of system calls reduces the total kernel surface exposed to the\n  application and thus improvises application security.",
      "descriptions": {
        "default": "Seccomp filtering provides a means for a process to specify a filter for\n  incoming system calls. The default Docker seccomp profile works on whitelist basis and\n  allows 311 system calls and blocks all others. It should not be disabled unless it hinders your\n  container application usage. A large number of system calls are exposed to every user and process with\n  many of them going unused for the entire lifetime of the process. Most of the\n  applications do not need all the system calls and thus benefit by having a reduced set of available\n  system calls. The reduced set of system calls reduces the total kernel surface exposed to the\n  application and thus improvises application security."
      },
      "impact": 0,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/reference/run/"
        },
        {
          "url": "http://blog.aquasec.com/new-docker-security-features-and-what-they-mean-seccomp-profiles"
        },
        {
          "url": "https://github.com/docker/docker/blob/master/profiles/seccomp/default.json"
        },
        {
          "url": "https://docs.docker.com/engine/security/seccomp/"
        },
        {
          "url": "https://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt"
        },
        {
          "url": "https://github.com/docker/docker/pull/17034"
        }
      ],
      "tags": {
        "ref": "1.\n  http://blog.scalock.com/new-docker-security-features-and-what-they-meanseccomp-profiles2.\n  https://docs.docker.com/engine/reference/run/#security-configuration3.\n  https://github.com/docker/docker/blob/master/profiles/seccomp/default.json4.\n  https://docs.docker.com/engine/security/seccomp/5.\n  https://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt6.\n  https://github.com/docker/docker/issues/22870",
        "severity": "medium",
        "cis_id": "5.21",
        "cis_control": [
          "18",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SI-1",
          "4"
        ],
        "check_text": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: SecurityOpt={{ .HostConfig.SecurityOpt }}' The above command should\n  return <no value> or your modified seccomp profile. If it returns\n  [seccomp:unconfined], that means this recommendation is non-compliant and\n  the container is running without any seccomp profiles.",
        "fix": "By default, seccomp profiles are enabled. You do not need to do\n  anything unless you want to modify and use the modified seccomp profile.",
        "Default Value": "When you run a container, it uses the default profile\n  unless you override it with the -security-opt option."
      },
      "code": "control 'M-5.21' do\n  title '5.21 Ensure the default seccomp profile is not Disabled (Scored)'\n  desc  \"Seccomp filtering provides a means for a process to specify a filter for\n  incoming system calls. The default Docker seccomp profile works on whitelist basis and\n  allows 311 system calls and blocks all others. It should not be disabled unless it hinders your\n  container application usage. A large number of system calls are exposed to every user and process with\n  many of them going unused for the entire lifetime of the process. Most of the\n  applications do not need all the system calls and thus benefit by having a reduced set of available\n  system calls. The reduced set of system calls reduces the total kernel surface exposed to the\n  application and thus improvises application security.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  http://blog.scalock.com/new-docker-security-features-and-what-they-meanseccomp-profiles2.\n  https://docs.docker.com/engine/reference/run/#security-configuration3.\n  https://github.com/docker/docker/blob/master/profiles/seccomp/default.json4.\n  https://docs.docker.com/engine/security/seccomp/5.\n  https://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt6.\n  https://github.com/docker/docker/issues/22870\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.21'\n  tag \"cis_control\": ['18', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SI-1', '4']\n  tag \"check_text\": \"docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: SecurityOpt={{ .HostConfig.SecurityOpt }}' The above command should\n  return <no value> or your modified seccomp profile. If it returns\n  [seccomp:unconfined], that means this recommendation is non-compliant and\n  the container is running without any seccomp profiles.\"\n  tag \"fix\": \"By default, seccomp profiles are enabled. You do not need to do\n  anything unless you want to modify and use the modified seccomp profile.\"\n  tag \"Default Value\": \"When you run a container, it uses the default profile\n  unless you override it with the -security-opt option.\"\n  ref url: 'https://docs.docker.com/engine/reference/run/'\n  ref url: 'http://blog.aquasec.com/new-docker-security-features-and-what-they-mean-seccomp-profiles'\n  ref url: 'https://github.com/docker/docker/blob/master/profiles/seccomp/default.json'\n  ref url: 'https://docs.docker.com/engine/security/seccomp/'\n  ref url: 'https://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt'\n  ref url: 'https://github.com/docker/docker/pull/17034'\n\n  if docker.containers.running?.ids.empty?\n    impact 0.0\n    describe 'There are no running docker containers, therfore this control is N/A' do\n      skip 'There are no running docker containers, therfore this control is N/A'\n    end\n  end\n\n  if !docker.containers.running?.ids.empty?\n    docker.containers.running?.ids.each do |id|\n      describe docker.object(id) do\n        its(%w{HostConfig SecurityOpt}) { should include(/seccomp/) }\n        its(%w{HostConfig SecurityOpt}) { should_not include(/seccomp[=|:]unconfined/) }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.21.rb",
        "line": 1
      },
      "id": "M-5.21"
    },
    {
      "title": "2.7 Ensure the default ulimit is configured appropriately (Not Scored)",
      "desc": "Set the default ulimit options as appropriate in your environment.\n  ulimit provides control over the resources available to the shell and to\n  processes started by it. Setting system resource limits judiciously saves you from many\n  disasters such as a fork bomb. Sometimes, even friendly users and legitimate processes can\n  overuse system resources and in-turn can make the system unusable.\n  Setting default ulimit for the Docker daemon would enforce the ulimit for\n  all container instances. You would not need to setup ulimit for each container instance.\n  However, the default ulimit can be overridden during container runtime, if needed.\n  Hence, to control the system resources, define a default ulimit as needed in your environment.",
      "descriptions": {
        "default": "Set the default ulimit options as appropriate in your environment.\n  ulimit provides control over the resources available to the shell and to\n  processes started by it. Setting system resource limits judiciously saves you from many\n  disasters such as a fork bomb. Sometimes, even friendly users and legitimate processes can\n  overuse system resources and in-turn can make the system unusable.\n  Setting default ulimit for the Docker daemon would enforce the ulimit for\n  all container instances. You would not need to setup ulimit for each container instance.\n  However, the default ulimit can be overridden during container runtime, if needed.\n  Hence, to control the system resources, define a default ulimit as needed in your environment."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/reference/commandline/daemon/#default-ulimits",
          "ref": "Docker daemon deafult ulimits"
        },
        {
          "url": "https://docs.docker.com/edge/engine/reference/commandline/dockerd/#defaultulimit",
          "ref": "defaultulimit"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "2.7",
        "cis_control": [
          "18",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SI-1",
          "4"
        ],
        "check_text": "ps -ef | grep dockerd Ensure that the --default-ulimit parameter is set as appropriate.",
        "fix": "Run the docker in daemon mode and pass --default-ulimit as\n  argument with respective ulimits as appropriate in your environment. For\n  Example, dockerd --default-ulimit nproc=1024:2048 --default-ulimit\n  nofile=100:200",
        "Default Value": "By default, no ulimit is set."
      },
      "code": "control 'M-2.7' do\n  title '2.7 Ensure the default ulimit is configured appropriately (Not Scored)'\n  desc  \"Set the default ulimit options as appropriate in your environment.\n  ulimit provides control over the resources available to the shell and to\n  processes started by it. Setting system resource limits judiciously saves you from many\n  disasters such as a fork bomb. Sometimes, even friendly users and legitimate processes can\n  overuse system resources and in-turn can make the system unusable.\n  Setting default ulimit for the Docker daemon would enforce the ulimit for\n  all container instances. You would not need to setup ulimit for each container instance.\n  However, the default ulimit can be overridden during container runtime, if needed.\n  Hence, to control the system resources, define a default ulimit as needed in your environment.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '2.7'\n  tag \"cis_control\": ['18', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SI-1', '4']\n  tag \"check_text\": 'ps -ef | grep dockerd Ensure that the --default-ulimit parameter is set as appropriate.'\n  tag \"fix\": \"Run the docker in daemon mode and pass --default-ulimit as\n  argument with respective ulimits as appropriate in your environment. For\n  Example, dockerd --default-ulimit nproc=1024:2048 --default-ulimit\n  nofile=100:200\"\n  tag \"Default Value\": 'By default, no ulimit is set.'\n  ref 'Docker daemon deafult ulimits', url: 'https://docs.docker.com/engine/reference/commandline/daemon/#default-ulimits'\n  ref 'defaultulimit', url: 'https://docs.docker.com/edge/engine/reference/commandline/dockerd/#defaultulimit'\n\n  describe json('/etc/docker/daemon.json') do\n    its(['default-ulimits', 'nproc']) { should eq('1024:2408') }\n    its(['default-ulimits', 'nofile']) { should eq('100:200') }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-2.7.rb",
        "line": 1
      },
      "id": "M-2.7"
    },
    {
      "title": "2.1 Ensure network traffic is restricted between containers on\n  the default bridge (Scored)",
      "desc": "By default, all network traffic is allowed between containers on the same\nhost on the default network bridge. If not desired, restrict all the inter-container\ncommunication. Link specific containers together that require communication. Alternatively, you\ncan a create custom network and only join containers that need to communicate to that\ncustom network. By default, unrestricted network traffic is enabled between all containers\non the same host on the default network bridge. Thus, each container has the potential of\nreading all packets across the container network on the same host. This might lead to an\nunintended and unwanted disclosure of information to other containers. Hence, restrict the\ninter-container communication on the default network bridge.",
      "descriptions": {
        "default": "By default, all network traffic is allowed between containers on the same\nhost on the default network bridge. If not desired, restrict all the inter-container\ncommunication. Link specific containers together that require communication. Alternatively, you\ncan a create custom network and only join containers that need to communicate to that\ncustom network. By default, unrestricted network traffic is enabled between all containers\non the same host on the default network bridge. Thus, each container has the potential of\nreading all packets across the container network on the same host. This might lead to an\nunintended and unwanted disclosure of information to other containers. Hence, restrict the\ninter-container communication on the default network bridge."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/userguide/networking/",
          "ref": "Docker container networking"
        },
        {
          "url": "https://docs.docker.com/engine/userguide/networking/default_network/containe\n  r-communication/#communication-between-containers",
          "ref": "communication-between-containers"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "2.1",
        "cis_control": [
          "6.2",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AU-3",
          "4"
        ],
        "check_text": "Run the below command and verify that the default network\n  bridge has been configured to restrict inter-container communication. docker\n  network ls --quiet | xargs docker network inspect --format '{{ .Name\n}}: {{\n  .Options }}' It should return com.docker.network.bridge.enable_icc:false for\n  the default network bridge.",
        "fix": "Run the docker in daemon mode and pass --icc=false as an\n  argument. For Example, dockerd --icc=false Alternatively, you can follow the\n  Docker documentation and create a custom network and only join containers that\n  need to communicate to that custom network. The --icc parameter only applies\n  to the default docker bridge, if custom networks are used then the approach of\n  segmenting networks should be adopted instead.",
        "Default Value": "By default, all inter-container communication is\n  allowed on the default network bridge.\n"
      },
      "code": "control 'M-2.1' do\n  title \"2.1 Ensure network traffic is restricted between containers on\n  the default bridge (Scored)\"\n  desc \"\n  By default, all network traffic is allowed between containers on the same\n  host on the default network bridge. If not desired, restrict all the inter-container\n  communication. Link specific containers together that require communication. Alternatively, you\n  can a create custom network and only join containers that need to communicate to that\n  custom network. By default, unrestricted network traffic is enabled between all containers\n  on the same host on the default network bridge. Thus, each container has the potential of\n  reading all packets across the container network on the same host. This might lead to an\n  unintended and unwanted disclosure of information to other containers. Hence, restrict the\n  inter-container communication on the default network bridge.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '2.1'\n  tag \"cis_control\": ['6.2', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AU-3', '4']\n  tag \"check_text\": \"Run the below command and verify that the default network\n  bridge has been configured to restrict inter-container communication. docker\n  network ls --quiet | xargs docker network inspect --format '{{ .Name\\n}}: {{\n  .Options }}' It should return com.docker.network.bridge.enable_icc:false for\n  the default network bridge.\"\n  tag \"fix\": \"Run the docker in daemon mode and pass --icc=false as an\n  argument. For Example, dockerd --icc=false Alternatively, you can follow the\n  Docker documentation and create a custom network and only join containers that\n  need to communicate to that custom network. The --icc parameter only applies\n  to the default docker bridge, if custom networks are used then the approach of\n  segmenting networks should be adopted instead.\"\n  tag \"Default Value\": \"By default, all inter-container communication is\n  allowed on the default network bridge.\\n\"\n  ref 'Docker container networking', url: 'https://docs.docker.com/engine/userguide/networking/'\n  ref 'communication-between-containers', url: 'https://docs.docker.com/engine/userguide/networking/default_network/containe\n  r-communication/#communication-between-containers'\n\n  describe json('/etc/docker/daemon.json') do\n    its(['icc']) { should eq(false) }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-2.1.rb",
        "line": 1
      },
      "id": "M-2.1"
    },
    {
      "title": "3.13 Ensure that Docker server certificate key file ownership is set\n  to root:root (Scored)",
      "desc": "Verify that the Docker server certificate key file (the file that is passed\n  along with the  --tlskey parameter) is owned and group-owned by root.\n  The Docker server certificate key file should be protected from any\n  tampering or unneeded reads. It holds the private key for the Docker server certificate. Hence,\n  it must be owned and group-owned by root to maintain the integrity of the Docker server certificate.",
      "descriptions": {
        "default": "Verify that the Docker server certificate key file (the file that is passed\n  along with the  --tlskey parameter) is owned and group-owned by root.\n  The Docker server certificate key file should be protected from any\n  tampering or unneeded reads. It holds the private key for the Docker server certificate. Hence,\n  it must be owned and group-owned by root to maintain the integrity of the Docker server certificate."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/security/certificates/"
        },
        {
          "url": "https://docs.docker.com/engine/security/https/"
        }
      ],
      "tags": {
        "ref": "1. https://docs.docker.com/registry/insecure/\n2.\n  https://docs.docker.com/engine/security/https/\n",
        "severity": "medium",
        "cis_id": "3.13",
        "cis_control": [
          "5.1",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-6(9)",
          "4"
        ],
        "check_text": "Execute the below command to verify that the Docker server\n  certificate key file is owned and group-owned by root: stat -c %U:%G <path to\n  the Docker server certificate key file> | grep -v root:root The above command\n  should not return anything.",
        "fix": "chown root:root <path to the Docker server certificate key\n  file> This would set the ownership and group-ownership for the Docker server\n  certificate key file to root.",
        "Default Value": "By default, the ownership and group-ownership for the\n  Docker server certificate key file is correctly set to root."
      },
      "code": "control 'M-3.13' do\n  title \"3.13 Ensure that Docker server certificate key file ownership is set\n  to root:root (Scored)\"\n  desc  \"Verify that the Docker server certificate key file (the file that is passed\n  along with the  --tlskey parameter) is owned and group-owned by root.\n  The Docker server certificate key file should be protected from any\n  tampering or unneeded reads. It holds the private key for the Docker server certificate. Hence,\n  it must be owned and group-owned by root to maintain the integrity of the Docker server certificate.\n  \"\n  impact 0.5\n  tag \"ref\": \"1. https://docs.docker.com/registry/insecure/\\n2.\n  https://docs.docker.com/engine/security/https/\\n\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '3.13'\n  tag \"cis_control\": ['5.1', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-6(9)', '4']\n  tag \"check_text\": \"Execute the below command to verify that the Docker server\n  certificate key file is owned and group-owned by root: stat -c %U:%G <path to\n  the Docker server certificate key file> | grep -v root:root The above command\n  should not return anything.\"\n  tag \"fix\": \"chown root:root <path to the Docker server certificate key\n  file> This would set the ownership and group-ownership for the Docker server\n  certificate key file to root.\"\n  tag \"Default Value\": \"By default, the ownership and group-ownership for the\n  Docker server certificate key file is correctly set to root.\"\n  ref url: 'https://docs.docker.com/engine/security/certificates/'\n  ref url: 'https://docs.docker.com/engine/security/https/'\n\n  describe file(json('/etc/docker/daemon.json').params['tlskey']) do\n    it { should exist }\n    it { should be_file }\n    it { should be_owned_by 'root' }\n    it { should be_grouped_into 'root' }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-3.13.rb",
        "line": 1
      },
      "id": "M-3.13"
    },
    {
      "title": "5.6 Ensure ssh is not run within containers (Scored)",
      "desc": "SSH server should not be running within the container. You should SSH into\n  the Docker host, and use nsenter tool to enter a container from a remote host.\n  Running SSH within the container increases the complexity of security\n  management by making it\n  Difficult to manage access policies and security compliance for SSH server\n  Difficult to manage keys and passwords across various containers\n  Difficult to manage security upgrades for SSH server\n  It is possible to have shell access to a container without using SSH, and\n  needlessly increasing the complexity of security management should be avoided.",
      "descriptions": {
        "default": "SSH server should not be running within the container. You should SSH into\n  the Docker host, and use nsenter tool to enter a container from a remote host.\n  Running SSH within the container increases the complexity of security\n  management by making it\n  Difficult to manage access policies and security compliance for SSH server\n  Difficult to manage keys and passwords across various containers\n  Difficult to manage security upgrades for SSH server\n  It is possible to have shell access to a container without using SSH, and\n  needlessly increasing the complexity of security management should be avoided."
      },
      "impact": 0,
      "refs": [
        {
          "url": "https://blog.docker.com/2014/06/why-you-dont-need-to-run-sshd-in-docker/"
        }
      ],
      "tags": {
        "ref": "1.\n  http://blog.docker.com/2014/06/why-you-dont-need-to-run-sshd-in-docker/",
        "severity": "medium",
        "cis_id": "5.6",
        "cis_control": [
          "9.1",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "CM-7(1)",
          "4"
        ],
        "check_text": "Step 1: List all the running instances of containers by\n  executing the below command: docker ps --quiet Step 2: For each container\n  instance, execute the below command: docker exec $INSTANCE_ID ps -el Ensure\n  that there is no process for SSH server.",
        "fix": "Uninstall SSH server from the container and use nsenteror or any\n  other commands such as docker exec or docker attach to interact with the\n  container instance. docker exec --interactive --tty $INSTANCE_ID\n  sh OR docker attach $INSTANCE_ID",
        "Default Value": "By default, SSH server is not running inside the\n  container. Only one process per container is allowed."
      },
      "code": "control 'M-5.6' do\n  title '5.6 Ensure ssh is not run within containers (Scored)'\n  desc  \"SSH server should not be running within the container. You should SSH into\n  the Docker host, and use nsenter tool to enter a container from a remote host.\n  Running SSH within the container increases the complexity of security\n  management by making it\n  Difficult to manage access policies and security compliance for SSH server\n  Difficult to manage keys and passwords across various containers\n  Difficult to manage security upgrades for SSH server\n  It is possible to have shell access to a container without using SSH, and\n  needlessly increasing the complexity of security management should be avoided.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  http://blog.docker.com/2014/06/why-you-dont-need-to-run-sshd-in-docker/\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.6'\n  tag \"cis_control\": ['9.1', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['CM-7(1)', '4']\n  tag \"check_text\": \"Step 1: List all the running instances of containers by\n  executing the below command: docker ps --quiet Step 2: For each container\n  instance, execute the below command: docker exec $INSTANCE_ID ps -el Ensure\n  that there is no process for SSH server.\"\n  tag \"fix\": \"Uninstall SSH server from the container and use nsenteror or any\n  other commands such as docker exec or docker attach to interact with the\n  container instance. docker exec --interactive --tty $INSTANCE_ID\n  sh OR docker attach $INSTANCE_ID\"\n  tag \"Default Value\": \"By default, SSH server is not running inside the\n  container. Only one process per container is allowed.\"\n  ref url: 'https://blog.docker.com/2014/06/why-you-dont-need-to-run-sshd-in-docker/'\n\n  if docker.containers.running?.ids.empty?\n    impact 0.0\n    describe 'There are no running docker containers, therfore this control is N/A' do\n      skip 'There are no running docker containers, therfore this control is N/A'\n    end\n  end\n\n  if !docker.containers.running?.ids.empty?\n    docker.containers.running?.ids.each do |id|\n      execute_command = 'docker exec ' + id + ' ps -e'\n      describe command(execute_command) do\n        its('stdout') { should_not match(/ssh/) }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.6.rb",
        "line": 1
      },
      "id": "M-5.6"
    },
    {
      "title": "5.3 Ensure Linux Kernel Capabilities are restricted within containers (Scored)",
      "desc": "By default, Docker starts containers with a restricted set of Linux Kernel\n  Capabilities. This means that any process may be granted the required capabilities instead of\n  root access. When using Linux Kernel Capabilities, the processes do not have to run as root\n  for almost all of the specific areas where root privileges are usually needed.\n  Docker supports the addition and removal of capabilities, allowing the use\n  of a non-default profile. This may make Docker more secure through capability removal, or\n  less secure through the addition of capabilities. It is thus recommended to remove all\n  capabilities except those explicitly required for your container process.\n  For example, capabilities such as below are usually not needed for\n  container process:\n  NET_ADMIN\n  SYS_ADMIN\n  SYS_MODULE",
      "descriptions": {
        "default": "By default, Docker starts containers with a restricted set of Linux Kernel\n  Capabilities. This means that any process may be granted the required capabilities instead of\n  root access. When using Linux Kernel Capabilities, the processes do not have to run as root\n  for almost all of the specific areas where root privileges are usually needed.\n  Docker supports the addition and removal of capabilities, allowing the use\n  of a non-default profile. This may make Docker more secure through capability removal, or\n  less secure through the addition of capabilities. It is thus recommended to remove all\n  capabilities except those explicitly required for your container process.\n  For example, capabilities such as below are usually not needed for\n  container process:\n  NET_ADMIN\n  SYS_ADMIN\n  SYS_MODULE"
      },
      "impact": 0,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/security/security/"
        },
        {
          "url": "http://man7.org/linux/man-pages/man7/capabilities.7.html"
        },
        {
          "url": "https://github.com/docker/docker/blob/master/oci/defaults_linux.go#L64-L79"
        }
      ],
      "tags": {
        "ref": "1.\n  https://docs.docker.com/engine/security/security/#linux-kernel-capabilities2.\n  http://man7.org/linux/man-pages/man7/capabilities.7.html3.\n  http://www.oreilly.com/webops-perf/free/files/docker-security.pdf",
        "severity": "medium",
        "cis_id": "5.3",
        "cis_control": [
          "5.1",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-6(9)",
          "4"
        ],
        "check_text": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: CapAdd={{.HostConfig.CapAdd }} CapDrop={{ .HostConfig.CapDrop }}' Verify\n  that the added and dropped Linux Kernel Capabilities are in line with the\n  ones needed for the container process for each container instance.",
        "fix": "Execute the below command to add needed capabilities: $> docker\n  run --cap-add={\"Capability 1\",\"Capability 2\"} For example, docker run\n  --interactive --tty --cap-add={\"NET_ADMIN\",\"SYS_ADMIN\"} centos:latest\n  /bin/bash Execute the below command to drop unneeded capabilities: $> docker\n  run --cap-drop={\"Capability 1\",\"Capability 2\"} For example, docker run\n  --interactive --tty --cap-drop={\"SETUID\",\"SETGID\"}\n  centos:latest /bin/bash Alternatively, You may choose to drop all\n  capabilities and add only add the needed ones: $> docker run --cap-drop=all\n  --cap-add={\"Capability 1\",\"Capability 2\"} For example, docker run\n  --interactive --tty --cap-drop=all --capadd={\"NET_ADMIN\",\"SYS_ADMIN\"}\n  centos:latest /bin/bash",
        "Default Value": "By default, the below capabilities are available for\n  containers: AUDIT_WRITE, CHOWN, DAC_OVERRIDE, FOWNER FSETID, KILL, MKNOD, NET_BIND_SERVICE,\n  NET_RAW, SETFCAP, SETGID, SETPCAP, SETUID, SYS_CHROOT"
      },
      "code": "control 'M-5.3' do\n  title '5.3 Ensure Linux Kernel Capabilities are restricted within containers (Scored)'\n  desc  \"By default, Docker starts containers with a restricted set of Linux Kernel\n  Capabilities. This means that any process may be granted the required capabilities instead of\n  root access. When using Linux Kernel Capabilities, the processes do not have to run as root\n  for almost all of the specific areas where root privileges are usually needed.\n  Docker supports the addition and removal of capabilities, allowing the use\n  of a non-default profile. This may make Docker more secure through capability removal, or\n  less secure through the addition of capabilities. It is thus recommended to remove all\n  capabilities except those explicitly required for your container process.\n  For example, capabilities such as below are usually not needed for\n  container process:\n  NET_ADMIN\n  SYS_ADMIN\n  SYS_MODULE\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  https://docs.docker.com/engine/security/security/#linux-kernel-capabilities2.\n  http://man7.org/linux/man-pages/man7/capabilities.7.html3.\n  http://www.oreilly.com/webops-perf/free/files/docker-security.pdf\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.3'\n  tag \"cis_control\": ['5.1', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-6(9)', '4']\n  tag \"check_text\": \"docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: CapAdd={{.HostConfig.CapAdd }} CapDrop={{ .HostConfig.CapDrop }}' Verify\n  that the added and dropped Linux Kernel Capabilities are in line with the\n  ones needed for the container process for each container instance.\"\n  tag \"fix\": \"Execute the below command to add needed capabilities: $> docker\n  run --cap-add={\\\"Capability 1\\\",\\\"Capability 2\\\"} For example, docker run\n  --interactive --tty --cap-add={\\\"NET_ADMIN\\\",\\\"SYS_ADMIN\\\"} centos:latest\n  /bin/bash Execute the below command to drop unneeded capabilities: $> docker\n  run --cap-drop={\\\"Capability 1\\\",\\\"Capability 2\\\"} For example, docker run\n  --interactive --tty --cap-drop={\\\"SETUID\\\",\\\"SETGID\\\"}\n  centos:latest /bin/bash Alternatively, You may choose to drop all\n  capabilities and add only add the needed ones: $> docker run --cap-drop=all\n  --cap-add={\\\"Capability 1\\\",\\\"Capability 2\\\"} For example, docker run\n  --interactive --tty --cap-drop=all --capadd={\\\"NET_ADMIN\\\",\\\"SYS_ADMIN\\\"}\n  centos:latest /bin/bash\"\n  tag \"Default Value\": \"By default, the below capabilities are available for\n  containers: AUDIT_WRITE, CHOWN, DAC_OVERRIDE, FOWNER FSETID, KILL, MKNOD, NET_BIND_SERVICE,\n  NET_RAW, SETFCAP, SETGID, SETPCAP, SETUID, SYS_CHROOT\"\n  ref url: 'https://docs.docker.com/engine/security/security/'\n  ref url: 'http://man7.org/linux/man-pages/man7/capabilities.7.html'\n  ref url: 'https://github.com/docker/docker/blob/master/oci/defaults_linux.go#L64-L79'\n  if docker.containers.running?.ids.empty?\n    impact 0.0\n    describe 'There are no running docker containers, therfore this control is N/A' do\n      skip 'There are no running docker containers, therfore this control is N/A'\n    end\n  end\n\n  if !docker.containers.running?.ids.empty?\n    docker.containers.running?.ids.each do |id|\n      describe docker.object(id) do\n        its(%w{HostConfig CapDrop}) { should include(/all/) }\n        its(%w{HostConfig CapDrop}) { should_not eq nil }\n        its(%w{HostConfig CapAdd}) { should eq attribute('container_capadd') }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.3.rb",
        "line": 1
      },
      "id": "M-5.3"
    },
    {
      "title": "1.5 Ensure auditing is configured for the docker daemon (Scored)",
      "desc": "Audit all Docker daemon activities.\n  Apart from auditing your regular Linux file system and system calls, audit\n  Docker daemon as well. Docker daemon runs with root privileges. It is thus necessary to\n  audit its activities and usage.",
      "descriptions": {
        "default": "Audit all Docker daemon activities.\n  Apart from auditing your regular Linux file system and system calls, audit\n  Docker daemon as well. Docker daemon runs with root privileges. It is thus necessary to\n  audit its activities and usage."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html",
          "ref": "System auditing"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "1.5",
        "cis_control": [
          "6.2",
          "6.1"
        ],
        "cis_level": "Level 1 - Linux Host OS",
        "nist": [
          "AU-3",
          "4"
        ],
        "check_text": "Verify that there is an audit rule for Docker daemon. For\n  example, execute below command: auditctl -l | grep /usr/bin/docker This\n  should list a rule for Docker daemon.",
        "fix": "Add a rule for Docker daemon. For example, Add the line as\n  below line in /etc/audit/audit.rules file: -w /usr/bin/docker -k docker Then,\n  restart the audit daemon. For example, service auditd restart",
        "Default Value": "By default, Docker daemon is not audited."
      },
      "code": "control 'M-1.5' do\n  title '1.5 Ensure auditing is configured for the docker daemon (Scored)'\n  desc  \"Audit all Docker daemon activities.\n  Apart from auditing your regular Linux file system and system calls, audit\n  Docker daemon as well. Docker daemon runs with root privileges. It is thus necessary to\n  audit its activities and usage.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '1.5'\n  tag \"cis_control\": ['6.2', '6.1']\n  tag \"cis_level\": 'Level 1 - Linux Host OS'\n  tag \"nist\": ['AU-3', '4']\n  tag \"check_text\": \"Verify that there is an audit rule for Docker daemon. For\n  example, execute below command: auditctl -l | grep /usr/bin/docker This\n  should list a rule for Docker daemon.\"\n  tag \"fix\": \"Add a rule for Docker daemon. For example, Add the line as\n  below line in /etc/audit/audit.rules file: -w /usr/bin/docker -k docker Then,\n  restart the audit daemon. For example, service auditd restart\"\n  tag \"Default Value\": 'By default, Docker daemon is not audited.'\n  ref 'System auditing', url: 'https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html'\n\n  only_if { os.linux? }\n  describe auditd do\n    its('lines') { should include '-w /usr/bin/docker -p rwxa -k docker' }\n  end\n  describe service('auditd') do\n    it { should be_installed }\n    it { should be_enabled }\n    it { should be_running }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-1.5.rb",
        "line": 1
      },
      "id": "M-1.5"
    },
    {
      "title": "5.12 Ensure the container's root filesystem is mounted as read only(Scored)",
      "desc": "The container's root filesystem should be treated as a 'golden image' by\n  using Docker run's --read-only option. This prevents any writes to the container's root\n  filesystem at container runtime and enforces the principle of immutable infrastructure.\n  Enabling this option forces containers at runtime to explicitly define their data writing\n  strategy to persist or not persist their data. This also reduces security attack vectors since\n  the container instance's filesystem cannot be tampered with or written to unless it has explicit\n  read-write permissions on its filesystem folder and directories.",
      "descriptions": {
        "default": "The container's root filesystem should be treated as a 'golden image' by\n  using Docker run's --read-only option. This prevents any writes to the container's root\n  filesystem at container runtime and enforces the principle of immutable infrastructure.\n  Enabling this option forces containers at runtime to explicitly define their data writing\n  strategy to persist or not persist their data. This also reduces security attack vectors since\n  the container instance's filesystem cannot be tampered with or written to unless it has explicit\n  read-write permissions on its filesystem folder and directories."
      },
      "impact": 0,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/reference/commandline/cli/#run"
        }
      ],
      "tags": {
        "ref": "1. http://docs.docker.com/reference/commandline/cli/#run2.\n  https://docs.docker.com/engine/tutorials/dockervolumes/3.\n  http://www.projectatomic.io/blog/2015/12/making-docker-images-write-only-inproduction/4.\n  https://docs.docker.com/engine/reference/commandline/run/#mount-tmpfstmpfs5.\n  https://docs.docker.com/engine/tutorials/dockervolumes/#creating-andmounting-a-data-volume-container",
        "severity": "medium",
        "cis_id": "5.12",
        "cis_control": [
          "14",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-6",
          "4"
        ],
        "check_text": "Run the following command on the docker host: docker ps\n  --quiet --all | xargs docker inspect --format '{{ .Id }}: ReadonlyRootfs={{\n  .HostConfig.ReadonlyRootfs }}' If the above command returns true, it means the\n  container's root filesystem is mounted read-only. If the above command\n  returns false, it means the container's root filesystem is writable.",
        "fix": "Add a --read-only flag at a container's runtime to enforce the\n  container's root filesystem to be mounted as read only. docker run <Run\n  arguments> --read-only <Container Image Name or ID> <Command> Enabling the\n  --read-only option at a container's runtime should be used by\n  administrators to force a container's executable processes to only write\n  container data to explicit storage locations during the container's\n  runtime. Examples of explicit storage locations during a container's runtime\n  include, but not limited to: 1. Use the --tmpfs option to mount a temporary\n  file system for non-persistent data writes. docker run --interactive --tty\n  --read-only --tmpfs \"/run\" --tmpfs \"/tmp\" centos /bin/bash2. Enabling\n  Docker rw mounts at a container's runtime to persist container data directly\n  on the Docker host filesystem. docker run --interactive --tty --read-only -v\n  /opt/app/data:/run/app/data:rw centos /bin/bash3. Utilizing Docker\n  shared-storage volume plugins for Docker data volume to persist container\n  data. docker volume create -d convoy --opt o=size=20GB my-named-volume docker\n  run --interactive --tty --read-only -v my-named-volume:/run/app/data centos\n  /bin/bash3. Transmitting container data outside of the docker during the\n  container's runtime for container data to persist container data. Examples\n  include hosted databases, network file shares, and APIs.",
        "Default Value": "By default, a container will have its root filesystem\n  writable allowing all container processes to write files owned by the\n  container's runtime user."
      },
      "code": "control 'M-5.12' do\n  title \"5.12 Ensure the container's root filesystem is mounted as read only(Scored)\"\n  desc  \"The container's root filesystem should be treated as a 'golden image' by\n  using Docker run's --read-only option. This prevents any writes to the container's root\n  filesystem at container runtime and enforces the principle of immutable infrastructure.\n  Enabling this option forces containers at runtime to explicitly define their data writing\n  strategy to persist or not persist their data. This also reduces security attack vectors since\n  the container instance's filesystem cannot be tampered with or written to unless it has explicit\n  read-write permissions on its filesystem folder and directories.\n  \"\n  impact 0.5\n  tag \"ref\": \"1. http://docs.docker.com/reference/commandline/cli/#run2.\n  https://docs.docker.com/engine/tutorials/dockervolumes/3.\n  http://www.projectatomic.io/blog/2015/12/making-docker-images-write-only-inproduction/4.\n  https://docs.docker.com/engine/reference/commandline/run/#mount-tmpfstmpfs5.\n  https://docs.docker.com/engine/tutorials/dockervolumes/#creating-andmounting-a-data-volume-container\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.12'\n  tag \"cis_control\": ['14', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-6', '4']\n  tag \"check_text\": \"Run the following command on the docker host: docker ps\n  --quiet --all | xargs docker inspect --format '{{ .Id }}: ReadonlyRootfs={{\n  .HostConfig.ReadonlyRootfs }}' If the above command returns true, it means the\n  container's root filesystem is mounted read-only. If the above command\n  returns false, it means the container's root filesystem is writable.\"\n  tag \"fix\": \"Add a --read-only flag at a container's runtime to enforce the\n  container's root filesystem to be mounted as read only. docker run <Run\n  arguments> --read-only <Container Image Name or ID> <Command> Enabling the\n  --read-only option at a container's runtime should be used by\n  administrators to force a container's executable processes to only write\n  container data to explicit storage locations during the container's\n  runtime. Examples of explicit storage locations during a container's runtime\n  include, but not limited to: 1. Use the --tmpfs option to mount a temporary\n  file system for non-persistent data writes. docker run --interactive --tty\n  --read-only --tmpfs \\\"/run\\\" --tmpfs \\\"/tmp\\\" centos /bin/bash2. Enabling\n  Docker rw mounts at a container's runtime to persist container data directly\n  on the Docker host filesystem. docker run --interactive --tty --read-only -v\n  /opt/app/data:/run/app/data:rw centos /bin/bash3. Utilizing Docker\n  shared-storage volume plugins for Docker data volume to persist container\n  data. docker volume create -d convoy --opt o=size=20GB my-named-volume docker\n  run --interactive --tty --read-only -v my-named-volume:/run/app/data centos\n  /bin/bash3. Transmitting container data outside of the docker during the\n  container's runtime for container data to persist container data. Examples\n  include hosted databases, network file shares, and APIs.\"\n  tag \"Default Value\": \"By default, a container will have its root filesystem\n  writable allowing all container processes to write files owned by the\n  container's runtime user.\"\n  ref url: 'https://docs.docker.com/engine/reference/commandline/cli/#run'\n\n  if docker.containers.running?.ids.empty?\n    impact 0.0\n    describe 'There are no running docker containers, therfore this control is N/A' do\n      skip 'There are no running docker containers, therfore this control is N/A'\n    end\n  end\n\n  if !docker.containers.running?.ids.empty?\n    docker.containers.running?.ids.each do |id|\n      describe docker.object(id) do\n        its(%w{HostConfig ReadonlyRootfs}) { should eq true }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.12.rb",
        "line": 1
      },
      "id": "M-5.12"
    },
    {
      "title": "2.16 Ensure daemon-wide custom seccomp profile is applied, if needed (Not Scored)",
      "desc": "You can choose to apply your custom seccomp profile at the daemon-wide\n  level if needed and override Docker's default seccomp profile.\n  A large number of system calls are exposed to every userland process with\n  many of them going unused for the entire lifetime of the process. Most of the\n  applications do not need all the system calls and thus benefit by having a reduced set of available\n  system calls. The reduced set of system calls reduces the total kernel surface exposed to the\n  application and thus improvises application security.\n  You could apply your own custom seccomp profile instead of Docker's default\n  seccomp profile. Alternatively, if Docker's default profile is good for your\n  environment, you can choose to ignore this recommendation.",
      "descriptions": {
        "default": "You can choose to apply your custom seccomp profile at the daemon-wide\n  level if needed and override Docker's default seccomp profile.\n  A large number of system calls are exposed to every userland process with\n  many of them going unused for the entire lifetime of the process. Most of the\n  applications do not need all the system calls and thus benefit by having a reduced set of available\n  system calls. The reduced set of system calls reduces the total kernel surface exposed to the\n  application and thus improvises application security.\n  You could apply your own custom seccomp profile instead of Docker's default\n  seccomp profile. Alternatively, if Docker's default profile is good for your\n  environment, you can choose to ignore this recommendation."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "ref": "1. https://docs.docker.com/engine/security/seccomp/\n2.\n  https://github.com/docker/docker/pull/26276\n",
        "severity": "medium",
        "cis_id": "2.16",
        "cis_control": [
          "18",
          "6.1"
        ],
        "cis_level": "Level 2 - Docker",
        "nist": [
          "SI-1",
          "4"
        ],
        "check_text": "Run the below command and review the seccomp profile listed in\n  the Security Options section. If it is default, that means, Docker's default\n  seccomp profile is applied. docker info --format '{{ .SecurityOptions }}'",
        "fix": "By default, Docker's default seccomp profile is applied. If this\n  is good for your environment, no action is necessary. Alternatively, if you\n  choose to apply your own seccomp profile, use the --seccomp-profile flag at\n  daemon start or put it in the daemon runtime parameters file.dockerd\n  --seccomp-profile </path/to/seccomp/profile>",
        "Default Value": "By default, Docker applies a seccomp profile."
      },
      "code": "control 'M-2.16' do\n  title '2.16 Ensure daemon-wide custom seccomp profile is applied, if needed (Not Scored)'\n  desc  \"You can choose to apply your custom seccomp profile at the daemon-wide\n  level if needed and override Docker's default seccomp profile.\n  A large number of system calls are exposed to every userland process with\n  many of them going unused for the entire lifetime of the process. Most of the\n  applications do not need all the system calls and thus benefit by having a reduced set of available\n  system calls. The reduced set of system calls reduces the total kernel surface exposed to the\n  application and thus improvises application security.\n  You could apply your own custom seccomp profile instead of Docker's default\n  seccomp profile. Alternatively, if Docker's default profile is good for your\n  environment, you can choose to ignore this recommendation.\n  \"\n  impact 0.5\n  tag \"ref\": \"1. https://docs.docker.com/engine/security/seccomp/\\n2.\n  https://github.com/docker/docker/pull/26276\\n\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '2.16'\n  tag \"cis_control\": ['18', '6.1']\n  tag \"cis_level\": 'Level 2 - Docker'\n  tag \"nist\": ['SI-1', '4']\n  tag \"check_text\": \"Run the below command and review the seccomp profile listed in\n  the Security Options section. If it is default, that means, Docker's default\n  seccomp profile is applied. docker info --format '{{ .SecurityOptions }}'\"\n  tag \"fix\": \"By default, Docker's default seccomp profile is applied. If this\n  is good for your environment, no action is necessary. Alternatively, if you\n  choose to apply your own seccomp profile, use the --seccomp-profile flag at\n  daemon start or put it in the daemon runtime parameters file.dockerd\n  --seccomp-profile </path/to/seccomp/profile>\"\n  tag \"Default Value\": 'By default, Docker applies a seccomp profile.'\n  seccomp_profile = command(\"docker info --format '{{ .SecurityOptions }}'\").stdout.strip\n  describe 'The docker seccommp profile applied' do\n    subject { seccomp_profile }\n    it { should_not include 'name=seccomp,profile=default' }\n  end\n\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-2.16.rb",
        "line": 1
      },
      "id": "M-2.16"
    },
    {
      "title": "3.1 Ensure that docker.service file ownership is set to root:root (Scored)",
      "desc": "Verify that the docker.service file ownership and group-ownership are\n  correctly set to root. The docker.service file contains sensitive parameters that may alter the\n  behavior of the Docker daemon. Hence, it should be owned and group-owned by root to maintain the\n  integrity of the file.",
      "descriptions": {
        "default": "Verify that the docker.service file ownership and group-ownership are\n  correctly set to root. The docker.service file contains sensitive parameters that may alter the\n  behavior of the Docker daemon. Hence, it should be owned and group-owned by root to maintain the\n  integrity of the file."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/admin/systemd/",
          "ref": "systemd"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "3.1",
        "cis_control": [
          "5.1",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-6(9)",
          "4"
        ],
        "check_text": "Step 1: Find out the file location: systemctl show -p\n  FragmentPath docker.service Step 2: If the file does not exist, this\n  recommendation is not applicable. If the file exists, execute the below\n  command with the correct file path to verify that the file is owned\n  and group-owned by root. For example, stat -c %U:%G\n  /usr/lib/systemd/system/docker.service | grep -v root:root The above command\n  should not return anything.",
        "fix": "Step 1: Find out the file location: systemctl show -p\n  FragmentPath docker.service Step 2: If the file does not exist, this\n  recommendation is not applicable. If the file exists, execute the below\n  command with the correct file path to set the ownership and group ownership\n  for the file to root. For example, chown root:root\n  /usr/lib/systemd/system/docker.service",
        "Default Value": "This file may not be present on the system. In that\n  case, this recommendation is not applicable. By default, if the file is\n  present, the ownership and group-ownership for this file is correctly set to\n  root."
      },
      "code": "control 'M-3.1' do\n  title '3.1 Ensure that docker.service file ownership is set to root:root (Scored)'\n  desc  \"Verify that the docker.service file ownership and group-ownership are\n  correctly set to root. The docker.service file contains sensitive parameters that may alter the\n  behavior of the Docker daemon. Hence, it should be owned and group-owned by root to maintain the\n  integrity of the file.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '3.1'\n  tag \"cis_control\": ['5.1', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-6(9)', '4']\n  tag \"check_text\": \"Step 1: Find out the file location: systemctl show -p\n  FragmentPath docker.service Step 2: If the file does not exist, this\n  recommendation is not applicable. If the file exists, execute the below\n  command with the correct file path to verify that the file is owned\n  and group-owned by root. For example, stat -c %U:%G\n  /usr/lib/systemd/system/docker.service | grep -v root:root The above command\n  should not return anything.\"\n  tag \"fix\": \"Step 1: Find out the file location: systemctl show -p\n  FragmentPath docker.service Step 2: If the file does not exist, this\n  recommendation is not applicable. If the file exists, execute the below\n  command with the correct file path to set the ownership and group ownership\n  for the file to root. For example, chown root:root\n  /usr/lib/systemd/system/docker.service\"\n  tag \"Default Value\": \"This file may not be present on the system. In that\n  case, this recommendation is not applicable. By default, if the file is\n  present, the ownership and group-ownership for this file is correctly set to\n  root.\"\n  ref 'systemd', url: 'https://docs.docker.com/engine/admin/systemd/'\n\n  docker_service_file = command('systemctl show -p FragmentPath docker.service').stdout.strip\n\n  equal_sign = docker_service_file.index('=')\n\n  docker_service_file = docker_service_file[equal_sign+1..-1]\n\n  if file(docker_service_file.to_s).exist?\n\n    describe file('docker_service_file') do\n      it { should exist }\n      it { should be_file }\n      it { should be_owned_by 'root' }\n      it { should be_grouped_into 'root' }\n    end\n\n  else\n    impact 0.0\n    describe 'The docker service file does not exist, therefore this control is N/A' do\n      skip 'The docker service file does not exist, therefore this control is N/A'\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-3.1.rb",
        "line": 1
      },
      "id": "M-3.1"
    },
    {
      "title": "6.1 Ensure image sprawl is avoided (Not Scored)",
      "desc": "Do not keep a large number of container images on the same host. Use only\n  tagged images as appropriate. Tagged images are useful to fall back from \"latest\" to a specific\n  version of an image in production. Images with unused or old tags may contain vulnerabilities that\n  might be exploited, if instantiated. Additionally, if you fail to remove unused\n  images from the system and there are various such redundant and unused images, the host filesystem\n  may become full, which could lead to denial of service.",
      "descriptions": {
        "default": "Do not keep a large number of container images on the same host. Use only\n  tagged images as appropriate. Tagged images are useful to fall back from \"latest\" to a specific\n  version of an image in production. Images with unused or old tags may contain vulnerabilities that\n  might be exploited, if instantiated. Additionally, if you fail to remove unused\n  images from the system and there are various such redundant and unused images, the host filesystem\n  may become full, which could lead to denial of service."
      },
      "impact": 0.5,
      "refs": [
        {
          "ref": "http://craiccomputing.blogspot.de/2014/09/clean-up-unused-docker-containers-and.html"
        },
        {
          "ref": "https://forums.docker.com/t/command-to-remove-all-unused-images/20/7"
        },
        {
          "ref": "https://github.com/docker/docker/issues/9054"
        },
        {
          "ref": "https://docs.docker.com/engine/reference/commandline/cli/#rmi"
        },
        {
          "ref": "https://docs.docker.com/engine/reference/commandline/cli/#pull"
        },
        {
          "ref": "https://github.com/docker/docker/pull/11109"
        }
      ],
      "tags": {
        "ref": "1.\n  http://craiccomputing.blogspot.in/2014/09/clean-up-unused-docker-containersand.html2.\n  https://forums.docker.com/t/command-to-remove-all-unused-images/20/83.\n  https://github.com/docker/docker/issues/90544.\n  https://docs.docker.com/engine/reference/commandline/rmi/5.\n  https://docs.docker.com/engine/reference/commandline/pull/6.\n  https://github.com/docker/docker/pull/11109",
        "severity": "medium",
        "cis_id": "6.1",
        "cis_control": [
          "18",
          "6.1"
        ],
        "cis_level": "Level 1 - Linux Host OS",
        "nist": [
          "SI-1",
          "4"
        ],
        "check_text": "Step 1 Make a list of all image IDs that are currently\n  instantiated by executing below command: docker images --quiet | xargs docker\n  inspect --format '{{ .Id }}: Image={{.Config.Image }}' Step 2: List all the\n  images present on the system by executing below command: docker images Step\n  3: Compare the list of image IDs populated from Step 1 and Step 2 and find out\n  which images are currently not being instantiated. If any such unused or old\n  images are found, discuss with the system administrator the need to keep such\n  images on the system. If such a need is not justified enough, then this\n  recommendation is non-compliant.",
        "fix": "Keep the set of the images that you actually need and establish a\n  workflow to remove old or stale images from the host. Additionally, use\n  features such as pull-by-digest to get specific images from the\n  registry. Additionally, you can follow the below set of steps to find out unused\n  images on the system and delete them. Step 1 Make a list of all image IDs\n  that are currently instantiated by executing the below command: docker images\n  --quiet | xargs docker inspect --format '{{ .Id }}: Image={{.Config.Image\n  }}' Step 2: List all the images present on the system by executing below\n  command: docker images Step 3: Compare the list of image IDs populated from\n  Step 1 and Step 2 and find out which images are currently not being\n  instantiated. Step 4: Decide if you want to keep the images that are not\n  currently in use. If not delete them by executing the below command: docker rmi\n  $IMAGE_ID",
        "Default Value": "Images and layered filesystems remain accessible on the\n  host until the administrator removes all tags that refer to those images or layers."
      },
      "code": "control 'M-6.1' do\n  title '6.1 Ensure image sprawl is avoided (Not Scored)'\n  desc  \"Do not keep a large number of container images on the same host. Use only\n  tagged images as appropriate. Tagged images are useful to fall back from \\\"latest\\\" to a specific\n  version of an image in production. Images with unused or old tags may contain vulnerabilities that\n  might be exploited, if instantiated. Additionally, if you fail to remove unused\n  images from the system and there are various such redundant and unused images, the host filesystem\n  may become full, which could lead to denial of service.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  http://craiccomputing.blogspot.in/2014/09/clean-up-unused-docker-containersand.html2.\n  https://forums.docker.com/t/command-to-remove-all-unused-images/20/83.\n  https://github.com/docker/docker/issues/90544.\n  https://docs.docker.com/engine/reference/commandline/rmi/5.\n  https://docs.docker.com/engine/reference/commandline/pull/6.\n  https://github.com/docker/docker/pull/11109\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '6.1'\n  tag \"cis_control\": ['18', '6.1']\n  tag \"cis_level\": 'Level 1 - Linux Host OS'\n  tag \"nist\": ['SI-1', '4']\n  tag \"check_text\": \"Step 1 Make a list of all image IDs that are currently\n  instantiated by executing below command: docker images --quiet | xargs docker\n  inspect --format '{{ .Id }}: Image={{.Config.Image }}' Step 2: List all the\n  images present on the system by executing below command: docker images Step\n  3: Compare the list of image IDs populated from Step 1 and Step 2 and find out\n  which images are currently not being instantiated. If any such unused or old\n  images are found, discuss with the system administrator the need to keep such\n  images on the system. If such a need is not justified enough, then this\n  recommendation is non-compliant.\"\n  tag \"fix\": \"Keep the set of the images that you actually need and establish a\n  workflow to remove old or stale images from the host. Additionally, use\n  features such as pull-by-digest to get specific images from the\n  registry. Additionally, you can follow the below set of steps to find out unused\n  images on the system and delete them. Step 1 Make a list of all image IDs\n  that are currently instantiated by executing the below command: docker images\n  --quiet | xargs docker inspect --format '{{ .Id }}: Image={{.Config.Image\n  }}' Step 2: List all the images present on the system by executing below\n  command: docker images Step 3: Compare the list of image IDs populated from\n  Step 1 and Step 2 and find out which images are currently not being\n  instantiated. Step 4: Decide if you want to keep the images that are not\n  currently in use. If not delete them by executing the below command: docker rmi\n  $IMAGE_ID\"\n  tag \"Default Value\": \"Images and layered filesystems remain accessible on the\n  host until the administrator removes all tags that refer to those images or layers.\"\n  ref 'http://craiccomputing.blogspot.de/2014/09/clean-up-unused-docker-containers-and.html'\n  ref 'https://forums.docker.com/t/command-to-remove-all-unused-images/20/7'\n  ref 'https://github.com/docker/docker/issues/9054'\n  ref 'https://docs.docker.com/engine/reference/commandline/cli/#rmi'\n  ref 'https://docs.docker.com/engine/reference/commandline/cli/#pull'\n  ref 'https://github.com/docker/docker/pull/11109'\n\n  instantiated_images = command('docker ps -qa | xargs docker inspect -f \\'{{.Image}}\\'').stdout.split\n  all_images = command('docker images -q --no-trunc').stdout.split\n  diff = all_images - instantiated_images\n\n  describe diff do\n    it { should be_empty }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-6.1.rb",
        "line": 1
      },
      "id": "M-6.1"
    },
    {
      "title": "5.19 Ensure mount propagation mode is not set to shared (Scored)",
      "desc": "Mount propagation mode allows mounting volumes in shared, slave or private\n  mode on a container. Do not use shared mount propagation mode until needed.\n  A shared mount is replicated at all mounts and the changes made at any\n  mount point are propagated to all mounts. Mounting a volume in shared mode does not\n  restrict any other container to mount and make changes to that volume. This might be\n  catastrophic if the mounted volume is sensitive to changes. Do not set mount propagation mode\n  to shared until needed.",
      "descriptions": {
        "default": "Mount propagation mode allows mounting volumes in shared, slave or private\n  mode on a container. Do not use shared mount propagation mode until needed.\n  A shared mount is replicated at all mounts and the changes made at any\n  mount point are propagated to all mounts. Mounting a volume in shared mode does not\n  restrict any other container to mount and make changes to that volume. This might be\n  catastrophic if the mounted volume is sensitive to changes. Do not set mount propagation mode\n  to shared until needed."
      },
      "impact": 0,
      "refs": [
        {
          "url": "https://github.com/docker/docker/pull/17034"
        },
        {
          "url": "https://docs.docker.com/engine/reference/run/"
        },
        {
          "url": "https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt"
        }
      ],
      "tags": {
        "ref": "1. https://github.com/docker/docker/pull/170342.\n  https://docs.docker.com/engine/reference/run/#volume-shared-filesystems3.\n  https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt",
        "severity": "medium",
        "cis_id": "5.19",
        "cis_control": [
          "14",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-6",
          "4"
        ],
        "check_text": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}:Propagation={{range $mnt := .Mounts}} {{json $mnt.Propagation}}\n  {{end}}' The above command would return the propagation mode for mounted\n  volumes. Propagation mode should not be set to shared unless needed. The above\n  command might throw errors if there are no mounts. In that case, this\n  recommendation is not applicable.",
        "fix": "Do not mount volumes in shared mode propagation. For example, do\n  not start container as below: docker run <Run arguments>\n  --volume=/hostPath:/containerPath:shared <Container Image Name or ID>\n  <Command>",
        "Default Value": "By default, the container mounts are private."
      },
      "code": "control 'M-5.19' do\n  title '5.19 Ensure mount propagation mode is not set to shared (Scored)'\n  desc  \"Mount propagation mode allows mounting volumes in shared, slave or private\n  mode on a container. Do not use shared mount propagation mode until needed.\n  A shared mount is replicated at all mounts and the changes made at any\n  mount point are propagated to all mounts. Mounting a volume in shared mode does not\n  restrict any other container to mount and make changes to that volume. This might be\n  catastrophic if the mounted volume is sensitive to changes. Do not set mount propagation mode\n  to shared until needed.\n  \"\n  impact 0.5\n  tag \"ref\": \"1. https://github.com/docker/docker/pull/170342.\n  https://docs.docker.com/engine/reference/run/#volume-shared-filesystems3.\n  https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.19'\n  tag \"cis_control\": ['14', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-6', '4']\n  tag \"check_text\": \"docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}:Propagation={{range $mnt := .Mounts}} {{json $mnt.Propagation}}\n  {{end}}' The above command would return the propagation mode for mounted\n  volumes. Propagation mode should not be set to shared unless needed. The above\n  command might throw errors if there are no mounts. In that case, this\n  recommendation is not applicable.\"\n  tag \"fix\": \"Do not mount volumes in shared mode propagation. For example, do\n  not start container as below: docker run <Run arguments>\n  --volume=/hostPath:/containerPath:shared <Container Image Name or ID>\n  <Command>\"\n  tag \"Default Value\": 'By default, the container mounts are private.'\n  ref url: 'https://github.com/docker/docker/pull/17034'\n  ref url: 'https://docs.docker.com/engine/reference/run/'\n  ref url: 'https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt'\n\n  if docker.containers.running?.ids.empty?\n    impact 0.0\n    describe 'There are no running docker containers, therfore this control is N/A' do\n      skip 'There are no running docker containers, therfore this control is N/A'\n    end\n  end\n\n  if !docker.containers.running?.ids.empty?\n    docker.containers.running?.ids.each do |id|\n      raw = command(\"docker inspect --format '{{range $mnt := .Mounts}} {{json $mnt.Propagation}} {{end}}' #{id}\").stdout\n      describe raw.delete(\"\\n\").delete('\\\"').delete(' ') do\n        it { should_not eq 'shared' }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.19.rb",
        "line": 1
      },
      "id": "M-5.19"
    },
    {
      "title": "5.31 Ensure the Docker socket is not mounted inside any containers (Scored)",
      "desc": "The docker socket docker.sock should not be mounted inside a container.\n  If the docker socket is mounted inside a container it would allow processes\n  running within the container to execute docker commands which effectively allows for full\n  control of the host.",
      "descriptions": {
        "default": "The docker socket docker.sock should not be mounted inside a container.\n  If the docker socket is mounted inside a container it would allow processes\n  running within the container to execute docker commands which effectively allows for full\n  control of the host."
      },
      "impact": 0,
      "refs": [],
      "tags": {
        "ref": "1.\n  https://raesene.github.io/blog/2016/03/06/The-Dangers-Of-Docker.sock/2.\n  https://forums.docker.com/t/docker-in-docker-vs-mounting-var-run-dockersock/9450/23.\n  https://github.com/docker/docker/issues/21109",
        "severity": "medium",
        "cis_id": "5.31",
        "cis_control": [
          "9",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SC-7",
          "4"
        ],
        "check_text": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: Volumes={{ .Mounts }}' | grep docker.sock The above command would return\n  any instances where docker.sock had been mapped to a container as a volume.",
        "fix": "Ensure that no containers mount docker.sock as a volume.",
        "Default Value": "By default, docker.sock is not mounted inside\n  containers."
      },
      "code": "control 'M-5.31' do\n  title '5.31 Ensure the Docker socket is not mounted inside any containers (Scored)'\n  desc  \"The docker socket docker.sock should not be mounted inside a container.\n  If the docker socket is mounted inside a container it would allow processes\n  running within the container to execute docker commands which effectively allows for full\n  control of the host.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  https://raesene.github.io/blog/2016/03/06/The-Dangers-Of-Docker.sock/2.\n  https://forums.docker.com/t/docker-in-docker-vs-mounting-var-run-dockersock/9450/23.\n  https://github.com/docker/docker/issues/21109\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.31'\n  tag \"cis_control\": ['9', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SC-7', '4']\n  tag \"check_text\": \"docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: Volumes={{ .Mounts }}' | grep docker.sock The above command would return\n  any instances where docker.sock had been mapped to a container as a volume.\"\n  tag \"fix\": 'Ensure that no containers mount docker.sock as a volume.'\n  tag \"Default Value\": \"By default, docker.sock is not mounted inside\n  containers.\"\n  if !docker.containers.running?.ids.empty?\n    docker.containers.running?.ids.each do |id|\n      if !docker.object(id).Mounts.empty?\n        docker.object(id).Mounts.each do |mount|\n          describe mount do\n            its('Source') { should_not include 'docker.sock' }\n          end\n        end\n      else\n        impact 0.0\n        describe 'There are no docker container mounts, therefore this control is N/A' do\n          skip 'There are no docker container mounts, therefore this control is N/A'\n        end\n      end\n    end\n  else\n    impact 0.0\n    describe 'There are no docker containers running, therefore this control is N/A' do\n      skip 'There are no docker containers running, therefore this control is N/A'\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.31.rb",
        "line": 1
      },
      "id": "M-5.31"
    },
    {
      "title": "1.13 Ensure auditing is configured for Docker files and directories\n  /usr/bin/docker-runc (Scored)",
      "desc": "Audit /usr/bin/docker-runc, if applicable.\nApart from auditing your regular Linux file system and system calls, audit all Docker\nrelated files and directories. Docker daemon runs with root privileges. Its\nbehavior depends on some key files and directories. /usr/bin/docker-runc is one such\nfile. Docker now relies on containerd and runC to spawn containers. It must be audited,\nif applicable.",
      "descriptions": {
        "default": "Audit /usr/bin/docker-runc, if applicable.\nApart from auditing your regular Linux file system and system calls, audit all Docker\nrelated files and directories. Docker daemon runs with root privileges. Its\nbehavior depends on some key files and directories. /usr/bin/docker-runc is one such\nfile. Docker now relies on containerd and runC to spawn containers. It must be audited,\nif applicable."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html",
          "ref": "System auditing"
        },
        {
          "url": "https://github.com/docker/docker/pull/20662",
          "ref": "Containerd integration"
        },
        {
          "url": "https://containerd.tools/",
          "ref": "Containerd tools"
        },
        {
          "url": "https://github.com/opencontainers/runc",
          "ref": "Opencontainers runc repository"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "1.13",
        "cis_control": [
          "14.6",
          "6.1"
        ],
        "cis_level": "Level 1 - Linux Host OS",
        "nist": [
          "AU-2",
          "4"
        ],
        "check_text": "Verify that there is an audit rule corresponding to\n  /usr/bin/docker-runc file. For example, execute below command: auditctl -l |\n  grep /usr/bin/docker-runc This should list a rule for /usr/bin/docker-runc\n  file.",
        "fix": "Add a rule for /usr/bin/docker-runc file. For example, Add the\n  line as below in /etc/audit/audit.rules file: -w /usr/bin/docker-runc -k\n  docker Then, restart the audit daemon. For example, service auditd restart",
        "Default Value": "By default, Docker related files and directories are\n  not audited. The file/usr/bin/dockerrunc may not be available on the system. In\n  that case, this recommendation is not applicable."
      },
      "code": "control 'M-1.13' do\n  title \"1.13 Ensure auditing is configured for Docker files and directories\n  /usr/bin/docker-runc (Scored)\"\n  desc  \"\n  Audit /usr/bin/docker-runc, if applicable.\n  Apart from auditing your regular Linux file system and system calls, audit all Docker\n  related files and directories. Docker daemon runs with root privileges. Its\n  behavior depends on some key files and directories. /usr/bin/docker-runc is one such\n  file. Docker now relies on containerd and runC to spawn containers. It must be audited,\n  if applicable.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '1.13'\n  tag \"cis_control\": ['14.6', '6.1']\n  tag \"cis_level\": 'Level 1 - Linux Host OS'\n  tag \"nist\": ['AU-2', '4']\n  tag \"check_text\": \"Verify that there is an audit rule corresponding to\n  /usr/bin/docker-runc file. For example, execute below command: auditctl -l |\n  grep /usr/bin/docker-runc This should list a rule for /usr/bin/docker-runc\n  file.\"\n  tag \"fix\": \"Add a rule for /usr/bin/docker-runc file. For example, Add the\n  line as below in /etc/audit/audit.rules file: -w /usr/bin/docker-runc -k\n  docker Then, restart the audit daemon. For example, service auditd restart\"\n  tag \"Default Value\": \"By default, Docker related files and directories are\n  not audited. The file/usr/bin/dockerrunc may not be available on the system. In\n  that case, this recommendation is not applicable.\"\n  ref 'System auditing', url: 'https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html'\n  ref 'Containerd integration', url: 'https://github.com/docker/docker/pull/20662'\n  ref 'Containerd tools', url: 'https://containerd.tools/'\n  ref 'Opencontainers runc repository', url: 'https://github.com/opencontainers/runc'\n\n  describe auditd do\n    its('lines') { should include '-w /usr/bin/docker-runc -p rwxa -k docker' }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-1.13.rb",
        "line": 1
      },
      "id": "M-1.13"
    },
    {
      "title": "3.19 Ensure that the /etc/default/docker file ownership is set to root:root(Scored)",
      "desc": "Verify that the /etc/default/docker file ownership and group-ownership is\n  correctly set to root.\n  The /etc/default/docker file contains sensitive parameters that may alter the\n  behavior of the docker daemon. Hence, it should be owned and group-owned by root to\n  maintain the integrity of the file.",
      "descriptions": {
        "default": "Verify that the /etc/default/docker file ownership and group-ownership is\n  correctly set to root.\n  The /etc/default/docker file contains sensitive parameters that may alter the\n  behavior of the docker daemon. Hence, it should be owned and group-owned by root to\n  maintain the integrity of the file."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/admin/configuring/"
        }
      ],
      "tags": {
        "ref": "1. https://docs.docker.com/engine/admin/configuring/",
        "severity": "medium",
        "cis_id": "3.19",
        "cis_control": [
          "5.1",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-6(9)",
          "4"
        ],
        "check_text": "Execute the below command to verify that the file is owned and\n  group-owned by root: stat -c %U:%G /etc/default/docker | grep -v\n  root:root The above command should not return anything.",
        "fix": "chown root:root /etc/default/docker This would set the ownership\n  and group-ownership for the file to root.",
        "Default Value": "This file may not be present on the system. In that\n  case, this recommendation is not applicable."
      },
      "code": "control 'M-3.19' do\n  title '3.19 Ensure that the /etc/default/docker file ownership is set to root:root(Scored)'\n  desc  \"Verify that the /etc/default/docker file ownership and group-ownership is\n  correctly set to root.\n  The /etc/default/docker file contains sensitive parameters that may alter the\n  behavior of the docker daemon. Hence, it should be owned and group-owned by root to\n  maintain the integrity of the file.\n  \"\n  impact 0.5\n  tag \"ref\": '1. https://docs.docker.com/engine/admin/configuring/'\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '3.19'\n  tag \"cis_control\": ['5.1', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-6(9)', '4']\n  tag \"check_text\": \"Execute the below command to verify that the file is owned and\n  group-owned by root: stat -c %U:%G /etc/default/docker | grep -v\n  root:root The above command should not return anything.\"\n  tag \"fix\": \"chown root:root /etc/default/docker This would set the ownership\n  and group-ownership for the file to root.\"\n  tag \"Default Value\": \"This file may not be present on the system. In that\n  case, this recommendation is not applicable.\"\n  ref url: 'https://docs.docker.com/engine/admin/configuring/'\n\n  only_if { os[:family] != 'centos' }\n  describe file('/etc/default/docker') do\n    it { should exist }\n    it { should be_file }\n    it { should be_owned_by 'root' }\n    it { should be_grouped_into 'root' }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-3.19.rb",
        "line": 1
      },
      "id": "M-3.19"
    },
    {
      "title": "7.5 Ensure Docker's secret management commands are used for managing secrets in a Swarm cluster (Not Scored)",
      "desc": "Use Docker's in-built secret management command.\n  Docker has various commands for managing secrets in a Swarm cluster. This\n  is the foundation for future secret support in Docker with potential improvements\n  such as Windows support, different backing stores, etc.",
      "descriptions": {
        "default": "Use Docker's in-built secret management command.\n  Docker has various commands for managing secrets in a Swarm cluster. This\n  is the foundation for future secret support in Docker with potential improvements\n  such as Windows support, different backing stores, etc."
      },
      "impact": 0,
      "refs": [],
      "tags": {
        "ref": "1. https://docs.docker.com/engine/reference/commandline/secret/",
        "severity": "medium",
        "cis_id": "7.5",
        "cis_control": [
          "18",
          "6.1"
        ],
        "cis_level": "Level 2 - Docker",
        "nist": [
          "SI-1",
          "4"
        ],
        "check_text": "On a swarm manager node, run the below command and ensure\n  docker secret management is used in your environment, if applicable. docker\n  secret ls",
        "fix": "Follow docker secret documentation and use it to manage secrets effectively.",
        "Default Value": "Not Applicable"
      },
      "code": "control 'M-7.5' do\n  title \"7.5 Ensure Docker's secret management commands are used for managing secrets in a Swarm cluster (Not Scored)\"\n  desc  \"Use Docker's in-built secret management command.\n  Docker has various commands for managing secrets in a Swarm cluster. This\n  is the foundation for future secret support in Docker with potential improvements\n  such as Windows support, different backing stores, etc.\n  \"\n  impact 0.5\n  tag \"ref\": '1. https://docs.docker.com/engine/reference/commandline/secret/'\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '7.5'\n  tag \"cis_control\": ['18', '6.1']\n  tag \"cis_level\": 'Level 2 - Docker'\n  tag \"nist\": ['SI-1', '4']\n  tag \"check_text\": \"On a swarm manager node, run the below command and ensure\n  docker secret management is used in your environment, if applicable. docker\n  secret ls\"\n  tag \"fix\": 'Follow docker secret documentation and use it to manage secrets effectively.'\n  tag \"Default Value\": 'Not Applicable'\n  if attribute('swarm_mode') == 'active'\n    secret_management_commands = command('docker secret ls -q').stdout.split(\"\\n\").length\n\n    describe 'The docker secret management commands' do\n      subject { secret_management_commands }\n      it { should be > 0 }\n    end\n  else\n    impact 0.0\n    describe 'The docker swarm mode is not being used, therefore this control is N/A' do\n      skip 'The docker swarm mode is not being used, therefore this control is N/A'\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-7.5.rb",
        "line": 1
      },
      "id": "M-7.5"
    },
    {
      "title": "3.15 Ensure that Docker socket file ownership is set to root:docker(Scored)",
      "desc": "Verify that the Docker socket file is owned by root and group-owned by\n  docker. The docker daemon runs as root. The default Unix socket hence must be owned by\n  root. If any other user or process owns this socket, then it might be possible for that\n  non-privileged user or process to interact with the docker daemon. Also, such a non-privileged\n  user or process might interact with containers. This is neither a secure nor desired\n  behavior. Additionally, the Docker installer creates a Unix group called docker. You\n  can add users to this group, and then those users would be able to read and write to the default\n  Docker Unix socket. The membership to the docker group is tightly controlled by the\n  system administrator. If any other group owns this socket, then it might be\n  possible for members of that group to interact with the Docker daemon. Also, such a group might not\n  be as tightly controlled as the docker group. This is neither secure nor desired behavior.\n  Hence, the default Docker Unix socket file must be owned by root and group-owned by\n  docker to maintain the integrity of the socket file.",
      "descriptions": {
        "default": "Verify that the Docker socket file is owned by root and group-owned by\n  docker. The docker daemon runs as root. The default Unix socket hence must be owned by\n  root. If any other user or process owns this socket, then it might be possible for that\n  non-privileged user or process to interact with the docker daemon. Also, such a non-privileged\n  user or process might interact with containers. This is neither a secure nor desired\n  behavior. Additionally, the Docker installer creates a Unix group called docker. You\n  can add users to this group, and then those users would be able to read and write to the default\n  Docker Unix socket. The membership to the docker group is tightly controlled by the\n  system administrator. If any other group owns this socket, then it might be\n  possible for members of that group to interact with the Docker daemon. Also, such a group might not\n  be as tightly controlled as the docker group. This is neither secure nor desired behavior.\n  Hence, the default Docker Unix socket file must be owned by root and group-owned by\n  docker to maintain the integrity of the socket file."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/reference/commandline/cli/#daemon-socket-option"
        },
        {
          "url": "https://docs.docker.com/engine/quickstart/"
        }
      ],
      "tags": {
        "ref": "1.\n  https://docs.docker.com/engine/reference/commandline/dockerd/#daemonsocket-option2.\n  https://docs.docker.com/engine/reference/commandline/dockerd/#bind-dockerto-another-hostport-or-a-unix-socket",
        "severity": "medium",
        "cis_id": "3.15",
        "cis_control": [
          "5.1",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-6(9)",
          "4"
        ],
        "check_text": "Execute the below command to verify that the Docker socket file\n  is owned by root and group-owned by docker: stat -c %U:%G\n  /var/run/docker.sock | grep -v root:docker The above command should not return\n  anything.",
        "fix": "chown root:docker /var/run/docker.sock This would set the\n  ownership to root and group-ownership to docker for the default Docker socket file.",
        "Default Value": "By default, the ownership and group-ownership for\n  the Docker socket file is correctly set to root:docker."
      },
      "code": "control 'M-3.15' do\n  title '3.15 Ensure that Docker socket file ownership is set to root:docker(Scored)'\n  desc  \"Verify that the Docker socket file is owned by root and group-owned by\n  docker. The docker daemon runs as root. The default Unix socket hence must be owned by\n  root. If any other user or process owns this socket, then it might be possible for that\n  non-privileged user or process to interact with the docker daemon. Also, such a non-privileged\n  user or process might interact with containers. This is neither a secure nor desired\n  behavior. Additionally, the Docker installer creates a Unix group called docker. You\n  can add users to this group, and then those users would be able to read and write to the default\n  Docker Unix socket. The membership to the docker group is tightly controlled by the\n  system administrator. If any other group owns this socket, then it might be\n  possible for members of that group to interact with the Docker daemon. Also, such a group might not\n  be as tightly controlled as the docker group. This is neither secure nor desired behavior.\n  Hence, the default Docker Unix socket file must be owned by root and group-owned by\n  docker to maintain the integrity of the socket file.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  https://docs.docker.com/engine/reference/commandline/dockerd/#daemonsocket-option2.\n  https://docs.docker.com/engine/reference/commandline/dockerd/#bind-dockerto-another-hostport-or-a-unix-socket\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '3.15'\n  tag \"cis_control\": ['5.1', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-6(9)', '4']\n  tag \"check_text\": \"Execute the below command to verify that the Docker socket file\n  is owned by root and group-owned by docker: stat -c %U:%G\n  /var/run/docker.sock | grep -v root:docker The above command should not return\n  anything.\"\n  tag \"fix\": \"chown root:docker /var/run/docker.sock This would set the\n  ownership to root and group-ownership to docker for the default Docker socket file.\"\n  tag \"Default Value\": \"By default, the ownership and group-ownership for\n  the Docker socket file is correctly set to root:docker.\"\n  ref url: 'https://docs.docker.com/engine/reference/commandline/cli/#daemon-socket-option'\n  ref url: 'https://docs.docker.com/engine/quickstart/'\n\n  describe file('/var/run/docker.sock') do\n    it { should exist }\n    it { should be_socket }\n    it { should be_owned_by 'root' }\n    it { should be_grouped_into 'docker' }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-3.15.rb",
        "line": 1
      },
      "id": "M-3.15"
    },
    {
      "title": "4.4 Ensure images are scanned and rebuilt to include security patches (Not Scored)",
      "desc": "Images should be scanned frequently for any vulnerabilities. Rebuild\n  the images toinclude patches and then instantiate new containers from it.\n  Vulnerabilities are loopholes/bugs that can be exploited and security\n  patches are updates to resolve these vulnerabilities. We can use image vulnerability scanning\n  tools to find any kind of vulnerabilities within the images and then check for available\n  patches to mitigate these vulnerabilities. Patches update the system to the most recent code\n  base. Being on the current code base is important because that's where vendors focus on fixing\n  problems. Evaluate the security patches before applying and follow the patching best\n  practices. Also, it would be better if, image vulnerability scanning tools could\n  perform binary level analysis or hash based verification instead of just version string matching.",
      "descriptions": {
        "default": "Images should be scanned frequently for any vulnerabilities. Rebuild\n  the images toinclude patches and then instantiate new containers from it.\n  Vulnerabilities are loopholes/bugs that can be exploited and security\n  patches are updates to resolve these vulnerabilities. We can use image vulnerability scanning\n  tools to find any kind of vulnerabilities within the images and then check for available\n  patches to mitigate these vulnerabilities. Patches update the system to the most recent code\n  base. Being on the current code base is important because that's where vendors focus on fixing\n  problems. Evaluate the security patches before applying and follow the patching best\n  practices. Also, it would be better if, image vulnerability scanning tools could\n  perform binary level analysis or hash based verification instead of just version string matching."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/userguide/containers/dockerimages/"
        }
      ],
      "tags": {
        "ref": "1.2.3.4.https://docs.docker.com/userguide/dockerimages/\n  https://docs.docker.com/docker-cloud/builds/image-scan/ https://blog.docker.com/2016/05/docker-security-scanning/ https://docs.docker.com/engine/reference/builder/#/onbuild",
        "severity": "medium",
        "cis_id": "4.4",
        "cis_control": [
          "18.1",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SI-2",
          "4"
        ],
        "check_text": "Step 1: List all the running instances of containers by\n  executing below command: docker ps --quiet Step 2: For each container\n  instance, execute the below or equivalent command to find the list of packages\n  installed within the container. Ensure that the security updates for\n  various affected packages are installed. docker exec $INSTANCE_ID rpm\n  -qa Alternatively, you could run image vulnerability scanning tools which can\n  scan all the images in your ecosystem and then apply patches for the detected\n  vulnerabilities based on your patch management procedures.",
        "fix": "Follow the below steps to rebuild the images with security\n  patches: Step 1: Pull all the base images (i.e., given your set of\n  Dockerfiles, extract all images declared in FROM instructions, and re-pull\n  them to check for an updated/patched versions). Patch the packages within the\n  images too. docker pull Step 2: Force a rebuild of each image: docker build\n  --no-cache Step 3: Restart all containers with the updated images. You could\n  also use ONBUILD directive in the Dockerfile to trigger particular\n  update instructions for images that you know are used as base images\n  frequently.",
        "Default Value": "By default, containers and images are not updated on\n  their own."
      },
      "code": "control 'M-4.4' do\n  title '4.4 Ensure images are scanned and rebuilt to include security patches (Not Scored)'\n  desc  \"Images should be scanned frequently for any vulnerabilities. Rebuild\n  the images toinclude patches and then instantiate new containers from it.\n  Vulnerabilities are loopholes/bugs that can be exploited and security\n  patches are updates to resolve these vulnerabilities. We can use image vulnerability scanning\n  tools to find any kind of vulnerabilities within the images and then check for available\n  patches to mitigate these vulnerabilities. Patches update the system to the most recent code\n  base. Being on the current code base is important because that's where vendors focus on fixing\n  problems. Evaluate the security patches before applying and follow the patching best\n  practices. Also, it would be better if, image vulnerability scanning tools could\n  perform binary level analysis or hash based verification instead of just version string matching.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.2.3.4.https://docs.docker.com/userguide/dockerimages/\n  https://docs.docker.com/docker-cloud/builds/image-scan/ https://blog.docker.com/2016/05/docker-security-scanning/ https://docs.docker.com/engine/reference/builder/#/onbuild\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '4.4'\n  tag \"cis_control\": ['18.1', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SI-2', '4']\n  tag \"check_text\": \"Step 1: List all the running instances of containers by\n  executing below command: docker ps --quiet Step 2: For each container\n  instance, execute the below or equivalent command to find the list of packages\n  installed within the container. Ensure that the security updates for\n  various affected packages are installed. docker exec $INSTANCE_ID rpm\n  -qa Alternatively, you could run image vulnerability scanning tools which can\n  scan all the images in your ecosystem and then apply patches for the detected\n  vulnerabilities based on your patch management procedures.\"\n  tag \"fix\": \"Follow the below steps to rebuild the images with security\n  patches: Step 1: Pull all the base images (i.e., given your set of\n  Dockerfiles, extract all images declared in FROM instructions, and re-pull\n  them to check for an updated/patched versions). Patch the packages within the\n  images too. docker pull Step 2: Force a rebuild of each image: docker build\n  --no-cache Step 3: Restart all containers with the updated images. You could\n  also use ONBUILD directive in the Dockerfile to trigger particular\n  update instructions for images that you know are used as base images\n  frequently.\"\n  tag \"Default Value\": \"By default, containers and images are not updated on\n  their own.\"\n  ref url: 'https://docs.docker.com/engine/userguide/containers/dockerimages/'\n  describe 'A manual review is required to ensure images are scanned and rebuilt to include security patches' do\n    skip 'A manual review is required to ensure images are scanned and rebuilt to include security patches'\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-4.4.rb",
        "line": 1
      },
      "id": "M-4.4"
    },
    {
      "title": "7.1 Ensure swarm mode is not Enabled, if not needed (Scored)",
      "desc": "Do not enable swarm mode on a docker engine instance unless needed.\n  By default, a Docker engine instance will not listen on any network ports,\n  with all communications with the client coming over the Unix socket. When Docker\n  swarm mode is enabled on a docker engine instance, multiple network ports are opened on\n  the system and made available to other systems on the network for the purposes of cluster\n  management and node communications.\n  Opening network ports on a system increases its attack surface and this should be avoided unless required.",
      "descriptions": {
        "default": "Do not enable swarm mode on a docker engine instance unless needed.\n  By default, a Docker engine instance will not listen on any network ports,\n  with all communications with the client coming over the Unix socket. When Docker\n  swarm mode is enabled on a docker engine instance, multiple network ports are opened on\n  the system and made available to other systems on the network for the purposes of cluster\n  management and node communications.\n  Opening network ports on a system increases its attack surface and this should be avoided unless required."
      },
      "impact": 0,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/reference/commandline/swarm_init/",
          "ref": "docker swarm init"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "7.1",
        "cis_control": [
          "9.1",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "CM-7(1)",
          "4"
        ],
        "check_text": "Review the output of the docker info command. If the output\n  includes Swarm: active it indicates that swarm mode has been activated on the\n  Docker engine. Confirm whether swarm mode on the docker engine instance is actually\n  needed.",
        "fix": "If swarm mode has been enabled on a system in error, run docker swarm leave",
        "Default Value": "By default, docker swarm mode is not enabled."
      },
      "code": "control 'M-7.1' do\n  title '7.1 Ensure swarm mode is not Enabled, if not needed (Scored)'\n  desc  \"Do not enable swarm mode on a docker engine instance unless needed.\n  By default, a Docker engine instance will not listen on any network ports,\n  with all communications with the client coming over the Unix socket. When Docker\n  swarm mode is enabled on a docker engine instance, multiple network ports are opened on\n  the system and made available to other systems on the network for the purposes of cluster\n  management and node communications.\n  Opening network ports on a system increases its attack surface and this should be avoided unless required.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '7.1'\n  tag \"cis_control\": ['9.1', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['CM-7(1)', '4']\n  tag \"check_text\": \"Review the output of the docker info command. If the output\n  includes Swarm: active it indicates that swarm mode has been activated on the\n  Docker engine. Confirm whether swarm mode on the docker engine instance is actually\n  needed.\"\n  tag \"fix\": 'If swarm mode has been enabled on a system in error, run docker swarm leave'\n  tag \"Default Value\": 'By default, docker swarm mode is not enabled.'\n  ref 'docker swarm init', url: 'https://docs.docker.com/engine/reference/commandline/swarm_init/'\n  if attribute('swarm_mode') == 'active'\n    describe docker.info do\n      its('Swarm.LocalNodeState') { should eq attribute('swarm_mode') }\n    end\n  else\n    impact 0.0\n    describe 'The docker swarm mode is not being used, therefore this control is N/A' do\n      skip 'The docker swarm mode is not being used, therefore this control is N/A'\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-7.1.rb",
        "line": 1
      },
      "id": "M-7.1"
    },
    {
      "title": "2.13 Ensure operations on legacy registry (v1) are Disabled (Scored)",
      "desc": "The latest Docker registry is v2. All operations on the legacy registry\n  version (v1) should be restricted.\n  Docker registry v2 brings in many performance and security improvements\n  over v1. It supports container image provenance and other security features such as\n  image signing and verification. Hence, operations on Docker legacy registry should be restricted.",
      "descriptions": {
        "default": "The latest Docker registry is v2. All operations on the legacy registry\n  version (v1) should be restricted.\n  Docker registry v2 brings in many performance and security improvements\n  over v1. It supports container image provenance and other security features such as\n  image signing and verification. Hence, operations on Docker legacy registry should be restricted."
      },
      "impact": 0.5,
      "refs": [
        {
          "url": "https://docs.docker.com/edge/engine/reference/commandline/dockerd/#legacyregistries",
          "ref": "legacyregistries"
        },
        {
          "url": "https://docs.docker.com/engine/reference/commandline/daemon/#storage-driver-options",
          "ref": "Docker daemon storage driver options"
        },
        {
          "url": "https://github.com/docker/docker/issues/8093",
          "ref": "Proposal: Provenance step 1 - Transform images for validation and verification"
        },
        {
          "url": "https://github.com/docker/docker/issues/9015",
          "ref": "Proposal: JSON Registry API V2.1"
        },
        {
          "url": "https://github.com/docker/docker-registry/issues/612",
          "ref": "Registry next generation"
        },
        {
          "url": "https://docs.docker.com/registry/spec/api/",
          "ref": "Docker Registry HTTP API V2"
        },
        {
          "url": "https://the.binbashtheory.com/creating-private-docker-registry-2-0-with-token-authentication-service/",
          "ref": "Creating Private Docker Registry 2.0 with Token Authentication Service"
        },
        {
          "url": "https://blog.docker.com/2015/07/new-tool-v1-registry-docker-trusted-registry-v2-open-source/",
          "ref": "New Tool to Migrate From V1 Registry to Docker Trusted Registry or V2 Open Source Registry"
        },
        {
          "url": "https://www.slideshare.net/Docker/docker-registry-v2",
          "ref": "Docker Registry V2"
        }
      ],
      "tags": {
        "severity": "medium",
        "cis_id": "2.13",
        "cis_control": [
          "18",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "SI-1",
          "4"
        ],
        "check_text": "ps -ef | grep dockerd The above command should list\n  --disable-legacy-registry as an option passed to the docker daemon.",
        "fix": "Start the docker daemon as below:\ndockerd\n  --disable-legacy-registry",
        "Default Value": "By default, legacy registry operations are allowed."
      },
      "code": "control 'M-2.13' do\n  title '2.13 Ensure operations on legacy registry (v1) are Disabled (Scored)'\n  desc  \"The latest Docker registry is v2. All operations on the legacy registry\n  version (v1) should be restricted.\n  Docker registry v2 brings in many performance and security improvements\n  over v1. It supports container image provenance and other security features such as\n  image signing and verification. Hence, operations on Docker legacy registry should be restricted.\n  \"\n  impact 0.5\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '2.13'\n  tag \"cis_control\": ['18', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['SI-1', '4']\n  tag \"check_text\": \"ps -ef | grep dockerd The above command should list\n  --disable-legacy-registry as an option passed to the docker daemon.\"\n  tag \"fix\": \"Start the docker daemon as below:\\ndockerd\n  --disable-legacy-registry\"\n  tag \"Default Value\": 'By default, legacy registry operations are allowed.'\n  ref 'legacyregistries', url: 'https://docs.docker.com/edge/engine/reference/commandline/dockerd/#legacyregistries'\n  ref 'Docker daemon storage driver options', url: 'https://docs.docker.com/engine/reference/commandline/daemon/#storage-driver-options'\n  ref 'Proposal: Provenance step 1 - Transform images for validation and verification', url: 'https://github.com/docker/docker/issues/8093'\n  ref 'Proposal: JSON Registry API V2.1', url: 'https://github.com/docker/docker/issues/9015'\n  ref 'Registry next generation', url: 'https://github.com/docker/docker-registry/issues/612'\n  ref 'Docker Registry HTTP API V2', url: 'https://docs.docker.com/registry/spec/api/'\n  ref 'Creating Private Docker Registry 2.0 with Token Authentication Service', url: 'https://the.binbashtheory.com/creating-private-docker-registry-2-0-with-token-authentication-service/'\n  ref 'New Tool to Migrate From V1 Registry to Docker Trusted Registry or V2 Open Source Registry', url: 'https://blog.docker.com/2015/07/new-tool-v1-registry-docker-trusted-registry-v2-open-source/'\n  ref 'Docker Registry V2', url: 'https://www.slideshare.net/Docker/docker-registry-v2'\n\n  describe json('/etc/docker/daemon.json') do\n    its(['disable-legacy-registry']) { should eq(true) }\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-2.13.rb",
        "line": 1
      },
      "id": "M-2.13"
    },
    {
      "title": "5.5 Ensure sensitive host system directories are not mounted on containers (Scored)",
      "desc": "Sensitive host system directories such as below should not be allowed to be\n  mounted as container volumes especially in read-write mode.\n  /\n  /boot\n  /dev\n  /etc\n  /lib\n  /proc\n  /sys\n  /usr\n  If sensitive directories are mounted in read-write mode, it would be\n  possible to make changes to files within those sensitive directories. The changes might\n  bring down security implications or unwarranted changes that could put the Docker host in\n  a compromised state.",
      "descriptions": {
        "default": "Sensitive host system directories such as below should not be allowed to be\n  mounted as container volumes especially in read-write mode.\n  /\n  /boot\n  /dev\n  /etc\n  /lib\n  /proc\n  /sys\n  /usr\n  If sensitive directories are mounted in read-write mode, it would be\n  possible to make changes to files within those sensitive directories. The changes might\n  bring down security implications or unwarranted changes that could put the Docker host in\n  a compromised state."
      },
      "impact": 0,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/userguide/containers/dockervolumes/"
        }
      ],
      "tags": {
        "ref": "1. https://docs.docker.com/engine/tutorials/dockervolumes/\n",
        "severity": "medium",
        "cis_id": "5.5",
        "cis_control": [
          "14",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-6",
          "4"
        ],
        "check_text": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: Volumes={{ .Mounts }}' The above commands would return the list of\n  current mapped directories and whether they are mounted in read-write mode for\n  each container instance.",
        "fix": "Do not mount host sensitive directories on containers especially\n  in read-write mode.",
        "Default Value": "Docker defaults to a read-write volume but you can also\n  mount a directory read-only. By default, no sensitive host directories are\n  mounted on containers."
      },
      "code": "control 'M-5.5' do\n  title '5.5 Ensure sensitive host system directories are not mounted on containers (Scored)'\n  desc  \"Sensitive host system directories such as below should not be allowed to be\n  mounted as container volumes especially in read-write mode.\n  /\n  /boot\n  /dev\n  /etc\n  /lib\n  /proc\n  /sys\n  /usr\n  If sensitive directories are mounted in read-write mode, it would be\n  possible to make changes to files within those sensitive directories. The changes might\n  bring down security implications or unwarranted changes that could put the Docker host in\n  a compromised state.\n  \"\n  impact 0.5\n  tag \"ref\": \"1. https://docs.docker.com/engine/tutorials/dockervolumes/\\n\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.5'\n  tag \"cis_control\": ['14', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-6', '4']\n  tag \"check_text\": \"docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: Volumes={{ .Mounts }}' The above commands would return the list of\n  current mapped directories and whether they are mounted in read-write mode for\n  each container instance.\"\n  tag \"fix\": \"Do not mount host sensitive directories on containers especially\n  in read-write mode.\"\n  tag \"Default Value\": \"Docker defaults to a read-write volume but you can also\n  mount a directory read-only. By default, no sensitive host directories are\n  mounted on containers.\"\n  ref url: 'https://docs.docker.com/engine/userguide/containers/dockervolumes/'\n\n  if !docker.containers.running?.ids.empty?\n    docker.containers.running?.ids.each do |id|\n      info = docker.object(id)\n      if !info['Mounts'].empty?\n        info['Mounts'].each do |mounts|\n          describe mounts['Source'] do\n            it { should_not eq '/' }\n            it { should_not match(%r{\\/boot}) }\n            it { should_not match(%r{\\/dev}) }\n            it { should_not match(%r{\\/etc}) }\n            it { should_not match(%r{\\/lib}) }\n            it { should_not match(%r{\\/proc}) }\n            it { should_not match(%r{\\/sys}) }\n            it { should_not match(%r{\\/usr}) }\n          end\n        end\n      else\n        impact 0.0\n        describe 'There are no docker container mounts, therefore this control is N/A' do\n          skip 'There are no docker container mounts, therefore this control is N/A'\n        end\n      end\n    end\n  else\n    impact 0.0\n    describe 'There are no docker containers running, therefore this control is N/A' do\n      skip 'There are no docker containers running, therefore this control is N/A'\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.5.rb",
        "line": 1
      },
      "id": "M-5.5"
    },
    {
      "title": "5.4 Ensure privileged containers are not used (Scored)",
      "desc": "Using the --privileged flag gives all Linux Kernel Capabilities to the\n  container thus overwriting the --cap-add and --cap-drop flags. Ensure that it is not used.\n  The --privileged flag gives all capabilities to the container, and it also\n  lifts all OF the limitations enforced by the device cgroup controller. In other words, the\n  container can then do almost everything that the host can do. This flag exists to allow\n  special use-cases, like running Docker within Docker.",
      "descriptions": {
        "default": "Using the --privileged flag gives all Linux Kernel Capabilities to the\n  container thus overwriting the --cap-add and --cap-drop flags. Ensure that it is not used.\n  The --privileged flag gives all capabilities to the container, and it also\n  lifts all OF the limitations enforced by the device cgroup controller. In other words, the\n  container can then do almost everything that the host can do. This flag exists to allow\n  special use-cases, like running Docker within Docker."
      },
      "impact": 0,
      "refs": [
        {
          "url": "https://docs.docker.com/engine/reference/commandline/cli/"
        }
      ],
      "tags": {
        "ref": "1.\n  https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linuxcapabilities",
        "severity": "medium",
        "cis_id": "5.4",
        "cis_control": [
          "5.1",
          "6.1"
        ],
        "cis_level": "Level 1 - Docker",
        "nist": [
          "AC-6(9)",
          "4"
        ],
        "check_text": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: Privileged={{ .HostConfig.Privileged }}' The above command should return\n  Privileged=false for each container instance.",
        "fix": "Do not run container with the --privileged flag. For example, do\n  not start a container as below: docker run --interactive --tty --privileged\n  centos /bin/bash",
        "Default Value": "False."
      },
      "code": "control 'M-5.4' do\n  title '5.4 Ensure privileged containers are not used (Scored)'\n  desc  \"Using the --privileged flag gives all Linux Kernel Capabilities to the\n  container thus overwriting the --cap-add and --cap-drop flags. Ensure that it is not used.\n  The --privileged flag gives all capabilities to the container, and it also\n  lifts all OF the limitations enforced by the device cgroup controller. In other words, the\n  container can then do almost everything that the host can do. This flag exists to allow\n  special use-cases, like running Docker within Docker.\n  \"\n  impact 0.5\n  tag \"ref\": \"1.\n  https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linuxcapabilities\"\n  tag \"severity\": 'medium'\n  tag \"cis_id\": '5.4'\n  tag \"cis_control\": ['5.1', '6.1']\n  tag \"cis_level\": 'Level 1 - Docker'\n  tag \"nist\": ['AC-6(9)', '4']\n  tag \"check_text\": \"docker ps --quiet --all | xargs docker inspect --format '{{ .Id\n  }}: Privileged={{ .HostConfig.Privileged }}' The above command should return\n  Privileged=false for each container instance.\"\n  tag \"fix\": \"Do not run container with the --privileged flag. For example, do\n  not start a container as below: docker run --interactive --tty --privileged\n  centos /bin/bash\"\n  tag \"Default Value\": 'False.'\n  ref url: 'https://docs.docker.com/engine/reference/commandline/cli/'\n\n  if docker.containers.running?.ids.empty?\n    impact 0.0\n    describe 'There are no running docker containers, therfore this control is N/A' do\n      skip 'There are no running docker containers, therfore this control is N/A'\n    end\n  end\n\n  if !docker.containers.running?.ids.empty?\n    docker.containers.running?.ids.each do |id|\n      describe docker.object(id) do\n        its(%w{HostConfig Privileged}) { should eq false }\n        its(%w{HostConfig Privileged}) { should_not eq true }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./Docker CE CIS/controls/M-5.4.rb",
        "line": 1
      },
      "id": "M-5.4"
    }
  ],
  "groups": [
    {
      "title": null,
      "controls": [
        "M-5.14"
      ],
      "id": "controls/M-5.14.rb"
    },
    {
      "title": null,
      "controls": [
        "M-5.27"
      ],
      "id": "controls/M-5.27.rb"
    },
    {
      "title": null,
      "controls": [
        "M-7.8"
      ],
      "id": "controls/M-7.8.rb"
    },
    {
      "title": null,
      "controls": [
        "M-1.1"
      ],
      "id": "controls/M-1.1.rb"
    },
    {
      "title": null,
      "controls": [
        "M-3.12"
      ],
      "id": "controls/M-3.12.rb"
    },
    {
      "title": null,
      "controls": [
        "M-1.6"
      ],
      "id": "controls/M-1.6.rb"
    },
    {
      "title": null,
      "controls": [
        "M-2.3"
      ],
      "id": "controls/M-2.3.rb"
    },
    {
      "title": null,
      "controls": [
        "M-5.25"
      ],
      "id": "controls/M-5.25.rb"
    },
    {
      "title": null,
      "controls": [
        "M-5.29"
      ],
      "id": "controls/M-5.29.rb"
    },
    {
      "title": null,
      "controls": [
        "M-1.7"
      ],
      "id": "controls/M-1.7.rb"
    },
    {
      "title": null,
      "controls": [
        "M-5.10"
      ],
      "id": "controls/M-5.10.rb"
    },
    {
      "title": null,
      "controls": [
        "M-2.9"
      ],
      "id": "controls/M-2.9.rb"
    },
    {
      "title": null,
      "controls": [
        "M-7.3"
      ],
      "id": "controls/M-7.3.rb"
    },
    {
      "title": null,
      "controls": [
        "M-3.5"
      ],
      "id": "controls/M-3.5.rb"
    },
    {
      "title": null,
      "controls": [
        "M-1.3"
      ],
      "id": "controls/M-1.3.rb"
    },
    {
      "title": null,
      "controls": [
        "M-5.23"
      ],
      "id": "controls/M-5.23.rb"
    },
    {
      "title": null,
      "controls": [
        "M-3.10"
      ],
      "id": "controls/M-3.10.rb"
    },
    {
      "title": null,
      "controls": [
        "M-1.11"
      ],
      "id": "controls/M-1.11.rb"
    },
    {
      "title": null,
      "controls": [
        "M-3.11"
      ],
      "id": "controls/M-3.11.rb"
    },
    {
      "title": null,
      "controls": [
        "M-1.10"
      ],
      "id": "controls/M-1.10.rb"
    },
    {
      "title": null,
      "controls": [
        "M-7.9"
      ],
      "id": "controls/M-7.9.rb"
    },
    {
      "title": null,
      "controls": [
        "M-7.6"
      ],
      "id": "controls/M-7.6.rb"
    },
    {
      "title": null,
      "controls": [
        "M-7.7"
      ],
      "id": "controls/M-7.7.rb"
    },
    {
      "title": null,
      "controls": [
        "M-2.15"
      ],
      "id": "controls/M-2.15.rb"
    },
    {
      "title": null,
      "controls": [
        "M-4.1"
      ],
      "id": "controls/M-4.1.rb"
    },
    {
      "title": null,
      "controls": [
        "M-3.16"
      ],
      "id": "controls/M-3.16.rb"
    },
    {
      "title": null,
      "controls": [
        "M-5.20"
      ],
      "id": "controls/M-5.20.rb"
    },
    {
      "title": null,
      "controls": [
        "M-5.26"
      ],
      "id": "controls/M-5.26.rb"
    },
    {
      "title": null,
      "controls": [
        "M-5.22"
      ],
      "id": "controls/M-5.22.rb"
    },
    {
      "title": null,
      "controls": [
        "M-7.10"
      ],
      "id": "controls/M-7.10.rb"
    },
    {
      "title": null,
      "controls": [
        "M-4.8"
      ],
      "id": "controls/M-4.8.rb"
    },
    {
      "title": null,
      "controls": [
        "M-5.16"
      ],
      "id": "controls/M-5.16.rb"
    },
    {
      "title": null,
      "controls": [
        "M-5.11"
      ],
      "id": "controls/M-5.11.rb"
    },
    {
      "title": null,
      "controls": [
        "M-5.15"
      ],
      "id": "controls/M-5.15.rb"
    },
    {
      "title": null,
      "controls": [
        "M-7.2"
      ],
      "id": "controls/M-7.2.rb"
    },
    {
      "title": null,
      "controls": [
        "M-2.6"
      ],
      "id": "controls/M-2.6.rb"
    },
    {
      "title": null,
      "controls": [
        "M-4.3"
      ],
      "id": "controls/M-4.3.rb"
    },
    {
      "title": null,
      "controls": [
        "M-5.30"
      ],
      "id": "controls/M-5.30.rb"
    },
    {
      "title": null,
      "controls": [
        "M-5.18"
      ],
      "id": "controls/M-5.18.rb"
    },
    {
      "title": null,
      "controls": [
        "M-3.6"
      ],
      "id": "controls/M-3.6.rb"
    },
    {
      "title": null,
      "controls": [
        "M-1.2"
      ],
      "id": "controls/M-1.2.rb"
    },
    {
      "title": null,
      "controls": [
        "M-4.2"
      ],
      "id": "controls/M-4.2.rb"
    },
    {
      "title": null,
      "controls": [
        "M-3.8"
      ],
      "id": "controls/M-3.8.rb"
    },
    {
      "title": null,
      "controls": [
        "M-2.17"
      ],
      "id": "controls/M-2.17.rb"
    },
    {
      "title": null,
      "controls": [
        "M-5.2"
      ],
      "id": "controls/M-5.2.rb"
    },
    {
      "title": null,
      "controls": [
        "M-3.20"
      ],
      "id": "controls/M-3.20.rb"
    },
    {
      "title": null,
      "controls": [
        "M-3.14"
      ],
      "id": "controls/M-3.14.rb"
    },
    {
      "title": null,
      "controls": [
        "M-2.14"
      ],
      "id": "controls/M-2.14.rb"
    },
    {
      "title": null,
      "controls": [
        "M-4.10"
      ],
      "id": "controls/M-4.10.rb"
    },
    {
      "title": null,
      "controls": [
        "M-2.11"
      ],
      "id": "controls/M-2.11.rb"
    },
    {
      "title": null,
      "controls": [
        "M-5.17"
      ],
      "id": "controls/M-5.17.rb"
    },
    {
      "title": null,
      "controls": [
        "M-4.9"
      ],
      "id": "controls/M-4.9.rb"
    },
    {
      "title": null,
      "controls": [
        "M-1.4"
      ],
      "id": "controls/M-1.4.rb"
    },
    {
      "title": null,
      "controls": [
        "M-5.1"
      ],
      "id": "controls/M-5.1.rb"
    },
    {
      "title": null,
      "controls": [
        "M-3.7"
      ],
      "id": "controls/M-3.7.rb"
    },
    {
      "title": null,
      "controls": [
        "M-2.4"
      ],
      "id": "controls/M-2.4.rb"
    },
    {
      "title": null,
      "controls": [
        "M-7.4"
      ],
      "id": "controls/M-7.4.rb"
    },
    {
      "title": null,
      "controls": [
        "M-5.24"
      ],
      "id": "controls/M-5.24.rb"
    },
    {
      "title": null,
      "controls": [
        "M-5.13"
      ],
      "id": "controls/M-5.13.rb"
    },
    {
      "title": null,
      "controls": [
        "M-4.5"
      ],
      "id": "controls/M-4.5.rb"
    },
    {
      "title": null,
      "controls": [
        "M-3.2"
      ],
      "id": "controls/M-3.2.rb"
    },
    {
      "title": null,
      "controls": [
        "M-1.8"
      ],
      "id": "controls/M-1.8.rb"
    },
    {
      "title": null,
      "controls": [
        "M-3.9"
      ],
      "id": "controls/M-3.9.rb"
    },
    {
      "title": null,
      "controls": [
        "M-5.7"
      ],
      "id": "controls/M-5.7.rb"
    },
    {
      "title": null,
      "controls": [
        "M-6.2"
      ],
      "id": "controls/M-6.2.rb"
    },
    {
      "title": null,
      "controls": [
        "M-3.17"
      ],
      "id": "controls/M-3.17.rb"
    },
    {
      "title": null,
      "controls": [
        "M-4.7"
      ],
      "id": "controls/M-4.7.rb"
    },
    {
      "title": null,
      "controls": [
        "M-1.9"
      ],
      "id": "controls/M-1.9.rb"
    },
    {
      "title": null,
      "controls": [
        "M-2.2"
      ],
      "id": "controls/M-2.2.rb"
    },
    {
      "title": null,
      "controls": [
        "M-2.12"
      ],
      "id": "controls/M-2.12.rb"
    },
    {
      "title": null,
      "controls": [
        "M-4.6"
      ],
      "id": "controls/M-4.6.rb"
    },
    {
      "title": null,
      "controls": [
        "M-5.28"
      ],
      "id": "controls/M-5.28.rb"
    },
    {
      "title": null,
      "controls": [
        "M-3.4"
      ],
      "id": "controls/M-3.4.rb"
    },
    {
      "title": null,
      "controls": [
        "M-5.9"
      ],
      "id": "controls/M-5.9.rb"
    },
    {
      "title": null,
      "controls": [
        "M-2.8"
      ],
      "id": "controls/M-2.8.rb"
    },
    {
      "title": null,
      "controls": [
        "M-2.10"
      ],
      "id": "controls/M-2.10.rb"
    },
    {
      "title": null,
      "controls": [
        "M-2.18"
      ],
      "id": "controls/M-2.18.rb"
    },
    {
      "title": null,
      "controls": [
        "M-1.12"
      ],
      "id": "controls/M-1.12.rb"
    },
    {
      "title": null,
      "controls": [
        "M-2.5"
      ],
      "id": "controls/M-2.5.rb"
    },
    {
      "title": null,
      "controls": [
        "M-4.11"
      ],
      "id": "controls/M-4.11.rb"
    },
    {
      "title": null,
      "controls": [
        "M-5.8"
      ],
      "id": "controls/M-5.8.rb"
    },
    {
      "title": null,
      "controls": [
        "M-3.18"
      ],
      "id": "controls/M-3.18.rb"
    },
    {
      "title": null,
      "controls": [
        "M-3.3"
      ],
      "id": "controls/M-3.3.rb"
    },
    {
      "title": null,
      "controls": [
        "M-5.21"
      ],
      "id": "controls/M-5.21.rb"
    },
    {
      "title": null,
      "controls": [
        "M-2.7"
      ],
      "id": "controls/M-2.7.rb"
    },
    {
      "title": null,
      "controls": [
        "M-2.1"
      ],
      "id": "controls/M-2.1.rb"
    },
    {
      "title": null,
      "controls": [
        "M-3.13"
      ],
      "id": "controls/M-3.13.rb"
    },
    {
      "title": null,
      "controls": [
        "M-5.6"
      ],
      "id": "controls/M-5.6.rb"
    },
    {
      "title": null,
      "controls": [
        "M-5.3"
      ],
      "id": "controls/M-5.3.rb"
    },
    {
      "title": null,
      "controls": [
        "M-1.5"
      ],
      "id": "controls/M-1.5.rb"
    },
    {
      "title": null,
      "controls": [
        "M-5.12"
      ],
      "id": "controls/M-5.12.rb"
    },
    {
      "title": null,
      "controls": [
        "M-2.16"
      ],
      "id": "controls/M-2.16.rb"
    },
    {
      "title": null,
      "controls": [
        "M-3.1"
      ],
      "id": "controls/M-3.1.rb"
    },
    {
      "title": null,
      "controls": [
        "M-6.1"
      ],
      "id": "controls/M-6.1.rb"
    },
    {
      "title": null,
      "controls": [
        "M-5.19"
      ],
      "id": "controls/M-5.19.rb"
    },
    {
      "title": null,
      "controls": [
        "M-5.31"
      ],
      "id": "controls/M-5.31.rb"
    },
    {
      "title": null,
      "controls": [
        "M-1.13"
      ],
      "id": "controls/M-1.13.rb"
    },
    {
      "title": null,
      "controls": [
        "M-3.19"
      ],
      "id": "controls/M-3.19.rb"
    },
    {
      "title": null,
      "controls": [
        "M-7.5"
      ],
      "id": "controls/M-7.5.rb"
    },
    {
      "title": null,
      "controls": [
        "M-3.15"
      ],
      "id": "controls/M-3.15.rb"
    },
    {
      "title": null,
      "controls": [
        "M-4.4"
      ],
      "id": "controls/M-4.4.rb"
    },
    {
      "title": null,
      "controls": [
        "M-7.1"
      ],
      "id": "controls/M-7.1.rb"
    },
    {
      "title": null,
      "controls": [
        "M-2.13"
      ],
      "id": "controls/M-2.13.rb"
    },
    {
      "title": null,
      "controls": [
        "M-5.5"
      ],
      "id": "controls/M-5.5.rb"
    },
    {
      "title": null,
      "controls": [
        "M-5.4"
      ],
      "id": "controls/M-5.4.rb"
    }
  ],
  "sha256": "c5835699f13d555eaa28056a68c9aa5d8090df514a8c85192ba2ae8fcba0353d",
  "status_message": "",
  "status": "loaded",
  "generator": {
    "name": "inspec",
    "version": "4.33.1"
  }
}