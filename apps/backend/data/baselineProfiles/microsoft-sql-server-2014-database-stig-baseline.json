{
  "name": "microsoft-sql-server-2014-database-stig-baseline",
  "title": "microsoft-sql-server-2014-database-stig-baseline",
  "maintainer": "The MITRE Corporation",
  "copyright": "(c) 2018 The MITRE Corporation",
  "copyright_email": "inspec@mitre.org",
  "license": "Apache-2.0",
  "summary": "Inspec Validation Profile for Microsoft SQL Server 2014 Database STIG",
  "version": "1.6.0",
  "inspec_version": ">= 4.0",
  "inputs": [],
  "supports": [],
  "controls": [
    {
      "title": "SQL Server must generate Trace or Audit records when locally-defined\nsecurity objects are modified.",
      "desc": "SQL Server protects its built-in security objects (tables, views,\nfunctions, procedures, etc.) from alteration by database users and\nadministrators.  However, applications sometimes have additional,\nsecurity-related objects defined in the database.  ALTER operations on these\nobjects must be monitored.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.",
      "descriptions": {
        "default": "SQL Server protects its built-in security objects (tables, views,\nfunctions, procedures, etc.) from alteration by database users and\nadministrators.  However, applications sometimes have additional,\nsecurity-related objects defined in the database.  ALTER operations on these\nobjects must be monitored.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000496-DB-000334",
        "gid": "V-67421",
        "rid": "SV-81911r2_rule",
        "stig_id": "SQL4-00-036400",
        "fix_id": "F-73535r1_fix",
        "cci": [
          "CCI-000172"
        ],
        "nist": [
          "AU-12 c",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "If there are no locally-defined security tables or procedures,\nthis is not a finding.\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes,\nthis is a finding.\n\nIf SQL Server Trace is in use for audit purposes, verify  that all required\nevents are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\nAll currently defined traces for the SQL server instance will be listed. If no\ntraces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing\nrequirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should all be among those listed; if not, this\nis a finding:\n\n46  -- Object:Created\n47  -- Object:Deleted\n162  -- User error message\n164 -- Object:Altered\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the broad, server-level audit action group\nSCHEMA_OBJECT_CHANGE_GROUP for this purpose.  SQL Server Audit's flexibility\nmakes other techniques possible.  If an alternative technique is in use and\ndemonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their\nnames.\n\nRun the following to verify that all CREATE, ALTER, and DROP actions on any\nlocally-defined permissions tables, procedures and functions are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_CHANGE_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"SUCCESS\" or \"SUCCESS AND FAILURE\",\nthis is a finding.",
        "fix": "Where SQL Server Trace is in use, define  and enable a trace that\ncaptures all auditable events.  The script provided in the supplemental file\nTrace.sql can be used to do this.\n\nWhere SQL Server Audit is in use, design and deploy a SQL Server Audit that\ncaptures all auditable events.  The script provided in the supplemental file\nAudit.sql can be used for this.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_CHANGE_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO"
      },
      "code": "control 'V-67421' do\n  title \"SQL Server must generate Trace or Audit records when locally-defined\nsecurity objects are modified.\"\n  desc  \"SQL Server protects its built-in security objects (tables, views,\nfunctions, procedures, etc.) from alteration by database users and\nadministrators.  However, applications sometimes have additional,\nsecurity-related objects defined in the database.  ALTER operations on these\nobjects must be monitored.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n  \"\n  impact 0.5\n  tag \"gtitle\": 'SRG-APP-000496-DB-000334'\n  tag \"gid\": 'V-67421'\n  tag \"rid\": 'SV-81911r2_rule'\n  tag \"stig_id\": 'SQL4-00-036400'\n  tag \"fix_id\": 'F-73535r1_fix'\n  tag \"cci\": ['CCI-000172']\n  tag \"nist\": ['AU-12 c', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"If there are no locally-defined security tables or procedures,\nthis is not a finding.\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes,\nthis is a finding.\n\nIf SQL Server Trace is in use for audit purposes, verify  that all required\nevents are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\nAll currently defined traces for the SQL server instance will be listed. If no\ntraces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing\nrequirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should all be among those listed; if not, this\nis a finding:\n\n46  -- Object:Created\n47  -- Object:Deleted\n162  -- User error message\n164 -- Object:Altered\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the broad, server-level audit action group\nSCHEMA_OBJECT_CHANGE_GROUP for this purpose.  SQL Server Audit's flexibility\nmakes other techniques possible.  If an alternative technique is in use and\ndemonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\n\nAlternatively, review the contents of the system views with \\\"audit\\\" in their\nnames.\n\nRun the following to verify that all CREATE, ALTER, and DROP actions on any\nlocally-defined permissions tables, procedures and functions are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_CHANGE_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \\\"SUCCESS\\\" or \\\"SUCCESS AND FAILURE\\\",\nthis is a finding.\"\n  tag \"fix\": \"Where SQL Server Trace is in use, define  and enable a trace that\ncaptures all auditable events.  The script provided in the supplemental file\nTrace.sql can be used to do this.\n\nWhere SQL Server Audit is in use, design and deploy a SQL Server Audit that\ncaptures all auditable events.  The script provided in the supplemental file\nAudit.sql can be used for this.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_CHANGE_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO\"\n  query_traces = %{\n    SELECT * FROM sys.traces\n  }\n  query_trace_eventinfo = %{\n    SELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(%<trace_id>s);\n  }\n\n  query_audits = %{\n    SELECT server_specification_id,\n           audit_action_name,\n           audited_result\n    FROM   sys.server_audit_specification_details\n    WHERE  audit_action_name = 'SCHEMA_OBJECT_CHANGE_GROUP';\n  }\n\n  server_trace_implemented = attribute('server_trace_implemented')\n  server_audit_implemented = attribute('server_audit_implemented')\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n\n  describe.one do\n    describe 'SQL Server Trace is in use for audit purposes' do\n      subject { server_trace_implemented }\n      it { should be true }\n    end\n\n    describe 'SQL Server Audit is in use for audit purposes' do\n      subject { server_audit_implemented }\n      it { should be true }\n    end\n  end\n\n  if server_trace_implemented\n    describe 'List defined traces for the SQL server instance' do\n      subject { sql_session.query(query_traces) }\n      it { should_not be_empty }\n    end\n\n    trace_ids = sql_session.query(query_traces).column('id')\n    describe.one do\n      trace_ids.each do |trace_id|\n        found_events = sql_session.query(format(query_trace_eventinfo, trace_id: trace_id)).column('eventid')\n        describe \"EventsIDs in Trace ID:#{trace_id}\" do\n          subject { found_events }\n          it { should include '46' }\n          it { should include '47' }\n          it { should include '162' }\n          it { should include '164' }\n        end\n      end\n    end\n  end\n\n  if server_audit_implemented\n    describe 'SQL Server Audit:' do\n      describe 'Defined Audits with Audit Action SCHEMA_OBJECT_CHANGE_GROUP' do\n        subject { sql_session.query(query_audits) }\n        it { should_not be_empty }\n      end\n      describe 'Audited Result for Defined Audit Actions' do\n        subject { sql_session.query(query_audits).column('audited_result').uniq.to_s }\n        it { should match /SUCCESS AND FAILURE|SUCCESS/ }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67421.rb",
        "line": 1
      },
      "id": "V-67421"
    },
    {
      "title": "SQL Server must generate Trace or Audit records for\norganization-defined auditable events.",
      "desc": "Audit records can be generated from various components within the\ninformation system (e.g., network interface, hard disk, modem, etc.). From an\napplication perspective, certain specific application functionalities may be\naudited as well.\n\n    The list of audited events is the set of events for which audits are to be\ngenerated. This set of events is typically a subset of the list of all events\nfor which the system is capable of generating audit records.  Examples are\nauditable events, time stamps, source and destination addresses, user/process\nidentifiers, event descriptions, success/fail indications, file names involved,\nand access control or flow control rules invoked.\n\n    Organizations define which application components shall provide auditable\nevents.\n\n    The DBMS must provide auditing for the list of events defined by the\norganization or risk negatively impacting forensic investigations into\nmalicious behavior in the information system.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.",
      "descriptions": {
        "default": "Audit records can be generated from various components within the\ninformation system (e.g., network interface, hard disk, modem, etc.). From an\napplication perspective, certain specific application functionalities may be\naudited as well.\n\n    The list of audited events is the set of events for which audits are to be\ngenerated. This set of events is typically a subset of the list of all events\nfor which the system is capable of generating audit records.  Examples are\nauditable events, time stamps, source and destination addresses, user/process\nidentifiers, event descriptions, success/fail indications, file names involved,\nand access control or flow control rules invoked.\n\n    Organizations define which application components shall provide auditable\nevents.\n\n    The DBMS must provide auditing for the list of events defined by the\norganization or risk negatively impacting forensic investigations into\nmalicious behavior in the information system.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000089-DB-000064",
        "gid": "V-67359",
        "rid": "SV-81849r2_rule",
        "stig_id": "SQL4-00-011200",
        "fix_id": "F-73471r1_fix",
        "cci": [
          "CCI-000169"
        ],
        "nist": [
          "AU-12 a",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "If there are no locally-defined security tables or procedures,\nthis is not applicable.\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes,\nthis is a finding.\n\nIf SQL Server Trace is in use for audit purposes, verify that all required\nevents are being audited. From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no\ntraces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing\nrequirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should all be among those listed; if not, this\nis a finding.\n\nAny additional events locally defined should also be in the list; if not, this\nis a finding.\n\n14 -- Audit Login\n15 -- Audit Logout\n16 -- Attention\n17 -- ExistingConnection\n18 -- Audit Server Starts and Stops\n20 -- Audit Login Failed\n42 -- SP:Starting\n43 -- SP:Completed\n46 -- Object:Created\n47 -- Object:Deleted\n90 -- User-defined Event\n102 -- Audit Database Scope GDR Event\n103 -- Audit Object GDR Event\n104 -- Audit AddLogin Event\n105 -- Audit Login GDR Event\n106 -- Audit Login Change Property Event\n107 -- Audit Login Change Password Event\n108 -- Audit Add Login to Server Role Event\n109 -- Audit Add DB User Event\n110 -- Audit Add Member to DB Role Event\n111 -- Audit Add Role Event\n112 -- Audit App Role Change Password Event\n113 -- Audit Statement Permission Event\n115 -- Audit Backup/Restore Event\n116 -- Audit DBCC Event\n117 -- Audit Change Audit Event\n118 -- Audit Object Derived Permission Event\n128 -- Audit Database Management Event\n129 -- Audit Database Object Management Event\n130 -- Audit Database Principal Management Event\n131 -- Audit Schema Object Management Event\n132 -- Audit Server Principal Impersonation Event\n133 -- Audit Database Principal Impersonation Event\n134 -- Audit Server Object Take Ownership Event\n135 -- Audit Database Object Take Ownership Event\n152 -- Audit Change Database Owner\n153 -- Audit Schema Object Take Ownership Event\n162 -- User error message\n164 -- Object:Altered\n170 -- Audit Server Scope GDR Event\n171 -- Audit Server Object GDR Event\n172 -- Audit Database Object GDR Event\n173 -- Audit Server Operation Event\n175 -- Audit Server Alter Trace Event\n176 -- Audit Server Object Management Event\n177 -- Audit Server Principal Management Event\n178 -- Audit Database Operation Event\n180 -- Audit Database Object Access Event\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses broad, server-level audit action groups for this purpose. SQL\nServer Audit's flexibility makes other techniques possible.\n\nIf an alternative technique is in use and demonstrated effective, this is not a\nfinding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their\nnames.\n\nRun the following code to verify that all configuration-related actions are\nbeing audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>');\nGO\n\nExamine the list produced by the query.\n\nIf the audited_result column is not \"SUCCESS AND FAILURE\" on every row, this\nis a finding.\n\nIf any of the following audit action groups is not included in the list, this\nis a finding.\n\nAPPLICATION_ROLE_CHANGE_PASSWORD_GROUP\nAUDIT_CHANGE_GROUP\nBACKUP_RESTORE_GROUP\nDATABASE_CHANGE_GROUP\nDATABASE_OBJECT_ACCESS_GROUP\nDATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP\nDATABASE_OBJECT_PERMISSION_CHANGE_GROUP\nDATABASE_OPERATION_GROUP\nDATABASE_OWNERSHIP_CHANGE_GROUP\nDATABASE_PERMISSION_CHANGE_GROUP\nDATABASE_PRINCIPAL_CHANGE_GROUP\nDATABASE_PRINCIPAL_IMPERSONATION_GROUP\nDATABASE_ROLE_MEMBER_CHANGE_GROUP\nDBCC_GROUP\nFAILED_LOGIN_GROUP\nLOGIN_CHANGE_PASSWORD_GROUP\nLOGOUT_GROUP\nSCHEMA_OBJECT_ACCESS_GROUP\nSCHEMA_OBJECT_CHANGE_GROUP\nSCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP\nSCHEMA_OBJECT_PERMISSION_CHANGE_GROUP\nSERVER_OBJECT_CHANGE_GROUP\nSERVER_OBJECT_OWNERSHIP_CHANGE_GROUP\nSERVER_OBJECT_PERMISSION_CHANGE_GROUP\nSERVER_OPERATION_GROUP\nSERVER_PERMISSION_CHANGE_GROUP\nSERVER_PRINCIPAL_CHANGE_GROUP\nSERVER_PRINCIPAL_IMPERSONATION_GROUP\nSERVER_ROLE_MEMBER_CHANGE_GROUP\nSERVER_STATE_CHANGE_GROUP\nSUCCESSFUL_LOGIN_GROUP\nTRACE_CHANGE_GROUP\n",
        "fix": "Design and deploy a SQL Server Audit or Trace that captures all\nauditable events.\n\nThe script provided in the supplemental file Trace.sql can be used to create a\ntrace; edit it as necessary to capture any additional, locally-defined events.\n\nThe script provided in the supplemental file Audit.sql can be used to create an\naudit; edit it as necessary to capture any additional, locally-defined events."
      },
      "code": "control 'V-67359' do\n  title \"SQL Server must generate Trace or Audit records for\norganization-defined auditable events.\"\n  desc  \"Audit records can be generated from various components within the\ninformation system (e.g., network interface, hard disk, modem, etc.). From an\napplication perspective, certain specific application functionalities may be\naudited as well.\n\n    The list of audited events is the set of events for which audits are to be\ngenerated. This set of events is typically a subset of the list of all events\nfor which the system is capable of generating audit records.  Examples are\nauditable events, time stamps, source and destination addresses, user/process\nidentifiers, event descriptions, success/fail indications, file names involved,\nand access control or flow control rules invoked.\n\n    Organizations define which application components shall provide auditable\nevents.\n\n    The DBMS must provide auditing for the list of events defined by the\norganization or risk negatively impacting forensic investigations into\nmalicious behavior in the information system.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n  \"\n  impact 0.5\n  tag \"gtitle\": 'SRG-APP-000089-DB-000064'\n  tag \"gid\": 'V-67359'\n  tag \"rid\": 'SV-81849r2_rule'\n  tag \"stig_id\": 'SQL4-00-011200'\n  tag \"fix_id\": 'F-73471r1_fix'\n  tag \"cci\": ['CCI-000169']\n  tag \"nist\": ['AU-12 a', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"If there are no locally-defined security tables or procedures,\nthis is not applicable.\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes,\nthis is a finding.\n\nIf SQL Server Trace is in use for audit purposes, verify that all required\nevents are being audited. From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no\ntraces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing\nrequirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should all be among those listed; if not, this\nis a finding.\n\nAny additional events locally defined should also be in the list; if not, this\nis a finding.\n\n14 -- Audit Login\n15 -- Audit Logout\n16 -- Attention\n17 -- ExistingConnection\n18 -- Audit Server Starts and Stops\n20 -- Audit Login Failed\n42 -- SP:Starting\n43 -- SP:Completed\n46 -- Object:Created\n47 -- Object:Deleted\n90 -- User-defined Event\n102 -- Audit Database Scope GDR Event\n103 -- Audit Object GDR Event\n104 -- Audit AddLogin Event\n105 -- Audit Login GDR Event\n106 -- Audit Login Change Property Event\n107 -- Audit Login Change Password Event\n108 -- Audit Add Login to Server Role Event\n109 -- Audit Add DB User Event\n110 -- Audit Add Member to DB Role Event\n111 -- Audit Add Role Event\n112 -- Audit App Role Change Password Event\n113 -- Audit Statement Permission Event\n115 -- Audit Backup/Restore Event\n116 -- Audit DBCC Event\n117 -- Audit Change Audit Event\n118 -- Audit Object Derived Permission Event\n128 -- Audit Database Management Event\n129 -- Audit Database Object Management Event\n130 -- Audit Database Principal Management Event\n131 -- Audit Schema Object Management Event\n132 -- Audit Server Principal Impersonation Event\n133 -- Audit Database Principal Impersonation Event\n134 -- Audit Server Object Take Ownership Event\n135 -- Audit Database Object Take Ownership Event\n152 -- Audit Change Database Owner\n153 -- Audit Schema Object Take Ownership Event\n162 -- User error message\n164 -- Object:Altered\n170 -- Audit Server Scope GDR Event\n171 -- Audit Server Object GDR Event\n172 -- Audit Database Object GDR Event\n173 -- Audit Server Operation Event\n175 -- Audit Server Alter Trace Event\n176 -- Audit Server Object Management Event\n177 -- Audit Server Principal Management Event\n178 -- Audit Database Operation Event\n180 -- Audit Database Object Access Event\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses broad, server-level audit action groups for this purpose. SQL\nServer Audit's flexibility makes other techniques possible.\n\nIf an alternative technique is in use and demonstrated effective, this is not a\nfinding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\n\nAlternatively, review the contents of the system views with \\\"audit\\\" in their\nnames.\n\nRun the following code to verify that all configuration-related actions are\nbeing audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>');\nGO\n\nExamine the list produced by the query.\n\nIf the audited_result column is not \\\"SUCCESS AND FAILURE\\\" on every row, this\nis a finding.\n\nIf any of the following audit action groups is not included in the list, this\nis a finding.\n\nAPPLICATION_ROLE_CHANGE_PASSWORD_GROUP\nAUDIT_CHANGE_GROUP\nBACKUP_RESTORE_GROUP\nDATABASE_CHANGE_GROUP\nDATABASE_OBJECT_ACCESS_GROUP\nDATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP\nDATABASE_OBJECT_PERMISSION_CHANGE_GROUP\nDATABASE_OPERATION_GROUP\nDATABASE_OWNERSHIP_CHANGE_GROUP\nDATABASE_PERMISSION_CHANGE_GROUP\nDATABASE_PRINCIPAL_CHANGE_GROUP\nDATABASE_PRINCIPAL_IMPERSONATION_GROUP\nDATABASE_ROLE_MEMBER_CHANGE_GROUP\nDBCC_GROUP\nFAILED_LOGIN_GROUP\nLOGIN_CHANGE_PASSWORD_GROUP\nLOGOUT_GROUP\nSCHEMA_OBJECT_ACCESS_GROUP\nSCHEMA_OBJECT_CHANGE_GROUP\nSCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP\nSCHEMA_OBJECT_PERMISSION_CHANGE_GROUP\nSERVER_OBJECT_CHANGE_GROUP\nSERVER_OBJECT_OWNERSHIP_CHANGE_GROUP\nSERVER_OBJECT_PERMISSION_CHANGE_GROUP\nSERVER_OPERATION_GROUP\nSERVER_PERMISSION_CHANGE_GROUP\nSERVER_PRINCIPAL_CHANGE_GROUP\nSERVER_PRINCIPAL_IMPERSONATION_GROUP\nSERVER_ROLE_MEMBER_CHANGE_GROUP\nSERVER_STATE_CHANGE_GROUP\nSUCCESSFUL_LOGIN_GROUP\nTRACE_CHANGE_GROUP\n\"\n  tag \"fix\": \"Design and deploy a SQL Server Audit or Trace that captures all\nauditable events.\n\nThe script provided in the supplemental file Trace.sql can be used to create a\ntrace; edit it as necessary to capture any additional, locally-defined events.\n\nThe script provided in the supplemental file Audit.sql can be used to create an\naudit; edit it as necessary to capture any additional, locally-defined events.\"\n\n  REQUIRED_EVENT_ID = %w{\n    14 15 16 17 18 20 42 43 46 47 90 102 103 104 105 106 107\n    108 109 110 111 112 113 115 116 117 118 128 129 130 131 132\n    133 134 135 152 153 162 164 170 171 172 173 175 176 177 178\n    180\n  }.freeze\n\n  REQUIRED_AUDITS_ACTIONS = %w{\n    APPLICATION_ROLE_CHANGE_PASSWORD_GROUP\n    AUDIT_CHANGE_GROUP\n    BACKUP_RESTORE_GROUP\n    DATABASE_CHANGE_GROUP\n    DATABASE_OBJECT_ACCESS_GROUP\n    DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP\n    DATABASE_OBJECT_PERMISSION_CHANGE_GROUP\n    DATABASE_OPERATION_GROUP\n    DATABASE_OWNERSHIP_CHANGE_GROUP\n    DATABASE_PERMISSION_CHANGE_GROUP\n    DATABASE_PRINCIPAL_CHANGE_GROUP\n    DATABASE_PRINCIPAL_IMPERSONATION_GROUP\n    DATABASE_ROLE_MEMBER_CHANGE_GROUP\n    DBCC_GROUP\n    FAILED_LOGIN_GROUP\n    LOGIN_CHANGE_PASSWORD_GROUP\n    LOGOUT_GROUP\n    SCHEMA_OBJECT_ACCESS_GROUP\n    SCHEMA_OBJECT_CHANGE_GROUP\n    SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP\n    SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP\n    SERVER_OBJECT_CHANGE_GROUP\n    SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP\n    SERVER_OBJECT_PERMISSION_CHANGE_GROUP\n    SERVER_OPERATION_GROUP\n    SERVER_PERMISSION_CHANGE_GROUP\n    SERVER_PRINCIPAL_CHANGE_GROUP\n    SERVER_PRINCIPAL_IMPERSONATION_GROUP\n    SERVER_ROLE_MEMBER_CHANGE_GROUP\n    SERVER_STATE_CHANGE_GROUP\n    SUCCESSFUL_LOGIN_GROUP\n    TRACE_CHANGE_GROUP\n  }.freeze\n\n  query_traces = %{\n    SELECT * FROM sys.traces\n  }\n  query_trace_eventinfo = %{\n    SELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(%<trace_id>s);\n  }\n\n  query_audits = %{\n    SELECT server_specification_id,\n           audit_action_name,\n           audited_result\n    FROM   sys.server_audit_specification_details\n  }\n\n  server_trace_implemented = attribute('server_trace_implemented')\n  server_audit_implemented = attribute('server_audit_implemented')\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n  describe.one do\n    describe 'SQL Server Trace is in use for audit purposes' do\n      subject { server_trace_implemented }\n      it { should be true }\n    end\n\n    describe 'SQL Server Audit is in use for audit purposes' do\n      subject { server_audit_implemented }\n      it { should be true }\n    end\n  end\n\n  if server_trace_implemented\n    describe 'List defined traces for the SQL server instance' do\n      subject { sql_session.query(query_traces) }\n      it { should_not be_empty }\n    end\n\n    trace_ids = sql_session.query(query_traces).column('id')\n    describe.one do\n      trace_ids.each do |trace_id|\n        found_events = sql_session.query(format(query_trace_eventinfo, trace_id: trace_id)).column('eventid')\n        describe \"EventsIDs in Trace ID:#{trace_id}\" do\n          subject { REQUIRED_EVENT_ID }\n          it { should be_in found_events }\n        end\n      end\n    end\n  end\n\n  found_actions = sql_session.query(query_audits).column('audit_action_name')\n\n  if server_audit_implemented\n    describe 'SQL Server Audit' do\n      describe 'Audited Result for Defined Audit Actions' do\n        subject { sql_session.query(query_audits).column('audited_result').uniq }\n        it { should cmp 'SUCCESS AND FAILURE' }\n      end\n      describe 'Defined Audit Actions' do\n        subject { REQUIRED_AUDITS_ACTIONS }\n        it { should be_in found_actions }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67359.rb",
        "line": 1
      },
      "id": "V-67359"
    },
    {
      "title": "SQL Server must reveal detailed error messages only to the ISSO, ISSM\n(or their designees), SA and DBA.",
      "desc": "If the DBMS provides too much information in error logs and\nadministrative messages to the screen, this could lead to compromise. The\nstructure and content of error messages need to be carefully considered by the\norganization and development team. The extent to which the information system\nis able to identify and handle error conditions is guided by organizational\npolicy and operational requirements.\n\n    Some default DBMS error messages can contain information that could aid an\nattacker in, among others things, identifying the database type, host address,\nor state of the database. Custom errors may contain sensitive customer\ninformation.\n\n    It is important that detailed error messages be visible only to those who\nare authorized to view them; that general users receive only generalized\nacknowledgment that errors have occurred; and that these generalized messages\nappear only when relevant to the user's task. For example, a message along the\nlines of, \"An error has occurred. Unable to save your changes. If this problem\npersists, please contact your help desk\" would be relevant. A message such as\n\"Warning: your transaction generated a large number of page splits\" would\nlikely not be relevant. \"ABGQ is not a valid widget code\" would be\nappropriate; but \"The INSERT statement conflicted with the FOREIGN KEY\nconstraint \"WidgetTransactionFK\". The conflict occurred in database \"DB7\",\ntable \"dbo.WidgetMaster\", column 'WidgetCode'\" would not, as it reveals too\nmuch about the database structure.\n\n    Administrative users authorized to review detailed error messages typically\nare the ISSO, ISSM, SA and DBA. Other individuals or roles may be specified\naccording to organization-specific needs, with appropriate approval.\n\n    This calls for inspection of application source code, which will require\ncollaboration with the application developers. It is recognized that in many\ncases, the database administrator (DBA) is organizationally separate from the\napplication developers and may have limited, if any, access to source code.\nNevertheless, protections of this type are so important to the secure operation\nof databases that they must not be ignored. At a minimum, the DBA must attempt\nto obtain assurances from the development organization that this issue has been\naddressed and must document what has been discovered.",
      "descriptions": {
        "default": "If the DBMS provides too much information in error logs and\nadministrative messages to the screen, this could lead to compromise. The\nstructure and content of error messages need to be carefully considered by the\norganization and development team. The extent to which the information system\nis able to identify and handle error conditions is guided by organizational\npolicy and operational requirements.\n\n    Some default DBMS error messages can contain information that could aid an\nattacker in, among others things, identifying the database type, host address,\nor state of the database. Custom errors may contain sensitive customer\ninformation.\n\n    It is important that detailed error messages be visible only to those who\nare authorized to view them; that general users receive only generalized\nacknowledgment that errors have occurred; and that these generalized messages\nappear only when relevant to the user's task. For example, a message along the\nlines of, \"An error has occurred. Unable to save your changes. If this problem\npersists, please contact your help desk\" would be relevant. A message such as\n\"Warning: your transaction generated a large number of page splits\" would\nlikely not be relevant. \"ABGQ is not a valid widget code\" would be\nappropriate; but \"The INSERT statement conflicted with the FOREIGN KEY\nconstraint \"WidgetTransactionFK\". The conflict occurred in database \"DB7\",\ntable \"dbo.WidgetMaster\", column 'WidgetCode'\" would not, as it reveals too\nmuch about the database structure.\n\n    Administrative users authorized to review detailed error messages typically\nare the ISSO, ISSM, SA and DBA. Other individuals or roles may be specified\naccording to organization-specific needs, with appropriate approval.\n\n    This calls for inspection of application source code, which will require\ncollaboration with the application developers. It is recognized that in many\ncases, the database administrator (DBA) is organizationally separate from the\napplication developers and may have limited, if any, access to source code.\nNevertheless, protections of this type are so important to the secure operation\nof databases that they must not be ignored. At a minimum, the DBA must attempt\nto obtain assurances from the development organization that this issue has been\naddressed and must document what has been discovered."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000267-DB-000163",
        "gid": "V-67399",
        "rid": "SV-81889r2_rule",
        "stig_id": "SQL4-00-022900",
        "fix_id": "F-73511r1_fix",
        "cci": [
          "CCI-001314"
        ],
        "nist": [
          "SI-11 b",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "Review application behavior, custom database code (stored\nprocedures; triggers) and DBMS audit and trace settings,  to determine whether\ndetailed error messages are logged or stored for review by authorized personnel.\n\nIf detailed error messages are not available to individuals authorized to view\nthem, this is a finding.",
        "fix": "Configure audit logging, tracing and/or custom code in the\ndatabase or application to record detailed error messages generated by SQL\nServer, for review by authorized personnel.\n\nConsider enabling trace flag 3625 to mask certain system-level error information\nreturned to non-administrative users.\n\nLaunch SQL Server Configuration Manager >> Click SQL Services >> Open the\ninstance properties >> Click the Service Parameters tab >> Enter '-T3625' >>\nClick Add >> Click OK >> Restart SQL instance."
      },
      "code": "control 'V-67399' do\n  title \"SQL Server must reveal detailed error messages only to the ISSO, ISSM\n(or their designees), SA and DBA.\"\n  desc  \"If the DBMS provides too much information in error logs and\nadministrative messages to the screen, this could lead to compromise. The\nstructure and content of error messages need to be carefully considered by the\norganization and development team. The extent to which the information system\nis able to identify and handle error conditions is guided by organizational\npolicy and operational requirements.\n\n    Some default DBMS error messages can contain information that could aid an\nattacker in, among others things, identifying the database type, host address,\nor state of the database. Custom errors may contain sensitive customer\ninformation.\n\n    It is important that detailed error messages be visible only to those who\nare authorized to view them; that general users receive only generalized\nacknowledgment that errors have occurred; and that these generalized messages\nappear only when relevant to the user's task. For example, a message along the\nlines of, \\\"An error has occurred. Unable to save your changes. If this problem\npersists, please contact your help desk\\\" would be relevant. A message such as\n\\\"Warning: your transaction generated a large number of page splits\\\" would\nlikely not be relevant. \\\"ABGQ is not a valid widget code\\\" would be\nappropriate; but \\\"The INSERT statement conflicted with the FOREIGN KEY\nconstraint \\\"WidgetTransactionFK\\\". The conflict occurred in database \\\"DB7\\\",\ntable \\\"dbo.WidgetMaster\\\", column 'WidgetCode'\\\" would not, as it reveals too\nmuch about the database structure.\n\n    Administrative users authorized to review detailed error messages typically\nare the ISSO, ISSM, SA and DBA. Other individuals or roles may be specified\naccording to organization-specific needs, with appropriate approval.\n\n    This calls for inspection of application source code, which will require\ncollaboration with the application developers. It is recognized that in many\ncases, the database administrator (DBA) is organizationally separate from the\napplication developers and may have limited, if any, access to source code.\nNevertheless, protections of this type are so important to the secure operation\nof databases that they must not be ignored. At a minimum, the DBA must attempt\nto obtain assurances from the development organization that this issue has been\naddressed and must document what has been discovered.\n  \"\n  impact 0.5\n  tag \"gtitle\": 'SRG-APP-000267-DB-000163'\n  tag \"gid\": 'V-67399'\n  tag \"rid\": 'SV-81889r2_rule'\n  tag \"stig_id\": 'SQL4-00-022900'\n  tag \"fix_id\": 'F-73511r1_fix'\n  tag \"cci\": ['CCI-001314']\n  tag \"nist\": ['SI-11 b', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"Review application behavior, custom database code (stored\nprocedures; triggers) and DBMS audit and trace settings,  to determine whether\ndetailed error messages are logged or stored for review by authorized personnel.\n\nIf detailed error messages are not available to individuals authorized to view\nthem, this is a finding.\"\n  tag \"fix\": \"Configure audit logging, tracing and/or custom code in the\ndatabase or application to record detailed error messages generated by SQL\nServer, for review by authorized personnel.\n\nConsider enabling trace flag 3625 to mask certain system-level error information\nreturned to non-administrative users.\n\nLaunch SQL Server Configuration Manager >> Click SQL Services >> Open the\ninstance properties >> Click the Service Parameters tab >> Enter '-T3625' >>\nClick Add >> Click OK >> Restart SQL instance.\"\n\n  query = %{\n    DBCC\n      TRACESTATUS (3625, -1)\n    GO\n    }\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n\n  describe 'TRACEFLAG 3625' do\n    subject { sql_session.query(query).rows[0] }\n    its('status') { should cmp 1 }\n    its('global') { should cmp 1 }\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67399.rb",
        "line": 1
      },
      "id": "V-67399"
    },
    {
      "title": "SQL Server must generate Trace or Audit records when unsuccessful\naccesses to designated objects occur.",
      "desc": "Without tracking all or selected types of access to all or selected\nobjects (tables, views, procedures, functions, etc.), it would be difficult to\nestablish, correlate, and investigate the events relating to an incident or\nidentify those responsible for one.\n\n    Types of access include, but are not necessarily limited to:\n    SELECT\n    INSERT\n    UPDATE\n    DELETE\n    EXECUTE\n\n    To aid in diagnosis, it is necessary to keep track of failed attempts in\naddition to the successful ones.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.",
      "descriptions": {
        "default": "Without tracking all or selected types of access to all or selected\nobjects (tables, views, procedures, functions, etc.), it would be difficult to\nestablish, correlate, and investigate the events relating to an incident or\nidentify those responsible for one.\n\n    Types of access include, but are not necessarily limited to:\n    SELECT\n    INSERT\n    UPDATE\n    DELETE\n    EXECUTE\n\n    To aid in diagnosis, it is necessary to keep track of failed attempts in\naddition to the successful ones.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000507-DB-000357",
        "gid": "V-67423",
        "rid": "SV-81913r3_rule",
        "stig_id": "SQL4-00-038200",
        "fix_id": "F-73537r3_fix",
        "cci": [
          "CCI-000172"
        ],
        "nist": [
          "AU-12 c",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "If neither SQL Server Audit nor SQL Server Trace is in use for\naudit purposes, this is a finding.\n\nObtain the list of objects (tables and stored procedures) where tracking of\nSELECT, INSERT, UPDATE, DELETE, or EXECUTE actions is required.  If there are\nnone, this is not a finding.\n\nIf SQL Server Trace is in use for audit purposes, verify that all required\nevent classes are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no\ntraces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing\nrequirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event ID should be among those listed; if not, this is a\nfinding:\n\n162 -- User error message\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the server-level audit action group SCHEMA_OBJECT_ACCESS_GROUP\nfor this purpose.  SQL Server Audit's flexibility makes other techniques\npossible.  If an alternative technique is in use and demonstrated effective,\nthis is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their\nnames.\n\nRun the following to verify that all logons and connections are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\nGO\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"FAILURE\" or \"SUCCESS AND FAILURE\",\nthis is a finding.",
        "fix": "Where SQL Server Trace is in use, define and enable a trace that\ncaptures all auditable events.  The script provided in the supplemental file\nTrace.sql can be used to do this.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all\nauditable events and data items.  The script provided in the supplemental file\nAudit.sql can be used as the basis for this.  Supplement the standard audit\ndata as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO"
      },
      "code": "control 'V-67423' do\n  title \"SQL Server must generate Trace or Audit records when unsuccessful\naccesses to designated objects occur.\"\n  desc  \"Without tracking all or selected types of access to all or selected\nobjects (tables, views, procedures, functions, etc.), it would be difficult to\nestablish, correlate, and investigate the events relating to an incident or\nidentify those responsible for one.\n\n    Types of access include, but are not necessarily limited to:\n    SELECT\n    INSERT\n    UPDATE\n    DELETE\n    EXECUTE\n\n    To aid in diagnosis, it is necessary to keep track of failed attempts in\naddition to the successful ones.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n  \"\n  impact 0.5\n  tag \"gtitle\": 'SRG-APP-000507-DB-000357'\n  tag \"gid\": 'V-67423'\n  tag \"rid\": 'SV-81913r3_rule'\n  tag \"stig_id\": 'SQL4-00-038200'\n  tag \"fix_id\": 'F-73537r3_fix'\n  tag \"cci\": ['CCI-000172']\n  tag \"nist\": ['AU-12 c', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"If neither SQL Server Audit nor SQL Server Trace is in use for\naudit purposes, this is a finding.\n\nObtain the list of objects (tables and stored procedures) where tracking of\nSELECT, INSERT, UPDATE, DELETE, or EXECUTE actions is required.  If there are\nnone, this is not a finding.\n\nIf SQL Server Trace is in use for audit purposes, verify that all required\nevent classes are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no\ntraces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing\nrequirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event ID should be among those listed; if not, this is a\nfinding:\n\n162 -- User error message\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the server-level audit action group SCHEMA_OBJECT_ACCESS_GROUP\nfor this purpose.  SQL Server Audit's flexibility makes other techniques\npossible.  If an alternative technique is in use and demonstrated effective,\nthis is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\n\nAlternatively, review the contents of the system views with \\\"audit\\\" in their\nnames.\n\nRun the following to verify that all logons and connections are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\nGO\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \\\"FAILURE\\\" or \\\"SUCCESS AND FAILURE\\\",\nthis is a finding.\"\n  tag \"fix\": \"Where SQL Server Trace is in use, define and enable a trace that\ncaptures all auditable events.  The script provided in the supplemental file\nTrace.sql can be used to do this.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all\nauditable events and data items.  The script provided in the supplemental file\nAudit.sql can be used as the basis for this.  Supplement the standard audit\ndata as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO\"\n  query_traces = %{\n    SELECT * FROM sys.traces\n  }\n  query_trace_eventinfo = %{\n    SELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(%<trace_id>s);\n  }\n\n  query_audits = %{\n    SELECT server_specification_id,\n           audit_action_name,\n           audited_result\n    FROM   sys.server_audit_specification_details\n    WHERE  audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n  }\n\n  server_trace_implemented = attribute('server_trace_implemented')\n  server_audit_implemented = attribute('server_audit_implemented')\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n\n  describe.one do\n    describe 'SQL Server Trace is in use for audit purposes' do\n      subject { server_trace_implemented }\n      it { should be true }\n    end\n\n    describe 'SQL Server Audit is in use for audit purposes' do\n      subject { server_audit_implemented }\n      it { should be true }\n    end\n  end\n\n  if server_trace_implemented\n    describe 'List defined traces for the SQL server instance' do\n      subject { sql_session.query(query_traces) }\n      it { should_not be_empty }\n    end\n\n    trace_ids = sql_session.query(query_traces).column('id')\n    describe.one do\n      trace_ids.each do |trace_id|\n        found_events = sql_session.query(format(query_trace_eventinfo, trace_id: trace_id)).column('eventid')\n        describe \"EventsIDs in Trace ID:#{trace_id}\" do\n          subject { found_events }\n          it { should include '162' }\n        end\n      end\n    end\n  end\n\n  if server_audit_implemented\n    describe 'SQL Server Audit:' do\n      describe 'Defined Audits with Audit Action SCHEMA_OBJECT_ACCESS_GROUP' do\n        subject { sql_session.query(query_audits) }\n        it { should_not be_empty }\n      end\n      describe 'Audited Result for Defined Audit Actions' do\n        subject { sql_session.query(query_audits).column('audited_result').uniq.to_s }\n        it { should match /SUCCESS AND FAILURE|FAILURE/ }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67423.rb",
        "line": 1
      },
      "id": "V-67423"
    },
    {
      "title": "The DBMS and associated applications must reserve the use of dynamic\ncode execution for situations that require it.",
      "desc": "With respect to database management systems, one class of threat is\nknown as SQL Injection, or more generally, code injection. It takes advantage\nof the dynamic execution capabilities of various programming languages,\nincluding dialects of SQL. In such cases, the attacker deduces the manner in\nwhich SQL statements are being processed, either from inside knowledge or by\nobserving system behavior in response to invalid inputs. When the attacker\nidentifies scenarios where SQL queries are being assembled by application code\n(which may be within the database or separate from it) and executed\ndynamically, the attacker is then able to craft input strings that subvert the\nintent of the query. Potentially, the attacker can gain unauthorized access to\ndata, including security settings, and severely corrupt or destroy the database.\n\n    The principal protection against code injection is not to use dynamic\nexecution except where it provides necessary functionality that cannot be\nutilized otherwise. Use strongly typed data items rather than general-purpose\nstrings as input parameters to task-specific, pre-compiled stored procedures\nand functions (and triggers).\n\n    This calls for inspection of application source code, which will require\ncollaboration with the application developers. It is recognized that in many\ncases, the database administrator (DBA) is organizationally separate from the\napplication developers and may have limited, if any, access to source code.\nNevertheless, protections of this type are so important to the secure operation\nof databases that they must not be ignored. At a minimum, the DBA must attempt\nto obtain assurances from the development organization that this issue has been\naddressed and must document what has been discovered",
      "descriptions": {
        "default": "With respect to database management systems, one class of threat is\nknown as SQL Injection, or more generally, code injection. It takes advantage\nof the dynamic execution capabilities of various programming languages,\nincluding dialects of SQL. In such cases, the attacker deduces the manner in\nwhich SQL statements are being processed, either from inside knowledge or by\nobserving system behavior in response to invalid inputs. When the attacker\nidentifies scenarios where SQL queries are being assembled by application code\n(which may be within the database or separate from it) and executed\ndynamically, the attacker is then able to craft input strings that subvert the\nintent of the query. Potentially, the attacker can gain unauthorized access to\ndata, including security settings, and severely corrupt or destroy the database.\n\n    The principal protection against code injection is not to use dynamic\nexecution except where it provides necessary functionality that cannot be\nutilized otherwise. Use strongly typed data items rather than general-purpose\nstrings as input parameters to task-specific, pre-compiled stored procedures\nand functions (and triggers).\n\n    This calls for inspection of application source code, which will require\ncollaboration with the application developers. It is recognized that in many\ncases, the database administrator (DBA) is organizationally separate from the\napplication developers and may have limited, if any, access to source code.\nNevertheless, protections of this type are so important to the secure operation\nof databases that they must not be ignored. At a minimum, the DBA must attempt\nto obtain assurances from the development organization that this issue has been\naddressed and must document what has been discovered"
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000251-DB-000391",
        "gid": "V-67393",
        "rid": "SV-81883r2_rule",
        "stig_id": "SQL4-00-031500",
        "fix_id": "F-73505r1_fix",
        "cci": [
          "CCI-001310"
        ],
        "nist": [
          "SI-10",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "Review source code in the database (stored procedures,\nfunctions, triggers) and application source code, to identify cases of dynamic\ncode execution.\n\nIf dynamic code execution is employed in circumstances where the objective\ncould practically be satisfied by static execution with strongly typed\nparameters, this is a finding.",
        "fix": "Where dynamic code execution is employed in circumstances where\nthe objective could practically be satisfied by static execution with strongly\ntyped parameters, modify the code to do so."
      },
      "code": "control 'V-67393' do\n  title \"The DBMS and associated applications must reserve the use of dynamic\ncode execution for situations that require it.\"\n  desc  \"With respect to database management systems, one class of threat is\nknown as SQL Injection, or more generally, code injection. It takes advantage\nof the dynamic execution capabilities of various programming languages,\nincluding dialects of SQL. In such cases, the attacker deduces the manner in\nwhich SQL statements are being processed, either from inside knowledge or by\nobserving system behavior in response to invalid inputs. When the attacker\nidentifies scenarios where SQL queries are being assembled by application code\n(which may be within the database or separate from it) and executed\ndynamically, the attacker is then able to craft input strings that subvert the\nintent of the query. Potentially, the attacker can gain unauthorized access to\ndata, including security settings, and severely corrupt or destroy the database.\n\n    The principal protection against code injection is not to use dynamic\nexecution except where it provides necessary functionality that cannot be\nutilized otherwise. Use strongly typed data items rather than general-purpose\nstrings as input parameters to task-specific, pre-compiled stored procedures\nand functions (and triggers).\n\n    This calls for inspection of application source code, which will require\ncollaboration with the application developers. It is recognized that in many\ncases, the database administrator (DBA) is organizationally separate from the\napplication developers and may have limited, if any, access to source code.\nNevertheless, protections of this type are so important to the secure operation\nof databases that they must not be ignored. At a minimum, the DBA must attempt\nto obtain assurances from the development organization that this issue has been\naddressed and must document what has been discovered\n  \"\n  impact 0.5\n  tag \"gtitle\": 'SRG-APP-000251-DB-000391'\n  tag \"gid\": 'V-67393'\n  tag \"rid\": 'SV-81883r2_rule'\n  tag \"stig_id\": 'SQL4-00-031500'\n  tag \"fix_id\": 'F-73505r1_fix'\n  tag \"cci\": ['CCI-001310']\n  tag \"nist\": ['SI-10', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"Review source code in the database (stored procedures,\nfunctions, triggers) and application source code, to identify cases of dynamic\ncode execution.\n\nIf dynamic code execution is employed in circumstances where the objective\ncould practically be satisfied by static execution with strongly typed\nparameters, this is a finding.\"\n  tag \"fix\": \"Where dynamic code execution is employed in circumstances where\nthe objective could practically be satisfied by static execution with strongly\ntyped parameters, modify the code to do so.\"\n\n  describe 'This test currently has no automated tests, you must check manually' do\n    skip 'This check must be preformed manually'\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67393.rb",
        "line": 1
      },
      "id": "V-67393"
    },
    {
      "title": "In a database owned by [sa], or by any other login having\nadministrative privileges at the instance level, the database property\nTRUSTWORTHY must be OFF.",
      "desc": "SQL Server's fixed (built-in) server roles, especially [sysadmin],\nhave powerful capabilities that could cause great harm if misused, so their use\nmust be tightly controlled.\n\n    The SQL Server instance uses each database's TRUSTWORTHY property to guard\nagainst tampering that could enable unwarranted privilege escalation. When\nTRUSTWORTHY is 0/False/Off, SQL Server prevents the database from accessing\nresources in other databases. When TRUSTWORTHY is 1/True/On, SQL Server permits\naccess to other databases (subject to other protections). SQL Server sets\nTRUSTWORTHY OFF when it creates a new database. SQL Server forces TRUSTWORTHY\nOFF, irrespective of its prior value, when an existing database is attached to\nit, to address the possibility that an adversary may have tampered with the\ndatabase, introducing malicious code. To set TRUSTWORTHY ON, an account with\nthe [sysadmin] role must issue an ALTER DATABASE command.\n\n    Although SQL Server itself treats this property conservatively, application\ninstaller programs may set TRUSTWORTHY ON and leave it on. This provides an\nopportunity for misuse.\n\n    When TRUSTWORTHY is ON, users of the database can take advantage of the\ndatabase owner's privileges, by impersonating the owner. This can have\nparticularly serious consequences if the database owner is the [sa] login\n(which may have been renamed in accordance with SQL4-00-010200, and disabled in\naccordance with SQL4-00-017100, but nonetheless can be invoked in an EXECUTE AS\nUSER = 'dbo' statement, or CREATE PROCEDURE ... WITH EXECUTE AS OWNER ...). The\n[sa] login cannot be removed from the [sysadmin] role. The user impersonating\n[sa] - or another [sysadmin] account - is then able to perform administrative\nactions across all databases under the instance, including making any himself\nor any other login a member of [sysadmin].\n\n    Most of the other fixed server roles could be similarly abused.\n\n    Therefore, TRUSTWORTHY must not be used on databases owned by logins that\nare members of the fixed server roles. Further, if TRUSTWORTHY is to be used\nfor any other database, the need must be documented and approved.\n\n    The system database [msdb] is an exception: it is required to be\nTRUSTWORTHY.",
      "descriptions": {
        "default": "SQL Server's fixed (built-in) server roles, especially [sysadmin],\nhave powerful capabilities that could cause great harm if misused, so their use\nmust be tightly controlled.\n\n    The SQL Server instance uses each database's TRUSTWORTHY property to guard\nagainst tampering that could enable unwarranted privilege escalation. When\nTRUSTWORTHY is 0/False/Off, SQL Server prevents the database from accessing\nresources in other databases. When TRUSTWORTHY is 1/True/On, SQL Server permits\naccess to other databases (subject to other protections). SQL Server sets\nTRUSTWORTHY OFF when it creates a new database. SQL Server forces TRUSTWORTHY\nOFF, irrespective of its prior value, when an existing database is attached to\nit, to address the possibility that an adversary may have tampered with the\ndatabase, introducing malicious code. To set TRUSTWORTHY ON, an account with\nthe [sysadmin] role must issue an ALTER DATABASE command.\n\n    Although SQL Server itself treats this property conservatively, application\ninstaller programs may set TRUSTWORTHY ON and leave it on. This provides an\nopportunity for misuse.\n\n    When TRUSTWORTHY is ON, users of the database can take advantage of the\ndatabase owner's privileges, by impersonating the owner. This can have\nparticularly serious consequences if the database owner is the [sa] login\n(which may have been renamed in accordance with SQL4-00-010200, and disabled in\naccordance with SQL4-00-017100, but nonetheless can be invoked in an EXECUTE AS\nUSER = 'dbo' statement, or CREATE PROCEDURE ... WITH EXECUTE AS OWNER ...). The\n[sa] login cannot be removed from the [sysadmin] role. The user impersonating\n[sa] - or another [sysadmin] account - is then able to perform administrative\nactions across all databases under the instance, including making any himself\nor any other login a member of [sysadmin].\n\n    Most of the other fixed server roles could be similarly abused.\n\n    Therefore, TRUSTWORTHY must not be used on databases owned by logins that\nare members of the fixed server roles. Further, if TRUSTWORTHY is to be used\nfor any other database, the need must be documented and approved.\n\n    The system database [msdb] is an exception: it is required to be\nTRUSTWORTHY."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000133-DB-000200",
        "gid": "V-67375",
        "rid": "SV-81865r1_rule",
        "stig_id": "SQL4-00-015610",
        "fix_id": "F-73487r1_fix",
        "cci": [
          "CCI-001499"
        ],
        "nist": [
          "CM-5 (6)",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "Run the SQL statements:\nUSE <database name>;\nGO\nWITH FixedServerRoles(RoleName) AS\n(\n      SELECT 'sysadmin'\n      UNION SELECT 'securityadmin'\n      UNION SELECT 'serveradmin'\n      UNION SELECT 'setupadmin'\n      UNION SELECT 'processadmin'\n      UNION SELECT 'diskadmin'\n      UNION SELECT 'dbcreator'\n      UNION SELECT 'bulkadmin'\n)\nSELECT\n      DB_NAME() AS [Database],\n      SUSER_SNAME(D.owner_sid) AS [Database Owner],\n      F.RoleName AS [Fixed Server Role],\n      CASE WHEN D.is_trustworthy_on = 1 THEN 'ON' ELSE 'off' END\n            AS [Trustworthy]\nFROM\n      FixedServerRoles F\n      INNER JOIN sys.databases D ON D.Name = DB_NAME()\nWHERE\n      IS_SRVROLEMEMBER(F.RoleName, SUSER_SNAME(D.owner_sid)) = 1\nAND   DB_NAME() <> 'msdb'\nAND   D.is_trustworthy_on = 1;\nGO\n\nIf the query returns any rows, this is a finding.",
        "fix": "Set the TRUSTWORTHY property OFF; or remove the database owner\nfrom the fixed server role(s); or change the database owner.\n\nTo set the TRUSTWORTHY property OFF:\nUSE [master];\nGO\nALTER DATABASE <name> SET TRUSTWORTHY OFF;\nGO\nVerify that this produced the intended result by re-running the query specified\nin the Check.\n\nTo determine the path or paths by which the database owner is assigned the\nfixed server role or roles, run this query:\n\nUSE <database name>;\nGO\nWITH C AS\n(\nSELECT\n      P.name      AS [Parent Server Role],\n      CAST('Fixed' AS varchar(8))\n                  AS [Server Role Type],\n      M.name      AS [Member],\n      M.type_desc AS [Member Type],\n      P.name      AS [Root],\n      1           AS [Level]\nFROM\n      [sys].[server_role_members] X\n      INNER JOIN [sys].[server_principals] P ON P.principal_id =\nX.role_principal_id\n      INNER JOIN [sys].[server_principals] M ON M.principal_id =\nX.member_principal_id\nWHERE\n      P.is_fixed_role = 1\nUNION ALL\nSELECT\n      P.name        AS [Parent Server Role],\n      CASE WHEN M.is_fixed_role = 1 THEN CAST('Fixed' AS varchar(8)) ELSE\nCAST('Custom' AS varchar(8)) END\n                    AS [Server Role Type],\n      M.name        AS [Member],\n      M.type_desc   AS [Member Type],\n      C.[Root]      AS [Root],\n      C.[Level] + 1 AS [Level]\nFROM\n      [sys].[server_role_members] X\n      INNER JOIN [sys].[server_principals] P ON P.principal_id =\nX.role_principal_id\n      INNER JOIN [sys].[server_principals] M ON M.principal_id =\nX.member_principal_id\n      INNER JOIN C ON P.name = C.Member\n)\n,\nB AS\n(\nSELECT\n      C.[Member] AS [Leaf],\n      C.[Root],\n      C.[Parent Server Role],\n      C.[Server Role Type],\n      C.[Member],\n      C.[Member Type],\n      C.[Level]\nFROM C\nWHERE\n      C.[Member Type] NOT LIKE '%ROLE%'\nUNION ALL\nSELECT\n      B.[Leaf],\n      C.[Root],\n      C.[Parent Server Role],\n      C.[Server Role Type],\n      C.[Member],\n      C.[Member Type],\n      C.[Level]\nFROM C\nINNER JOIN B\n      ON       C.[Member] = B.[Parent Server Role]\n      AND       C.[Level] = B.[Level] - 1\n      AND       C.[Root] = B.[Root]\n)\nSELECT\n      DB_NAME() AS [Database],\n      B.[Leaf]  AS [Owner Login],\n      B.[Root]  AS[Top-Level Server Role],\n      B.[Parent Server Role],\n      B.[Server Role Type],\n      B.[Member],\n      B.[Member Type],\n      B.[Level]\nFROM B\nWHERE B.[Leaf] = (SELECT SUSER_SNAME(D.owner_sid) FROM sys.databases D WHERE\nD.Name = DB_NAME())\nORDER BY B.[Root], B.[Level], B.[Parent Server Role], B.[Member]\n;\nGO\n\nTo remove the database owner from a fixed server role or a custom server role:\nUSE [master];\nGO\nALTER SERVER ROLE <fixed/custom server role name>\n      DROP MEMBER <database owner name>;\nGO\nVerify that this produced the intended result by re-running the Check query.\n\nTo change the database owner:\nUSE [master];\nGO\nALTER AUTHORIZATION ON DATABASE::<DB name> TO <new owner name>;\nGO\nVerify that this produced the intended result by re-running the Check query."
      },
      "code": "control 'V-67375' do\n  title \"In a database owned by [sa], or by any other login having\nadministrative privileges at the instance level, the database property\nTRUSTWORTHY must be OFF.\"\n  desc  \"SQL Server's fixed (built-in) server roles, especially [sysadmin],\nhave powerful capabilities that could cause great harm if misused, so their use\nmust be tightly controlled.\n\n    The SQL Server instance uses each database's TRUSTWORTHY property to guard\nagainst tampering that could enable unwarranted privilege escalation. When\nTRUSTWORTHY is 0/False/Off, SQL Server prevents the database from accessing\nresources in other databases. When TRUSTWORTHY is 1/True/On, SQL Server permits\naccess to other databases (subject to other protections). SQL Server sets\nTRUSTWORTHY OFF when it creates a new database. SQL Server forces TRUSTWORTHY\nOFF, irrespective of its prior value, when an existing database is attached to\nit, to address the possibility that an adversary may have tampered with the\ndatabase, introducing malicious code. To set TRUSTWORTHY ON, an account with\nthe [sysadmin] role must issue an ALTER DATABASE command.\n\n    Although SQL Server itself treats this property conservatively, application\ninstaller programs may set TRUSTWORTHY ON and leave it on. This provides an\nopportunity for misuse.\n\n    When TRUSTWORTHY is ON, users of the database can take advantage of the\ndatabase owner's privileges, by impersonating the owner. This can have\nparticularly serious consequences if the database owner is the [sa] login\n(which may have been renamed in accordance with SQL4-00-010200, and disabled in\naccordance with SQL4-00-017100, but nonetheless can be invoked in an EXECUTE AS\nUSER = 'dbo' statement, or CREATE PROCEDURE ... WITH EXECUTE AS OWNER ...). The\n[sa] login cannot be removed from the [sysadmin] role. The user impersonating\n[sa] - or another [sysadmin] account - is then able to perform administrative\nactions across all databases under the instance, including making any himself\nor any other login a member of [sysadmin].\n\n    Most of the other fixed server roles could be similarly abused.\n\n    Therefore, TRUSTWORTHY must not be used on databases owned by logins that\nare members of the fixed server roles. Further, if TRUSTWORTHY is to be used\nfor any other database, the need must be documented and approved.\n\n    The system database [msdb] is an exception: it is required to be\nTRUSTWORTHY.\n  \"\n  impact 0.5\n  tag \"gtitle\": 'SRG-APP-000133-DB-000200'\n  tag \"gid\": 'V-67375'\n  tag \"rid\": 'SV-81865r1_rule'\n  tag \"stig_id\": 'SQL4-00-015610'\n  tag \"fix_id\": 'F-73487r1_fix'\n  tag \"cci\": ['CCI-001499']\n  tag \"nist\": ['CM-5 (6)', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"Run the SQL statements:\nUSE <database name>;\nGO\nWITH FixedServerRoles(RoleName) AS\n(\n      SELECT 'sysadmin'\n      UNION SELECT 'securityadmin'\n      UNION SELECT 'serveradmin'\n      UNION SELECT 'setupadmin'\n      UNION SELECT 'processadmin'\n      UNION SELECT 'diskadmin'\n      UNION SELECT 'dbcreator'\n      UNION SELECT 'bulkadmin'\n)\nSELECT\n      DB_NAME() AS [Database],\n      SUSER_SNAME(D.owner_sid) AS [Database Owner],\n      F.RoleName AS [Fixed Server Role],\n      CASE WHEN D.is_trustworthy_on = 1 THEN 'ON' ELSE 'off' END\n            AS [Trustworthy]\nFROM\n      FixedServerRoles F\n      INNER JOIN sys.databases D ON D.Name = DB_NAME()\nWHERE\n      IS_SRVROLEMEMBER(F.RoleName, SUSER_SNAME(D.owner_sid)) = 1\nAND   DB_NAME() <> 'msdb'\nAND   D.is_trustworthy_on = 1;\nGO\n\nIf the query returns any rows, this is a finding.\"\n  tag \"fix\": \"Set the TRUSTWORTHY property OFF; or remove the database owner\nfrom the fixed server role(s); or change the database owner.\n\nTo set the TRUSTWORTHY property OFF:\nUSE [master];\nGO\nALTER DATABASE <name> SET TRUSTWORTHY OFF;\nGO\nVerify that this produced the intended result by re-running the query specified\nin the Check.\n\nTo determine the path or paths by which the database owner is assigned the\nfixed server role or roles, run this query:\n\nUSE <database name>;\nGO\nWITH C AS\n(\nSELECT\n      P.name      AS [Parent Server Role],\n      CAST('Fixed' AS varchar(8))\n                  AS [Server Role Type],\n      M.name      AS [Member],\n      M.type_desc AS [Member Type],\n      P.name      AS [Root],\n      1           AS [Level]\nFROM\n      [sys].[server_role_members] X\n      INNER JOIN [sys].[server_principals] P ON P.principal_id =\nX.role_principal_id\n      INNER JOIN [sys].[server_principals] M ON M.principal_id =\nX.member_principal_id\nWHERE\n      P.is_fixed_role = 1\nUNION ALL\nSELECT\n      P.name        AS [Parent Server Role],\n      CASE WHEN M.is_fixed_role = 1 THEN CAST('Fixed' AS varchar(8)) ELSE\nCAST('Custom' AS varchar(8)) END\n                    AS [Server Role Type],\n      M.name        AS [Member],\n      M.type_desc   AS [Member Type],\n      C.[Root]      AS [Root],\n      C.[Level] + 1 AS [Level]\nFROM\n      [sys].[server_role_members] X\n      INNER JOIN [sys].[server_principals] P ON P.principal_id =\nX.role_principal_id\n      INNER JOIN [sys].[server_principals] M ON M.principal_id =\nX.member_principal_id\n      INNER JOIN C ON P.name = C.Member\n)\n,\nB AS\n(\nSELECT\n      C.[Member] AS [Leaf],\n      C.[Root],\n      C.[Parent Server Role],\n      C.[Server Role Type],\n      C.[Member],\n      C.[Member Type],\n      C.[Level]\nFROM C\nWHERE\n      C.[Member Type] NOT LIKE '%ROLE%'\nUNION ALL\nSELECT\n      B.[Leaf],\n      C.[Root],\n      C.[Parent Server Role],\n      C.[Server Role Type],\n      C.[Member],\n      C.[Member Type],\n      C.[Level]\nFROM C\nINNER JOIN B\n      ON       C.[Member] = B.[Parent Server Role]\n      AND       C.[Level] = B.[Level] - 1\n      AND       C.[Root] = B.[Root]\n)\nSELECT\n      DB_NAME() AS [Database],\n      B.[Leaf]  AS [Owner Login],\n      B.[Root]  AS[Top-Level Server Role],\n      B.[Parent Server Role],\n      B.[Server Role Type],\n      B.[Member],\n      B.[Member Type],\n      B.[Level]\nFROM B\nWHERE B.[Leaf] = (SELECT SUSER_SNAME(D.owner_sid) FROM sys.databases D WHERE\nD.Name = DB_NAME())\nORDER BY B.[Root], B.[Level], B.[Parent Server Role], B.[Member]\n;\nGO\n\nTo remove the database owner from a fixed server role or a custom server role:\nUSE [master];\nGO\nALTER SERVER ROLE <fixed/custom server role name>\n      DROP MEMBER <database owner name>;\nGO\nVerify that this produced the intended result by re-running the Check query.\n\nTo change the database owner:\nUSE [master];\nGO\nALTER AUTHORIZATION ON DATABASE::<DB name> TO <new owner name>;\nGO\nVerify that this produced the intended result by re-running the Check query.\"\n\n  query = %{\n    WITH FixedServerRoles(RoleName) AS\n    (\n          SELECT 'sysadmin'\n          UNION SELECT 'securityadmin'\n          UNION SELECT 'serveradmin'\n          UNION SELECT 'setupadmin'\n          UNION SELECT 'processadmin'\n          UNION SELECT 'diskadmin'\n          UNION SELECT 'dbcreator'\n          UNION SELECT 'bulkadmin'\n    )\n    SELECT\n          DB_NAME(database_id) AS [Database],\n          SUSER_SNAME(D.owner_sid) AS [Database Owner],\n          F.RoleName AS [Fixed Server Role],\n          CASE WHEN D.is_trustworthy_on = 1 THEN 'ON' ELSE 'off' END\n                AS [Trustworthy]\n    FROM\n          FixedServerRoles F\n          INNER JOIN sys.databases D ON D.Name = DB_NAME(database_id)\n    WHERE\n          IS_SRVROLEMEMBER(F.RoleName, SUSER_SNAME(D.owner_sid)) = 1\n    AND   DB_NAME(database_id) <> 'msdb'\n    AND   D.is_trustworthy_on = 1;\n    GO\n  }\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n\n  describe 'Non Compliant Database list' do\n    subject { sql_session.query(query).column('database') }\n    it { should be_empty }\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67375.rb",
        "line": 1
      },
      "id": "V-67375"
    },
    {
      "title": "Database objects (including but not limited to tables, indexes,\nstorage, stored procedures, functions, triggers, links to software external to\nSQL Server, etc.) must be owned by database/DBMS principals authorized for\nownership.",
      "desc": "Within the database, object ownership implies full privileges to the\nowned object, including the privilege to assign access to the owned objects to\nother subjects. Database functions and procedures can be coded using definer's\nrights. This allows anyone who utilizes the object to perform the actions if\nthey were the owner. If not properly managed, this can lead to privileged\nactions being taken by unauthorized individuals.\n\n    Conversely, if critical tables or other objects rely on unauthorized owner\naccounts, these objects may be lost when an account is removed.",
      "descriptions": {
        "default": "Within the database, object ownership implies full privileges to the\nowned object, including the privilege to assign access to the owned objects to\nother subjects. Database functions and procedures can be coded using definer's\nrights. This allows anyone who utilizes the object to perform the actions if\nthey were the owner. If not properly managed, this can lead to privileged\nactions being taken by unauthorized individuals.\n\n    Conversely, if critical tables or other objects rely on unauthorized owner\naccounts, these objects may be lost when an account is removed."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000133-DB-000200",
        "gid": "V-67371",
        "rid": "SV-81861r1_rule",
        "stig_id": "SQL4-00-015600",
        "fix_id": "F-73483r1_fix",
        "cci": [
          "CCI-001499"
        ],
        "nist": [
          "CM-5 (6)",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "Review system documentation to identify SQL Server accounts\nauthorized to own database objects.\n\nIf the SQL Server database ownership list does not exist or needs to be\nupdated, this is a finding.\n\nThe view STIG.database_permissions, included in the supplemental file,\nPermissions.sql, can be of use in making this determination:\nUSE <database name>;\nGO\nSELECT DISTINCT\n        S.[Schema/Owner] AS  [Owner],\n        O.[Schema/Owner] AS [Schema],\n        O.[Securable]\nFROM\n        STIG.database_permissions O\n        INNER JOIN STIG.database_permissions S\n                ON S.[Securable] = O.[Schema/Owner]\n                AND O.[Securable Type or Class] = 'OBJECT_OR_COLUMN'\n                AND S.[Securable Type or Class] = 'SCHEMA'\nWHERE\n        S.[Schema/Owner] NOT IN ('dbo', 'sys', 'INFORMATION_SCHEMA' ... )\n        --  Complete the \"NOT IN\" list with the names of user accounts\nauthorized for ownership.\n;\nIf any of the listed owners is not authorized, this is a finding.",
        "fix": "Add and/or update system documentation to include any accounts\nauthorized for object ownership and remove any account not authorized.\n\nTo change the schema owning a database object in SQL Server, use this code:\nUSE <database name>;\nGO\nALTER SCHEMA <name of new schema> TRANSFER <name of old schema>.<object name>;\nGO\n\nCaution:  this can break code.  This Fix should be implemented in conjunction\nwith corrections to such code.  Test before deploying in production.  Deploy\nduring a scheduled maintenance window."
      },
      "code": "control 'V-67371' do\n  title \"Database objects (including but not limited to tables, indexes,\nstorage, stored procedures, functions, triggers, links to software external to\nSQL Server, etc.) must be owned by database/DBMS principals authorized for\nownership.\"\n  desc  \"Within the database, object ownership implies full privileges to the\nowned object, including the privilege to assign access to the owned objects to\nother subjects. Database functions and procedures can be coded using definer's\nrights. This allows anyone who utilizes the object to perform the actions if\nthey were the owner. If not properly managed, this can lead to privileged\nactions being taken by unauthorized individuals.\n\n    Conversely, if critical tables or other objects rely on unauthorized owner\naccounts, these objects may be lost when an account is removed.\n  \"\n  impact 0.5\n  tag \"gtitle\": 'SRG-APP-000133-DB-000200'\n  tag \"gid\": 'V-67371'\n  tag \"rid\": 'SV-81861r1_rule'\n  tag \"stig_id\": 'SQL4-00-015600'\n  tag \"fix_id\": 'F-73483r1_fix'\n  tag \"cci\": ['CCI-001499']\n  tag \"nist\": ['CM-5 (6)', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"Review system documentation to identify SQL Server accounts\nauthorized to own database objects.\n\nIf the SQL Server database ownership list does not exist or needs to be\nupdated, this is a finding.\n\nThe view STIG.database_permissions, included in the supplemental file,\nPermissions.sql, can be of use in making this determination:\nUSE <database name>;\nGO\nSELECT DISTINCT\n        S.[Schema/Owner] AS  [Owner],\n        O.[Schema/Owner] AS [Schema],\n        O.[Securable]\nFROM\n        STIG.database_permissions O\n        INNER JOIN STIG.database_permissions S\n                ON S.[Securable] = O.[Schema/Owner]\n                AND O.[Securable Type or Class] = 'OBJECT_OR_COLUMN'\n                AND S.[Securable Type or Class] = 'SCHEMA'\nWHERE\n        S.[Schema/Owner] NOT IN ('dbo', 'sys', 'INFORMATION_SCHEMA' ... )\n        --  Complete the \\\"NOT IN\\\" list with the names of user accounts\nauthorized for ownership.\n;\nIf any of the listed owners is not authorized, this is a finding.\"\n  tag \"fix\": \"Add and/or update system documentation to include any accounts\nauthorized for object ownership and remove any account not authorized.\n\nTo change the schema owning a database object in SQL Server, use this code:\nUSE <database name>;\nGO\nALTER SCHEMA <name of new schema> TRANSFER <name of old schema>.<object name>;\nGO\n\nCaution:  this can break code.  This Fix should be implemented in conjunction\nwith corrections to such code.  Test before deploying in production.  Deploy\nduring a scheduled maintenance window.\"\n\n  # The query in check text is assumes the presence of STIG schema as supplied\n  # with the STIG supplemental. The below query ( taken from 2016 MSSQL STIG)\n  # will work without STIG supplemental schema.\n\n  query = %{\n      ;WITH OBJECTS_CTE\n           AS (SELECT O.NAME,\n                      O.TYPE_DESC,\n                      CASE\n                        WHEN O.PRINCIPAL_ID IS NULL THEN S.PRINCIPAL_ID\n                        ELSE O.PRINCIPAL_ID\n                      END AS PRINCIPAL_ID\n               FROM   SYS.OBJECTS O\n                      INNER JOIN SYS.SCHEMAS S\n                              ON O.SCHEMA_ID = S.SCHEMA_ID\n               WHERE  O.IS_MS_SHIPPED = 0)\n      SELECT CTE.NAME,\n             CTE.TYPE_DESC,\n             DP.NAME AS OBJECTOWNER\n      FROM   OBJECTS_CTE CTE\n             INNER JOIN SYS.DATABASE_PRINCIPALS DP\n                     ON CTE.PRINCIPAL_ID = DP.PRINCIPAL_ID\n      ORDER  BY DP.NAME,\n                CTE.NAME\n  }\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n\n  describe \"Authorized users for Database: #{attribute('db_name')}\" do\n    subject { sql_session.query(query).column('objectowner').uniq }\n    it { should cmp attribute('authorized_principals') }\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67371.rb",
        "line": 1
      },
      "id": "V-67371"
    },
    {
      "title": "SQL Server must generate Trace or Audit records when unsuccessful\nattempts to modify locally-defined security objects occur.",
      "desc": "SQL Server protects its built-in security objects (tables, views,\nfunctions, procedures, etc.) from alteration by database users and\nadministrators.  However, applications sometimes have additional,\nsecurity-related objects defined in the database.  ALTER operations on these\nobjects must be monitored.\n\n    To aid in diagnosis, it is necessary to keep track of failed attempts in\naddition to the successful ones.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    Use of SQL Server Audit's SCHEMA_OBJECT_CHANGE_GROUP causes capture of all\nattempts, successful and otherwise, to CREATE, ALTER, or DROP any schema-scoped\nobjects.  The [Succeeded] column in the audit output indicates the success or\nfailure of the attempted action.  Be aware, however, that it may report True in\nsome cases where one would intuitively expect False.",
      "descriptions": {
        "default": "SQL Server protects its built-in security objects (tables, views,\nfunctions, procedures, etc.) from alteration by database users and\nadministrators.  However, applications sometimes have additional,\nsecurity-related objects defined in the database.  ALTER operations on these\nobjects must be monitored.\n\n    To aid in diagnosis, it is necessary to keep track of failed attempts in\naddition to the successful ones.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    Use of SQL Server Audit's SCHEMA_OBJECT_CHANGE_GROUP causes capture of all\nattempts, successful and otherwise, to CREATE, ALTER, or DROP any schema-scoped\nobjects.  The [Succeeded] column in the audit output indicates the success or\nfailure of the attempted action.  Be aware, however, that it may report True in\nsome cases where one would intuitively expect False."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000496-DB-000335",
        "gid": "V-67435",
        "rid": "SV-81925r2_rule",
        "stig_id": "SQL4-00-036500",
        "fix_id": "F-73549r1_fix",
        "cci": [
          "CCI-000172"
        ],
        "nist": [
          "AU-12 c",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "If there are no locally-defined security tables or procedures,\nthis is not a finding.\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes,\nthis is a finding.\n\nIf SQL Server Trace is in use for audit purposes, verify  that all required\nevents are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no\ntraces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing\nrequirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should all be among those listed; if not, this\nis a finding:\n\n46  -- Object:Created\n47  -- Object:Deleted\n162  -- User error message\n164 -- Object:Altered\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the broad, server-level audit action group\nSCHEMA_OBJECT_CHANGE_GROUP for this purpose.  SQL Server Audit's flexibility\nmakes other techniques possible.  If an alternative technique is in use and\ndemonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their\nnames.\n\nRun the following to verify that all CREATE, ALTER, and DROP actions on any\nlocally-defined permissions tables, procedures and functions are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_CHANGE_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"FAILURE\" or \"SUCCESS AND FAILURE\",\nthis is a finding.",
        "fix": "Where SQL Server Trace is in use, define  and enable a trace that\ncaptures all auditable events.  The script provided in the supplemental file\nTrace.sql can be used to do this.\n\nWhere SQL Server Audit is in use, design and deploy a SQL Server Audit that\ncaptures all auditable events.  The script provided in the supplemental file\nAudit.sql can be used for this.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_CHANGE_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO"
      },
      "code": "control 'V-67435' do\n  title \"SQL Server must generate Trace or Audit records when unsuccessful\nattempts to modify locally-defined security objects occur.\"\n  desc  \"SQL Server protects its built-in security objects (tables, views,\nfunctions, procedures, etc.) from alteration by database users and\nadministrators.  However, applications sometimes have additional,\nsecurity-related objects defined in the database.  ALTER operations on these\nobjects must be monitored.\n\n    To aid in diagnosis, it is necessary to keep track of failed attempts in\naddition to the successful ones.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    Use of SQL Server Audit's SCHEMA_OBJECT_CHANGE_GROUP causes capture of all\nattempts, successful and otherwise, to CREATE, ALTER, or DROP any schema-scoped\nobjects.  The [Succeeded] column in the audit output indicates the success or\nfailure of the attempted action.  Be aware, however, that it may report True in\nsome cases where one would intuitively expect False.\n  \"\n  impact 0.5\n  tag \"gtitle\": 'SRG-APP-000496-DB-000335'\n  tag \"gid\": 'V-67435'\n  tag \"rid\": 'SV-81925r2_rule'\n  tag \"stig_id\": 'SQL4-00-036500'\n  tag \"fix_id\": 'F-73549r1_fix'\n  tag \"cci\": ['CCI-000172']\n  tag \"nist\": ['AU-12 c', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"If there are no locally-defined security tables or procedures,\nthis is not a finding.\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes,\nthis is a finding.\n\nIf SQL Server Trace is in use for audit purposes, verify  that all required\nevents are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no\ntraces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing\nrequirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should all be among those listed; if not, this\nis a finding:\n\n46  -- Object:Created\n47  -- Object:Deleted\n162  -- User error message\n164 -- Object:Altered\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the broad, server-level audit action group\nSCHEMA_OBJECT_CHANGE_GROUP for this purpose.  SQL Server Audit's flexibility\nmakes other techniques possible.  If an alternative technique is in use and\ndemonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\n\nAlternatively, review the contents of the system views with \\\"audit\\\" in their\nnames.\n\nRun the following to verify that all CREATE, ALTER, and DROP actions on any\nlocally-defined permissions tables, procedures and functions are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_CHANGE_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \\\"FAILURE\\\" or \\\"SUCCESS AND FAILURE\\\",\nthis is a finding.\"\n  tag \"fix\": \"Where SQL Server Trace is in use, define  and enable a trace that\ncaptures all auditable events.  The script provided in the supplemental file\nTrace.sql can be used to do this.\n\nWhere SQL Server Audit is in use, design and deploy a SQL Server Audit that\ncaptures all auditable events.  The script provided in the supplemental file\nAudit.sql can be used for this.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_CHANGE_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO\"\n  query_traces = %{\n    SELECT * FROM sys.traces\n  }\n  query_trace_eventinfo = %{\n    SELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(%<trace_id>s);\n  }\n\n  query_audits = %{\n    SELECT server_specification_id,\n           audit_action_name,\n           audited_result\n    FROM   sys.server_audit_specification_details\n    WHERE  audit_action_name = 'SCHEMA_OBJECT_CHANGE_GROUP';\n  }\n\n  server_trace_implemented = attribute('server_trace_implemented')\n  server_audit_implemented = attribute('server_audit_implemented')\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n\n  describe.one do\n    describe 'SQL Server Trace is in use for audit purposes' do\n      subject { server_trace_implemented }\n      it { should be true }\n    end\n\n    describe 'SQL Server Audit is in use for audit purposes' do\n      subject { server_audit_implemented }\n      it { should be true }\n    end\n  end\n\n  if server_trace_implemented\n    describe 'List defined traces for the SQL server instance' do\n      subject { sql_session.query(query_traces) }\n      it { should_not be_empty }\n    end\n\n    trace_ids = sql_session.query(query_traces).column('id')\n    describe.one do\n      trace_ids.each do |trace_id|\n        found_events = sql_session.query(format(query_trace_eventinfo, trace_id: trace_id)).column('eventid')\n        describe \"EventsIDs in Trace ID:#{trace_id}\" do\n          subject { found_events }\n          it { should include '46' }\n          it { should include '47' }\n          it { should include '162' }\n          it { should include '164' }\n        end\n      end\n    end\n  end\n\n  if server_audit_implemented\n    describe 'SQL Server Audit:' do\n      describe 'Defined Audits with Audit Action SCHEMA_OBJECT_CHANGE_GROUP' do\n        subject { sql_session.query(query_audits) }\n        it { should_not be_empty }\n      end\n      describe 'Audited Result for Defined Audit Actions' do\n        subject { sql_session.query(query_audits).column('audited_result').uniq.to_s }\n        it { should match /SUCCESS AND FAILURE|FAILURE/ }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67435.rb",
        "line": 1
      },
      "id": "V-67435"
    },
    {
      "title": "SQL Server must protect data at rest and ensure confidentiality and\nintegrity of data.",
      "desc": "This control is intended to address the confidentiality and integrity\nof information at rest in non-mobile devices and covers user information and\nsystem information.  Information at rest refers to the state of information\nwhen it is located on a secondary storage device (e.g., disk drive, tape drive)\nwithin an organizational information system. Applications and application users\ngenerate information throughout the course of their application use.\n\n    User-generated data, as well as, application-specific configuration data,\nneeds to be protected. Configurations and/or rule sets for firewalls, gateways,\nintrusion detection/prevention systems, filtering routers, and authenticator\ncontent are examples of system information likely requiring protection.\nOrganizations may choose to employ different mechanisms to achieve\nconfidentiality and integrity protections, as appropriate.\n\n    If the confidentiality and integrity of SQL Server data is not protected,\nthe data will be open to compromise and unauthorized modification.\n\n    Protective measures include encryption, physical security of the facility\nwhere the storage devices reside, operating system file permissions, and\norganizational controls.  Each of these should be applied as necessary and\nappropriate.",
      "descriptions": {
        "default": "This control is intended to address the confidentiality and integrity\nof information at rest in non-mobile devices and covers user information and\nsystem information.  Information at rest refers to the state of information\nwhen it is located on a secondary storage device (e.g., disk drive, tape drive)\nwithin an organizational information system. Applications and application users\ngenerate information throughout the course of their application use.\n\n    User-generated data, as well as, application-specific configuration data,\nneeds to be protected. Configurations and/or rule sets for firewalls, gateways,\nintrusion detection/prevention systems, filtering routers, and authenticator\ncontent are examples of system information likely requiring protection.\nOrganizations may choose to employ different mechanisms to achieve\nconfidentiality and integrity protections, as appropriate.\n\n    If the confidentiality and integrity of SQL Server data is not protected,\nthe data will be open to compromise and unauthorized modification.\n\n    Protective measures include encryption, physical security of the facility\nwhere the storage devices reside, operating system file permissions, and\norganizational controls.  Each of these should be applied as necessary and\nappropriate."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000231-DB-000154",
        "gid": "V-67877",
        "rid": "SV-82367r3_rule",
        "stig_id": "SQL4-00-021300",
        "fix_id": "F-73993r1_fix",
        "cci": [
          "CCI-001199"
        ],
        "nist": [
          "SC-28",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "If the application owner and Authorizing Official have\ndetermined that encryption of data at rest is NOT required, this is not a\nfinding.\n\nIf the application owner and Authorizing Official have determined that\nencryption of data at rest is required, ensure the data on secondary devices is\nencrypted.\n\nIf full-disk encryption is being used, this is not a finding.\n\nIf DBMS data encryption is required, ensure the data is encrypted before being\nput on the secondary device by executing:\n\nSELECT\n      d.name AS [Database Name],\n      CASE e.encryption_state\n            WHEN 0 THEN 'No database encryption key present, no encryption'\n            WHEN 1 THEN 'Unencrypted'\n            WHEN 2 THEN 'Encryption in progress'\n            WHEN 3 THEN 'Encrypted'\n            WHEN 4 THEN 'Key change in progress'\n            WHEN 5 THEN 'Decryption in progress'\n            WHEN 6 THEN 'Protection change in progress'\n      END AS [Encryption State]\nFROM sys.dm_database_encryption_keys e\nRIGHT JOIN sys.databases d ON DB_NAME(e.database_id) = d.name\nWHERE d.name NOT IN ('master','model','msdb')\nORDER BY 1;\n\nFor each user database where encryption is required, verify that encryption is\nin effect. If not, this is a finding.\n\nVerify that there are physical security measures, operating system access\ncontrol lists and organizational controls appropriate to the sensitivity level\nof the data in the database(s). If not, this is a finding.",
        "fix": "Apply appropriate controls to protect the confidentiality and\nintegrity of data on a secondary device.\n\nWhere encryption is required, this can be done by full-disk encryption or by\ndatabase encryption. To enable database encryption, create a master key, create\na database encryption key, and protect it by using mechanisms tied to the\nmaster key, and then set encryption on.\n\nImplement physical security measures, operating system access control lists and\norganizational controls appropriate to the sensitivity level of the data in the\ndatabase(s)."
      },
      "code": "control 'V-67877' do\n  title \"SQL Server must protect data at rest and ensure confidentiality and\nintegrity of data.\"\n  desc  \"This control is intended to address the confidentiality and integrity\nof information at rest in non-mobile devices and covers user information and\nsystem information.  Information at rest refers to the state of information\nwhen it is located on a secondary storage device (e.g., disk drive, tape drive)\nwithin an organizational information system. Applications and application users\ngenerate information throughout the course of their application use.\n\n    User-generated data, as well as, application-specific configuration data,\nneeds to be protected. Configurations and/or rule sets for firewalls, gateways,\nintrusion detection/prevention systems, filtering routers, and authenticator\ncontent are examples of system information likely requiring protection.\nOrganizations may choose to employ different mechanisms to achieve\nconfidentiality and integrity protections, as appropriate.\n\n    If the confidentiality and integrity of SQL Server data is not protected,\nthe data will be open to compromise and unauthorized modification.\n\n    Protective measures include encryption, physical security of the facility\nwhere the storage devices reside, operating system file permissions, and\norganizational controls.  Each of these should be applied as necessary and\nappropriate.\n  \"\n  impact 0.5\n  tag \"gtitle\": 'SRG-APP-000231-DB-000154'\n  tag \"gid\": 'V-67877'\n  tag \"rid\": 'SV-82367r3_rule'\n  tag \"stig_id\": 'SQL4-00-021300'\n  tag \"fix_id\": 'F-73993r1_fix'\n  tag \"cci\": ['CCI-001199']\n  tag \"nist\": ['SC-28', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"If the application owner and Authorizing Official have\ndetermined that encryption of data at rest is NOT required, this is not a\nfinding.\n\nIf the application owner and Authorizing Official have determined that\nencryption of data at rest is required, ensure the data on secondary devices is\nencrypted.\n\nIf full-disk encryption is being used, this is not a finding.\n\nIf DBMS data encryption is required, ensure the data is encrypted before being\nput on the secondary device by executing:\n\nSELECT\n      d.name AS [Database Name],\n      CASE e.encryption_state\n            WHEN 0 THEN 'No database encryption key present, no encryption'\n            WHEN 1 THEN 'Unencrypted'\n            WHEN 2 THEN 'Encryption in progress'\n            WHEN 3 THEN 'Encrypted'\n            WHEN 4 THEN 'Key change in progress'\n            WHEN 5 THEN 'Decryption in progress'\n            WHEN 6 THEN 'Protection change in progress'\n      END AS [Encryption State]\nFROM sys.dm_database_encryption_keys e\nRIGHT JOIN sys.databases d ON DB_NAME(e.database_id) = d.name\nWHERE d.name NOT IN ('master','model','msdb')\nORDER BY 1;\n\nFor each user database where encryption is required, verify that encryption is\nin effect. If not, this is a finding.\n\nVerify that there are physical security measures, operating system access\ncontrol lists and organizational controls appropriate to the sensitivity level\nof the data in the database(s). If not, this is a finding.\"\n  tag \"fix\": \"Apply appropriate controls to protect the confidentiality and\nintegrity of data on a secondary device.\n\nWhere encryption is required, this can be done by full-disk encryption or by\ndatabase encryption. To enable database encryption, create a master key, create\na database encryption key, and protect it by using mechanisms tied to the\nmaster key, and then set encryption on.\n\nImplement physical security measures, operating system access control lists and\norganizational controls appropriate to the sensitivity level of the data in the\ndatabase(s).\"\n\n  data_at_rest_encryption_required = attribute('data_at_rest_encryption_required')\n  full_disk_encryption_inplace = attribute('full_disk_encryption_inplace')\n\n  query = %{\n    SELECT     d.NAME AS [Database Name],\n               CASE e.encryption_state\n                          WHEN 0 THEN 'No database encryption key present, no encryption'\n                          WHEN 1 THEN 'Unencrypted'\n                          WHEN 2 THEN 'Encryption in progress'\n                          WHEN 3 THEN 'Encrypted'\n                          WHEN 4 THEN 'Key change in progress'\n                          WHEN 5 THEN 'Decryption in progress'\n                          WHEN 6 THEN 'Protection change in progress'\n               END AS [Encryption State]\n    FROM       sys.dm_database_encryption_keys e\n    RIGHT JOIN sys.databases d\n    ON         Db_name(e.database_id) = d.NAME\n    WHERE      d.NAME NOT IN ('master',\n                              'model',\n                              'msdb')\n    AND        d.NAME IN ('#{attribute('db_name')}')\n  }\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n\n  unless data_at_rest_encryption_required\n    impact 0.0\n    desc 'The application owner and Authorizing Official have\n    determined that encryption of data at rest is NOT required, this is not a\n    finding.'\n  end\n\n  if full_disk_encryption_inplace\n    impact 0.0\n    desc 'Full-disk encryption is being used, this is not a finding.'\n\n    describe 'Encryption of data at rest' do\n      subject { full_disk_encryption_inplace }\n      it { should be true }\n    end\n  end\n\n  describe \"Database: #{attribute('db_name')} encryption state\" do\n    subject { sql_session.query(query).column('encryption state').uniq }\n    it { should cmp 'Encrypted' }\n  end\n\n  describe 'The following checks must be preformed manually' do\n    skip \"The following checks must be preformed manually:\n    Verify that there are physical security measures, operating system access\n    control lists and organizational controls appropriate to the sensitivity level\n    of the data in the database(s). If not, this is a finding.\"\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67877.rb",
        "line": 1
      },
      "id": "V-67877"
    },
    {
      "title": "Trace or Audit records must be generated when categorized information\n(e.g., classification levels/security levels) is modified.",
      "desc": "Changes in categorized information must be tracked. Without an audit\ntrail, unauthorized access to protected data could go undetected.\n\n    For detailed information on categorizing information, refer to FIPS\nPublication 199, Standards for Security Categorization of Federal Information\nand Information Systems, and FIPS Publication 200, Minimum Security\nRequirements for Federal Information and Information Systems.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    Since Trace does not provide for tracking SELECT statements, it is\nnecessary to provide that part of the tracking at the application level.\nBecause of this, it may also be appropriate to audit UPDATE actions at the\napplication level.  However, to capture all UPDATEs, whether they come from the\napplication or bypass it, the Trace must be configured to cover them.",
      "descriptions": {
        "default": "Changes in categorized information must be tracked. Without an audit\ntrail, unauthorized access to protected data could go undetected.\n\n    For detailed information on categorizing information, refer to FIPS\nPublication 199, Standards for Security Categorization of Federal Information\nand Information Systems, and FIPS Publication 200, Minimum Security\nRequirements for Federal Information and Information Systems.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    Since Trace does not provide for tracking SELECT statements, it is\nnecessary to provide that part of the tracking at the application level.\nBecause of this, it may also be appropriate to audit UPDATE actions at the\napplication level.  However, to capture all UPDATEs, whether they come from the\napplication or bypass it, the Trace must be configured to cover them."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000498-DB-000346",
        "gid": "V-67441",
        "rid": "SV-81931r2_rule",
        "stig_id": "SQL4-00-036650",
        "fix_id": "F-73555r1_fix",
        "cci": [
          "CCI-000172"
        ],
        "nist": [
          "AU-12 c",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "Review the system documentation to determine whether it is\nrequired to track categories of information, such as classification or\nsensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes,\nthis is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the triggers on all\ntables holding categorized information, to determine whether trace events are\ngenerated for all UPDATE actions on these tables.  If not, this is a finding.\n\nCheck to see that all required event classes are being audited.  From the query\nprompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no\ntraces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing\nrequirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is\na finding:\n\n82-91  -- User-defined Event (at least one of these, matching the triggers; 90\nis used in the supplied script)\n162 -- User error message\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the broad, server-level audit action group\nSCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility\nmakes other techniques possible.  If an alternative technique is in use and\ndemonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their\nnames.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions\non tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"SUCCESS\" or \"SUCCESS AND FAILURE\",\nthis is a finding.",
        "fix": "Where SQL Server Trace is in use, create triggers to raise a\ncustom event for UPDATEs on each table holding categorized information.  The\nexamples provided in the supplemental file CustomTraceEvents.sql can serve as\nthe basis for these.\n\nAdd a block of code to the supplemental file Trace.sql for each custom event\nclass (integers in the range 82-91; the same event class may be used for all\nsuch triggers) used in these triggers.  Execute Trace.sql.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all\nauditable events and data items.  The script provided in the supplemental file\nAudit.sql can be used as the basis for this.  Supplement the standard audit\ndata as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO"
      },
      "code": "control 'V-67441' do\n  title \"Trace or Audit records must be generated when categorized information\n(e.g., classification levels/security levels) is modified.\"\n  desc  \"Changes in categorized information must be tracked. Without an audit\ntrail, unauthorized access to protected data could go undetected.\n\n    For detailed information on categorizing information, refer to FIPS\nPublication 199, Standards for Security Categorization of Federal Information\nand Information Systems, and FIPS Publication 200, Minimum Security\nRequirements for Federal Information and Information Systems.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    Since Trace does not provide for tracking SELECT statements, it is\nnecessary to provide that part of the tracking at the application level.\nBecause of this, it may also be appropriate to audit UPDATE actions at the\napplication level.  However, to capture all UPDATEs, whether they come from the\napplication or bypass it, the Trace must be configured to cover them.\n  \"\n  if attribute('server_trace_or_audit_required')\n    impact 0.5\n  else\n    impact 0.0\n    desc 'Inspec attributes has specified that is not required to track categories\n    of information, such as classification or sensitivity level on the target'\n  end\n\n  tag \"gtitle\": 'SRG-APP-000498-DB-000346'\n  tag \"gid\": 'V-67441'\n  tag \"rid\": 'SV-81931r2_rule'\n  tag \"stig_id\": 'SQL4-00-036650'\n  tag \"fix_id\": 'F-73555r1_fix'\n  tag \"cci\": ['CCI-000172']\n  tag \"nist\": ['AU-12 c', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"Review the system documentation to determine whether it is\nrequired to track categories of information, such as classification or\nsensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes,\nthis is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the triggers on all\ntables holding categorized information, to determine whether trace events are\ngenerated for all UPDATE actions on these tables.  If not, this is a finding.\n\nCheck to see that all required event classes are being audited.  From the query\nprompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no\ntraces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing\nrequirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is\na finding:\n\n82-91  -- User-defined Event (at least one of these, matching the triggers; 90\nis used in the supplied script)\n162 -- User error message\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the broad, server-level audit action group\nSCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility\nmakes other techniques possible.  If an alternative technique is in use and\ndemonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\n\nAlternatively, review the contents of the system views with \\\"audit\\\" in their\nnames.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions\non tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \\\"SUCCESS\\\" or \\\"SUCCESS AND FAILURE\\\",\nthis is a finding.\"\n  tag \"fix\": \"Where SQL Server Trace is in use, create triggers to raise a\ncustom event for UPDATEs on each table holding categorized information.  The\nexamples provided in the supplemental file CustomTraceEvents.sql can serve as\nthe basis for these.\n\nAdd a block of code to the supplemental file Trace.sql for each custom event\nclass (integers in the range 82-91; the same event class may be used for all\nsuch triggers) used in these triggers.  Execute Trace.sql.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all\nauditable events and data items.  The script provided in the supplemental file\nAudit.sql can be used as the basis for this.  Supplement the standard audit\ndata as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO\"\n  query_traces = %{\n    SELECT * FROM sys.traces\n  }\n  query_trace_eventinfo = %{\n    SELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(%<trace_id>s);\n  }\n\n  query_audits = %{\n    SELECT server_specification_id,\n           audit_action_name,\n           audited_result\n    FROM   sys.server_audit_specification_details\n    WHERE  audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n  }\n\n  server_trace_implemented = attribute('server_trace_implemented')\n  server_audit_implemented = attribute('server_audit_implemented')\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n\n  describe.one do\n    describe 'SQL Server Trace is in use for audit purposes' do\n      subject { server_trace_implemented }\n      it { should be true }\n    end\n\n    describe 'SQL Server Audit is in use for audit purposes' do\n      subject { server_audit_implemented }\n      it { should be true }\n    end\n  end\n\n  if server_trace_implemented\n    describe 'List defined traces for the SQL server instance' do\n      subject { sql_session.query(query_traces) }\n      it { should_not be_empty }\n    end\n\n    trace_ids = sql_session.query(query_traces).column('id')\n    describe.one do\n      trace_ids.each do |trace_id|\n        found_events = sql_session.query(format(query_trace_eventinfo, trace_id: trace_id)).column('eventid')\n        describe \"EventsIDs in Trace ID:#{trace_id}\" do\n          subject { found_events }\n          its('to_s') { should match /\"82\"|\"83\"|\"84\"|\"85\"|\"86\"|\"87\"|\"88\"|\"89\"|\"90\"|\"91\"/ }\n          it { should include '162' }\n        end\n      end\n    end\n  end\n\n  if server_audit_implemented\n    describe 'SQL Server Audit:' do\n      describe 'Defined Audits with Audit Action SCHEMA_OBJECT_ACCESS_GROUP' do\n        subject { sql_session.query(query_audits) }\n        it { should_not be_empty }\n      end\n      describe 'Audited Result for Defined Audit Actions' do\n        subject { sql_session.query(query_audits).column('audited_result').uniq.to_s }\n        it { should match /SUCCESS AND FAILURE|SUCCESS/ }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67441.rb",
        "line": 1
      },
      "id": "V-67441"
    },
    {
      "title": "Database Master Key passwords must not be stored in credentials within\nthe database.",
      "desc": "Storage of the Database Master Key password in a database credential\nallows decryption of sensitive data by privileged users who may not have a\nneed-to-know requirement to access the data.",
      "descriptions": {
        "default": "Storage of the Database Master Key password in a database credential\nallows decryption of sensitive data by privileged users who may not have a\nneed-to-know requirement to access the data."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000231-DB-000154",
        "gid": "V-67383",
        "rid": "SV-81873r1_rule",
        "stig_id": "SQL4-00-024200",
        "fix_id": "F-73495r1_fix",
        "cci": [
          "CCI-001199"
        ],
        "nist": [
          "SC-28",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "From the query prompt:\nSELECT COUNT(credential_id)\nFROM [master].sys.master_key_passwords\n\nIf count is not 0, this is a finding.",
        "fix": "Use the stored procedure sp_control_dbmasterkey_password to\nremove any credentials that\nstore Database Master Key passwords.\nFrom the query prompt:\nEXEC SP_CONTROL_DBMASTERKEY_PASSWORD @db_name = '<database name>', @action\n= N'drop'"
      },
      "code": "control 'V-67383' do\n  title \"Database Master Key passwords must not be stored in credentials within\nthe database.\"\n  desc  \"Storage of the Database Master Key password in a database credential\nallows decryption of sensitive data by privileged users who may not have a\nneed-to-know requirement to access the data.\"\n  impact 0.5\n  tag \"gtitle\": 'SRG-APP-000231-DB-000154'\n  tag \"gid\": 'V-67383'\n  tag \"rid\": 'SV-81873r1_rule'\n  tag \"stig_id\": 'SQL4-00-024200'\n  tag \"fix_id\": 'F-73495r1_fix'\n  tag \"cci\": ['CCI-001199']\n  tag \"nist\": ['SC-28', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"From the query prompt:\nSELECT COUNT(credential_id)\nFROM [master].sys.master_key_passwords\n\nIf count is not 0, this is a finding.\"\n  tag \"fix\": \"Use the stored procedure sp_control_dbmasterkey_password to\nremove any credentials that\nstore Database Master Key passwords.\nFrom the query prompt:\nEXEC SP_CONTROL_DBMASTERKEY_PASSWORD @db_name = '<database name>', @action\n= N'drop'\"\n\n  query= %{\n    SELECT\n          COUNT(credential_id) AS count_of_ids\n    FROM\n          [master].sys.master_key_passwords\n  }\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n\n  describe 'Count of `Database Master Key passwords` stored in credentials within the database' do\n    subject { sql_session.query(query).row(0).column('count_of_ids') }\n    its('value') { should cmp 0 }\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67383.rb",
        "line": 1
      },
      "id": "V-67383"
    },
    {
      "title": "In a database owned by a login not having administrative privileges at\nthe instance level, the database property TRUSTWORTHY must be OFF unless\nrequired and authorized.",
      "desc": "SQL Server's fixed (built-in) server roles, especially [sysadmin],\nhave powerful capabilities that could cause great harm if misused, so their use\nmust be tightly controlled.\n\n    The SQL Server instance uses each database's TRUSTWORTHY property to guard\nagainst tampering that could enable unwarranted privilege escalation. When\nTRUSTWORTHY is 0/False/Off, SQL Server prevents the database from accessing\nresources in other databases. When TRUSTWORTHY is 1/True/On, SQL Server permits\naccess to other databases (subject to other protections). SQL Server sets\nTRUSTWORTHY OFF when it creates a new database. SQL Server forces TRUSTWORTHY\nOFF, irrespective of its prior value, when an existing database is attached to\nit, to address the possibility that an adversary may have tampered with the\ndatabase, introducing malicious code. To set TRUSTWORTHY ON, an account with\nthe [sysadmin] role must issue an ALTER DATABASE command.\n\n    Although SQL Server itself treats this property conservatively, application\ninstaller programs may set TRUSTWORTHY ON and leave it on. This provides an\nopportunity for misuse.\n\n    When TRUSTWORTHY is ON, users of the database can take advantage of the\ndatabase owner's privileges, by impersonating the owner. This can have\nparticularly serious consequences if the database owner is the [sa] login\n(which may have been renamed in accordance with SQL4-00-010200, and disabled in\naccordance with SQL4-00-017100, but nonetheless can be invoked in an EXECUTE AS\nUSER = 'dbo' statement, or CREATE PROCEDURE ... WITH EXECUTE AS OWNER ...). The\n[sa] login cannot be removed from the [sysadmin] role. The user impersonating\n[sa] - or another [sysadmin] account - is then able to perform administrative\nactions across all databases under the instance, including making any himself\nor any other login a member of [sysadmin].\n\n    Most of the other fixed server roles could be similarly abused.\n\n    Therefore, TRUSTWORTHY must not be used on databases owned by logins that\nare members of the fixed server roles. Further, if TRUSTWORTHY is to be used\nfor any other database, the need must be documented and approved.\n\n    The system database [msdb] is an exception: it is required to be\nTRUSTWORTHY.",
      "descriptions": {
        "default": "SQL Server's fixed (built-in) server roles, especially [sysadmin],\nhave powerful capabilities that could cause great harm if misused, so their use\nmust be tightly controlled.\n\n    The SQL Server instance uses each database's TRUSTWORTHY property to guard\nagainst tampering that could enable unwarranted privilege escalation. When\nTRUSTWORTHY is 0/False/Off, SQL Server prevents the database from accessing\nresources in other databases. When TRUSTWORTHY is 1/True/On, SQL Server permits\naccess to other databases (subject to other protections). SQL Server sets\nTRUSTWORTHY OFF when it creates a new database. SQL Server forces TRUSTWORTHY\nOFF, irrespective of its prior value, when an existing database is attached to\nit, to address the possibility that an adversary may have tampered with the\ndatabase, introducing malicious code. To set TRUSTWORTHY ON, an account with\nthe [sysadmin] role must issue an ALTER DATABASE command.\n\n    Although SQL Server itself treats this property conservatively, application\ninstaller programs may set TRUSTWORTHY ON and leave it on. This provides an\nopportunity for misuse.\n\n    When TRUSTWORTHY is ON, users of the database can take advantage of the\ndatabase owner's privileges, by impersonating the owner. This can have\nparticularly serious consequences if the database owner is the [sa] login\n(which may have been renamed in accordance with SQL4-00-010200, and disabled in\naccordance with SQL4-00-017100, but nonetheless can be invoked in an EXECUTE AS\nUSER = 'dbo' statement, or CREATE PROCEDURE ... WITH EXECUTE AS OWNER ...). The\n[sa] login cannot be removed from the [sysadmin] role. The user impersonating\n[sa] - or another [sysadmin] account - is then able to perform administrative\nactions across all databases under the instance, including making any himself\nor any other login a member of [sysadmin].\n\n    Most of the other fixed server roles could be similarly abused.\n\n    Therefore, TRUSTWORTHY must not be used on databases owned by logins that\nare members of the fixed server roles. Further, if TRUSTWORTHY is to be used\nfor any other database, the need must be documented and approved.\n\n    The system database [msdb] is an exception: it is required to be\nTRUSTWORTHY."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000133-DB-000200",
        "gid": "V-67373",
        "rid": "SV-81863r1_rule",
        "stig_id": "SQL4-00-015620",
        "fix_id": "F-73485r1_fix",
        "cci": [
          "CCI-001499"
        ],
        "nist": [
          "CM-5 (6)",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "If the database is owned by an account that is directly or\nindirectly a member of a fixed (built-in) server role, this is not applicable\n(NA).\n\nRun the query:\nUSE <database name>;\nGO\nSELECT\nDB_NAME() AS [Database],\nSUSER_SNAME(D.owner_sid) AS [Database Owner],\nCASE WHEN D.is_trustworthy_on = 1 THEN 'ON' ELSE 'off' END\nAS [Trustworthy]\nFROM\nsys.databases D\nWHERE\nD.[name] = DB_NAME()\nAND DB_NAME() <> 'msdb'\nAND D.is_trustworthy_on = 1;\nGO\nIf the query returns a row indicating that the TRUSTWORTHY setting is OFF, or\nreturns no rows, this is not a finding.\n\nReview the system security plan to determine whether the need for TRUSTWORTHY\nis documented and approved. If not, this is a finding.",
        "fix": "Run the SQL statements:\nUSE [master];\nGO\nALTER DATABASE <name> SET TRUSTWORTHY OFF;\nGO"
      },
      "code": "control 'V-67373' do\n  title \"In a database owned by a login not having administrative privileges at\nthe instance level, the database property TRUSTWORTHY must be OFF unless\nrequired and authorized.\"\n  desc  \"SQL Server's fixed (built-in) server roles, especially [sysadmin],\nhave powerful capabilities that could cause great harm if misused, so their use\nmust be tightly controlled.\n\n    The SQL Server instance uses each database's TRUSTWORTHY property to guard\nagainst tampering that could enable unwarranted privilege escalation. When\nTRUSTWORTHY is 0/False/Off, SQL Server prevents the database from accessing\nresources in other databases. When TRUSTWORTHY is 1/True/On, SQL Server permits\naccess to other databases (subject to other protections). SQL Server sets\nTRUSTWORTHY OFF when it creates a new database. SQL Server forces TRUSTWORTHY\nOFF, irrespective of its prior value, when an existing database is attached to\nit, to address the possibility that an adversary may have tampered with the\ndatabase, introducing malicious code. To set TRUSTWORTHY ON, an account with\nthe [sysadmin] role must issue an ALTER DATABASE command.\n\n    Although SQL Server itself treats this property conservatively, application\ninstaller programs may set TRUSTWORTHY ON and leave it on. This provides an\nopportunity for misuse.\n\n    When TRUSTWORTHY is ON, users of the database can take advantage of the\ndatabase owner's privileges, by impersonating the owner. This can have\nparticularly serious consequences if the database owner is the [sa] login\n(which may have been renamed in accordance with SQL4-00-010200, and disabled in\naccordance with SQL4-00-017100, but nonetheless can be invoked in an EXECUTE AS\nUSER = 'dbo' statement, or CREATE PROCEDURE ... WITH EXECUTE AS OWNER ...). The\n[sa] login cannot be removed from the [sysadmin] role. The user impersonating\n[sa] - or another [sysadmin] account - is then able to perform administrative\nactions across all databases under the instance, including making any himself\nor any other login a member of [sysadmin].\n\n    Most of the other fixed server roles could be similarly abused.\n\n    Therefore, TRUSTWORTHY must not be used on databases owned by logins that\nare members of the fixed server roles. Further, if TRUSTWORTHY is to be used\nfor any other database, the need must be documented and approved.\n\n    The system database [msdb] is an exception: it is required to be\nTRUSTWORTHY.\n  \"\n  impact 0.5\n  tag \"gtitle\": 'SRG-APP-000133-DB-000200'\n  tag \"gid\": 'V-67373'\n  tag \"rid\": 'SV-81863r1_rule'\n  tag \"stig_id\": 'SQL4-00-015620'\n  tag \"fix_id\": 'F-73485r1_fix'\n  tag \"cci\": ['CCI-001499']\n  tag \"nist\": ['CM-5 (6)', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"If the database is owned by an account that is directly or\nindirectly a member of a fixed (built-in) server role, this is not applicable\n(NA).\n\nRun the query:\nUSE <database name>;\nGO\nSELECT\nDB_NAME() AS [Database],\nSUSER_SNAME(D.owner_sid) AS [Database Owner],\nCASE WHEN D.is_trustworthy_on = 1 THEN 'ON' ELSE 'off' END\nAS [Trustworthy]\nFROM\nsys.databases D\nWHERE\nD.[name] = DB_NAME()\nAND DB_NAME() <> 'msdb'\nAND D.is_trustworthy_on = 1;\nGO\nIf the query returns a row indicating that the TRUSTWORTHY setting is OFF, or\nreturns no rows, this is not a finding.\n\nReview the system security plan to determine whether the need for TRUSTWORTHY\nis documented and approved. If not, this is a finding.\"\n  tag \"fix\": \"Run the SQL statements:\nUSE [master];\nGO\nALTER DATABASE <name> SET TRUSTWORTHY OFF;\nGO\"\n\n  query = %{\n    SELECT\n          DB_NAME(D.database_id) AS [Database],\n          SUSER_SNAME(D.owner_sid) AS [Database Owner],\n          CASE WHEN D.is_trustworthy_on = 1 THEN 'ON' ELSE 'off' END\n          AS [Trustworthy]\n    FROM\n          sys.databases D\n    WHERE\n          D.[name] = DB_NAME(D.database_id)\n          AND DB_NAME(D.database_id) <> 'msdb'\n          AND D.is_trustworthy_on = 1;\n    GO\n  }\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n\n  describe 'Non Compliant Database list' do\n    subject { sql_session.query(query).column('database') }\n    it { should be_empty }\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67373.rb",
        "line": 1
      },
      "id": "V-67373"
    },
    {
      "title": "SQL Server must check the validity of all data inputs except those\nspecifically identified by the organization.",
      "desc": "Invalid user input occurs when a user inserts data or characters into\nan application’s data entry fields and the application is unprepared to process\nthat data. This results in unanticipated application behavior potentially\nleading to an application or information system compromise. Invalid user input\nis one of the primary methods employed when attempting to compromise an\napplication.\n\n    SQL Server needs to validate the data user’s attempt to input to the\napplication for processing. Rules for checking the valid syntax and semantics\nof information system inputs (e.g., character set, length, numerical range,\nacceptable values) are in place to verify inputs match specified definitions\nfor format and content. Inputs passed to interpreters are prescreened to\nprevent the content from being unintentionally interpreted as commands.\n\n    A poorly designed database system can have many problems. A common issue\nwith these types of systems is the missed opportunity to use constraints.\n\n    This calls for inspection of application source code, which will require\ncollaboration with the application developers. It is recognized that in many\ncases, the database administrator (DBA) is organizationally separate from the\napplication developers and may have limited, if any, access to source code.\nNevertheless, protections of this type are so important to the secure operation\nof databases that they must not be ignored. At a minimum, the DBA must attempt\nto obtain assurances from the development organization that this issue has been\naddressed and must document what has been discovered.",
      "descriptions": {
        "default": "Invalid user input occurs when a user inserts data or characters into\nan application’s data entry fields and the application is unprepared to process\nthat data. This results in unanticipated application behavior potentially\nleading to an application or information system compromise. Invalid user input\nis one of the primary methods employed when attempting to compromise an\napplication.\n\n    SQL Server needs to validate the data user’s attempt to input to the\napplication for processing. Rules for checking the valid syntax and semantics\nof information system inputs (e.g., character set, length, numerical range,\nacceptable values) are in place to verify inputs match specified definitions\nfor format and content. Inputs passed to interpreters are prescreened to\nprevent the content from being unintentionally interpreted as commands.\n\n    A poorly designed database system can have many problems. A common issue\nwith these types of systems is the missed opportunity to use constraints.\n\n    This calls for inspection of application source code, which will require\ncollaboration with the application developers. It is recognized that in many\ncases, the database administrator (DBA) is organizationally separate from the\napplication developers and may have limited, if any, access to source code.\nNevertheless, protections of this type are so important to the secure operation\nof databases that they must not be ignored. At a minimum, the DBA must attempt\nto obtain assurances from the development organization that this issue has been\naddressed and must document what has been discovered."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000251-DB-000160",
        "gid": "V-67391",
        "rid": "SV-81881r2_rule",
        "stig_id": "SQL4-00-022500",
        "fix_id": "F-73503r1_fix",
        "cci": [
          "CCI-001310"
        ],
        "nist": [
          "SI-10",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "Review DBMS code (stored procedures, functions, triggers),\napplication code, settings, column and field definitions, and constraints to\ndetermine whether the database is protected against invalid input.\n\nIf code exists that allows invalid data to be acted upon or input into the\ndatabase, this is a finding.\n\nIf column/field definitions are not reflective of the data, this is a finding.\n\nIf columns/fields do not contain constraints and validity checking where\nrequired, this is a finding.\n\nWhere a column/field is noted in the system documentation as necessarily\nfree-form, even though its name and context suggest that it should be strongly\ntyped and constrained, the absence of these protections is not a finding.\n\nWhere a column/field is clearly identified by name, caption or context as\nNotes, Comments, Description, Text, etc., the absence of these protections is\nnot a finding.",
        "fix": "Use triggers, constraints, foreign keys, etc. to validate data\ninput.\n\nModify SQL Server to properly use the correct column data types as required in\nthe database."
      },
      "code": "control 'V-67391' do\n  title \"SQL Server must check the validity of all data inputs except those\nspecifically identified by the organization.\"\n  desc  \"Invalid user input occurs when a user inserts data or characters into\nan application’s data entry fields and the application is unprepared to process\nthat data. This results in unanticipated application behavior potentially\nleading to an application or information system compromise. Invalid user input\nis one of the primary methods employed when attempting to compromise an\napplication.\n\n    SQL Server needs to validate the data user’s attempt to input to the\napplication for processing. Rules for checking the valid syntax and semantics\nof information system inputs (e.g., character set, length, numerical range,\nacceptable values) are in place to verify inputs match specified definitions\nfor format and content. Inputs passed to interpreters are prescreened to\nprevent the content from being unintentionally interpreted as commands.\n\n    A poorly designed database system can have many problems. A common issue\nwith these types of systems is the missed opportunity to use constraints.\n\n    This calls for inspection of application source code, which will require\ncollaboration with the application developers. It is recognized that in many\ncases, the database administrator (DBA) is organizationally separate from the\napplication developers and may have limited, if any, access to source code.\nNevertheless, protections of this type are so important to the secure operation\nof databases that they must not be ignored. At a minimum, the DBA must attempt\nto obtain assurances from the development organization that this issue has been\naddressed and must document what has been discovered.\n  \"\n  impact 0.5\n  tag \"gtitle\": 'SRG-APP-000251-DB-000160'\n  tag \"gid\": 'V-67391'\n  tag \"rid\": 'SV-81881r2_rule'\n  tag \"stig_id\": 'SQL4-00-022500'\n  tag \"fix_id\": 'F-73503r1_fix'\n  tag \"cci\": ['CCI-001310']\n  tag \"nist\": ['SI-10', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"Review DBMS code (stored procedures, functions, triggers),\napplication code, settings, column and field definitions, and constraints to\ndetermine whether the database is protected against invalid input.\n\nIf code exists that allows invalid data to be acted upon or input into the\ndatabase, this is a finding.\n\nIf column/field definitions are not reflective of the data, this is a finding.\n\nIf columns/fields do not contain constraints and validity checking where\nrequired, this is a finding.\n\nWhere a column/field is noted in the system documentation as necessarily\nfree-form, even though its name and context suggest that it should be strongly\ntyped and constrained, the absence of these protections is not a finding.\n\nWhere a column/field is clearly identified by name, caption or context as\nNotes, Comments, Description, Text, etc., the absence of these protections is\nnot a finding.\"\n  tag \"fix\": \"Use triggers, constraints, foreign keys, etc. to validate data\ninput.\n\nModify SQL Server to properly use the correct column data types as required in\nthe database.\"\n\n  describe 'This test currently has no automated tests, you must check manually' do\n    skip 'This check must be preformed manually'\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67391.rb",
        "line": 1
      },
      "id": "V-67391"
    },
    {
      "title": "SQL Server must generate Trace or Audit records when successful\naccesses to designated objects occur.",
      "desc": "Without tracking all or selected types of access to all or selected\nobjects (tables, views, procedures, functions, etc.), it would be difficult to\nestablish, correlate, and investigate the events relating to an incident, or\nidentify those responsible for one.\n\n    Types of access include, but are not necessarily limited to:\n    SELECT\n    INSERT\n    UPDATE\n    DELETE\n    EXECUTE\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    Trace does not offer tracking of SELECT operations, so where this is\nrequired it must be implemented at the application level.",
      "descriptions": {
        "default": "Without tracking all or selected types of access to all or selected\nobjects (tables, views, procedures, functions, etc.), it would be difficult to\nestablish, correlate, and investigate the events relating to an incident, or\nidentify those responsible for one.\n\n    Types of access include, but are not necessarily limited to:\n    SELECT\n    INSERT\n    UPDATE\n    DELETE\n    EXECUTE\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    Trace does not offer tracking of SELECT operations, so where this is\nrequired it must be implemented at the application level."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000507-DB-000356",
        "gid": "V-67425",
        "rid": "SV-81915r3_rule",
        "stig_id": "SQL4-00-038100",
        "fix_id": "F-73539r1_fix",
        "cci": [
          "CCI-000172"
        ],
        "nist": [
          "AU-12 c",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "If neither SQL Server Audit nor SQL Server Trace is in use for\naudit purposes, this is a finding.\n\nObtain the list of objects (tables and stored procedures) where tracking of\nSELECT, INSERT, UPDATE, DELETE, or EXECUTE actions is required.  If there are\nnone, this is not a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the application(s)\nusing the database to verify that all SELECT actions on categorized data are\nbeing audited, and that the tracking records are written to the SQL Server\nTrace used for audit purposes.  If not, this is a finding.\n\nReview the designated tables for the existence of triggers to raise a custom\nevent on each Insert-Update-Delete operation.\n\nIf such triggers are not present, this is a finding.\n\nCheck to see that all required event classes are being audited.  From the query\nprompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no\ntraces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing\nrequirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is\na finding:\n\n42  -- SP:Starting\n43  -- SP:Completed\n82-91  -- User-defined Event (at least one of these; 90 is used in the supplied\nscript)\n162 -- User error message\n\nIf SQL Server Audit is in use, verify that execution of all SELECT, INSERT,\nUPDATE, DELETE, or EXECUTE actions on the designated objects, is audited,.\n\nIf any such actions are not audited, this is a finding.\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the server-level audit action group SCHEMA_OBJECT_ACCESS_GROUP\nfor this purpose.  SQL Server Audit's flexibility makes other techniques\npossible.  If an alternative technique is in use and demonstrated effective,\nthis is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their\nnames.\n\nRun the following to verify that all logons and connections are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\nGO\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"SUCCESS\" or \"SUCCESS AND FAILURE\",\nthis is a finding.",
        "fix": "Where SQL Server Trace is in use, implement tracking of SELECTs\non designated tables at the application level, using the system stored\nprocedure sp_trace_generateevent to write the tracking records to the Trace\nused for audit purposes.\n\nCreate triggers to raise a custom event on each table that requires tracking of\nInsert-Update-Delete operations.  The examples provided in the supplemental\nfile CustomTraceEvents.sql can serve as the basis for these.\n\nAdd a block of code to the supplemental file Trace.sql for each custom event\nclass (integers in the range 82-91; the same event class may be used for all\nsuch triggers) used in these triggers.\n\nEnsure that Trace.sql includes blocks of code for event classes 42, 43, and 162.\n\nExecute Trace.sql.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all\nauditable events and data items.  The script provided in the supplemental file\nAudit.sql can be used as the basis for this.  Supplement the standard audit\ndata as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO"
      },
      "code": "control 'V-67425' do\n  title \"SQL Server must generate Trace or Audit records when successful\naccesses to designated objects occur.\"\n  desc  \"Without tracking all or selected types of access to all or selected\nobjects (tables, views, procedures, functions, etc.), it would be difficult to\nestablish, correlate, and investigate the events relating to an incident, or\nidentify those responsible for one.\n\n    Types of access include, but are not necessarily limited to:\n    SELECT\n    INSERT\n    UPDATE\n    DELETE\n    EXECUTE\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    Trace does not offer tracking of SELECT operations, so where this is\nrequired it must be implemented at the application level.\n  \"\n  impact 0.5\n  tag \"gtitle\": 'SRG-APP-000507-DB-000356'\n  tag \"gid\": 'V-67425'\n  tag \"rid\": 'SV-81915r3_rule'\n  tag \"stig_id\": 'SQL4-00-038100'\n  tag \"fix_id\": 'F-73539r1_fix'\n  tag \"cci\": ['CCI-000172']\n  tag \"nist\": ['AU-12 c', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"If neither SQL Server Audit nor SQL Server Trace is in use for\naudit purposes, this is a finding.\n\nObtain the list of objects (tables and stored procedures) where tracking of\nSELECT, INSERT, UPDATE, DELETE, or EXECUTE actions is required.  If there are\nnone, this is not a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the application(s)\nusing the database to verify that all SELECT actions on categorized data are\nbeing audited, and that the tracking records are written to the SQL Server\nTrace used for audit purposes.  If not, this is a finding.\n\nReview the designated tables for the existence of triggers to raise a custom\nevent on each Insert-Update-Delete operation.\n\nIf such triggers are not present, this is a finding.\n\nCheck to see that all required event classes are being audited.  From the query\nprompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no\ntraces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing\nrequirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is\na finding:\n\n42  -- SP:Starting\n43  -- SP:Completed\n82-91  -- User-defined Event (at least one of these; 90 is used in the supplied\nscript)\n162 -- User error message\n\nIf SQL Server Audit is in use, verify that execution of all SELECT, INSERT,\nUPDATE, DELETE, or EXECUTE actions on the designated objects, is audited,.\n\nIf any such actions are not audited, this is a finding.\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the server-level audit action group SCHEMA_OBJECT_ACCESS_GROUP\nfor this purpose.  SQL Server Audit's flexibility makes other techniques\npossible.  If an alternative technique is in use and demonstrated effective,\nthis is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\n\nAlternatively, review the contents of the system views with \\\"audit\\\" in their\nnames.\n\nRun the following to verify that all logons and connections are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\nGO\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \\\"SUCCESS\\\" or \\\"SUCCESS AND FAILURE\\\",\nthis is a finding.\"\n  tag \"fix\": \"Where SQL Server Trace is in use, implement tracking of SELECTs\non designated tables at the application level, using the system stored\nprocedure sp_trace_generateevent to write the tracking records to the Trace\nused for audit purposes.\n\nCreate triggers to raise a custom event on each table that requires tracking of\nInsert-Update-Delete operations.  The examples provided in the supplemental\nfile CustomTraceEvents.sql can serve as the basis for these.\n\nAdd a block of code to the supplemental file Trace.sql for each custom event\nclass (integers in the range 82-91; the same event class may be used for all\nsuch triggers) used in these triggers.\n\nEnsure that Trace.sql includes blocks of code for event classes 42, 43, and 162.\n\nExecute Trace.sql.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all\nauditable events and data items.  The script provided in the supplemental file\nAudit.sql can be used as the basis for this.  Supplement the standard audit\ndata as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO\"\n\n  query_traces = %{\n    SELECT * FROM sys.traces\n  }\n  query_trace_eventinfo = %{\n    SELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(%<trace_id>s);\n  }\n\n  query_audits = %{\n    SELECT server_specification_id,\n           audit_action_name,\n           audited_result\n    FROM   sys.server_audit_specification_details\n    WHERE  audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n  }\n\n  server_trace_implemented = attribute('server_trace_implemented')\n  server_audit_implemented = attribute('server_audit_implemented')\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n\n  describe.one do\n    describe 'SQL Server Trace is in use for audit purposes' do\n      subject { server_trace_implemented }\n      it { should be true }\n    end\n\n    describe 'SQL Server Audit is in use for audit purposes' do\n      subject { server_audit_implemented }\n      it { should be true }\n    end\n  end\n\n  if server_trace_implemented\n    describe 'List defined traces for the SQL server instance' do\n      subject { sql_session.query(query_traces) }\n      it { should_not be_empty }\n    end\n\n    trace_ids = sql_session.query(query_traces).column('id')\n    describe.one do\n      trace_ids.each do |trace_id|\n        found_events = sql_session.query(format(query_trace_eventinfo, trace_id: trace_id)).column('eventid')\n        describe \"EventsIDs in Trace ID:#{trace_id}\" do\n          subject { found_events }\n          it { should include '42' }\n          it { should include '43' }\n          its('to_s') { should match /\"82\"|\"83\"|\"84\"|\"85\"|\"86\"|\"87\"|\"88\"|\"89\"|\"90\"|\"91\"/ }\n          it { should include '162' }\n        end\n      end\n    end\n  end\n\n  if server_audit_implemented\n    describe 'SQL Server Audit:' do\n      describe 'Defined Audits with Audit Action SCHEMA_OBJECT_ACCESS_GROUP' do\n        subject { sql_session.query(query_audits) }\n        it { should_not be_empty }\n      end\n      describe 'Audited Result for Defined Audit Actions' do\n        subject { sql_session.query(query_audits).column('audited_result').uniq.to_s }\n        it { should match /SUCCESS AND FAILURE|SUCCESS/ }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67425.rb",
        "line": 1
      },
      "id": "V-67425"
    },
    {
      "title": "Trace or Audit records must be generated when categorized information\n(e.g., classification levels/security levels) is created.",
      "desc": "Changes in categorized information must be tracked. Without an audit\ntrail, unauthorized access to protected data could go undetected.\n\n    For detailed information on categorizing information, refer to FIPS\nPublication 199, Standards for Security Categorization of Federal Information\nand Information Systems, and FIPS Publication 200, Minimum Security\nRequirements for Federal Information and Information Systems.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    Since Trace does not provide for tracking SELECT statements, it is\nnecessary to provide that part of the tracking at the application level.\nBecause of this, it may also be appropriate to audit INSERT actions at the\napplication level.  However, to capture all INSERTs, whether they come from the\napplication or bypass it, the Trace must be configured to cover them.",
      "descriptions": {
        "default": "Changes in categorized information must be tracked. Without an audit\ntrail, unauthorized access to protected data could go undetected.\n\n    For detailed information on categorizing information, refer to FIPS\nPublication 199, Standards for Security Categorization of Federal Information\nand Information Systems, and FIPS Publication 200, Minimum Security\nRequirements for Federal Information and Information Systems.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    Since Trace does not provide for tracking SELECT statements, it is\nnecessary to provide that part of the tracking at the application level.\nBecause of this, it may also be appropriate to audit INSERT actions at the\napplication level.  However, to capture all INSERTs, whether they come from the\napplication or bypass it, the Trace must be configured to cover them."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000498-DB-000346",
        "gid": "V-67437",
        "rid": "SV-81927r2_rule",
        "stig_id": "SQL4-00-036600",
        "fix_id": "F-73551r1_fix",
        "cci": [
          "CCI-000172"
        ],
        "nist": [
          "AU-12 c",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "Review the system documentation to determine whether it is\nrequired to track categories of information, such as classification or\nsensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes,\nthis is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the Trace settings,\nand the triggers on the tables holding categorized information, to determine\nwhether all INSERT actions on these tables are traced, including failed\nattempts.  If not, this is a finding.\n\nCheck to see that all required event classes are being audited.  From the query\nprompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no\ntraces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing\nrequirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is\na finding:\n\n82-91  -- User-defined Event (at least one of these, matching the triggers; 90\nis used in the supplied script)\n162 -- User error message\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the broad, server-level audit action group\nSCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility\nmakes other techniques possible.  If an alternative technique is in use and\ndemonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their\nnames.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions\non tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"SUCCESS\" or \"SUCCESS AND FAILURE\",\nthis is a finding.",
        "fix": "Where SQL Server Trace is in use, create triggers to raise a\ncustom event for INSERTs on each table holding categorized information.  The\nexamples provided in the supplemental file CustomTraceEvents.sql can serve as\nthe basis for these.\n\nAdd a block of code to the supplemental file Trace.sql for each custom event\nclass (integers in the range 82-91; the same event class may be used for all\nsuch triggers) used in these triggers.  Execute Trace.sql.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all\nauditable events and data items.  The script provided in the supplemental file\nAudit.sql can be used as the basis for this.  Supplement the standard audit\ndata as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO"
      },
      "code": "control 'V-67437' do\n  title \"Trace or Audit records must be generated when categorized information\n(e.g., classification levels/security levels) is created.\"\n  desc  \"Changes in categorized information must be tracked. Without an audit\ntrail, unauthorized access to protected data could go undetected.\n\n    For detailed information on categorizing information, refer to FIPS\nPublication 199, Standards for Security Categorization of Federal Information\nand Information Systems, and FIPS Publication 200, Minimum Security\nRequirements for Federal Information and Information Systems.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    Since Trace does not provide for tracking SELECT statements, it is\nnecessary to provide that part of the tracking at the application level.\nBecause of this, it may also be appropriate to audit INSERT actions at the\napplication level.  However, to capture all INSERTs, whether they come from the\napplication or bypass it, the Trace must be configured to cover them.\n  \"\n  if attribute('server_trace_or_audit_required')\n    impact 0.5\n  else\n    impact 0.0\n    desc 'Inspec attributes has specified that is not required to track categories\n    of information, such as classification or sensitivity level on the target'\n  end\n\n  tag \"gtitle\": 'SRG-APP-000498-DB-000346'\n  tag \"gid\": 'V-67437'\n  tag \"rid\": 'SV-81927r2_rule'\n  tag \"stig_id\": 'SQL4-00-036600'\n  tag \"fix_id\": 'F-73551r1_fix'\n  tag \"cci\": ['CCI-000172']\n  tag \"nist\": ['AU-12 c', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"Review the system documentation to determine whether it is\nrequired to track categories of information, such as classification or\nsensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes,\nthis is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the Trace settings,\nand the triggers on the tables holding categorized information, to determine\nwhether all INSERT actions on these tables are traced, including failed\nattempts.  If not, this is a finding.\n\nCheck to see that all required event classes are being audited.  From the query\nprompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no\ntraces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing\nrequirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is\na finding:\n\n82-91  -- User-defined Event (at least one of these, matching the triggers; 90\nis used in the supplied script)\n162 -- User error message\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the broad, server-level audit action group\nSCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility\nmakes other techniques possible.  If an alternative technique is in use and\ndemonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\n\nAlternatively, review the contents of the system views with \\\"audit\\\" in their\nnames.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions\non tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \\\"SUCCESS\\\" or \\\"SUCCESS AND FAILURE\\\",\nthis is a finding.\"\n  tag \"fix\": \"Where SQL Server Trace is in use, create triggers to raise a\ncustom event for INSERTs on each table holding categorized information.  The\nexamples provided in the supplemental file CustomTraceEvents.sql can serve as\nthe basis for these.\n\nAdd a block of code to the supplemental file Trace.sql for each custom event\nclass (integers in the range 82-91; the same event class may be used for all\nsuch triggers) used in these triggers.  Execute Trace.sql.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all\nauditable events and data items.  The script provided in the supplemental file\nAudit.sql can be used as the basis for this.  Supplement the standard audit\ndata as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO\"\n\n  query_traces = %{\n    SELECT * FROM sys.traces\n  }\n  query_trace_eventinfo = %{\n    SELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(%<trace_id>s);\n  }\n\n  query_audits = %{\n    SELECT server_specification_id,\n           audit_action_name,\n           audited_result\n    FROM   sys.server_audit_specification_details\n    WHERE  audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n  }\n\n  server_trace_implemented = attribute('server_trace_implemented')\n  server_audit_implemented = attribute('server_audit_implemented')\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n\n  describe.one do\n    describe 'SQL Server Trace is in use for audit purposes' do\n      subject { server_trace_implemented }\n      it { should be true }\n    end\n\n    describe 'SQL Server Audit is in use for audit purposes' do\n      subject { server_audit_implemented }\n      it { should be true }\n    end\n  end\n\n  if server_trace_implemented\n    describe 'List defined traces for the SQL server instance' do\n      subject { sql_session.query(query_traces) }\n      it { should_not be_empty }\n    end\n\n    trace_ids = sql_session.query(query_traces).column('id')\n    describe.one do\n      trace_ids.each do |trace_id|\n        found_events = sql_session.query(format(query_trace_eventinfo, trace_id: trace_id)).column('eventid')\n        describe \"EventsIDs in Trace ID:#{trace_id}\" do\n          subject { found_events }\n          its('to_s') { should match /\"82\"|\"83\"|\"84\"|\"85\"|\"86\"|\"87\"|\"88\"|\"89\"|\"90\"|\"91\"/ }\n          it { should include '162' }\n        end\n      end\n    end\n  end\n\n  if server_audit_implemented\n    describe 'SQL Server Audit:' do\n      describe 'Defined Audits with Audit Action SCHEMA_OBJECT_ACCESS_GROUP' do\n        subject { sql_session.query(query_audits) }\n        it { should_not be_empty }\n      end\n      describe 'Audited Result for Defined Audit Actions' do\n        subject { sql_session.query(query_audits).column('audited_result').uniq.to_s }\n        it { should match /SUCCESS AND FAILURE|SUCCESS/ }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67437.rb",
        "line": 1
      },
      "id": "V-67437"
    },
    {
      "title": "SQL Server must generate Trace or Audit records when locally-defined\nsecurity objects are dropped.",
      "desc": "SQL Server protects its built-in security objects (tables, views,\nfunctions, procedures, etc.) from alteration by database users and\nadministrators.  However, applications sometimes have additional,\nsecurity-related objects defined in the database.  DROP operations on these\nobjects must be monitored.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.",
      "descriptions": {
        "default": "SQL Server protects its built-in security objects (tables, views,\nfunctions, procedures, etc.) from alteration by database users and\nadministrators.  However, applications sometimes have additional,\nsecurity-related objects defined in the database.  DROP operations on these\nobjects must be monitored.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000501-DB-000336",
        "gid": "V-67433",
        "rid": "SV-81923r3_rule",
        "stig_id": "SQL4-00-037100",
        "fix_id": "F-73547r2_fix",
        "cci": [
          "CCI-000172"
        ],
        "nist": [
          "AU-12 c",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "If neither SQL Server Audit nor SQL Server Trace is in use for\naudit purposes, this is a finding.\n\nIf there are no locally-defined security tables or procedures, this is not a\nfinding.\n\nIf SQL Server Trace is in use for audit purposes, verify that all required\nevents are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\nAll currently defined traces for the SQL server instance will be listed.\n\nIf no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing\nrequirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should all be among those listed; if not, this\nis a finding:\n\n46  -- Object:Created\n47  -- Object:Deleted\n162  -- User error message\n164 -- Object:Altered\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the broad, server-level audit action group\nSCHEMA_OBJECT_CHANGE_GROUP for this purpose.  SQL Server Audit's flexibility\nmakes other techniques possible.  If an alternative technique is in use and\ndemonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their\nnames.\n\nRun the following to verify that all CREATE, ALTER, and DROP actions on any\nlocally-defined permissions tables, procedures and functions are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_CHANGE_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"SUCCESS\" or \"SUCCESS AND FAILURE\",\nthis is a finding.",
        "fix": "Where SQL Server Trace is in use, define  and enable a trace that\ncaptures all auditable events.  The script provided in the supplemental file\nTrace.sql can be used to do this.\n\nAdd blocks of code to Trace.sql for each custom event class (integers in the\nrange 82-91; the same event class may be used for all such triggers) used in\nthese triggers.\n\nCreate triggers to raise a custom event on each locally-defined security table\nthat requires tracking of Insert-Update-Delete operations.  The examples\nprovided in the supplemental file CustomTraceEvents.sql can serve as the basis\nfor these.\n\nExecute Trace.sql.\n\nWhere SQL Server Audit is in use, design and deploy a SQL Server Audit that\ncaptures all auditable events.  The script provided in the supplemental file\nAudit.sql can be used for this.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_CHANGE_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO"
      },
      "code": "control 'V-67433' do\n  title \"SQL Server must generate Trace or Audit records when locally-defined\nsecurity objects are dropped.\"\n  desc  \"SQL Server protects its built-in security objects (tables, views,\nfunctions, procedures, etc.) from alteration by database users and\nadministrators.  However, applications sometimes have additional,\nsecurity-related objects defined in the database.  DROP operations on these\nobjects must be monitored.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n  \"\n  impact 0.5\n  tag \"gtitle\": 'SRG-APP-000501-DB-000336'\n  tag \"gid\": 'V-67433'\n  tag \"rid\": 'SV-81923r3_rule'\n  tag \"stig_id\": 'SQL4-00-037100'\n  tag \"fix_id\": 'F-73547r2_fix'\n  tag \"cci\": ['CCI-000172']\n  tag \"nist\": ['AU-12 c', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"If neither SQL Server Audit nor SQL Server Trace is in use for\naudit purposes, this is a finding.\n\nIf there are no locally-defined security tables or procedures, this is not a\nfinding.\n\nIf SQL Server Trace is in use for audit purposes, verify that all required\nevents are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\nAll currently defined traces for the SQL server instance will be listed.\n\nIf no traces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing\nrequirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should all be among those listed; if not, this\nis a finding:\n\n46  -- Object:Created\n47  -- Object:Deleted\n162  -- User error message\n164 -- Object:Altered\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the broad, server-level audit action group\nSCHEMA_OBJECT_CHANGE_GROUP for this purpose.  SQL Server Audit's flexibility\nmakes other techniques possible.  If an alternative technique is in use and\ndemonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\n\nAlternatively, review the contents of the system views with \\\"audit\\\" in their\nnames.\n\nRun the following to verify that all CREATE, ALTER, and DROP actions on any\nlocally-defined permissions tables, procedures and functions are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_CHANGE_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \\\"SUCCESS\\\" or \\\"SUCCESS AND FAILURE\\\",\nthis is a finding.\"\n  tag \"fix\": \"Where SQL Server Trace is in use, define  and enable a trace that\ncaptures all auditable events.  The script provided in the supplemental file\nTrace.sql can be used to do this.\n\nAdd blocks of code to Trace.sql for each custom event class (integers in the\nrange 82-91; the same event class may be used for all such triggers) used in\nthese triggers.\n\nCreate triggers to raise a custom event on each locally-defined security table\nthat requires tracking of Insert-Update-Delete operations.  The examples\nprovided in the supplemental file CustomTraceEvents.sql can serve as the basis\nfor these.\n\nExecute Trace.sql.\n\nWhere SQL Server Audit is in use, design and deploy a SQL Server Audit that\ncaptures all auditable events.  The script provided in the supplemental file\nAudit.sql can be used for this.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_CHANGE_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO\"\n  query_traces = %{\n    SELECT * FROM sys.traces\n  }\n  query_trace_eventinfo = %{\n    SELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(%<trace_id>s);\n  }\n\n  query_audits = %{\n    SELECT server_specification_id,\n           audit_action_name,\n           audited_result\n    FROM   sys.server_audit_specification_details\n    WHERE  audit_action_name = 'SCHEMA_OBJECT_CHANGE_GROUP';\n  }\n  server_trace_implemented = attribute('server_trace_implemented')\n  server_audit_implemented = attribute('server_audit_implemented')\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n\n  describe.one do\n    describe 'SQL Server Trace is in use for audit purposes' do\n      subject { server_trace_implemented }\n      it { should be true }\n    end\n\n    describe 'SQL Server Audit is in use for audit purposes' do\n      subject { server_audit_implemented }\n      it { should be true }\n    end\n  end\n\n  if server_trace_implemented\n    describe 'List defined traces for the SQL server instance' do\n      subject { sql_session.query(query_traces) }\n      it { should_not be_empty }\n    end\n\n    trace_ids = sql_session.query(query_traces).column('id')\n    describe.one do\n      trace_ids.each do |trace_id|\n        found_events = sql_session.query(format(query_trace_eventinfo, trace_id: trace_id)).column('eventid')\n        describe \"EventsIDs in Trace ID:#{trace_id}\" do\n          subject { found_events }\n          it { should include '46' }\n          it { should include '47' }\n          it { should include '162' }\n          it { should include '164' }\n        end\n      end\n    end\n  end\n\n  if server_audit_implemented\n    describe 'SQL Server Audit:' do\n      describe 'Defined Audits with Audit Action SCHEMA_OBJECT_CHANGE_GROUP' do\n        subject { sql_session.query(query_audits) }\n        it { should_not be_empty }\n      end\n      describe 'Audited Result for Defined Audit Actions' do\n        subject { sql_session.query(query_audits).column('audited_result').uniq.to_s }\n        it { should match /SUCCESS AND FAILURE|SUCCESS/ }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67433.rb",
        "line": 1
      },
      "id": "V-67433"
    },
    {
      "title": "When supporting applications that require security labeling of data,\nSQL Server must associate organization-defined types of security labels having\norganization-defined security label values with information in process.",
      "desc": "Without the association of security labels to information, there is no\nbasis for the DBMS to make security-related access-control decisions.\n\n    Security labels are abstractions representing the basic properties or\ncharacteristics of an entity (e.g., subjects and objects) with respect to\nsafeguarding information.\n\n    These labels are typically associated with internal data structures (e.g.,\ntables, rows) within the database and are used to enable the implementation of\naccess control and flow control policies, reflect special dissemination,\nhandling or distribution instructions, or support other aspects of the\ninformation security policy.\n\n    One example includes marking data as classified or FOUO. These security\nlabels may be assigned manually or during data processing, but, either way, it\nis imperative these assignments are maintained while the data is in storage. If\nthe security labels are lost when the data is stored, there is the risk of a\ndata compromise.\n\n    SQL Server does not include security labeling as a standard or licensable\nfeature. Earlier releases of this STIG suggested using the SQL Server Label\nSecurity Toolkit, from codeplex.com.  However, codeplex.com has been shut down,\nand it is unclear whether the Toolkit is still supported.  If the organization\ndoes have access to the Toolkit, it may still be used, provided the\norganization accepts responsibility for its support.  Other implementations may\nalso exist. Custom application code is also a viable way to implement a\nsolution.",
      "descriptions": {
        "default": "Without the association of security labels to information, there is no\nbasis for the DBMS to make security-related access-control decisions.\n\n    Security labels are abstractions representing the basic properties or\ncharacteristics of an entity (e.g., subjects and objects) with respect to\nsafeguarding information.\n\n    These labels are typically associated with internal data structures (e.g.,\ntables, rows) within the database and are used to enable the implementation of\naccess control and flow control policies, reflect special dissemination,\nhandling or distribution instructions, or support other aspects of the\ninformation security policy.\n\n    One example includes marking data as classified or FOUO. These security\nlabels may be assigned manually or during data processing, but, either way, it\nis imperative these assignments are maintained while the data is in storage. If\nthe security labels are lost when the data is stored, there is the risk of a\ndata compromise.\n\n    SQL Server does not include security labeling as a standard or licensable\nfeature. Earlier releases of this STIG suggested using the SQL Server Label\nSecurity Toolkit, from codeplex.com.  However, codeplex.com has been shut down,\nand it is unclear whether the Toolkit is still supported.  If the organization\ndoes have access to the Toolkit, it may still be used, provided the\norganization accepts responsibility for its support.  Other implementations may\nalso exist. Custom application code is also a viable way to implement a\nsolution."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000313-DB-000309",
        "gid": "V-67403",
        "rid": "SV-81893r2_rule",
        "stig_id": "SQL4-00-032000",
        "fix_id": "F-73515r2_fix",
        "cci": [
          "CCI-002263"
        ],
        "nist": [
          "AC-16 a",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "If security labeling is not required, this is not a finding.\n\nIf security labeling requirements have been specified, but the security\nlabeling is not implemented or does not reliably maintain labels on information\nin process, this is a finding.",
        "fix": "Develop SQL or application code or acquire a third party tool to\nperform data labeling."
      },
      "code": "control 'V-67403' do\n  title \"When supporting applications that require security labeling of data,\nSQL Server must associate organization-defined types of security labels having\norganization-defined security label values with information in process.\"\n  desc  \"Without the association of security labels to information, there is no\nbasis for the DBMS to make security-related access-control decisions.\n\n    Security labels are abstractions representing the basic properties or\ncharacteristics of an entity (e.g., subjects and objects) with respect to\nsafeguarding information.\n\n    These labels are typically associated with internal data structures (e.g.,\ntables, rows) within the database and are used to enable the implementation of\naccess control and flow control policies, reflect special dissemination,\nhandling or distribution instructions, or support other aspects of the\ninformation security policy.\n\n    One example includes marking data as classified or FOUO. These security\nlabels may be assigned manually or during data processing, but, either way, it\nis imperative these assignments are maintained while the data is in storage. If\nthe security labels are lost when the data is stored, there is the risk of a\ndata compromise.\n\n    SQL Server does not include security labeling as a standard or licensable\nfeature. Earlier releases of this STIG suggested using the SQL Server Label\nSecurity Toolkit, from codeplex.com.  However, codeplex.com has been shut down,\nand it is unclear whether the Toolkit is still supported.  If the organization\ndoes have access to the Toolkit, it may still be used, provided the\norganization accepts responsibility for its support.  Other implementations may\nalso exist. Custom application code is also a viable way to implement a\nsolution.\n  \"\n  if attribute('security_labeling_required')\n    impact 0.5\n  else\n    impact 0.0\n    desc 'Security labeling is stated as `not required` in the attributes file,\n    this control is not applicable'\n  end\n\n  tag \"gtitle\": 'SRG-APP-000313-DB-000309'\n  tag \"gid\": 'V-67403'\n  tag \"rid\": 'SV-81893r2_rule'\n  tag \"stig_id\": 'SQL4-00-032000'\n  tag \"fix_id\": 'F-73515r2_fix'\n  tag \"cci\": ['CCI-002263']\n  tag \"nist\": ['AC-16 a', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"If security labeling is not required, this is not a finding.\n\nIf security labeling requirements have been specified, but the security\nlabeling is not implemented or does not reliably maintain labels on information\nin process, this is a finding.\"\n  tag \"fix\": \"Develop SQL or application code or acquire a third party tool to\nperform data labeling.\"\n\n  describe 'This test currently has no automated tests, you must check manually' do\n    skip 'This check must be preformed manually'\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67403.rb",
        "line": 1
      },
      "id": "V-67403"
    },
    {
      "title": "Trace or Audit records must be generated when unsuccessful attempts to\ncreate categorized information (e.g., classification levels/security levels)\noccur.",
      "desc": "Changes in categorized information must be tracked. Without an audit\ntrail, unauthorized access to protected data could go undetected.\n\n    To aid in diagnosis, it is necessary to keep track of failed attempts in\naddition to the successful ones.\n\n    For detailed information on categorizing information, refer to FIPS\nPublication 199, Standards for Security Categorization of Federal Information\nand Information Systems, and FIPS Publication 200, Minimum Security\nRequirements for Federal Information and Information Systems.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    Since Trace does not provide for tracking SELECT statements, it is\nnecessary to provide that part of the tracking at the application level.\nBecause of this, it may also be appropriate to audit INSERT actions at the\napplication level.  However, to capture all INSERTs, whether they come from the\napplication or bypass it, the Trace must be configured to cover them.\n\n    Use of SQL Server Audit's SCHEMA_OBJECT_ACCESS_GROUP causes capture of all\naccesses, successful and otherwise, to all schema-scoped objects.  The\n[Succeeded] column in the audit output indicates the success or failure of the\nattempted action.  Be aware, however, that it may report True in some cases\nwhere one would intuitively expect False; and some other actions that one would\nconsider failures (such as selecting from a table that does not exist) may not\nappear at all.",
      "descriptions": {
        "default": "Changes in categorized information must be tracked. Without an audit\ntrail, unauthorized access to protected data could go undetected.\n\n    To aid in diagnosis, it is necessary to keep track of failed attempts in\naddition to the successful ones.\n\n    For detailed information on categorizing information, refer to FIPS\nPublication 199, Standards for Security Categorization of Federal Information\nand Information Systems, and FIPS Publication 200, Minimum Security\nRequirements for Federal Information and Information Systems.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    Since Trace does not provide for tracking SELECT statements, it is\nnecessary to provide that part of the tracking at the application level.\nBecause of this, it may also be appropriate to audit INSERT actions at the\napplication level.  However, to capture all INSERTs, whether they come from the\napplication or bypass it, the Trace must be configured to cover them.\n\n    Use of SQL Server Audit's SCHEMA_OBJECT_ACCESS_GROUP causes capture of all\naccesses, successful and otherwise, to all schema-scoped objects.  The\n[Succeeded] column in the audit output indicates the success or failure of the\nattempted action.  Be aware, however, that it may report True in some cases\nwhere one would intuitively expect False; and some other actions that one would\nconsider failures (such as selecting from a table that does not exist) may not\nappear at all."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000498-DB-000347",
        "gid": "V-67439",
        "rid": "SV-81929r2_rule",
        "stig_id": "SQL4-00-036800",
        "fix_id": "F-73553r1_fix",
        "cci": [
          "CCI-000172"
        ],
        "nist": [
          "AU-12 c",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "Review the system documentation to determine whether it is\nrequired to track categories of information, such as classification or\nsensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes,\nthis is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the Trace settings,\nand the triggers on the tables holding categorized information, to determine\nwhether all INSERT actions on these tables are traced, including failed\nattempts.  If not, this is a finding.\n\nCheck to see that all required event classes are being audited.  From the query\nprompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no\ntraces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing\nrequirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is\na finding:\n\n82-91  -- User-defined Event (at least one of these, matching the triggers; 90\nis used in the supplied script)\n162 -- User error message\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the broad, server-level audit action group\nSCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility\nmakes other techniques possible.  If an alternative technique is in use and\ndemonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their\nnames.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions\non tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"FAILURE\" or \"SUCCESS AND FAILURE\",\nthis is a finding.",
        "fix": "Where SQL Server Trace is in use, create triggers to raise a\ncustom event for INSERTs on each table holding categorized information.  The\nexamples provided in the supplemental file CustomTraceEvents.sql can serve as\nthe basis for these.\n\nAdd a block of code to the supplemental file Trace.sql for each custom event\nclass (integers in the range 82-91; the same event class may be used for all\nsuch triggers) used in these triggers.  Execute Trace.sql.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all\nauditable events and data items.  The script provided in the supplemental file\nAudit.sql can be used as the basis for this.  Supplement the standard audit\ndata as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO"
      },
      "code": "control 'V-67439' do\n  title \"Trace or Audit records must be generated when unsuccessful attempts to\ncreate categorized information (e.g., classification levels/security levels)\noccur.\"\n  desc  \"Changes in categorized information must be tracked. Without an audit\ntrail, unauthorized access to protected data could go undetected.\n\n    To aid in diagnosis, it is necessary to keep track of failed attempts in\naddition to the successful ones.\n\n    For detailed information on categorizing information, refer to FIPS\nPublication 199, Standards for Security Categorization of Federal Information\nand Information Systems, and FIPS Publication 200, Minimum Security\nRequirements for Federal Information and Information Systems.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    Since Trace does not provide for tracking SELECT statements, it is\nnecessary to provide that part of the tracking at the application level.\nBecause of this, it may also be appropriate to audit INSERT actions at the\napplication level.  However, to capture all INSERTs, whether they come from the\napplication or bypass it, the Trace must be configured to cover them.\n\n    Use of SQL Server Audit's SCHEMA_OBJECT_ACCESS_GROUP causes capture of all\naccesses, successful and otherwise, to all schema-scoped objects.  The\n[Succeeded] column in the audit output indicates the success or failure of the\nattempted action.  Be aware, however, that it may report True in some cases\nwhere one would intuitively expect False; and some other actions that one would\nconsider failures (such as selecting from a table that does not exist) may not\nappear at all.\n  \"\n  if attribute('server_trace_or_audit_required')\n    impact 0.5\n  else\n    impact 0.0\n    desc 'Inspec attributes has specified that is not required to track categories\n    of information, such as classification or sensitivity level on the target'\n  end\n\n  tag \"gtitle\": 'SRG-APP-000498-DB-000347'\n  tag \"gid\": 'V-67439'\n  tag \"rid\": 'SV-81929r2_rule'\n  tag \"stig_id\": 'SQL4-00-036800'\n  tag \"fix_id\": 'F-73553r1_fix'\n  tag \"cci\": ['CCI-000172']\n  tag \"nist\": ['AU-12 c', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"Review the system documentation to determine whether it is\nrequired to track categories of information, such as classification or\nsensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes,\nthis is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the Trace settings,\nand the triggers on the tables holding categorized information, to determine\nwhether all INSERT actions on these tables are traced, including failed\nattempts.  If not, this is a finding.\n\nCheck to see that all required event classes are being audited.  From the query\nprompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no\ntraces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing\nrequirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is\na finding:\n\n82-91  -- User-defined Event (at least one of these, matching the triggers; 90\nis used in the supplied script)\n162 -- User error message\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the broad, server-level audit action group\nSCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility\nmakes other techniques possible.  If an alternative technique is in use and\ndemonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\n\nAlternatively, review the contents of the system views with \\\"audit\\\" in their\nnames.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions\non tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \\\"FAILURE\\\" or \\\"SUCCESS AND FAILURE\\\",\nthis is a finding.\"\n  tag \"fix\": \"Where SQL Server Trace is in use, create triggers to raise a\ncustom event for INSERTs on each table holding categorized information.  The\nexamples provided in the supplemental file CustomTraceEvents.sql can serve as\nthe basis for these.\n\nAdd a block of code to the supplemental file Trace.sql for each custom event\nclass (integers in the range 82-91; the same event class may be used for all\nsuch triggers) used in these triggers.  Execute Trace.sql.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all\nauditable events and data items.  The script provided in the supplemental file\nAudit.sql can be used as the basis for this.  Supplement the standard audit\ndata as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO\"\n\n  query_traces = %{\n    SELECT * FROM sys.traces\n  }\n  query_trace_eventinfo = %{\n    SELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(%<trace_id>s);\n  }\n\n  query_audits = %{\n    SELECT server_specification_id,\n           audit_action_name,\n           audited_result\n    FROM   sys.server_audit_specification_details\n    WHERE  audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n  }\n\n  server_trace_implemented = attribute('server_trace_implemented')\n  server_audit_implemented = attribute('server_audit_implemented')\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n\n  describe.one do\n    describe 'SQL Server Trace is in use for audit purposes' do\n      subject { server_trace_implemented }\n      it { should be true }\n    end\n\n    describe 'SQL Server Audit is in use for audit purposes' do\n      subject { server_audit_implemented }\n      it { should be true }\n    end\n  end\n\n  if server_trace_implemented\n    describe 'List defined traces for the SQL server instance' do\n      subject { sql_session.query(query_traces) }\n      it { should_not be_empty }\n    end\n\n    trace_ids = sql_session.query(query_traces).column('id')\n    describe.one do\n      trace_ids.each do |trace_id|\n        found_events = sql_session.query(format(query_trace_eventinfo, trace_id: trace_id)).column('eventid')\n        describe \"EventsIDs in Trace ID:#{trace_id}\" do\n          subject { found_events }\n          its('to_s') { should match /\"82\"|\"83\"|\"84\"|\"85\"|\"86\"|\"87\"|\"88\"|\"89\"|\"90\"|\"91\"/ }\n          it { should include '162' }\n        end\n      end\n    end\n  end\n\n  if server_audit_implemented\n    describe 'SQL Server Audit:' do\n      describe 'Defined Audits with Audit Action SCHEMA_OBJECT_ACCESS_GROUP' do\n        subject { sql_session.query(query_audits) }\n        it { should_not be_empty }\n      end\n      describe 'Audited Result for Defined Audit Actions' do\n        subject { sql_session.query(query_audits).column('audited_result').uniq.to_s }\n        it { should match /SUCCESS AND FAILURE|FAILURE/ }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67439.rb",
        "line": 1
      },
      "id": "V-67439"
    },
    {
      "title": "When supporting applications that require security labeling of data,\nSQL Server must associate organization-defined types of security labels having\norganization-defined security label values with information in transmission.",
      "desc": "Without the association of security labels to information, there is no\nbasis for the DBMS to make security-related access-control decisions.\n\n    Security labels are abstractions representing the basic properties or\ncharacteristics of an entity (e.g., subjects and objects) with respect to\nsafeguarding information.\n\n    These labels are typically associated with internal data structures (e.g.,\ntables, rows) within the database and are used to enable the implementation of\naccess control and flow control policies, reflect special dissemination,\nhandling or distribution instructions, or support other aspects of the\ninformation security policy.\n\n    One example includes marking data as classified or FOUO. These security\nlabels may be assigned manually or during data processing, but, either way, it\nis imperative these assignments are maintained while the data is in storage. If\nthe security labels are lost when the data is stored, there is the risk of a\ndata compromise.\n\n    SQL Server does not include security labeling as a standard or licensable\nfeature. Earlier releases of this STIG suggested using the SQL Server Label\nSecurity Toolkit, from codeplex.com.  However, codeplex.com has been shut down,\nand it is unclear whether the Toolkit is still supported.  If the organization\ndoes have access to the Toolkit, it may still be used, provided the\norganization accepts responsibility for its support.  Other implementations may\nalso exist. Custom application code is also a viable way to implement a\nsolution.",
      "descriptions": {
        "default": "Without the association of security labels to information, there is no\nbasis for the DBMS to make security-related access-control decisions.\n\n    Security labels are abstractions representing the basic properties or\ncharacteristics of an entity (e.g., subjects and objects) with respect to\nsafeguarding information.\n\n    These labels are typically associated with internal data structures (e.g.,\ntables, rows) within the database and are used to enable the implementation of\naccess control and flow control policies, reflect special dissemination,\nhandling or distribution instructions, or support other aspects of the\ninformation security policy.\n\n    One example includes marking data as classified or FOUO. These security\nlabels may be assigned manually or during data processing, but, either way, it\nis imperative these assignments are maintained while the data is in storage. If\nthe security labels are lost when the data is stored, there is the risk of a\ndata compromise.\n\n    SQL Server does not include security labeling as a standard or licensable\nfeature. Earlier releases of this STIG suggested using the SQL Server Label\nSecurity Toolkit, from codeplex.com.  However, codeplex.com has been shut down,\nand it is unclear whether the Toolkit is still supported.  If the organization\ndoes have access to the Toolkit, it may still be used, provided the\norganization accepts responsibility for its support.  Other implementations may\nalso exist. Custom application code is also a viable way to implement a\nsolution."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000314-DB-000310",
        "gid": "V-67405",
        "rid": "SV-81895r2_rule",
        "stig_id": "SQL4-00-032100",
        "fix_id": "F-73517r3_fix",
        "cci": [
          "CCI-002264"
        ],
        "nist": [
          "AC-16 a",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "If security labeling is not required, this is not a finding.\n\nIf security labeling requirements have been specified, but the security\nlabeling is not implemented or does not reliably maintain labels on information\nin transmission, this is a finding.",
        "fix": "Develop SQL or application code or acquire a third party tool to\nperform data labeling."
      },
      "code": "control 'V-67405' do\n  title \"When supporting applications that require security labeling of data,\nSQL Server must associate organization-defined types of security labels having\norganization-defined security label values with information in transmission.\"\n  desc  \"Without the association of security labels to information, there is no\nbasis for the DBMS to make security-related access-control decisions.\n\n    Security labels are abstractions representing the basic properties or\ncharacteristics of an entity (e.g., subjects and objects) with respect to\nsafeguarding information.\n\n    These labels are typically associated with internal data structures (e.g.,\ntables, rows) within the database and are used to enable the implementation of\naccess control and flow control policies, reflect special dissemination,\nhandling or distribution instructions, or support other aspects of the\ninformation security policy.\n\n    One example includes marking data as classified or FOUO. These security\nlabels may be assigned manually or during data processing, but, either way, it\nis imperative these assignments are maintained while the data is in storage. If\nthe security labels are lost when the data is stored, there is the risk of a\ndata compromise.\n\n    SQL Server does not include security labeling as a standard or licensable\nfeature. Earlier releases of this STIG suggested using the SQL Server Label\nSecurity Toolkit, from codeplex.com.  However, codeplex.com has been shut down,\nand it is unclear whether the Toolkit is still supported.  If the organization\ndoes have access to the Toolkit, it may still be used, provided the\norganization accepts responsibility for its support.  Other implementations may\nalso exist. Custom application code is also a viable way to implement a\nsolution.\n  \"\n\n  if attribute('security_labeling_required')\n    impact 0.5\n  else\n    impact 0.0\n    desc 'Security labeling is stated as `not required` in the attributes file,\n    this control is not applicable'\n  end\n  tag \"gtitle\": 'SRG-APP-000314-DB-000310'\n  tag \"gid\": 'V-67405'\n  tag \"rid\": 'SV-81895r2_rule'\n  tag \"stig_id\": 'SQL4-00-032100'\n  tag \"fix_id\": 'F-73517r3_fix'\n  tag \"cci\": ['CCI-002264']\n  tag \"nist\": ['AC-16 a', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"If security labeling is not required, this is not a finding.\n\nIf security labeling requirements have been specified, but the security\nlabeling is not implemented or does not reliably maintain labels on information\nin transmission, this is a finding.\"\n  tag \"fix\": \"Develop SQL or application code or acquire a third party tool to\nperform data labeling.\"\n\n  describe 'This test currently has no automated tests, you must check manually' do\n    skip 'This check must be preformed manually'\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67405.rb",
        "line": 1
      },
      "id": "V-67405"
    },
    {
      "title": "SQL Server must enforce approved authorizations for logical access to\ninformation and database-level system resources in accordance with applicable\naccess control policies.",
      "desc": "Authentication with a DoD-approved PKI certificate does not\nnecessarily imply authorization to access the database and all its contents.\nTo mitigate the risk of unauthorized access to sensitive information by\nentities that have been issued certificates by DoD-approved PKIs, all DoD\nsystems, including SQL Server databases, must be properly configured to\nimplement access control policies.\n\n    Successful authentication must not automatically give an entity access to\nan asset or security boundary. Authorization procedures and controls must be\nimplemented to ensure each authenticated entity also has a validated and\ncurrent authorization. Authorization is the process of determining whether an\nentity, once authenticated, is permitted to access a specific asset.\nInformation systems use access control policies and enforcement mechanisms to\nimplement this requirement.\n\n    Access control policies include identity-based policies, role-based\npolicies, and attribute-based policies. Access enforcement mechanisms include\naccess control lists, access control matrices, and cryptography. These policies\nand mechanisms must be employed by the application to control access between\nusers (or processes acting on behalf of users) and objects (e.g., devices,\nfiles, records, processes, programs, and domains) in the information system.\n\n    This requirement is applicable to access control enforcement applications,\na category that includes SQL Server.  If SQL Server is not configured to follow\napplicable policy when approving access, it may be in conflict with networks or\nother applications in the information system. This may result in users either\ngaining or being denied access inappropriately and in conflict with applicable\npolicy.",
      "descriptions": {
        "default": "Authentication with a DoD-approved PKI certificate does not\nnecessarily imply authorization to access the database and all its contents.\nTo mitigate the risk of unauthorized access to sensitive information by\nentities that have been issued certificates by DoD-approved PKIs, all DoD\nsystems, including SQL Server databases, must be properly configured to\nimplement access control policies.\n\n    Successful authentication must not automatically give an entity access to\nan asset or security boundary. Authorization procedures and controls must be\nimplemented to ensure each authenticated entity also has a validated and\ncurrent authorization. Authorization is the process of determining whether an\nentity, once authenticated, is permitted to access a specific asset.\nInformation systems use access control policies and enforcement mechanisms to\nimplement this requirement.\n\n    Access control policies include identity-based policies, role-based\npolicies, and attribute-based policies. Access enforcement mechanisms include\naccess control lists, access control matrices, and cryptography. These policies\nand mechanisms must be employed by the application to control access between\nusers (or processes acting on behalf of users) and objects (e.g., devices,\nfiles, records, processes, programs, and domains) in the information system.\n\n    This requirement is applicable to access control enforcement applications,\na category that includes SQL Server.  If SQL Server is not configured to follow\napplicable policy when approving access, it may be in conflict with networks or\nother applications in the information system. This may result in users either\ngaining or being denied access inappropriately and in conflict with applicable\npolicy."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000033-DB-000084",
        "gid": "V-67357",
        "rid": "SV-81847r1_rule",
        "stig_id": "SQL4-00-002000",
        "fix_id": "F-73469r1_fix",
        "cci": [
          "CCI-000213"
        ],
        "nist": [
          "AC-3",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "Review the system documentation to determine the required\nlevels of protection for securables in the database, by type of user.\n\nReview the permissions actually in place in the database.\n\nThe database permission functions and views provided in the supplemental file\nPermissions.sql can help with this.\n\nIf the actual permissions do not match the documented requirements, this is a\nfinding.",
        "fix": "Use GRANT, REVOKE, DENY, ALTER ROLE … ADD MEMBER … and/or ALTER\nROLE …. DROP MEMBER statements to add and remove permissions on database-level\nsecurables, bringing them into line with the documented requirements."
      },
      "code": "control 'V-67357' do\n  title \"SQL Server must enforce approved authorizations for logical access to\ninformation and database-level system resources in accordance with applicable\naccess control policies.\"\n  desc  \"Authentication with a DoD-approved PKI certificate does not\nnecessarily imply authorization to access the database and all its contents.\nTo mitigate the risk of unauthorized access to sensitive information by\nentities that have been issued certificates by DoD-approved PKIs, all DoD\nsystems, including SQL Server databases, must be properly configured to\nimplement access control policies.\n\n    Successful authentication must not automatically give an entity access to\nan asset or security boundary. Authorization procedures and controls must be\nimplemented to ensure each authenticated entity also has a validated and\ncurrent authorization. Authorization is the process of determining whether an\nentity, once authenticated, is permitted to access a specific asset.\nInformation systems use access control policies and enforcement mechanisms to\nimplement this requirement.\n\n    Access control policies include identity-based policies, role-based\npolicies, and attribute-based policies. Access enforcement mechanisms include\naccess control lists, access control matrices, and cryptography. These policies\nand mechanisms must be employed by the application to control access between\nusers (or processes acting on behalf of users) and objects (e.g., devices,\nfiles, records, processes, programs, and domains) in the information system.\n\n    This requirement is applicable to access control enforcement applications,\na category that includes SQL Server.  If SQL Server is not configured to follow\napplicable policy when approving access, it may be in conflict with networks or\nother applications in the information system. This may result in users either\ngaining or being denied access inappropriately and in conflict with applicable\npolicy.\n  \"\n  impact 0.5\n  tag \"gtitle\": 'SRG-APP-000033-DB-000084'\n  tag \"gid\": 'V-67357'\n  tag \"rid\": 'SV-81847r1_rule'\n  tag \"stig_id\": 'SQL4-00-002000'\n  tag \"fix_id\": 'F-73469r1_fix'\n  tag \"cci\": ['CCI-000213']\n  tag \"nist\": ['AC-3', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"Review the system documentation to determine the required\nlevels of protection for securables in the database, by type of user.\n\nReview the permissions actually in place in the database.\n\nThe database permission functions and views provided in the supplemental file\nPermissions.sql can help with this.\n\nIf the actual permissions do not match the documented requirements, this is a\nfinding.\"\n  tag \"fix\": \"Use GRANT, REVOKE, DENY, ALTER ROLE … ADD MEMBER … and/or ALTER\nROLE …. DROP MEMBER statements to add and remove permissions on database-level\nsecurables, bringing them into line with the documented requirements.\"\n\n  describe 'This test currently has no automated tests, you must check manually' do\n    skip 'This check must be preformed manually'\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67357.rb",
        "line": 1
      },
      "id": "V-67357"
    },
    {
      "title": "SQL Server must be monitored to discover unauthorized changes to\ntriggers.",
      "desc": "When dealing with change control issues, it should be noted, any\nchanges to the hardware, software, and/or firmware components of SQL Server\nand/or application can potentially have significant effects on the overall\nsecurity of the system.\n\n    If SQL Server were to allow any user to make changes to software libraries,\nthen those changes might be implemented without undergoing the appropriate\ntesting and approvals that are part of a robust change management process.\n\n    This requirement is contingent upon the language in which the application\nis programmed, as many application architectures in use today incorporate their\nsoftware libraries into, and make them inseparable from, their compiled\ndistributions, rendering them static and version-dependent. However, this\nrequirement does apply to applications with software libraries accessible and\nconfigurable, as in the case of interpreted languages.\n\n    Accordingly, only qualified and authorized individuals shall be allowed to\nobtain access to SQL Server components for purposes of initiating changes,\nincluding upgrades and modifications.\n\n    Unmanaged changes that occur to the SQL Server software libraries or\nconfiguration, such as Triggers, can lead to unauthorized or compromised\ninstallations.",
      "descriptions": {
        "default": "When dealing with change control issues, it should be noted, any\nchanges to the hardware, software, and/or firmware components of SQL Server\nand/or application can potentially have significant effects on the overall\nsecurity of the system.\n\n    If SQL Server were to allow any user to make changes to software libraries,\nthen those changes might be implemented without undergoing the appropriate\ntesting and approvals that are part of a robust change management process.\n\n    This requirement is contingent upon the language in which the application\nis programmed, as many application architectures in use today incorporate their\nsoftware libraries into, and make them inseparable from, their compiled\ndistributions, rendering them static and version-dependent. However, this\nrequirement does apply to applications with software libraries accessible and\nconfigurable, as in the case of interpreted languages.\n\n    Accordingly, only qualified and authorized individuals shall be allowed to\nobtain access to SQL Server components for purposes of initiating changes,\nincluding upgrades and modifications.\n\n    Unmanaged changes that occur to the SQL Server software libraries or\nconfiguration, such as Triggers, can lead to unauthorized or compromised\ninstallations."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000133-DB-000179",
        "gid": "V-67367",
        "rid": "SV-81857r2_rule",
        "stig_id": "SQL4-00-015100",
        "fix_id": "F-73479r2_fix",
        "cci": [
          "CCI-001499"
        ],
        "nist": [
          "CM-5 (6)",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "Check the SQL Server configuration for the timed job that\nautomatically checks all system and user-defined Triggers for being modified by\nrunning the following SQL Server query:\nEXEC msdb.dbo.sp_help_job @job_name = '<enter . . . job name>';\n\n(Alternatively, in SQL Server Management Studio, navigate to SQL Server Agent\nand examine the job from there.)\n\nIf such a job, or an alternative method of monitoring triggers for\nmodification, does not exist, this is a finding",
        "fix": "Configure a SQL Server timed job that automatically checks all\nsystem and user-defined Triggers for modification.\n\n(The supplemental file Track.sql, provided with this STIG, can be used to\nestablish a monitoring job.  This should be supplemented with a process for\ninforming the appropriate personnel.  Other techniques for achieving the same\nends, such as the use of DDL triggers, are acceptable.)"
      },
      "code": "control 'V-67367' do\n  title \"SQL Server must be monitored to discover unauthorized changes to\ntriggers.\"\n  desc  \"When dealing with change control issues, it should be noted, any\nchanges to the hardware, software, and/or firmware components of SQL Server\nand/or application can potentially have significant effects on the overall\nsecurity of the system.\n\n    If SQL Server were to allow any user to make changes to software libraries,\nthen those changes might be implemented without undergoing the appropriate\ntesting and approvals that are part of a robust change management process.\n\n    This requirement is contingent upon the language in which the application\nis programmed, as many application architectures in use today incorporate their\nsoftware libraries into, and make them inseparable from, their compiled\ndistributions, rendering them static and version-dependent. However, this\nrequirement does apply to applications with software libraries accessible and\nconfigurable, as in the case of interpreted languages.\n\n    Accordingly, only qualified and authorized individuals shall be allowed to\nobtain access to SQL Server components for purposes of initiating changes,\nincluding upgrades and modifications.\n\n    Unmanaged changes that occur to the SQL Server software libraries or\nconfiguration, such as Triggers, can lead to unauthorized or compromised\ninstallations.\n  \"\n  impact 0.5\n  tag \"gtitle\": 'SRG-APP-000133-DB-000179'\n  tag \"gid\": 'V-67367'\n  tag \"rid\": 'SV-81857r2_rule'\n  tag \"stig_id\": 'SQL4-00-015100'\n  tag \"fix_id\": 'F-73479r2_fix'\n  tag \"cci\": ['CCI-001499']\n  tag \"nist\": ['CM-5 (6)', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"Check the SQL Server configuration for the timed job that\nautomatically checks all system and user-defined Triggers for being modified by\nrunning the following SQL Server query:\nEXEC msdb.dbo.sp_help_job @job_name = '<enter . . . job name>';\n\n(Alternatively, in SQL Server Management Studio, navigate to SQL Server Agent\nand examine the job from there.)\n\nIf such a job, or an alternative method of monitoring triggers for\nmodification, does not exist, this is a finding\"\n  tag \"fix\": \"Configure a SQL Server timed job that automatically checks all\nsystem and user-defined Triggers for modification.\n\n(The supplemental file Track.sql, provided with this STIG, can be used to\nestablish a monitoring job.  This should be supplemented with a process for\ninforming the appropriate personnel.  Other techniques for achieving the same\nends, such as the use of DDL triggers, are acceptable.)\"\n\n  query = %{\n    SELECT enabled\n    FROM   msdb.dbo.sysjobs\n    WHERE  [name] = '%<job_name>s'\n  }\n\n  job_name = attribute('track_triggers_changes_job_name')\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n\n  describe \"Scheduled job: #{job_name} enabled status\" do\n    subject { sql_session.query(format(query, job_name: job_name)).column('enabled') }\n    it { should cmp 1 }\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67367.rb",
        "line": 1
      },
      "id": "V-67367"
    },
    {
      "title": "Database contents must be protected from unauthorized and unintended\ninformation transfer by enforcement of a data-transfer policy.",
      "desc": "The purpose of this control is to prevent information, including\nencrypted representations of information, produced by the actions of a prior\nuser/role (or the actions of a process acting on behalf of a prior user/role)\nfrom being available to any current user/role (or current process) that obtains\naccess to a shared system resource (e.g., registers, main memory, secondary\nstorage) after the resource has been released back to the information system.\nControl of information in shared resources is also referred to as object reuse.\n\n    Data used for the development and testing of applications often involves\ncopying data from production. It is important that specific procedures exist\nfor this process, so copies of sensitive data are not misplaced or left in a\ntemporary location without the proper controls.",
      "descriptions": {
        "default": "The purpose of this control is to prevent information, including\nencrypted representations of information, produced by the actions of a prior\nuser/role (or the actions of a process acting on behalf of a prior user/role)\nfrom being available to any current user/role (or current process) that obtains\naccess to a shared system resource (e.g., registers, main memory, secondary\nstorage) after the resource has been released back to the information system.\nControl of information in shared resources is also referred to as object reuse.\n\n    Data used for the development and testing of applications often involves\ncopying data from production. It is important that specific procedures exist\nfor this process, so copies of sensitive data are not misplaced or left in a\ntemporary location without the proper controls."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000243-DB-000128",
        "gid": "V-67389",
        "rid": "SV-81879r1_rule",
        "stig_id": "SQL4-00-021800",
        "fix_id": "F-73501r1_fix",
        "cci": [
          "CCI-001090"
        ],
        "nist": [
          "SC-4",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "Verify there are proper procedures in place for the transfer of\ndevelopment/test data from production. Review any scripts or code that exists\nfor the movement of production data to development/test and verify copies of\nproduction data are not left in unprotected locations.\n\nIf there is no documented procedure for data movement from production to\ndevelopment/test, this is a finding.\n\nIf data movement code that copies from production to development/test does\nexist and leaves any copies of production data in unprotected locations, this\nis a finding.",
        "fix": "Create and document a process for moving data from production to\ndevelopment/test systems and follow the process.\n\nModify any code used for moving data from production to development/test\nsystems to ensure copies of production data are not left in unsecured\nlocations."
      },
      "code": "control 'V-67389' do\n  title \"Database contents must be protected from unauthorized and unintended\ninformation transfer by enforcement of a data-transfer policy.\"\n  desc  \"The purpose of this control is to prevent information, including\nencrypted representations of information, produced by the actions of a prior\nuser/role (or the actions of a process acting on behalf of a prior user/role)\nfrom being available to any current user/role (or current process) that obtains\naccess to a shared system resource (e.g., registers, main memory, secondary\nstorage) after the resource has been released back to the information system.\nControl of information in shared resources is also referred to as object reuse.\n\n    Data used for the development and testing of applications often involves\ncopying data from production. It is important that specific procedures exist\nfor this process, so copies of sensitive data are not misplaced or left in a\ntemporary location without the proper controls.\n  \"\n  impact 0.5\n  tag \"gtitle\": 'SRG-APP-000243-DB-000128'\n  tag \"gid\": 'V-67389'\n  tag \"rid\": 'SV-81879r1_rule'\n  tag \"stig_id\": 'SQL4-00-021800'\n  tag \"fix_id\": 'F-73501r1_fix'\n  tag \"cci\": ['CCI-001090']\n  tag \"nist\": ['SC-4', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"Verify there are proper procedures in place for the transfer of\ndevelopment/test data from production. Review any scripts or code that exists\nfor the movement of production data to development/test and verify copies of\nproduction data are not left in unprotected locations.\n\nIf there is no documented procedure for data movement from production to\ndevelopment/test, this is a finding.\n\nIf data movement code that copies from production to development/test does\nexist and leaves any copies of production data in unprotected locations, this\nis a finding.\"\n  tag \"fix\": \"Create and document a process for moving data from production to\ndevelopment/test systems and follow the process.\n\nModify any code used for moving data from production to development/test\nsystems to ensure copies of production data are not left in unsecured\nlocations.\"\n\n  describe 'This test currently has no automated tests, you must check manually' do\n    skip 'This check must be preformed manually'\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67389.rb",
        "line": 1
      },
      "id": "V-67389"
    },
    {
      "title": "Symmetric keys (other than the database master key) must use a DoD\ncertificate to encrypt the key.",
      "desc": "Data within the database is protected by use of encryption. The\nsymmetric keys are critical for this process. If the symmetric keys were to be\ncompromised the data could be disclosed to unauthorized personnel.\n\n    The database master key is exempt, as a password must be supplied when\ncreating it.",
      "descriptions": {
        "default": "Data within the database is protected by use of encryption. The\nsymmetric keys are critical for this process. If the symmetric keys were to be\ncompromised the data could be disclosed to unauthorized personnel.\n\n    The database master key is exempt, as a password must be supplied when\ncreating it."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000231-DB-000154",
        "gid": "V-67385",
        "rid": "SV-81875r2_rule",
        "stig_id": "SQL4-00-024300",
        "fix_id": "F-73497r2_fix",
        "cci": [
          "CCI-001199"
        ],
        "nist": [
          "SC-28",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "In a query tool:\n\nUSE <database name>;\nGO\nSELECT s.name, k.crypt_type_desc\nFROM sys.symmetric_keys s, sys.key_encryptions k\nWHERE s.symmetric_key_id = k.key_id\nAND s.name <> '##MS_DatabaseMasterKey##'\nAND k.crypt_type IN ('ESKP', 'ESKS')\nORDER BY s.name, k.crypt_type_desc;\nGO\n\nReview any symmetric keys that have been defined against the System Security\nPlan.\n\nIf any keys are defined that are not documented in the System Security Plan,\nthis is a finding.\n\nReview the System Security Plan to review the encryption mechanism specified\nfor each symmetric key. If the method does not indicate use of certificates,\nthis is a finding.\n\nIf the certificate specified is not a DoD PKI certificate, this is a finding.",
        "fix": "Configure or alter symmetric keys to encrypt keys with\ncertificates or authorized asymmetric keys.\nIn a query tool:\n     ALTER SYMMETRIC KEY <key name> ADD ENCRYPTION BY CERTIFICATE <certificate\nname>;\n     ALTER SYMMETRIC KEY <key name> DROP ENCRYPTION BY <password, symmetric key\nor asymmetric key>;\n\nThe symmetric key must specify a certificate or asymmetric key for encryption."
      },
      "code": "control 'V-67385' do\n  title \"Symmetric keys (other than the database master key) must use a DoD\ncertificate to encrypt the key.\"\n  desc  \"Data within the database is protected by use of encryption. The\nsymmetric keys are critical for this process. If the symmetric keys were to be\ncompromised the data could be disclosed to unauthorized personnel.\n\n    The database master key is exempt, as a password must be supplied when\ncreating it.\n  \"\n  impact 0.5\n  tag \"gtitle\": 'SRG-APP-000231-DB-000154'\n  tag \"gid\": 'V-67385'\n  tag \"rid\": 'SV-81875r2_rule'\n  tag \"stig_id\": 'SQL4-00-024300'\n  tag \"fix_id\": 'F-73497r2_fix'\n  tag \"cci\": ['CCI-001199']\n  tag \"nist\": ['SC-28', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"In a query tool:\n\nUSE <database name>;\nGO\nSELECT s.name, k.crypt_type_desc\nFROM sys.symmetric_keys s, sys.key_encryptions k\nWHERE s.symmetric_key_id = k.key_id\nAND s.name <> '##MS_DatabaseMasterKey##'\nAND k.crypt_type IN ('ESKP', 'ESKS')\nORDER BY s.name, k.crypt_type_desc;\nGO\n\nReview any symmetric keys that have been defined against the System Security\nPlan.\n\nIf any keys are defined that are not documented in the System Security Plan,\nthis is a finding.\n\nReview the System Security Plan to review the encryption mechanism specified\nfor each symmetric key. If the method does not indicate use of certificates,\nthis is a finding.\n\nIf the certificate specified is not a DoD PKI certificate, this is a finding.\"\n  tag \"fix\": \"Configure or alter symmetric keys to encrypt keys with\ncertificates or authorized asymmetric keys.\nIn a query tool:\n     ALTER SYMMETRIC KEY <key name> ADD ENCRYPTION BY CERTIFICATE <certificate\nname>;\n     ALTER SYMMETRIC KEY <key name> DROP ENCRYPTION BY <password, symmetric key\nor asymmetric key>;\n\nThe symmetric key must specify a certificate or asymmetric key for encryption.\"\n\n  # review\n\n  query = %{\n    SELECT\n        s.name, k.crypt_type_desc\n    FROM\n        sys.symmetric_keys s, sys.key_encryptions k\n    WHERE\n        s.symmetric_key_id = k.key_id\n    AND\n        s.name <> '##MS_DatabaseMasterKey##'\n    AND\n        k.crypt_type IN ('ESKS', 'ESKP','ESP2','ESP3')\n    ORDER\n        BY s.name, k.crypt_type_desc\n    }\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n\n  if !sql_session.query(query).column('name').empty?\n    describe \"List of Symmetric keys in DB: #{attribute('db_name')} not encrypted\\\n    by DoD certificate\" do\n      subject { sql_session.query(query).column('name') }\n      it { should be_empty }\n    end\n  end\n\n  describe 'The following checks must be preformed manually' do\n    skip \"The following checks must be preformed manually:\n    Review any symmetric keys that have been defined against the System Security\n    Plan.\n\n    If any keys are defined that are not documented in the System Security Plan,\n    this is a finding.\n\n    Review the System Security Plan to review the encryption mechanism specified\n    for each symmetric key. If the method does not indicate use of certificates,\n    this is a finding.\n\n    If the certificate specified is not a DoD PKI certificate, this is a finding.\"\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67385.rb",
        "line": 1
      },
      "id": "V-67385"
    },
    {
      "title": "Trace or Audit records must be generated when unsuccessful attempts to\nmodify categorized information (e.g., classification levels/security levels)\noccur.",
      "desc": "Changes in categorized information must be tracked. Without an audit\ntrail, unauthorized access to protected data could go undetected.\n\n    For detailed information on categorizing information, refer to FIPS\nPublication 199, Standards for Security Categorization of Federal Information\nand Information Systems, and FIPS Publication 200, Minimum Security\nRequirements for Federal Information and Information Systems.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    Since Trace does not provide for tracking SELECT statements, it is\nnecessary to provide that part of the tracking at the application level.\nBecause of this, it may also be appropriate to audit UPDATE actions at the\napplication level.  However, to capture all UPDATEs, whether they come from the\napplication or bypass it, the Trace must be configured to cover them.\n\n    Use of SQL Server Audit's SCHEMA_OBJECT_ACCESS_GROUP causes capture of all\naccesses, successful and otherwise, to all schema-scoped objects.  The\n[Succeeded] column in the audit output indicates the success or failure of the\nattempted action.  Be aware, however, that it may report True in some cases\nwhere one would intuitively expect False.  For example, SELECT 1/0 FROM\nSYS.ALL_OBJECTS will appear in the audit trail as successful, if the user has\npermission to perform that action, even though it contains an invalid\nexpression.  Some other actions that one would consider failures (such as\nselecting from a table that does not exist) may not appear at all.",
      "descriptions": {
        "default": "Changes in categorized information must be tracked. Without an audit\ntrail, unauthorized access to protected data could go undetected.\n\n    For detailed information on categorizing information, refer to FIPS\nPublication 199, Standards for Security Categorization of Federal Information\nand Information Systems, and FIPS Publication 200, Minimum Security\nRequirements for Federal Information and Information Systems.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    Since Trace does not provide for tracking SELECT statements, it is\nnecessary to provide that part of the tracking at the application level.\nBecause of this, it may also be appropriate to audit UPDATE actions at the\napplication level.  However, to capture all UPDATEs, whether they come from the\napplication or bypass it, the Trace must be configured to cover them.\n\n    Use of SQL Server Audit's SCHEMA_OBJECT_ACCESS_GROUP causes capture of all\naccesses, successful and otherwise, to all schema-scoped objects.  The\n[Succeeded] column in the audit output indicates the success or failure of the\nattempted action.  Be aware, however, that it may report True in some cases\nwhere one would intuitively expect False.  For example, SELECT 1/0 FROM\nSYS.ALL_OBJECTS will appear in the audit trail as successful, if the user has\npermission to perform that action, even though it contains an invalid\nexpression.  Some other actions that one would consider failures (such as\nselecting from a table that does not exist) may not appear at all."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000498-DB-000347",
        "gid": "V-67443",
        "rid": "SV-81933r2_rule",
        "stig_id": "SQL4-00-036850",
        "fix_id": "F-73557r1_fix",
        "cci": [
          "CCI-000172"
        ],
        "nist": [
          "AU-12 c",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "Review the system documentation to determine whether it is\nrequired to track categories of information, such as classification or\nsensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes,\nthis is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the Trace settings,\nand the triggers on the tables holding categorized information, to determine\nwhether all UPDATE actions on these tables are traced, including failed\nattempts.  If not, this is a finding.\n\nCheck to see that all required event classes are being audited.  From the query\nprompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no\ntraces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing\nrequirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is\na finding:\n\n82-91  -- User-defined Event (at least one of these, matching the triggers; 90\nis used in the supplied script)\n162 -- User error message\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the broad, server-level audit action group\nSCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility\nmakes other techniques possible.  If an alternative technique is in use and\ndemonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\nAlternatively, review the contents of the system views with \"audit\" in their\nnames.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions\non tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"SUCCESS\" or \"SUCCESS AND FAILURE\",\nthis is a finding.",
        "fix": "Where SQL Server Trace is in use, create triggers to raise a\ncustom event for UPDATEs on each table holding categorized information.  The\nexamples provided in the supplemental file CustomTraceEvents.sql can serve as\nthe basis for these.\n\nAdd a block of code to the supplemental file Trace.sql for each custom event\nclass (integers in the range 82-91; the same event class may be used for all\nsuch triggers) used in these triggers.  Execute Trace.sql.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all\nauditable events and data items.  The script provided in the supplemental file\nAudit.sql can be used as the basis for this.  Supplement the standard audit\ndata as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO"
      },
      "code": "control 'V-67443' do\n  title \"Trace or Audit records must be generated when unsuccessful attempts to\nmodify categorized information (e.g., classification levels/security levels)\noccur.\"\n  desc  \"Changes in categorized information must be tracked. Without an audit\ntrail, unauthorized access to protected data could go undetected.\n\n    For detailed information on categorizing information, refer to FIPS\nPublication 199, Standards for Security Categorization of Federal Information\nand Information Systems, and FIPS Publication 200, Minimum Security\nRequirements for Federal Information and Information Systems.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    Since Trace does not provide for tracking SELECT statements, it is\nnecessary to provide that part of the tracking at the application level.\nBecause of this, it may also be appropriate to audit UPDATE actions at the\napplication level.  However, to capture all UPDATEs, whether they come from the\napplication or bypass it, the Trace must be configured to cover them.\n\n    Use of SQL Server Audit's SCHEMA_OBJECT_ACCESS_GROUP causes capture of all\naccesses, successful and otherwise, to all schema-scoped objects.  The\n[Succeeded] column in the audit output indicates the success or failure of the\nattempted action.  Be aware, however, that it may report True in some cases\nwhere one would intuitively expect False.  For example, SELECT 1/0 FROM\nSYS.ALL_OBJECTS will appear in the audit trail as successful, if the user has\npermission to perform that action, even though it contains an invalid\nexpression.  Some other actions that one would consider failures (such as\nselecting from a table that does not exist) may not appear at all.\n  \"\n  if attribute('server_trace_or_audit_required')\n    impact 0.5\n  else\n    impact 0.0\n    desc 'Inspec attributes has specified that is not required to track categories\n    of information, such as classification or sensitivity level on the target'\n  end\n\n  tag \"gtitle\": 'SRG-APP-000498-DB-000347'\n  tag \"gid\": 'V-67443'\n  tag \"rid\": 'SV-81933r2_rule'\n  tag \"stig_id\": 'SQL4-00-036850'\n  tag \"fix_id\": 'F-73557r1_fix'\n  tag \"cci\": ['CCI-000172']\n  tag \"nist\": ['AU-12 c', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"Review the system documentation to determine whether it is\nrequired to track categories of information, such as classification or\nsensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes,\nthis is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the Trace settings,\nand the triggers on the tables holding categorized information, to determine\nwhether all UPDATE actions on these tables are traced, including failed\nattempts.  If not, this is a finding.\n\nCheck to see that all required event classes are being audited.  From the query\nprompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no\ntraces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing\nrequirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is\na finding:\n\n82-91  -- User-defined Event (at least one of these, matching the triggers; 90\nis used in the supplied script)\n162 -- User error message\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the broad, server-level audit action group\nSCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility\nmakes other techniques possible.  If an alternative technique is in use and\ndemonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\nAlternatively, review the contents of the system views with \\\"audit\\\" in their\nnames.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions\non tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \\\"SUCCESS\\\" or \\\"SUCCESS AND FAILURE\\\",\nthis is a finding.\"\n  tag \"fix\": \"Where SQL Server Trace is in use, create triggers to raise a\ncustom event for UPDATEs on each table holding categorized information.  The\nexamples provided in the supplemental file CustomTraceEvents.sql can serve as\nthe basis for these.\n\nAdd a block of code to the supplemental file Trace.sql for each custom event\nclass (integers in the range 82-91; the same event class may be used for all\nsuch triggers) used in these triggers.  Execute Trace.sql.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all\nauditable events and data items.  The script provided in the supplemental file\nAudit.sql can be used as the basis for this.  Supplement the standard audit\ndata as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO\"\n\n  query_traces = %{\n    SELECT * FROM sys.traces\n  }\n  query_trace_eventinfo = %{\n    SELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(%<trace_id>s);\n  }\n\n  query_audits = %{\n    SELECT server_specification_id,\n           audit_action_name,\n           audited_result\n    FROM   sys.server_audit_specification_details\n    WHERE  audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n  }\n\n  server_trace_implemented = attribute('server_trace_implemented')\n  server_audit_implemented = attribute('server_audit_implemented')\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n\n  describe.one do\n    describe 'SQL Server Trace is in use for audit purposes' do\n      subject { server_trace_implemented }\n      it { should be true }\n    end\n\n    describe 'SQL Server Audit is in use for audit purposes' do\n      subject { server_audit_implemented }\n      it { should be true }\n    end\n  end\n\n  if server_trace_implemented\n    describe 'List defined traces for the SQL server instance' do\n      subject { sql_session.query(query_traces) }\n      it { should_not be_empty }\n    end\n\n    trace_ids = sql_session.query(query_traces).column('id')\n    describe.one do\n      trace_ids.each do |trace_id|\n        found_events = sql_session.query(format(query_trace_eventinfo, trace_id: trace_id)).column('eventid')\n        describe \"EventsIDs in Trace ID:#{trace_id}\" do\n          subject { found_events }\n          its('to_s') { should match /\"82\"|\"83\"|\"84\"|\"85\"|\"86\"|\"87\"|\"88\"|\"89\"|\"90\"|\"91\"/ }\n          it { should include '162' }\n        end\n      end\n    end\n  end\n\n  if server_audit_implemented\n    describe 'SQL Server Audit:' do\n      describe 'Defined Audits with Audit Action SCHEMA_OBJECT_ACCESS_GROUP' do\n        subject { sql_session.query(query_audits) }\n        it { should_not be_empty }\n      end\n      describe 'Audited Result for Defined Audit Actions' do\n        subject { sql_session.query(query_audits).column('audited_result').uniq.to_s }\n        it { should match /SUCCESS AND FAILURE|SUCCESS/ }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67443.rb",
        "line": 1
      },
      "id": "V-67443"
    },
    {
      "title": "When supporting applications that require security labeling of data,\nSQL Server must associate organization-defined types of security labels having\norganization-defined security label values with information in storage.",
      "desc": "Without the association of security labels to information, there is no\nbasis for the DBMS to make security-related access-control decisions.\n\n    Security labels are abstractions representing the basic properties or\ncharacteristics of an entity (e.g., subjects and objects) with respect to\nsafeguarding information.\n\n    These labels are typically associated with internal data structures (e.g.,\ntables, rows) within the database and are used to enable the implementation of\naccess control and flow control policies, reflect special dissemination,\nhandling or distribution instructions, or support other aspects of the\ninformation security policy.\n\n    One example includes marking data as classified or FOUO. These security\nlabels may be assigned manually or during data processing, but, either way, it\nis imperative these assignments are maintained while the data is in storage. If\nthe security labels are lost when the data is stored, there is the risk of a\ndata compromise.\n\n\n    SQL Server does not include security labeling as a standard or licensable\nfeature. Earlier releases of this STIG suggested using the SQL Server Label\nSecurity Toolkit, from codeplex.com.  However, codeplex.com has been shut down,\nand it is unclear whether the Toolkit is still supported.  If the organization\ndoes have access to the Toolkit, it may still be used, provided the\norganization accepts responsibility for its support.  Other implementations may\nalso exist. Custom application code is also a viable way to implement a\nsolution.",
      "descriptions": {
        "default": "Without the association of security labels to information, there is no\nbasis for the DBMS to make security-related access-control decisions.\n\n    Security labels are abstractions representing the basic properties or\ncharacteristics of an entity (e.g., subjects and objects) with respect to\nsafeguarding information.\n\n    These labels are typically associated with internal data structures (e.g.,\ntables, rows) within the database and are used to enable the implementation of\naccess control and flow control policies, reflect special dissemination,\nhandling or distribution instructions, or support other aspects of the\ninformation security policy.\n\n    One example includes marking data as classified or FOUO. These security\nlabels may be assigned manually or during data processing, but, either way, it\nis imperative these assignments are maintained while the data is in storage. If\nthe security labels are lost when the data is stored, there is the risk of a\ndata compromise.\n\n\n    SQL Server does not include security labeling as a standard or licensable\nfeature. Earlier releases of this STIG suggested using the SQL Server Label\nSecurity Toolkit, from codeplex.com.  However, codeplex.com has been shut down,\nand it is unclear whether the Toolkit is still supported.  If the organization\ndoes have access to the Toolkit, it may still be used, provided the\norganization accepts responsibility for its support.  Other implementations may\nalso exist. Custom application code is also a viable way to implement a\nsolution."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000311-DB-000308",
        "gid": "V-67401",
        "rid": "SV-81891r2_rule",
        "stig_id": "SQL4-00-031900",
        "fix_id": "F-73513r2_fix",
        "cci": [
          "CCI-002262"
        ],
        "nist": [
          "AC-16 a",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "If security labeling is not required, this is not a finding.\n\nIf security labeling requirements have been specified, but the security\nlabeling is not implemented or does not reliably maintain labels on information\nin storage, this is a finding.",
        "fix": "Develop SQL or application code or acquire a third party tool to\nperform data labeling."
      },
      "code": "control 'V-67401' do\n  title \"When supporting applications that require security labeling of data,\nSQL Server must associate organization-defined types of security labels having\norganization-defined security label values with information in storage.\"\n  desc  \"Without the association of security labels to information, there is no\nbasis for the DBMS to make security-related access-control decisions.\n\n    Security labels are abstractions representing the basic properties or\ncharacteristics of an entity (e.g., subjects and objects) with respect to\nsafeguarding information.\n\n    These labels are typically associated with internal data structures (e.g.,\ntables, rows) within the database and are used to enable the implementation of\naccess control and flow control policies, reflect special dissemination,\nhandling or distribution instructions, or support other aspects of the\ninformation security policy.\n\n    One example includes marking data as classified or FOUO. These security\nlabels may be assigned manually or during data processing, but, either way, it\nis imperative these assignments are maintained while the data is in storage. If\nthe security labels are lost when the data is stored, there is the risk of a\ndata compromise.\n\n\n    SQL Server does not include security labeling as a standard or licensable\nfeature. Earlier releases of this STIG suggested using the SQL Server Label\nSecurity Toolkit, from codeplex.com.  However, codeplex.com has been shut down,\nand it is unclear whether the Toolkit is still supported.  If the organization\ndoes have access to the Toolkit, it may still be used, provided the\norganization accepts responsibility for its support.  Other implementations may\nalso exist. Custom application code is also a viable way to implement a\nsolution.\n  \"\n  if attribute('security_labeling_required')\n    impact 0.5\n  else\n    impact 0.0\n    desc 'Security labeling is stated as `not required` in the attributes file,\n    this control is not applicable'\n  end\n\n  tag \"gtitle\": 'SRG-APP-000311-DB-000308'\n  tag \"gid\": 'V-67401'\n  tag \"rid\": 'SV-81891r2_rule'\n  tag \"stig_id\": 'SQL4-00-031900'\n  tag \"fix_id\": 'F-73513r2_fix'\n  tag \"cci\": ['CCI-002262']\n  tag \"nist\": ['AC-16 a', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"If security labeling is not required, this is not a finding.\n\nIf security labeling requirements have been specified, but the security\nlabeling is not implemented or does not reliably maintain labels on information\nin storage, this is a finding.\"\n  tag \"fix\": \"Develop SQL or application code or acquire a third party tool to\nperform data labeling.\"\n\n  describe 'This test currently has no automated tests, you must check manually' do\n    skip 'This check must be preformed manually'\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67401.rb",
        "line": 1
      },
      "id": "V-67401"
    },
    {
      "title": "SQL Server must generate Trace or Audit records when  unsuccessful\nattempts to drop locally-defined security objects occur.",
      "desc": "SQL Server protects its built-in security objects (tables, views,\nfunctions, procedures, etc.) from alteration by database users and\nadministrators.  However, applications sometimes have additional,\nsecurity-related objects defined in the database.  DROP operations on these\nobjects must be monitored.\n\n    To aid in diagnosis, it is necessary to keep track of failed attempts in\naddition to the successful ones.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    Use of SQL Server Audit's SCHEMA_OBJECT_CHANGE_GROUP causes capture of all\nattempts, successful and otherwise, to CREATE, ALTER, or DROP any schema-scoped\nobjects.  The [Succeeded] column in the audit output indicates the success or\nfailure of the attempted action.  Be aware, however, that it may report True in\nsome cases where one would intuitively expect False.",
      "descriptions": {
        "default": "SQL Server protects its built-in security objects (tables, views,\nfunctions, procedures, etc.) from alteration by database users and\nadministrators.  However, applications sometimes have additional,\nsecurity-related objects defined in the database.  DROP operations on these\nobjects must be monitored.\n\n    To aid in diagnosis, it is necessary to keep track of failed attempts in\naddition to the successful ones.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    Use of SQL Server Audit's SCHEMA_OBJECT_CHANGE_GROUP causes capture of all\nattempts, successful and otherwise, to CREATE, ALTER, or DROP any schema-scoped\nobjects.  The [Succeeded] column in the audit output indicates the success or\nfailure of the attempted action.  Be aware, however, that it may report True in\nsome cases where one would intuitively expect False."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000501-DB-000337",
        "gid": "V-67431",
        "rid": "SV-81921r3_rule",
        "stig_id": "SQL4-00-037200",
        "fix_id": "F-73545r2_fix",
        "cci": [
          "CCI-000172"
        ],
        "nist": [
          "AU-12 c",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "If neither SQL Server Audit nor SQL Server Trace is in use for\naudit purposes, this is a finding.\n\nIf there are no locally-defined security tables or procedures, this is not a\nfinding.\n\nIf SQL Server Trace is in use for audit purposes, verify that all required\nevents are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no\ntraces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing\nrequirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should all be among those listed; if not, this\nis a finding:\n\n46  -- Object:Created\n47  -- Object:Deleted\n162  -- User error message\n164 -- Object:Altered\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the broad, server-level audit action group\nSCHEMA_OBJECT_CHANGE_GROUP for this purpose.  SQL Server Audit's flexibility\nmakes other techniques possible.  If an alternative technique is in use and\ndemonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their\nnames.\n\nRun the following to verify that all CREATE, ALTER, and DROP actions on any\nlocally-defined permissions tables, procedures and functions are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_CHANGE_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"FAILURE\" or \"SUCCESS AND FAILURE\",\nthis is a finding.",
        "fix": "Where SQL Server Trace is in use, define  and enable a trace that\ncaptures all auditable events.  The script provided in the supplemental file\nTrace.sql can be used to do this.\n\nAdd blocks of code to Trace.sql for each custom event class (integers in the\nrange 82-91; the same event class may be used for all such triggers) used in\nthese triggers.\n\nCreate triggers to raise a custom event on each locally-defined security table\nthat requires tracking of Insert-Update-Delete operations.  The examples\nprovided in the supplemental file CustomTraceEvents.sql can serve as the basis\nfor these.\n\nExecute Trace.sql.\n\nWhere SQL Server Audit is in use, design and deploy a SQL Server Audit that\ncaptures all auditable events.  The script provided in the supplemental file\nAudit.sql can be used for this.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_CHANGE_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO"
      },
      "code": "control 'V-67431' do\n  title \"SQL Server must generate Trace or Audit records when  unsuccessful\nattempts to drop locally-defined security objects occur.\"\n  desc  \"SQL Server protects its built-in security objects (tables, views,\nfunctions, procedures, etc.) from alteration by database users and\nadministrators.  However, applications sometimes have additional,\nsecurity-related objects defined in the database.  DROP operations on these\nobjects must be monitored.\n\n    To aid in diagnosis, it is necessary to keep track of failed attempts in\naddition to the successful ones.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    Use of SQL Server Audit's SCHEMA_OBJECT_CHANGE_GROUP causes capture of all\nattempts, successful and otherwise, to CREATE, ALTER, or DROP any schema-scoped\nobjects.  The [Succeeded] column in the audit output indicates the success or\nfailure of the attempted action.  Be aware, however, that it may report True in\nsome cases where one would intuitively expect False.\n  \"\n  impact 0.5\n  tag \"gtitle\": 'SRG-APP-000501-DB-000337'\n  tag \"gid\": 'V-67431'\n  tag \"rid\": 'SV-81921r3_rule'\n  tag \"stig_id\": 'SQL4-00-037200'\n  tag \"fix_id\": 'F-73545r2_fix'\n  tag \"cci\": ['CCI-000172']\n  tag \"nist\": ['AU-12 c', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"If neither SQL Server Audit nor SQL Server Trace is in use for\naudit purposes, this is a finding.\n\nIf there are no locally-defined security tables or procedures, this is not a\nfinding.\n\nIf SQL Server Trace is in use for audit purposes, verify that all required\nevents are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no\ntraces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing\nrequirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should all be among those listed; if not, this\nis a finding:\n\n46  -- Object:Created\n47  -- Object:Deleted\n162  -- User error message\n164 -- Object:Altered\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the broad, server-level audit action group\nSCHEMA_OBJECT_CHANGE_GROUP for this purpose.  SQL Server Audit's flexibility\nmakes other techniques possible.  If an alternative technique is in use and\ndemonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\n\nAlternatively, review the contents of the system views with \\\"audit\\\" in their\nnames.\n\nRun the following to verify that all CREATE, ALTER, and DROP actions on any\nlocally-defined permissions tables, procedures and functions are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_CHANGE_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \\\"FAILURE\\\" or \\\"SUCCESS AND FAILURE\\\",\nthis is a finding.\"\n  tag \"fix\": \"Where SQL Server Trace is in use, define  and enable a trace that\ncaptures all auditable events.  The script provided in the supplemental file\nTrace.sql can be used to do this.\n\nAdd blocks of code to Trace.sql for each custom event class (integers in the\nrange 82-91; the same event class may be used for all such triggers) used in\nthese triggers.\n\nCreate triggers to raise a custom event on each locally-defined security table\nthat requires tracking of Insert-Update-Delete operations.  The examples\nprovided in the supplemental file CustomTraceEvents.sql can serve as the basis\nfor these.\n\nExecute Trace.sql.\n\nWhere SQL Server Audit is in use, design and deploy a SQL Server Audit that\ncaptures all auditable events.  The script provided in the supplemental file\nAudit.sql can be used for this.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_CHANGE_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO\"\n  query_traces = %{\n    SELECT * FROM sys.traces\n  }\n  query_trace_eventinfo = %{\n    SELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(%<trace_id>s);\n  }\n\n  query_audits = %{\n    SELECT server_specification_id,\n           audit_action_name,\n           audited_result\n    FROM   sys.server_audit_specification_details\n    WHERE  audit_action_name = 'SCHEMA_OBJECT_CHANGE_GROUP';\n  }\n  server_trace_implemented = attribute('server_trace_implemented')\n  server_audit_implemented = attribute('server_audit_implemented')\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n\n  describe.one do\n    describe 'SQL Server Trace is in use for audit purposes' do\n      subject { server_trace_implemented }\n      it { should be true }\n    end\n\n    describe 'SQL Server Audit is in use for audit purposes' do\n      subject { server_audit_implemented }\n      it { should be true }\n    end\n  end\n\n  if server_trace_implemented\n    describe 'List defined traces for the SQL server instance' do\n      subject { sql_session.query(query_traces) }\n      it { should_not be_empty }\n    end\n\n    trace_ids = sql_session.query(query_traces).column('id')\n    describe.one do\n      trace_ids.each do |trace_id|\n        found_events = sql_session.query(format(query_trace_eventinfo, trace_id: trace_id)).column('eventid')\n        describe \"EventsIDs in Trace ID:#{trace_id}\" do\n          subject { found_events }\n          it { should include '46' }\n          it { should include '47' }\n          it { should include '162' }\n          it { should include '164' }\n        end\n      end\n    end\n  end\n\n  if server_audit_implemented\n    describe 'SQL Server Audit:' do\n      describe 'Defined Audits with Audit Action SCHEMA_OBJECT_CHANGE_GROUP' do\n        subject { sql_session.query(query_audits) }\n        it { should_not be_empty }\n      end\n      describe 'Audited Result for Defined Audit Actions' do\n        subject { sql_session.query(query_audits).column('audited_result').uniq.to_s }\n        it { should match /SUCCESS AND FAILURE|FAILURE/ }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67431.rb",
        "line": 1
      },
      "id": "V-67431"
    },
    {
      "title": "Trace or Audit records must be generated when categorized information\n(e.g., classification levels/security levels) is accessed.",
      "desc": "Changes in categorized information must be tracked. Without an audit\ntrail, unauthorized access to protected data could go undetected.\n\n    For detailed information on categorizing information, refer to FIPS\nPublication 199, Standards for Security Categorization of Federal Information\nand Information Systems, and FIPS Publication 200, Minimum Security\nRequirements for Federal Information and Information Systems.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\nNote also that Trace does not support auditing of SELECT statements, whereas\nAudit does.\n\n    Since Trace does not provide for tracking SELECT statements, it is\nnecessary to provide this tracking at the application level, if Trace is used\nfor audit purposes.",
      "descriptions": {
        "default": "Changes in categorized information must be tracked. Without an audit\ntrail, unauthorized access to protected data could go undetected.\n\n    For detailed information on categorizing information, refer to FIPS\nPublication 199, Standards for Security Categorization of Federal Information\nand Information Systems, and FIPS Publication 200, Minimum Security\nRequirements for Federal Information and Information Systems.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\nNote also that Trace does not support auditing of SELECT statements, whereas\nAudit does.\n\n    Since Trace does not provide for tracking SELECT statements, it is\nnecessary to provide this tracking at the application level, if Trace is used\nfor audit purposes."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000494-DB-000344",
        "gid": "V-67413",
        "rid": "SV-81903r2_rule",
        "stig_id": "SQL4-00-035800",
        "fix_id": "F-73527r1_fix",
        "cci": [
          "CCI-000172"
        ],
        "nist": [
          "AU-12 c",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "Review the system documentation to determine whether it is\nrequired to track categories of information, such as classification or\nsensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes,\nthis is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the application(s)\nusing the database to verify that all SELECT actions on categorized data are\nbeing audited, and that the tracking records are written to the SQL Server\nTrace.  If not, this is a finding.\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the broad, server-level audit action group\nSCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility\nmakes other techniques possible.\n\nIf an alternative technique is in use and demonstrated effective, this is not a\nfinding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their\nnames.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions\non tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"SUCCESS\" or \"SUCCESS AND FAILURE\",\nthis is a finding.",
        "fix": "Where SQL Server Trace is in use, implement tracking of SELECTs\non categorized data at the application level, using the system stored procedure\nsp_trace_generateevent to write the tracking records to the Trace used for\naudit purposes.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all\nauditable events and data items.  The script provided in the supplemental file\nAudit.sql can be used as the basis for this.  Supplement the standard audit\ndata as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO"
      },
      "code": "control 'V-67413' do\n  title \"Trace or Audit records must be generated when categorized information\n(e.g., classification levels/security levels) is accessed.\"\n  desc  \"Changes in categorized information must be tracked. Without an audit\ntrail, unauthorized access to protected data could go undetected.\n\n    For detailed information on categorizing information, refer to FIPS\nPublication 199, Standards for Security Categorization of Federal Information\nand Information Systems, and FIPS Publication 200, Minimum Security\nRequirements for Federal Information and Information Systems.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\nNote also that Trace does not support auditing of SELECT statements, whereas\nAudit does.\n\n    Since Trace does not provide for tracking SELECT statements, it is\nnecessary to provide this tracking at the application level, if Trace is used\nfor audit purposes.\n  \"\n\n  if attribute('server_trace_or_audit_required')\n    impact 0.5\n  else\n    impact 0.0\n    desc 'Inspec attributes has specified that is not required to track categories\n    of information, such as classification or sensitivity level on the target'\n  end\n\n  tag \"gtitle\": 'SRG-APP-000494-DB-000344'\n  tag \"gid\": 'V-67413'\n  tag \"rid\": 'SV-81903r2_rule'\n  tag \"stig_id\": 'SQL4-00-035800'\n  tag \"fix_id\": 'F-73527r1_fix'\n  tag \"cci\": ['CCI-000172']\n  tag \"nist\": ['AU-12 c', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"Review the system documentation to determine whether it is\nrequired to track categories of information, such as classification or\nsensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes,\nthis is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the application(s)\nusing the database to verify that all SELECT actions on categorized data are\nbeing audited, and that the tracking records are written to the SQL Server\nTrace.  If not, this is a finding.\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the broad, server-level audit action group\nSCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility\nmakes other techniques possible.\n\nIf an alternative technique is in use and demonstrated effective, this is not a\nfinding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\n\nAlternatively, review the contents of the system views with \\\"audit\\\" in their\nnames.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions\non tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \\\"SUCCESS\\\" or \\\"SUCCESS AND FAILURE\\\",\nthis is a finding.\"\n  tag \"fix\": \"Where SQL Server Trace is in use, implement tracking of SELECTs\non categorized data at the application level, using the system stored procedure\nsp_trace_generateevent to write the tracking records to the Trace used for\naudit purposes.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all\nauditable events and data items.  The script provided in the supplemental file\nAudit.sql can be used as the basis for this.  Supplement the standard audit\ndata as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO\"\n\n  query_traces = %{\n    SELECT * FROM sys.traces\n  }\n  query_trace_eventinfo = %{\n    SELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(%<trace_id>s);\n  }\n\n  query_audits = %{\n    SELECT server_specification_id,\n           audit_action_name,\n           audited_result\n    FROM   sys.server_audit_specification_details\n    WHERE  audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n  }\n\n  server_trace_implemented = attribute('server_trace_implemented')\n  server_audit_implemented = attribute('server_audit_implemented')\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n\n  describe.one do\n    describe 'SQL Server Trace is in use for audit purposes' do\n      subject { server_trace_implemented }\n      it { should be true }\n    end\n\n    describe 'SQL Server Audit is in use for audit purposes' do\n      subject { server_audit_implemented }\n      it { should be true }\n    end\n  end\n\n  if server_trace_implemented\n    describe 'List defined traces for the SQL server instance' do\n      subject { sql_session.query(query_traces) }\n      it { should_not be_empty }\n    end\n\n    trace_ids = sql_session.query(query_traces).column('id')\n    describe.one do\n      trace_ids.each do |trace_id|\n        found_events = sql_session.query(format(query_trace_eventinfo, trace_id: trace_id)).column('eventid')\n        describe \"EventsIDs in Trace ID:#{trace_id}\" do\n          subject { found_events }\n          it { should include '28' }\n          it { should include '114' }\n        end\n      end\n    end\n  end\n\n  if server_audit_implemented\n    describe 'SQL Server Audit:' do\n      describe 'Defined Audits with Audit Action SCHEMA_OBJECT_ACCESS_GROUP' do\n        subject { sql_session.query(query_audits) }\n        it { should_not be_empty }\n      end\n      describe 'Audited Result for Defined Audit Actions' do\n        subject { sql_session.query(query_audits).column('audited_result').uniq.to_s }\n        it { should match /SUCCESS AND FAILURE|FAILURE/ }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67413.rb",
        "line": 1
      },
      "id": "V-67413"
    },
    {
      "title": "The DBMS and associated applications, when making use of dynamic code\nexecution, must scan input data for invalid values that may indicate a code\ninjection attack.",
      "desc": "With respect to database management systems, one class of threat is\nknown as SQL Injection, or more generally, code injection. It takes advantage\nof the dynamic execution capabilities of various programming languages,\nincluding dialects of SQL. In such cases, the attacker deduces the manner in\nwhich SQL statements are being processed, either from inside knowledge or by\nobserving system behavior in response to invalid inputs. When the attacker\nidentifies scenarios where SQL queries are being assembled by application code\n(which may be within the database or separate from it) and executed\ndynamically, the attacker is then able to craft input strings that subvert the\nintent of the query. Potentially, the attacker can gain unauthorized access to\ndata, including security settings, and severely corrupt or destroy the database.\n\n    The principal protection against code injection is not to use dynamic\nexecution except where it provides necessary functionality that cannot be\nutilized otherwise. Use strongly typed data items rather than general-purpose\nstrings as input parameters to task-specific, pre-compiled stored procedures\nand functions (and triggers).\n\n    When dynamic execution is necessary, ways to mitigate the risk include the\nfollowing, which should be implemented both in the on-screen application and at\nthe database level, in the stored procedures:\n    -- Allow strings as input only when necessary.\n    -- Rely on data typing to validate numbers, dates, etc. Do not accept\ninvalid values. If substituting other values for them, think carefully about\nwhether this could be subverted.\n    -- Limit the size of input strings to what is truly necessary.\n    -- If single quotes/apostrophes, double quotes, semicolons, equals signs,\nangle brackets, or square brackets will never be valid as input, reject them.\n    -- If comment markers will never be valid as input, reject them. In SQL,\nthese are -- or /* */\n    -- If HTML and XML tags, entities, comments, etc., will never be valid,\nreject them.\n    -- If wildcards are present, reject them unless truly necessary. In SQL\nthese are the underscore and the percentage sign, and the word ESCAPE is also a\nclue that wildcards are in use.\n    -- If SQL key words, such as SELECT, INSERT, UPDATE, DELETE, CREATE, ALTER,\nDROP, ESCAPE, UNION, GRANT, REVOKE, DENY, MODIFY will never be valid, reject\nthem. Use case-insensitive comparisons when searching for these. Bear in mind\nthat some of these words, particularly Grant (as a person's name), could also\nbe valid input.\n    -- If there are range limits on the values that may be entered, enforce\nthose limits.\n    -- Institute procedures for inspection of programs for correct use of\ndynamic coding, by a party other than the developer.\n    -- Conduct rigorous testing of program modules that use dynamic coding,\nsearching for ways to subvert the intended use.\n    -- Record the inspection and testing in the system documentation.\n    -- Bear in mind that all this applies not only to screen input, but also to\nthe values in an incoming message to a web service or to a stored procedure\ncalled by a software component that has not itself been hardened in these ways.\nNot only can the caller be subject to such vulnerabilities; it may itself be\nthe attacker.\n\n    This calls for inspection of application source code, which will require\ncollaboration with the application developers. It is recognized that in many\ncases, the database administrator (DBA) is organizationally separate from the\napplication developers and may have limited, if any, access to source code.\nNevertheless, protections of this type are so important to the secure operation\nof databases that they must not be ignored. At a minimum, the DBA must attempt\nto obtain assurances from the development organization that this issue has been\naddressed and must document what has been discovered",
      "descriptions": {
        "default": "With respect to database management systems, one class of threat is\nknown as SQL Injection, or more generally, code injection. It takes advantage\nof the dynamic execution capabilities of various programming languages,\nincluding dialects of SQL. In such cases, the attacker deduces the manner in\nwhich SQL statements are being processed, either from inside knowledge or by\nobserving system behavior in response to invalid inputs. When the attacker\nidentifies scenarios where SQL queries are being assembled by application code\n(which may be within the database or separate from it) and executed\ndynamically, the attacker is then able to craft input strings that subvert the\nintent of the query. Potentially, the attacker can gain unauthorized access to\ndata, including security settings, and severely corrupt or destroy the database.\n\n    The principal protection against code injection is not to use dynamic\nexecution except where it provides necessary functionality that cannot be\nutilized otherwise. Use strongly typed data items rather than general-purpose\nstrings as input parameters to task-specific, pre-compiled stored procedures\nand functions (and triggers).\n\n    When dynamic execution is necessary, ways to mitigate the risk include the\nfollowing, which should be implemented both in the on-screen application and at\nthe database level, in the stored procedures:\n    -- Allow strings as input only when necessary.\n    -- Rely on data typing to validate numbers, dates, etc. Do not accept\ninvalid values. If substituting other values for them, think carefully about\nwhether this could be subverted.\n    -- Limit the size of input strings to what is truly necessary.\n    -- If single quotes/apostrophes, double quotes, semicolons, equals signs,\nangle brackets, or square brackets will never be valid as input, reject them.\n    -- If comment markers will never be valid as input, reject them. In SQL,\nthese are -- or /* */\n    -- If HTML and XML tags, entities, comments, etc., will never be valid,\nreject them.\n    -- If wildcards are present, reject them unless truly necessary. In SQL\nthese are the underscore and the percentage sign, and the word ESCAPE is also a\nclue that wildcards are in use.\n    -- If SQL key words, such as SELECT, INSERT, UPDATE, DELETE, CREATE, ALTER,\nDROP, ESCAPE, UNION, GRANT, REVOKE, DENY, MODIFY will never be valid, reject\nthem. Use case-insensitive comparisons when searching for these. Bear in mind\nthat some of these words, particularly Grant (as a person's name), could also\nbe valid input.\n    -- If there are range limits on the values that may be entered, enforce\nthose limits.\n    -- Institute procedures for inspection of programs for correct use of\ndynamic coding, by a party other than the developer.\n    -- Conduct rigorous testing of program modules that use dynamic coding,\nsearching for ways to subvert the intended use.\n    -- Record the inspection and testing in the system documentation.\n    -- Bear in mind that all this applies not only to screen input, but also to\nthe values in an incoming message to a web service or to a stored procedure\ncalled by a software component that has not itself been hardened in these ways.\nNot only can the caller be subject to such vulnerabilities; it may itself be\nthe attacker.\n\n    This calls for inspection of application source code, which will require\ncollaboration with the application developers. It is recognized that in many\ncases, the database administrator (DBA) is organizationally separate from the\napplication developers and may have limited, if any, access to source code.\nNevertheless, protections of this type are so important to the secure operation\nof databases that they must not be ignored. At a minimum, the DBA must attempt\nto obtain assurances from the development organization that this issue has been\naddressed and must document what has been discovered"
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000251-DB-000392",
        "gid": "V-67395",
        "rid": "SV-81885r2_rule",
        "stig_id": "SQL4-00-031600",
        "fix_id": "F-73507r1_fix",
        "cci": [
          "CCI-001310"
        ],
        "nist": [
          "SI-10",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "Review source code in the database (stored procedures,\nfunctions, triggers) and application source code to identify cases of dynamic\ncode execution.\n\nIf dynamic code execution is employed without protective measures against code\ninjection, this is a finding.",
        "fix": "Where dynamic code execution is used, modify the code to\nimplement protections against code injection."
      },
      "code": "control 'V-67395' do\n  title \"The DBMS and associated applications, when making use of dynamic code\nexecution, must scan input data for invalid values that may indicate a code\ninjection attack.\"\n  desc  \"With respect to database management systems, one class of threat is\nknown as SQL Injection, or more generally, code injection. It takes advantage\nof the dynamic execution capabilities of various programming languages,\nincluding dialects of SQL. In such cases, the attacker deduces the manner in\nwhich SQL statements are being processed, either from inside knowledge or by\nobserving system behavior in response to invalid inputs. When the attacker\nidentifies scenarios where SQL queries are being assembled by application code\n(which may be within the database or separate from it) and executed\ndynamically, the attacker is then able to craft input strings that subvert the\nintent of the query. Potentially, the attacker can gain unauthorized access to\ndata, including security settings, and severely corrupt or destroy the database.\n\n    The principal protection against code injection is not to use dynamic\nexecution except where it provides necessary functionality that cannot be\nutilized otherwise. Use strongly typed data items rather than general-purpose\nstrings as input parameters to task-specific, pre-compiled stored procedures\nand functions (and triggers).\n\n    When dynamic execution is necessary, ways to mitigate the risk include the\nfollowing, which should be implemented both in the on-screen application and at\nthe database level, in the stored procedures:\n    -- Allow strings as input only when necessary.\n    -- Rely on data typing to validate numbers, dates, etc. Do not accept\ninvalid values. If substituting other values for them, think carefully about\nwhether this could be subverted.\n    -- Limit the size of input strings to what is truly necessary.\n    -- If single quotes/apostrophes, double quotes, semicolons, equals signs,\nangle brackets, or square brackets will never be valid as input, reject them.\n    -- If comment markers will never be valid as input, reject them. In SQL,\nthese are -- or /* */\n    -- If HTML and XML tags, entities, comments, etc., will never be valid,\nreject them.\n    -- If wildcards are present, reject them unless truly necessary. In SQL\nthese are the underscore and the percentage sign, and the word ESCAPE is also a\nclue that wildcards are in use.\n    -- If SQL key words, such as SELECT, INSERT, UPDATE, DELETE, CREATE, ALTER,\nDROP, ESCAPE, UNION, GRANT, REVOKE, DENY, MODIFY will never be valid, reject\nthem. Use case-insensitive comparisons when searching for these. Bear in mind\nthat some of these words, particularly Grant (as a person's name), could also\nbe valid input.\n    -- If there are range limits on the values that may be entered, enforce\nthose limits.\n    -- Institute procedures for inspection of programs for correct use of\ndynamic coding, by a party other than the developer.\n    -- Conduct rigorous testing of program modules that use dynamic coding,\nsearching for ways to subvert the intended use.\n    -- Record the inspection and testing in the system documentation.\n    -- Bear in mind that all this applies not only to screen input, but also to\nthe values in an incoming message to a web service or to a stored procedure\ncalled by a software component that has not itself been hardened in these ways.\nNot only can the caller be subject to such vulnerabilities; it may itself be\nthe attacker.\n\n    This calls for inspection of application source code, which will require\ncollaboration with the application developers. It is recognized that in many\ncases, the database administrator (DBA) is organizationally separate from the\napplication developers and may have limited, if any, access to source code.\nNevertheless, protections of this type are so important to the secure operation\nof databases that they must not be ignored. At a minimum, the DBA must attempt\nto obtain assurances from the development organization that this issue has been\naddressed and must document what has been discovered\n  \"\n  impact 0.5\n  tag \"gtitle\": 'SRG-APP-000251-DB-000392'\n  tag \"gid\": 'V-67395'\n  tag \"rid\": 'SV-81885r2_rule'\n  tag \"stig_id\": 'SQL4-00-031600'\n  tag \"fix_id\": 'F-73507r1_fix'\n  tag \"cci\": ['CCI-001310']\n  tag \"nist\": ['SI-10', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"Review source code in the database (stored procedures,\nfunctions, triggers) and application source code to identify cases of dynamic\ncode execution.\n\nIf dynamic code execution is employed without protective measures against code\ninjection, this is a finding.\"\n  tag \"fix\": \"Where dynamic code execution is used, modify the code to\nimplement protections against code injection.\"\n\n  describe 'This test currently has no automated tests, you must check manually' do\n    skip 'This check must be preformed manually'\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67395.rb",
        "line": 1
      },
      "id": "V-67395"
    },
    {
      "title": "SQL Server must implement and/or support cryptographic mechanisms to\nprevent unauthorized modification of organization-defined information at rest\n(to include, at a minimum, PII and classified information) on\norganization-defined information system components.",
      "desc": "Databases holding data requiring \"data at rest\" protections must\nemploy cryptographic mechanisms to prevent unauthorized disclosure and\nmodification of the information at rest. These cryptographic mechanisms may be\nnative to the DBMS or implemented via additional software or operating\nsystem/file system settings, as appropriate to the situation.\n\n    Selection of a cryptographic mechanism is based on the need to protect the\nintegrity of organizational information. The strength of the mechanism is\ncommensurate with the security category and/or classification of the\ninformation. Organizations have the flexibility to either encrypt all\ninformation on storage devices (i.e., full disk encryption) or encrypt specific\ndata structures (e.g., files, records, or fields).\n\n    The decision whether and what to encrypt rests with the data owner and is\nalso influenced by the physical measures taken to secure the equipment and\nmedia on which the information resides.",
      "descriptions": {
        "default": "Databases holding data requiring \"data at rest\" protections must\nemploy cryptographic mechanisms to prevent unauthorized disclosure and\nmodification of the information at rest. These cryptographic mechanisms may be\nnative to the DBMS or implemented via additional software or operating\nsystem/file system settings, as appropriate to the situation.\n\n    Selection of a cryptographic mechanism is based on the need to protect the\nintegrity of organizational information. The strength of the mechanism is\ncommensurate with the security category and/or classification of the\ninformation. Organizations have the flexibility to either encrypt all\ninformation on storage devices (i.e., full disk encryption) or encrypt specific\ndata structures (e.g., files, records, or fields).\n\n    The decision whether and what to encrypt rests with the data owner and is\nalso influenced by the physical measures taken to secure the equipment and\nmedia on which the information resides."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000428-DB-000386",
        "gid": "V-67409",
        "rid": "SV-81899r1_rule",
        "stig_id": "SQL4-00-034700",
        "fix_id": "F-73521r1_fix",
        "cci": [
          "CCI-002475"
        ],
        "nist": [
          "SC-28 (1)",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "Review the system documentation to determine whether the\norganization has defined the information at rest that is to be protected from\nmodification, which must include, at a minimum, PII and classified information.\n\nIf no information is identified as requiring such protection, this is not a\nfinding.\n\nReview the configuration of SQL Server, Windows, and additional software as\nrelevant.\n\nIf full-disk encryption is required, and Windows or the storage system is not\nconfigured for this, this is a finding.\n\nIf database transparent data encryption (TDE) is called for, check whether it\nis enabled:\nIn SQL Server Management Studio, Object Explorer, expand the instance and\nright-click on the database name; select properties.  Select the Options page,\nState section, Encryption Enabled parameter.\n\nIf the value displayed is False, this is a finding.\n\nIf column encryption, done via SQL Server features, is required, review the\ndefinitions and contents of the relevant tables and columns.\n\nIf any of the information defined as requiring cryptographic protection is not\nencrypted in a manner that provides the required level of protection, this is a\nfinding.\n\nSELECT\nDB_NAME(database_id) AS [Database Name], CASE encryption_state WHEN 0 THEN\n'No database encryption key present, no encryption'\nWHEN 1 THEN 'Unencrypted'\nWHEN 2 THEN 'Encryption in progress'\nWHEN 3 THEN 'Encrypted'\nWHEN 4 THEN 'Key change in progress'\nWHEN 5 THEN 'Decryption in progress'\nWHEN 6 THEN 'Protection change in progress'\nEND AS [Encryption State]\nFROM sys.dm_database_encryption_keys\n\nFor each user database for which encryption is called for and it is marked\nUnencrypted, this is a finding.\n\nIf table/column encryption and/or a separation between those who own the data\n(and can view it) and those who manage the data (but should have no access) is\nrequired for PII or similar types of data, use Always Encrypted. The details\nfor configuring Always Encrypted are located here:\nhttps://msdn.microsoft.com/en-us/library/mt163865.aspx.\n\nReview the definitions and contents of the relevant tables/columns for the\nAlways Encryption settings, if any of the information defined as requiring\ncryptographic protection is not encrypted this is a finding.\n",
        "fix": "Where full-disk encryption is required, configure Windows and/or\nthe storage system to provide this.\n\nWhere transparent data encryption (TDE) is required, deploy the necessary stack\nof certificates and keys, and set the Encryption Enabled to True.  For guidance\nfrom the Microsoft Developer Network on how to do this, perform a web search\nfor \"SQL Server 2014 TDE\".\n\nWhere column encryption is required, deploy the necessary stack of certificates\nand keys, and enable encryption on the columns in question.  For guidance from\nthe Microsoft Developer Network on how to do this, perform a web search for\n\"SQL Server 2014 Encrypt a Column of Data\"."
      },
      "code": "control 'V-67409' do\n  title \"SQL Server must implement and/or support cryptographic mechanisms to\nprevent unauthorized modification of organization-defined information at rest\n(to include, at a minimum, PII and classified information) on\norganization-defined information system components.\"\n  desc  \"Databases holding data requiring \\\"data at rest\\\" protections must\nemploy cryptographic mechanisms to prevent unauthorized disclosure and\nmodification of the information at rest. These cryptographic mechanisms may be\nnative to the DBMS or implemented via additional software or operating\nsystem/file system settings, as appropriate to the situation.\n\n    Selection of a cryptographic mechanism is based on the need to protect the\nintegrity of organizational information. The strength of the mechanism is\ncommensurate with the security category and/or classification of the\ninformation. Organizations have the flexibility to either encrypt all\ninformation on storage devices (i.e., full disk encryption) or encrypt specific\ndata structures (e.g., files, records, or fields).\n\n    The decision whether and what to encrypt rests with the data owner and is\nalso influenced by the physical measures taken to secure the equipment and\nmedia on which the information resides.\n  \"\n  impact 0.5\n  tag \"gtitle\": 'SRG-APP-000428-DB-000386'\n  tag \"gid\": 'V-67409'\n  tag \"rid\": 'SV-81899r1_rule'\n  tag \"stig_id\": 'SQL4-00-034700'\n  tag \"fix_id\": 'F-73521r1_fix'\n  tag \"cci\": ['CCI-002475']\n  tag \"nist\": ['SC-28 (1)', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"Review the system documentation to determine whether the\norganization has defined the information at rest that is to be protected from\nmodification, which must include, at a minimum, PII and classified information.\n\nIf no information is identified as requiring such protection, this is not a\nfinding.\n\nReview the configuration of SQL Server, Windows, and additional software as\nrelevant.\n\nIf full-disk encryption is required, and Windows or the storage system is not\nconfigured for this, this is a finding.\n\nIf database transparent data encryption (TDE) is called for, check whether it\nis enabled:\nIn SQL Server Management Studio, Object Explorer, expand the instance and\nright-click on the database name; select properties.  Select the Options page,\nState section, Encryption Enabled parameter.\n\nIf the value displayed is False, this is a finding.\n\nIf column encryption, done via SQL Server features, is required, review the\ndefinitions and contents of the relevant tables and columns.\n\nIf any of the information defined as requiring cryptographic protection is not\nencrypted in a manner that provides the required level of protection, this is a\nfinding.\n\nSELECT\nDB_NAME(database_id) AS [Database Name], CASE encryption_state WHEN 0 THEN\n'No database encryption key present, no encryption'\nWHEN 1 THEN 'Unencrypted'\nWHEN 2 THEN 'Encryption in progress'\nWHEN 3 THEN 'Encrypted'\nWHEN 4 THEN 'Key change in progress'\nWHEN 5 THEN 'Decryption in progress'\nWHEN 6 THEN 'Protection change in progress'\nEND AS [Encryption State]\nFROM sys.dm_database_encryption_keys\n\nFor each user database for which encryption is called for and it is marked\nUnencrypted, this is a finding.\n\nIf table/column encryption and/or a separation between those who own the data\n(and can view it) and those who manage the data (but should have no access) is\nrequired for PII or similar types of data, use Always Encrypted. The details\nfor configuring Always Encrypted are located here:\nhttps://msdn.microsoft.com/en-us/library/mt163865.aspx.\n\nReview the definitions and contents of the relevant tables/columns for the\nAlways Encryption settings, if any of the information defined as requiring\ncryptographic protection is not encrypted this is a finding.\n\"\n  tag \"fix\": \"Where full-disk encryption is required, configure Windows and/or\nthe storage system to provide this.\n\nWhere transparent data encryption (TDE) is required, deploy the necessary stack\nof certificates and keys, and set the Encryption Enabled to True.  For guidance\nfrom the Microsoft Developer Network on how to do this, perform a web search\nfor \\\"SQL Server 2014 TDE\\\".\n\nWhere column encryption is required, deploy the necessary stack of certificates\nand keys, and enable encryption on the columns in question.  For guidance from\nthe Microsoft Developer Network on how to do this, perform a web search for\n\\\"SQL Server 2014 Encrypt a Column of Data\\\".\"\n\n  data_at_rest_encryption_required = attribute('data_at_rest_encryption_required')\n\n  query = %{\n    SELECT\n          d.name AS [Database Name],\n          CASE e.encryption_state\n                WHEN 0 THEN 'No database encryption key present, no encryption'\n                WHEN 1 THEN 'Unencrypted'\n                WHEN 2 THEN 'Encryption in progress'\n                WHEN 3 THEN 'Encrypted'\n                WHEN 4 THEN 'Key change in progress'\n                WHEN 5 THEN 'Decryption in progress'\n                WHEN 6 THEN 'Protection change in progress'\n          END AS [Encryption State]\n    FROM sys.dm_database_encryption_keys e\n    RIGHT JOIN sys.databases d ON DB_NAME(e.database_id) = d.name\n    WHERE d.name IN ('#{attribute('db_name')}')\n  }\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n\n  unless data_at_rest_encryption_required\n    impact 0.0\n    desc 'If the application owner and Authorizing Official have\n    determined that encryption of data at rest is NOT required, this is not a\n    finding.'\n  end\n\n  describe \"Database: #{attribute('db_name')} encryption state\" do\n    subject { sql_session.query(query).column('encryption state').uniq }\n    it { should cmp 'Encrypted' }\n  end\n\n  describe 'The following checks must be preformed manually' do\n    skip \"The following checks must be preformed manually:\n      If full-disk encryption is required, and Windows or the storage system is not\n      configured for this, this is a finding.\n\n      If database transparent data encryption (TDE) is called for, check whether it\n      is enabled:\n      In SQL Server Management Studio, Object Explorer, expand the instance and\n      right-click on the database name; select properties.  Select the Options page,\n      State section, Encryption Enabled parameter.\n\n      If the value displayed is False, this is a finding.\n\n      If column encryption, done via SQL Server features, is required, review the\n      definitions and contents of the relevant tables and columns.\n\n      If any of the information defined as requiring cryptographic protection is not\n      encrypted in a manner that provides the required level of protection, this is a\n      finding.\n\n      If table/column encryption and/or a separation between those who own the data\n      (and can view it) and those who manage the data (but should have no access) is\n      required for PII or similar types of data, use Always Encrypted. The details\n      for configuring Always Encrypted are located here:\n      https://msdn.microsoft.com/en-us/library/mt163865.aspx.\n\n      Review the definitions and contents of the relevant tables/columns for the\n      Always Encryption settings, if any of the information defined as requiring\n      cryptographic protection is not encrypted this is a finding.\"\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67409.rb",
        "line": 1
      },
      "id": "V-67409"
    },
    {
      "title": "The Database Master Key must be encrypted by the Service Master Key,\nwhere a Database Master Key is required and another encryption method has not\nbeen specified.",
      "desc": "When not encrypted by the Service Master Key, system administrators or\napplication administrators may access and use the Database Master Key to view\nsensitive data that they are not authorized to view. Where alternate encryption\nmeans are not feasible, encryption by the Service Master Key may be necessary.\nTo help protect sensitive data from unauthorized access by DBAs, mitigations\nmay be in order. Mitigations may include automatic alerts or other audit events\nwhen the Database Master Key is accessed outside of the application or by a DBA\naccount.",
      "descriptions": {
        "default": "When not encrypted by the Service Master Key, system administrators or\napplication administrators may access and use the Database Master Key to view\nsensitive data that they are not authorized to view. Where alternate encryption\nmeans are not feasible, encryption by the Service Master Key may be necessary.\nTo help protect sensitive data from unauthorized access by DBAs, mitigations\nmay be in order. Mitigations may include automatic alerts or other audit events\nwhen the Database Master Key is accessed outside of the application or by a DBA\naccount."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000231-DB-000154",
        "gid": "V-67381",
        "rid": "SV-81871r1_rule",
        "stig_id": "SQL4-00-024100",
        "fix_id": "F-73493r1_fix",
        "cci": [
          "CCI-001199"
        ],
        "nist": [
          "SC-28",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "If no databases require encryption, this is not a finding.\n\nFrom the query prompt:\nSELECT name\nFROM [master].sys.databases\nWHERE is_master_key_encrypted_by_server = 1\nAND owner_sid <> 1\nAND state = 0;\n(Note that this query assumes that the [sa] account is not used as the owner of\napplication databases, in keeping with other STIG guidance.  If this is not the\ncase, modify the query accordingly.)\n\nIf no databases are returned by the query, this is not a finding.\n\nFor any databases returned, verify in the System Security Plan that encryption\nof the Database Master Key using the Service Master Key is acceptable and\napproved by the Information Owner, and the encrypted data does not require\nadditional protections to deter or detect DBA access. If not approved, this is\na finding.\n\nIf approved and additional protections are required, then verify the additional\nrequirements are in place in accordance with the System Security Plan. These\nmay include additional auditing on access of the Database Master Key with\nalerts or other automated monitoring.\n\nIf the additional requirements are not in place, this is a finding.",
        "fix": "Where possible, encrypt the Database Master Key with a password\nknown only to the application administrator.  Where not possible, configure\nadditional audit events or alerts to detect unauthorized access to the Database\nMaster Key by users not authorized to view sensitive data."
      },
      "code": "control 'V-67381' do\n  title \"The Database Master Key must be encrypted by the Service Master Key,\nwhere a Database Master Key is required and another encryption method has not\nbeen specified.\"\n  desc  \"When not encrypted by the Service Master Key, system administrators or\napplication administrators may access and use the Database Master Key to view\nsensitive data that they are not authorized to view. Where alternate encryption\nmeans are not feasible, encryption by the Service Master Key may be necessary.\nTo help protect sensitive data from unauthorized access by DBAs, mitigations\nmay be in order. Mitigations may include automatic alerts or other audit events\nwhen the Database Master Key is accessed outside of the application or by a DBA\naccount.\"\n  impact 0.5\n  tag \"gtitle\": 'SRG-APP-000231-DB-000154'\n  tag \"gid\": 'V-67381'\n  tag \"rid\": 'SV-81871r1_rule'\n  tag \"stig_id\": 'SQL4-00-024100'\n  tag \"fix_id\": 'F-73493r1_fix'\n  tag \"cci\": ['CCI-001199']\n  tag \"nist\": ['SC-28', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"If no databases require encryption, this is not a finding.\n\nFrom the query prompt:\nSELECT name\nFROM [master].sys.databases\nWHERE is_master_key_encrypted_by_server = 1\nAND owner_sid <> 1\nAND state = 0;\n(Note that this query assumes that the [sa] account is not used as the owner of\napplication databases, in keeping with other STIG guidance.  If this is not the\ncase, modify the query accordingly.)\n\nIf no databases are returned by the query, this is not a finding.\n\nFor any databases returned, verify in the System Security Plan that encryption\nof the Database Master Key using the Service Master Key is acceptable and\napproved by the Information Owner, and the encrypted data does not require\nadditional protections to deter or detect DBA access. If not approved, this is\na finding.\n\nIf approved and additional protections are required, then verify the additional\nrequirements are in place in accordance with the System Security Plan. These\nmay include additional auditing on access of the Database Master Key with\nalerts or other automated monitoring.\n\nIf the additional requirements are not in place, this is a finding.\"\n  tag \"fix\": \"Where possible, encrypt the Database Master Key with a password\nknown only to the application administrator.  Where not possible, configure\nadditional audit events or alerts to detect unauthorized access to the Database\nMaster Key by users not authorized to view sensitive data.\"\n\n  query = %{\n    SELECT NAME\n    FROM   [master].sys.databases\n    WHERE  is_master_key_encrypted_by_server = 1\n           AND owner_sid <> 1\n           AND state = 0\n           AND name = '#{attribute('db_name')}';\n  }\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n\n  results = sql_session.query(query)\n\n  if results.empty?\n    impact 0.0\n    desc 'No databases require encryption hence this is not a finding'\n  end\n\n  describe 'The following checks must be preformed manually' do\n    skip \"The following checks must be preformed manually:\n    For the database #{results.column('name')} verify in the System Security\n    Plan that encryption of the Database Master Key using the Service Master Key\n    is acceptable and approved by the Information Owner, and the encrypted data\n    does not require additional protections to deter or detect DBA access.\n    If not approved, this is a finding.\n\n    If approved and additional protections are required, then verify the additional\n    requirements are in place in accordance with the System Security Plan. These\n    may include additional auditing on access of the Database Master Key with\n    alerts or other automated monitoring.\n\n    If the additional requirements are not in place, this is a finding.\"\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67381.rb",
        "line": 1
      },
      "id": "V-67381"
    },
    {
      "title": "SQL Server must generate Trace or Audit records when unsuccessful\nattempts to modify privileges/permissions via locally-defined security objects\noccur.",
      "desc": "Failed attempts to change the permissions, privileges, and roles\ngranted to users and roles must be tracked. Without an audit trail,\nunauthorized attempts to elevate or restrict privileges could go undetected.\n\n    In SQL Server, there is no distinction between modification of permissions\nand granting or dropping them.  However, native SQL Server security\nfunctionality may be supplemented with application-specific tables and logic,\nin which case the following actions on these tables and\nprocedures/triggers/functions are also relevant:\n    UPDATE\n    EXECUTE\n\n    To aid in diagnosis, it is necessary to keep track of failed attempts in\naddition to the successful ones.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    Use of SQL Server Audit's SCHEMA_OBJECT_ACCESS_GROUP causes capture of all\naccesses, successful and otherwise, to the system views (and all other\nschema-scoped objects).  The [Succeeded] column in the audit output indicates\nthe success or failure of the attempted action.  Be aware, however, that it may\nreport True in some cases where one would intuitively expect False.  For\nexample, SELECT 1/0 FROM SYS.ALL_OBJECTS will appear in the audit trail as\nsuccessful, if the user has permission to perform that action, even though it\ncontains an invalid expression.  Some other actions that one would consider\nfailures (such as selecting from a table that does not exist) may not appear at\nall.",
      "descriptions": {
        "default": "Failed attempts to change the permissions, privileges, and roles\ngranted to users and roles must be tracked. Without an audit trail,\nunauthorized attempts to elevate or restrict privileges could go undetected.\n\n    In SQL Server, there is no distinction between modification of permissions\nand granting or dropping them.  However, native SQL Server security\nfunctionality may be supplemented with application-specific tables and logic,\nin which case the following actions on these tables and\nprocedures/triggers/functions are also relevant:\n    UPDATE\n    EXECUTE\n\n    To aid in diagnosis, it is necessary to keep track of failed attempts in\naddition to the successful ones.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    Use of SQL Server Audit's SCHEMA_OBJECT_ACCESS_GROUP causes capture of all\naccesses, successful and otherwise, to the system views (and all other\nschema-scoped objects).  The [Succeeded] column in the audit output indicates\nthe success or failure of the attempted action.  Be aware, however, that it may\nreport True in some cases where one would intuitively expect False.  For\nexample, SELECT 1/0 FROM SYS.ALL_OBJECTS will appear in the audit trail as\nsuccessful, if the user has permission to perform that action, even though it\ncontains an invalid expression.  Some other actions that one would consider\nfailures (such as selecting from a table that does not exist) may not appear at\nall."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000495-DB-000329",
        "gid": "V-67419",
        "rid": "SV-81909r2_rule",
        "stig_id": "SQL4-00-036300",
        "fix_id": "F-73533r1_fix",
        "cci": [
          "CCI-000172"
        ],
        "nist": [
          "AU-12 c",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "Obtain the list of locally-defined security tables, procedures\nand functions that require tracking.  If there are none, this is not a finding.\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes,\nthis is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the locally-defined\nsecurity tables for the existence of triggers to raise a custom event on each\nUpdate operation.  If such triggers are not present, this is a finding.\n\nVerify  that all required events are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no\ntraces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing\nrequirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is\na finding:\n\n42  -- SP:Starting\n43  -- SP:Completed\n82-91  -- User-defined Event\n162  -- User error message\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nVerify that all EXECUTE actions on locally-defined permissions-related\nprocedures are being audited.  If not, this is a finding.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the broad, server-level audit action group\nSCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility\nmakes other techniques possible.  If an alternative technique is in use and\ndemonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their\nnames.\n\nRun the following to verify that all UPDATE and EXECUTE actions on any\nlocally-defined permissions tables, procedures and functions are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"FAILURE\" or \"SUCCESS AND FAILURE\",\nthis is a finding.",
        "fix": "Where SQL Server Trace is in use, define  and enable a trace that\ncaptures all auditable events.  The script provided in the supplemental file\nTrace.sql can be used to do this.\n\nAdd blocks of code to Trace.sql for each custom event class (integers in the\nrange 82-91; the same event class may be used for all such triggers) used in\nthese triggers.\n\nCreate triggers to raise a custom event on each locally-defined security table\nthat requires tracking of Insert-Update-Delete operations.  The examples\nprovided in the supplemental file CustomTraceEvents.sql can serve as the basis\nfor these.\n\nExecute Trace.sql.\n\nWhere SQL Server Audit is in use, design and deploy a SQL Server Audit that\ncaptures all auditable events.  The script provided in the supplemental file\nAudit.sql can be used for this.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO"
      },
      "code": "control 'V-67419' do\n  title \"SQL Server must generate Trace or Audit records when unsuccessful\nattempts to modify privileges/permissions via locally-defined security objects\noccur.\"\n  desc  \"Failed attempts to change the permissions, privileges, and roles\ngranted to users and roles must be tracked. Without an audit trail,\nunauthorized attempts to elevate or restrict privileges could go undetected.\n\n    In SQL Server, there is no distinction between modification of permissions\nand granting or dropping them.  However, native SQL Server security\nfunctionality may be supplemented with application-specific tables and logic,\nin which case the following actions on these tables and\nprocedures/triggers/functions are also relevant:\n    UPDATE\n    EXECUTE\n\n    To aid in diagnosis, it is necessary to keep track of failed attempts in\naddition to the successful ones.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    Use of SQL Server Audit's SCHEMA_OBJECT_ACCESS_GROUP causes capture of all\naccesses, successful and otherwise, to the system views (and all other\nschema-scoped objects).  The [Succeeded] column in the audit output indicates\nthe success or failure of the attempted action.  Be aware, however, that it may\nreport True in some cases where one would intuitively expect False.  For\nexample, SELECT 1/0 FROM SYS.ALL_OBJECTS will appear in the audit trail as\nsuccessful, if the user has permission to perform that action, even though it\ncontains an invalid expression.  Some other actions that one would consider\nfailures (such as selecting from a table that does not exist) may not appear at\nall.\n  \"\n  impact 0.5\n  tag \"gtitle\": 'SRG-APP-000495-DB-000329'\n  tag \"gid\": 'V-67419'\n  tag \"rid\": 'SV-81909r2_rule'\n  tag \"stig_id\": 'SQL4-00-036300'\n  tag \"fix_id\": 'F-73533r1_fix'\n  tag \"cci\": ['CCI-000172']\n  tag \"nist\": ['AU-12 c', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"Obtain the list of locally-defined security tables, procedures\nand functions that require tracking.  If there are none, this is not a finding.\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes,\nthis is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the locally-defined\nsecurity tables for the existence of triggers to raise a custom event on each\nUpdate operation.  If such triggers are not present, this is a finding.\n\nVerify  that all required events are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no\ntraces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing\nrequirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is\na finding:\n\n42  -- SP:Starting\n43  -- SP:Completed\n82-91  -- User-defined Event\n162  -- User error message\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nVerify that all EXECUTE actions on locally-defined permissions-related\nprocedures are being audited.  If not, this is a finding.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the broad, server-level audit action group\nSCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility\nmakes other techniques possible.  If an alternative technique is in use and\ndemonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\n\nAlternatively, review the contents of the system views with \\\"audit\\\" in their\nnames.\n\nRun the following to verify that all UPDATE and EXECUTE actions on any\nlocally-defined permissions tables, procedures and functions are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \\\"FAILURE\\\" or \\\"SUCCESS AND FAILURE\\\",\nthis is a finding.\"\n  tag \"fix\": \"Where SQL Server Trace is in use, define  and enable a trace that\ncaptures all auditable events.  The script provided in the supplemental file\nTrace.sql can be used to do this.\n\nAdd blocks of code to Trace.sql for each custom event class (integers in the\nrange 82-91; the same event class may be used for all such triggers) used in\nthese triggers.\n\nCreate triggers to raise a custom event on each locally-defined security table\nthat requires tracking of Insert-Update-Delete operations.  The examples\nprovided in the supplemental file CustomTraceEvents.sql can serve as the basis\nfor these.\n\nExecute Trace.sql.\n\nWhere SQL Server Audit is in use, design and deploy a SQL Server Audit that\ncaptures all auditable events.  The script provided in the supplemental file\nAudit.sql can be used for this.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO\"\n\n  query_traces = %{\n    SELECT * FROM sys.traces\n  }\n  query_trace_eventinfo = %{\n    SELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(%<trace_id>s);\n  }\n\n  query_audits = %{\n    SELECT server_specification_id,\n           audit_action_name,\n           audited_result\n    FROM   sys.server_audit_specification_details\n    WHERE  audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n  }\n\n  server_trace_implemented = attribute('server_trace_implemented')\n  server_audit_implemented = attribute('server_audit_implemented')\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n\n  describe.one do\n    describe 'SQL Server Trace is in use for audit purposes' do\n      subject { server_trace_implemented }\n      it { should be true }\n    end\n\n    describe 'SQL Server Audit is in use for audit purposes' do\n      subject { server_audit_implemented }\n      it { should be true }\n    end\n  end\n\n  if server_trace_implemented\n    describe 'List defined traces for the SQL server instance' do\n      subject { sql_session.query(query_traces) }\n      it { should_not be_empty }\n    end\n\n    trace_ids = sql_session.query(query_traces).column('id')\n    describe.one do\n      trace_ids.each do |trace_id|\n        found_events = sql_session.query(format(query_trace_eventinfo, trace_id: trace_id)).column('eventid')\n        describe \"EventsIDs in Trace ID:#{trace_id}\" do\n          subject { found_events }\n          it { should include '42' }\n          it { should include '43' }\n          its('to_s') { should match /\"82\"|\"83\"|\"84\"|\"85\"|\"86\"|\"87\"|\"88\"|\"89\"|\"90\"|\"91\"/ }\n          it { should include '162' }\n        end\n      end\n    end\n  end\n\n  if server_audit_implemented\n    describe 'SQL Server Audit:' do\n      describe 'Defined Audits with Audit Action SCHEMA_OBJECT_ACCESS_GROUP' do\n        subject { sql_session.query(query_audits) }\n        it { should_not be_empty }\n      end\n      describe 'Audited Result for Defined Audit Actions' do\n        subject { sql_session.query(query_audits).column('audited_result').uniq.to_s }\n        it { should match /SUCCESS AND FAILURE|FAILURE/ }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67419.rb",
        "line": 1
      },
      "id": "V-67419"
    },
    {
      "title": "SQL Server must be monitored to discover unauthorized changes to\nstored procedures.",
      "desc": "When dealing with change control issues, it should be noted, any\nchanges to the hardware, software, and/or firmware components of SQL Server\nand/or application can potentially have significant effects on the overall\nsecurity of the system.\n\n    If SQL Server were to allow any user to make changes to software libraries,\nthen those changes might be implemented without undergoing the appropriate\ntesting and approvals that are part of a robust change management process.\n\n    This requirement is contingent upon the language in which the application\nis programmed, as many application architectures in use today incorporate their\nsoftware libraries into, and make them inseparable from, their compiled\ndistributions, rendering them static and version-dependent. However, this\nrequirement does apply to applications with software libraries accessible and\nconfigurable, as in the case of interpreted languages.\n\n    Accordingly, only qualified and authorized individuals shall be allowed to\nobtain access to SQL Server components for purposes of initiating changes,\nincluding upgrades and modifications.\n\n    Unmanaged changes that occur to the SQL Server software libraries or\nconfiguration, such as Stored Procedures, can lead to unauthorized or\ncompromised installations.",
      "descriptions": {
        "default": "When dealing with change control issues, it should be noted, any\nchanges to the hardware, software, and/or firmware components of SQL Server\nand/or application can potentially have significant effects on the overall\nsecurity of the system.\n\n    If SQL Server were to allow any user to make changes to software libraries,\nthen those changes might be implemented without undergoing the appropriate\ntesting and approvals that are part of a robust change management process.\n\n    This requirement is contingent upon the language in which the application\nis programmed, as many application architectures in use today incorporate their\nsoftware libraries into, and make them inseparable from, their compiled\ndistributions, rendering them static and version-dependent. However, this\nrequirement does apply to applications with software libraries accessible and\nconfigurable, as in the case of interpreted languages.\n\n    Accordingly, only qualified and authorized individuals shall be allowed to\nobtain access to SQL Server components for purposes of initiating changes,\nincluding upgrades and modifications.\n\n    Unmanaged changes that occur to the SQL Server software libraries or\nconfiguration, such as Stored Procedures, can lead to unauthorized or\ncompromised installations."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000133-DB-000179",
        "gid": "V-67369",
        "rid": "SV-81859r2_rule",
        "stig_id": "SQL4-00-015200",
        "fix_id": "F-73481r3_fix",
        "cci": [
          "CCI-001499"
        ],
        "nist": [
          "CM-5 (6)",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "Check for the existence of a job to monitor for changes to\nstored procedures:\nEXEC msdb.dbo.sp_help_job @job_name = '<enter . . . job name>';\n\n(Alternatively, in SQL Server Management Studio, navigate to SQL Server Agent\nand examine the job from there.)\n\nIf such a job, or an alternative method of monitoring stored procedures for\nmodification, does not exist, this is a finding.",
        "fix": "Configure a SQL Server timed job that automatically checks all\nsystem and user-defined Stored Procedures for modification.\n\n(The supplemental file Track.sql, provided with this STIG, can be used to\nestablish a monitoring job.  This should be supplemented with a process for\ninforming the appropriate personnel.  Other techniques for achieving the same\nends, such as the use of DDL triggers, are acceptable.)"
      },
      "code": "control 'V-67369' do\n  title \"SQL Server must be monitored to discover unauthorized changes to\nstored procedures.\"\n  desc  \"When dealing with change control issues, it should be noted, any\nchanges to the hardware, software, and/or firmware components of SQL Server\nand/or application can potentially have significant effects on the overall\nsecurity of the system.\n\n    If SQL Server were to allow any user to make changes to software libraries,\nthen those changes might be implemented without undergoing the appropriate\ntesting and approvals that are part of a robust change management process.\n\n    This requirement is contingent upon the language in which the application\nis programmed, as many application architectures in use today incorporate their\nsoftware libraries into, and make them inseparable from, their compiled\ndistributions, rendering them static and version-dependent. However, this\nrequirement does apply to applications with software libraries accessible and\nconfigurable, as in the case of interpreted languages.\n\n    Accordingly, only qualified and authorized individuals shall be allowed to\nobtain access to SQL Server components for purposes of initiating changes,\nincluding upgrades and modifications.\n\n    Unmanaged changes that occur to the SQL Server software libraries or\nconfiguration, such as Stored Procedures, can lead to unauthorized or\ncompromised installations.\n  \"\n  impact 0.5\n  tag \"gtitle\": 'SRG-APP-000133-DB-000179'\n  tag \"gid\": 'V-67369'\n  tag \"rid\": 'SV-81859r2_rule'\n  tag \"stig_id\": 'SQL4-00-015200'\n  tag \"fix_id\": 'F-73481r3_fix'\n  tag \"cci\": ['CCI-001499']\n  tag \"nist\": ['CM-5 (6)', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"Check for the existence of a job to monitor for changes to\nstored procedures:\nEXEC msdb.dbo.sp_help_job @job_name = '<enter . . . job name>';\n\n(Alternatively, in SQL Server Management Studio, navigate to SQL Server Agent\nand examine the job from there.)\n\nIf such a job, or an alternative method of monitoring stored procedures for\nmodification, does not exist, this is a finding.\"\n  tag \"fix\": \"Configure a SQL Server timed job that automatically checks all\nsystem and user-defined Stored Procedures for modification.\n\n(The supplemental file Track.sql, provided with this STIG, can be used to\nestablish a monitoring job.  This should be supplemented with a process for\ninforming the appropriate personnel.  Other techniques for achieving the same\nends, such as the use of DDL triggers, are acceptable.)\"\n\n  query = %{\n    SELECT enabled\n    FROM   msdb.dbo.sysjobs\n    WHERE  [name] = '%<job_name>s'\n  }\n\n  job_name = attribute('track_stored_procedures_changes_job_name')\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n\n  describe \"Scheduled job: #{job_name} enabled status\" do\n    subject { sql_session.query(format(query, job_name: job_name)).column('enabled') }\n    it { should cmp 1 }\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67369.rb",
        "line": 1
      },
      "id": "V-67369"
    },
    {
      "title": "Trace or Audit records must be generated when unsuccessful attempts to\ndelete categorized information (e.g., classification levels/security levels)\noccur.",
      "desc": "Changes in categorized information must be tracked. Without an audit\ntrail, unauthorized access to protected data could go undetected.\n\n    To aid in diagnosis, it is necessary to keep track of failed attempts in\naddition to the successful ones.\n\n    For detailed information on categorizing information, refer to FIPS\nPublication 199, Standards for Security Categorization of Federal Information\nand Information Systems, and FIPS Publication 200, Minimum Security\nRequirements for Federal Information and Information Systems.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    Since Trace does not provide for tracking SELECT statements, it is\nnecessary to provide that part of the tracking at the application level.\nBecause of this, it may also be appropriate to audit DELETE actions at the\napplication level.  However, to capture all DELETEs, whether they come from the\napplication or bypass it, the Trace must be configured to cover them.\n\n    Use of SQL Server Audit's SCHEMA_OBJECT_ACCESS_GROUP causes capture of all\naccesses, successful and otherwise, to all schema-scoped objects.  The\n[Succeeded] column in the audit output indicates the success or failure of the\nattempted action.  Be aware, however, that it may report True in some cases\nwhere one would intuitively expect False.  For example, SELECT 1/0 FROM\nSYS.ALL_OBJECTS will appear in the audit trail as successful, if the user has\npermission to perform that action, even though it contains an invalid\nexpression.  Some other actions that one would consider failures (such as\nselecting from a table that does not exist) may not appear at all.",
      "descriptions": {
        "default": "Changes in categorized information must be tracked. Without an audit\ntrail, unauthorized access to protected data could go undetected.\n\n    To aid in diagnosis, it is necessary to keep track of failed attempts in\naddition to the successful ones.\n\n    For detailed information on categorizing information, refer to FIPS\nPublication 199, Standards for Security Categorization of Federal Information\nand Information Systems, and FIPS Publication 200, Minimum Security\nRequirements for Federal Information and Information Systems.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    Since Trace does not provide for tracking SELECT statements, it is\nnecessary to provide that part of the tracking at the application level.\nBecause of this, it may also be appropriate to audit DELETE actions at the\napplication level.  However, to capture all DELETEs, whether they come from the\napplication or bypass it, the Trace must be configured to cover them.\n\n    Use of SQL Server Audit's SCHEMA_OBJECT_ACCESS_GROUP causes capture of all\naccesses, successful and otherwise, to all schema-scoped objects.  The\n[Succeeded] column in the audit output indicates the success or failure of the\nattempted action.  Be aware, however, that it may report True in some cases\nwhere one would intuitively expect False.  For example, SELECT 1/0 FROM\nSYS.ALL_OBJECTS will appear in the audit trail as successful, if the user has\npermission to perform that action, even though it contains an invalid\nexpression.  Some other actions that one would consider failures (such as\nselecting from a table that does not exist) may not appear at all."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000502-DB-000349",
        "gid": "V-67427",
        "rid": "SV-81917r2_rule",
        "stig_id": "SQL4-00-037400",
        "fix_id": "F-73541r1_fix",
        "cci": [
          "CCI-000172"
        ],
        "nist": [
          "AU-12 c",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "Review the system documentation to determine whether it is\nrequired to track categories of information, such as classification or\nsensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes,\nthis is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the Trace settings,\nand the triggers on the tables holding categorized information, to determine\nwhether all DELETE actions on these tables are traced, including failed\nattempts.  If not, this is a finding.\n\nCheck to see that all required event classes are being audited.  From the query\nprompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no\ntraces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing\nrequirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is\na finding:\n\n82-91  -- User-defined Event (at least one of these, matching the triggers; 90\nis used in the supplied script)\n162 -- User error message\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the broad, server-level audit action group\nSCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility\nmakes other techniques possible.  If an alternative technique is in use and\ndemonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their\nnames.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions\non tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"FAILURE\" or \"SUCCESS AND FAILURE\",\nthis is a finding.",
        "fix": "Where SQL Server Trace is in use, create triggers to raise a\ncustom event for DELETEs on each table holding categorized information.  The\nexamples provided in the supplemental file CustomTraceEvents.sql can serve as\nthe basis for these.\n\nAdd a block of code to the supplemental file Trace.sql for each custom event\nclass (integers in the range 82-91; the same event class may be used for all\nsuch triggers) used in these triggers.  Execute Trace.sql.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all\nauditable events and data items.  The script provided in the supplemental file\nAudit.sql can be used as the basis for this.  Supplement the standard audit\ndata as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO"
      },
      "code": "control 'V-67427' do\n  title \"Trace or Audit records must be generated when unsuccessful attempts to\ndelete categorized information (e.g., classification levels/security levels)\noccur.\"\n  desc  \"Changes in categorized information must be tracked. Without an audit\ntrail, unauthorized access to protected data could go undetected.\n\n    To aid in diagnosis, it is necessary to keep track of failed attempts in\naddition to the successful ones.\n\n    For detailed information on categorizing information, refer to FIPS\nPublication 199, Standards for Security Categorization of Federal Information\nand Information Systems, and FIPS Publication 200, Minimum Security\nRequirements for Federal Information and Information Systems.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    Since Trace does not provide for tracking SELECT statements, it is\nnecessary to provide that part of the tracking at the application level.\nBecause of this, it may also be appropriate to audit DELETE actions at the\napplication level.  However, to capture all DELETEs, whether they come from the\napplication or bypass it, the Trace must be configured to cover them.\n\n    Use of SQL Server Audit's SCHEMA_OBJECT_ACCESS_GROUP causes capture of all\naccesses, successful and otherwise, to all schema-scoped objects.  The\n[Succeeded] column in the audit output indicates the success or failure of the\nattempted action.  Be aware, however, that it may report True in some cases\nwhere one would intuitively expect False.  For example, SELECT 1/0 FROM\nSYS.ALL_OBJECTS will appear in the audit trail as successful, if the user has\npermission to perform that action, even though it contains an invalid\nexpression.  Some other actions that one would consider failures (such as\nselecting from a table that does not exist) may not appear at all.\n  \"\n  if attribute('server_trace_or_audit_required')\n    impact 0.5\n  else\n    impact 0.0\n    desc 'Inspec attributes has specified that is not required to track categories\n    of information, such as classification or sensitivity level on the target'\n  end\n\n  tag \"gtitle\": 'SRG-APP-000502-DB-000349'\n  tag \"gid\": 'V-67427'\n  tag \"rid\": 'SV-81917r2_rule'\n  tag \"stig_id\": 'SQL4-00-037400'\n  tag \"fix_id\": 'F-73541r1_fix'\n  tag \"cci\": ['CCI-000172']\n  tag \"nist\": ['AU-12 c', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"Review the system documentation to determine whether it is\nrequired to track categories of information, such as classification or\nsensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes,\nthis is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the Trace settings,\nand the triggers on the tables holding categorized information, to determine\nwhether all DELETE actions on these tables are traced, including failed\nattempts.  If not, this is a finding.\n\nCheck to see that all required event classes are being audited.  From the query\nprompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no\ntraces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing\nrequirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is\na finding:\n\n82-91  -- User-defined Event (at least one of these, matching the triggers; 90\nis used in the supplied script)\n162 -- User error message\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the broad, server-level audit action group\nSCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility\nmakes other techniques possible.  If an alternative technique is in use and\ndemonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\n\nAlternatively, review the contents of the system views with \\\"audit\\\" in their\nnames.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions\non tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \\\"FAILURE\\\" or \\\"SUCCESS AND FAILURE\\\",\nthis is a finding.\"\n  tag \"fix\": \"Where SQL Server Trace is in use, create triggers to raise a\ncustom event for DELETEs on each table holding categorized information.  The\nexamples provided in the supplemental file CustomTraceEvents.sql can serve as\nthe basis for these.\n\nAdd a block of code to the supplemental file Trace.sql for each custom event\nclass (integers in the range 82-91; the same event class may be used for all\nsuch triggers) used in these triggers.  Execute Trace.sql.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all\nauditable events and data items.  The script provided in the supplemental file\nAudit.sql can be used as the basis for this.  Supplement the standard audit\ndata as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO\"\n\n  query_traces = %{\n    SELECT * FROM sys.traces\n  }\n  query_trace_eventinfo = %{\n    SELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(%<trace_id>s);\n  }\n\n  query_audits = %{\n    SELECT server_specification_id,\n           audit_action_name,\n           audited_result\n    FROM   sys.server_audit_specification_details\n    WHERE  audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n  }\n\n  server_trace_implemented = attribute('server_trace_implemented')\n  server_audit_implemented = attribute('server_audit_implemented')\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n\n  describe.one do\n    describe 'SQL Server Trace is in use for audit purposes' do\n      subject { server_trace_implemented }\n      it { should be true }\n    end\n\n    describe 'SQL Server Audit is in use for audit purposes' do\n      subject { server_audit_implemented }\n      it { should be true }\n    end\n  end\n\n  if server_trace_implemented\n    describe 'List defined traces for the SQL server instance' do\n      subject { sql_session.query(query_traces) }\n      it { should_not be_empty }\n    end\n\n    trace_ids = sql_session.query(query_traces).column('id')\n    describe.one do\n      trace_ids.each do |trace_id|\n        found_events = sql_session.query(format(query_trace_eventinfo, trace_id: trace_id)).column('eventid')\n        describe \"EventsIDs in Trace ID:#{trace_id}\" do\n          subject { found_events }\n          its('to_s') { should match /\"82\"|\"83\"|\"84\"|\"85\"|\"86\"|\"87\"|\"88\"|\"89\"|\"90\"|\"91\"/ }\n          it { should include '162' }\n        end\n      end\n    end\n  end\n\n  if server_audit_implemented\n    describe 'SQL Server Audit:' do\n      describe 'Defined Audits with Audit Action SCHEMA_OBJECT_ACCESS_GROUP' do\n        subject { sql_session.query(query_audits) }\n        it { should_not be_empty }\n      end\n      describe 'Audited Result for Defined Audit Actions' do\n        subject { sql_session.query(query_audits).column('audited_result').uniq.to_s }\n        it { should match /SUCCESS AND FAILURE|FAILURE/ }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67427.rb",
        "line": 1
      },
      "id": "V-67427"
    },
    {
      "title": "When invalid inputs are received, SQL Server must behave in a\npredictable and documented manner that reflects organizational and system\nobjectives.",
      "desc": "A common vulnerability is unplanned behavior when invalid inputs are\nreceived. This requirement guards against adverse or unintended system behavior\ncaused by invalid inputs, where information system responses to the invalid\ninput may be disruptive or cause the system to fail into an unsafe state.\n\n    The behavior will be derived from the organizational and system\nrequirements and includes, but is not limited to, notification of the\nappropriate personnel, creating an audit record, and rejecting invalid input.\n\n    This calls for inspection of application source code, which will require\ncollaboration with the application developers. It is recognized that in many\ncases, the database administrator (DBA) is organizationally separate from the\napplication developers and may have limited, if any, access to source code.\nNevertheless, protections of this type are so important to the secure operation\nof databases that they must not be ignored. At a minimum, the DBA must attempt\nto obtain assurances from the development organization that this issue has been\naddressed and must document what has been discovered.",
      "descriptions": {
        "default": "A common vulnerability is unplanned behavior when invalid inputs are\nreceived. This requirement guards against adverse or unintended system behavior\ncaused by invalid inputs, where information system responses to the invalid\ninput may be disruptive or cause the system to fail into an unsafe state.\n\n    The behavior will be derived from the organizational and system\nrequirements and includes, but is not limited to, notification of the\nappropriate personnel, creating an audit record, and rejecting invalid input.\n\n    This calls for inspection of application source code, which will require\ncollaboration with the application developers. It is recognized that in many\ncases, the database administrator (DBA) is organizationally separate from the\napplication developers and may have limited, if any, access to source code.\nNevertheless, protections of this type are so important to the secure operation\nof databases that they must not be ignored. At a minimum, the DBA must attempt\nto obtain assurances from the development organization that this issue has been\naddressed and must document what has been discovered."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000447-DB-000393",
        "gid": "V-67411",
        "rid": "SV-81901r2_rule",
        "stig_id": "SQL4-00-035200",
        "fix_id": "F-73525r1_fix",
        "cci": [
          "CCI-002754"
        ],
        "nist": [
          "SI-10 (3)",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "Review system documentation to determine how input errors are\nto be handled in general and if any special handling is defined for specific\ncircumstances.\n\nReview the source code for database program objects (stored procedures,\nfunctions, triggers) and application source code to identify how the system\nresponds to invalid input.\n\nIf it does not implement the documented behavior, this is a finding.",
        "fix": "Revise and deploy the source code for database program objects\n(stored procedures, functions, triggers) and application source code, to\nimplement the documented behavior."
      },
      "code": "control 'V-67411' do\n  title \"When invalid inputs are received, SQL Server must behave in a\npredictable and documented manner that reflects organizational and system\nobjectives.\"\n  desc  \"A common vulnerability is unplanned behavior when invalid inputs are\nreceived. This requirement guards against adverse or unintended system behavior\ncaused by invalid inputs, where information system responses to the invalid\ninput may be disruptive or cause the system to fail into an unsafe state.\n\n    The behavior will be derived from the organizational and system\nrequirements and includes, but is not limited to, notification of the\nappropriate personnel, creating an audit record, and rejecting invalid input.\n\n    This calls for inspection of application source code, which will require\ncollaboration with the application developers. It is recognized that in many\ncases, the database administrator (DBA) is organizationally separate from the\napplication developers and may have limited, if any, access to source code.\nNevertheless, protections of this type are so important to the secure operation\nof databases that they must not be ignored. At a minimum, the DBA must attempt\nto obtain assurances from the development organization that this issue has been\naddressed and must document what has been discovered.\n  \"\n  impact 0.5\n  tag \"gtitle\": 'SRG-APP-000447-DB-000393'\n  tag \"gid\": 'V-67411'\n  tag \"rid\": 'SV-81901r2_rule'\n  tag \"stig_id\": 'SQL4-00-035200'\n  tag \"fix_id\": 'F-73525r1_fix'\n  tag \"cci\": ['CCI-002754']\n  tag \"nist\": ['SI-10 (3)', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"Review system documentation to determine how input errors are\nto be handled in general and if any special handling is defined for specific\ncircumstances.\n\nReview the source code for database program objects (stored procedures,\nfunctions, triggers) and application source code to identify how the system\nresponds to invalid input.\n\nIf it does not implement the documented behavior, this is a finding.\"\n  tag \"fix\": \"Revise and deploy the source code for database program objects\n(stored procedures, functions, triggers) and application source code, to\nimplement the documented behavior.\"\n\n  describe 'This test currently has no automated tests, you must check manually' do\n    skip 'This check must be preformed manually'\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67411.rb",
        "line": 1
      },
      "id": "V-67411"
    },
    {
      "title": "Time stamps in database tables, intended for auditing or\nactivity-tracking purposes, must include both date and time of day, with a\nminimum granularity of one second.",
      "desc": "If time stamps are not consistently applied and there is no common\ntime reference, it is difficult to perform forensic analysis, in audit files,\ntrace files/tables, and application data tables.\n\n    Time stamps generated by SQL Server must include date and time, to a\ngranularity of one second or finer. Time is commonly expressed in Coordinated\nUniversal Time (UTC), a modern continuation of Greenwich Mean Time (GMT), or\nlocal time with an offset from UTC. Granularity of time measurements refers to\nthe precision available in time stamp values. Granularity coarser than one\nsecond is not sufficient for audit trail purposes, and granularity finer than\none second is recommended. Time stamp values are typically presented with three\nor more decimal places of seconds; however, the actual granularity may be\ncoarser than the apparent precision. For example, SQL Server's\nGETDATE()/CURRENT_TMESTAMP values are presented to three decimal places, but\nthe granularity is not one millisecond: it is about 1/300 of a second.\n\n    The data types that can be used for this purpose in SQL Server are:\n    DATETIME2 - precision variable from a whole second down to a ten-millionth\n(subject to the actual precision of the hardware and operating system)\n    DATETIMEOFFSET - as datetime2, together with local offset from UTC\n    DATE, together with TIME (same precision considerations as for datetime2)\n    DATETIME - precision 1/300 of a second\n    Character-string data types allowing for at least 20 characters are also\npermissible, but not recommended.\n\n    SQL Server built-in functions for retrieving current timestamps are:  (high\nprecision) sysdatetime(), sysdatetimeoffset(), sysutcdatetime();  (lower\nprecision) CURRENT_TIMESTAMP or getdate(), getutcdate().\n\n    Ensure that values recorded for tracking purposes in data tables are\ncorrectly defined and maintained.  (Design decisions about which tables require\naudit-trail or activity-tracking columns are outside the scope of this STIG.\nThis requirement applies only to the data type and maintenance of such columns\nif they do exist.)\n\n    The SMALLDATETIME data type is not precise enough for this purpose.\nAlthough it gives the impression of including a seconds component, the seconds\nvalue is always \"00\".\n\n    SQL Server offers a data type called TIMESTAMP that is not a representation\nof date and time. Rather, it is a database state counter and does not\ncorrespond to calendar and clock time. This requirement does not refer to that\nmeaning of TIMESTAMP.  To avoid confusion, Microsoft recommends using the newer\nname for this data type, ROWVERSION, instead.",
      "descriptions": {
        "default": "If time stamps are not consistently applied and there is no common\ntime reference, it is difficult to perform forensic analysis, in audit files,\ntrace files/tables, and application data tables.\n\n    Time stamps generated by SQL Server must include date and time, to a\ngranularity of one second or finer. Time is commonly expressed in Coordinated\nUniversal Time (UTC), a modern continuation of Greenwich Mean Time (GMT), or\nlocal time with an offset from UTC. Granularity of time measurements refers to\nthe precision available in time stamp values. Granularity coarser than one\nsecond is not sufficient for audit trail purposes, and granularity finer than\none second is recommended. Time stamp values are typically presented with three\nor more decimal places of seconds; however, the actual granularity may be\ncoarser than the apparent precision. For example, SQL Server's\nGETDATE()/CURRENT_TMESTAMP values are presented to three decimal places, but\nthe granularity is not one millisecond: it is about 1/300 of a second.\n\n    The data types that can be used for this purpose in SQL Server are:\n    DATETIME2 - precision variable from a whole second down to a ten-millionth\n(subject to the actual precision of the hardware and operating system)\n    DATETIMEOFFSET - as datetime2, together with local offset from UTC\n    DATE, together with TIME (same precision considerations as for datetime2)\n    DATETIME - precision 1/300 of a second\n    Character-string data types allowing for at least 20 characters are also\npermissible, but not recommended.\n\n    SQL Server built-in functions for retrieving current timestamps are:  (high\nprecision) sysdatetime(), sysdatetimeoffset(), sysutcdatetime();  (lower\nprecision) CURRENT_TIMESTAMP or getdate(), getutcdate().\n\n    Ensure that values recorded for tracking purposes in data tables are\ncorrectly defined and maintained.  (Design decisions about which tables require\naudit-trail or activity-tracking columns are outside the scope of this STIG.\nThis requirement applies only to the data type and maintenance of such columns\nif they do exist.)\n\n    The SMALLDATETIME data type is not precise enough for this purpose.\nAlthough it gives the impression of including a seconds component, the seconds\nvalue is always \"00\".\n\n    SQL Server offers a data type called TIMESTAMP that is not a representation\nof date and time. Rather, it is a database state counter and does not\ncorrespond to calendar and clock time. This requirement does not refer to that\nmeaning of TIMESTAMP.  To avoid confusion, Microsoft recommends using the newer\nname for this data type, ROWVERSION, instead."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000375-DB-000323",
        "gid": "V-67407",
        "rid": "SV-81897r1_rule",
        "stig_id": "SQL4-00-033700",
        "fix_id": "F-73519r1_fix",
        "cci": [
          "CCI-001889"
        ],
        "nist": [
          "AU-8 b",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "Review the column definitions and contents of audit-trail and\nactivity-tracking timestamps in database tables.\n\nIf these are not defined and maintained to include date and time of day,\naccurate to a granularity of one second or finer, this is a finding.",
        "fix": "Modify applications and/or column/field definitions so that the\ntime stamps in audit-trail and activity-tracking columns/fields in application\ndata include date and time of day, to a granularity of one second or finer, and\nare recorded accurately."
      },
      "code": "control 'V-67407' do\n  title \"Time stamps in database tables, intended for auditing or\nactivity-tracking purposes, must include both date and time of day, with a\nminimum granularity of one second.\"\n  desc  \"If time stamps are not consistently applied and there is no common\ntime reference, it is difficult to perform forensic analysis, in audit files,\ntrace files/tables, and application data tables.\n\n    Time stamps generated by SQL Server must include date and time, to a\ngranularity of one second or finer. Time is commonly expressed in Coordinated\nUniversal Time (UTC), a modern continuation of Greenwich Mean Time (GMT), or\nlocal time with an offset from UTC. Granularity of time measurements refers to\nthe precision available in time stamp values. Granularity coarser than one\nsecond is not sufficient for audit trail purposes, and granularity finer than\none second is recommended. Time stamp values are typically presented with three\nor more decimal places of seconds; however, the actual granularity may be\ncoarser than the apparent precision. For example, SQL Server's\nGETDATE()/CURRENT_TMESTAMP values are presented to three decimal places, but\nthe granularity is not one millisecond: it is about 1/300 of a second.\n\n    The data types that can be used for this purpose in SQL Server are:\n    DATETIME2 - precision variable from a whole second down to a ten-millionth\n(subject to the actual precision of the hardware and operating system)\n    DATETIMEOFFSET - as datetime2, together with local offset from UTC\n    DATE, together with TIME (same precision considerations as for datetime2)\n    DATETIME - precision 1/300 of a second\n    Character-string data types allowing for at least 20 characters are also\npermissible, but not recommended.\n\n    SQL Server built-in functions for retrieving current timestamps are:  (high\nprecision) sysdatetime(), sysdatetimeoffset(), sysutcdatetime();  (lower\nprecision) CURRENT_TIMESTAMP or getdate(), getutcdate().\n\n    Ensure that values recorded for tracking purposes in data tables are\ncorrectly defined and maintained.  (Design decisions about which tables require\naudit-trail or activity-tracking columns are outside the scope of this STIG.\nThis requirement applies only to the data type and maintenance of such columns\nif they do exist.)\n\n    The SMALLDATETIME data type is not precise enough for this purpose.\nAlthough it gives the impression of including a seconds component, the seconds\nvalue is always \\\"00\\\".\n\n    SQL Server offers a data type called TIMESTAMP that is not a representation\nof date and time. Rather, it is a database state counter and does not\ncorrespond to calendar and clock time. This requirement does not refer to that\nmeaning of TIMESTAMP.  To avoid confusion, Microsoft recommends using the newer\nname for this data type, ROWVERSION, instead.\n  \"\n  impact 0.5\n  tag \"gtitle\": 'SRG-APP-000375-DB-000323'\n  tag \"gid\": 'V-67407'\n  tag \"rid\": 'SV-81897r1_rule'\n  tag \"stig_id\": 'SQL4-00-033700'\n  tag \"fix_id\": 'F-73519r1_fix'\n  tag \"cci\": ['CCI-001889']\n  tag \"nist\": ['AU-8 b', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"Review the column definitions and contents of audit-trail and\nactivity-tracking timestamps in database tables.\n\nIf these are not defined and maintained to include date and time of day,\naccurate to a granularity of one second or finer, this is a finding.\"\n  tag \"fix\": \"Modify applications and/or column/field definitions so that the\ntime stamps in audit-trail and activity-tracking columns/fields in application\ndata include date and time of day, to a granularity of one second or finer, and\nare recorded accurately.\"\n\n  describe 'This test currently has no automated tests, you must check manually' do\n    skip 'This check must be preformed manually'\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67407.rb",
        "line": 1
      },
      "id": "V-67407"
    },
    {
      "title": "In the event of a system failure, SQL Server must preserve any\ninformation necessary to return to operations with least disruption to mission\nprocesses.",
      "desc": "Failure to a known state can address safety or security in accordance\nwith the mission/business needs of the organization. The existence and\nreliability of database backups is an essential aspect of the ability to fail\nto a known state. It helps prevent a loss of confidentiality, integrity, or\navailability in the event of a failure of the information system or a component\nof the system.\n\n    Backups must be performed according to an appropriate schedule, and must be\ntested periodically to provide assurance that they can be used for restoring\nthe database.",
      "descriptions": {
        "default": "Failure to a known state can address safety or security in accordance\nwith the mission/business needs of the organization. The existence and\nreliability of database backups is an essential aspect of the ability to fail\nto a known state. It helps prevent a loss of confidentiality, integrity, or\navailability in the event of a failure of the information system or a component\nof the system.\n\n    Backups must be performed according to an appropriate schedule, and must be\ntested periodically to provide assurance that they can be used for restoring\nthe database."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000226-DB-000147",
        "gid": "V-67377",
        "rid": "SV-81867r2_rule",
        "stig_id": "SQL4-00-021210",
        "fix_id": "F-73489r1_fix",
        "cci": [
          "CCI-001665"
        ],
        "nist": [
          "SC-24",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "Review the system security plan (SSP) to determine whether the\ndatabase is static, the recovery model to be used, the backup schedule, and the\nplan for testing database restoration.  If the SSP does not state that the\ndatabase is static, assume that it is not static.  If any of the other\ninformation is absent, this is a finding.\n\nIf the database is not static, but the documented recovery model is Simple,\nthis is a finding.\n\nIf the database is not static, and the documented recovery model is Bulk\nLogged, but the justification and authorization for this are not documented,\nthis is a finding.\n\nIn SQL Server Management Studio, Object Explorer, right-click on the name of\nthe database; select Properties.  Select the Options page.\n\nObserve the Recovery Model field, near the top of the page.  If this does not\nmatch the documented recovery model, this is a finding.\n\nIn Object Explorer, expand  <server name>  >>  SQL Server Agent  >>  Jobs.\n\nReview the jobs set up to implement the backup plan.  If they are absent, this\nis a finding.\n\nRight-click on each backup job; select View History.  If the history indicates\na pattern of job failures, this is a finding.\n\nReview evidence that database recovery is tested annually or more often, and\nthat the most recent test was successful.  If not, this is a finding.",
        "fix": "Modify the system security plan, to include whether the database\nis static, the correct recovery model to be used, the backup schedule, and the\nplan for testing database restoration.\n\nIn SQL Server Management Studio, Object Explorer, right-click on the name of\nthe database; select Properties.  Select the Options page.  Set the Recovery\nModel field, near the top of the page, to the correct value.\n\nIn Object Explorer, expand  <server name>  >>  SQL Server Agent  >>  Jobs.\nCreate, modify and delete jobs to implement the backup schedule.\n(Alternatively, this may done using T-SQL code.)\n\nCorrect any issues that have been causing backups to fail.\n\nTest the restoration of the database at least once a year; correct any issues\nthat cause it to fail.  Maintain a record of these tests."
      },
      "code": "control 'V-67377' do\n  title \"In the event of a system failure, SQL Server must preserve any\ninformation necessary to return to operations with least disruption to mission\nprocesses.\"\n  desc  \"Failure to a known state can address safety or security in accordance\nwith the mission/business needs of the organization. The existence and\nreliability of database backups is an essential aspect of the ability to fail\nto a known state. It helps prevent a loss of confidentiality, integrity, or\navailability in the event of a failure of the information system or a component\nof the system.\n\n    Backups must be performed according to an appropriate schedule, and must be\ntested periodically to provide assurance that they can be used for restoring\nthe database.\n  \"\n  impact 0.5\n  tag \"gtitle\": 'SRG-APP-000226-DB-000147'\n  tag \"gid\": 'V-67377'\n  tag \"rid\": 'SV-81867r2_rule'\n  tag \"stig_id\": 'SQL4-00-021210'\n  tag \"fix_id\": 'F-73489r1_fix'\n  tag \"cci\": ['CCI-001665']\n  tag \"nist\": ['SC-24', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"Review the system security plan (SSP) to determine whether the\ndatabase is static, the recovery model to be used, the backup schedule, and the\nplan for testing database restoration.  If the SSP does not state that the\ndatabase is static, assume that it is not static.  If any of the other\ninformation is absent, this is a finding.\n\nIf the database is not static, but the documented recovery model is Simple,\nthis is a finding.\n\nIf the database is not static, and the documented recovery model is Bulk\nLogged, but the justification and authorization for this are not documented,\nthis is a finding.\n\nIn SQL Server Management Studio, Object Explorer, right-click on the name of\nthe database; select Properties.  Select the Options page.\n\nObserve the Recovery Model field, near the top of the page.  If this does not\nmatch the documented recovery model, this is a finding.\n\nIn Object Explorer, expand  <server name>  >>  SQL Server Agent  >>  Jobs.\n\nReview the jobs set up to implement the backup plan.  If they are absent, this\nis a finding.\n\nRight-click on each backup job; select View History.  If the history indicates\na pattern of job failures, this is a finding.\n\nReview evidence that database recovery is tested annually or more often, and\nthat the most recent test was successful.  If not, this is a finding.\"\n  tag \"fix\": \"Modify the system security plan, to include whether the database\nis static, the correct recovery model to be used, the backup schedule, and the\nplan for testing database restoration.\n\nIn SQL Server Management Studio, Object Explorer, right-click on the name of\nthe database; select Properties.  Select the Options page.  Set the Recovery\nModel field, near the top of the page, to the correct value.\n\nIn Object Explorer, expand  <server name>  >>  SQL Server Agent  >>  Jobs.\nCreate, modify and delete jobs to implement the backup schedule.\n(Alternatively, this may done using T-SQL code.)\n\nCorrect any issues that have been causing backups to fail.\n\nTest the restoration of the database at least once a year; correct any issues\nthat cause it to fail.  Maintain a record of these tests.\"\n\n  describe 'This test currently has no automated tests, you must check manually' do\n    skip 'This check must be preformed manually'\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67377.rb",
        "line": 1
      },
      "id": "V-67377"
    },
    {
      "title": "Trace or Audit records must be generated when categorized information\n(e.g., classification levels/security levels) is deleted.",
      "desc": "Changes in categorized information must be tracked. Without an audit\ntrail, unauthorized access to protected data could go undetected.\n\n    For detailed information on categorizing information, refer to FIPS\nPublication 199, Standards for Security Categorization of Federal Information\nand Information Systems, and FIPS Publication 200, Minimum Security\nRequirements for Federal Information and Information Systems.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    Since Trace does not provide for tracking SELECT statements, it is\nnecessary to provide that part of the tracking at the application level.\nBecause of this, it may also be appropriate to audit DELETE actions at the\napplication level.  However, to capture all DELETEs, whether they come from the\napplication or bypass it, the Trace must be configured to cover them.",
      "descriptions": {
        "default": "Changes in categorized information must be tracked. Without an audit\ntrail, unauthorized access to protected data could go undetected.\n\n    For detailed information on categorizing information, refer to FIPS\nPublication 199, Standards for Security Categorization of Federal Information\nand Information Systems, and FIPS Publication 200, Minimum Security\nRequirements for Federal Information and Information Systems.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    Since Trace does not provide for tracking SELECT statements, it is\nnecessary to provide that part of the tracking at the application level.\nBecause of this, it may also be appropriate to audit DELETE actions at the\napplication level.  However, to capture all DELETEs, whether they come from the\napplication or bypass it, the Trace must be configured to cover them."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000502-DB-000348",
        "gid": "V-67429",
        "rid": "SV-81919r2_rule",
        "stig_id": "SQL4-00-037300",
        "fix_id": "F-73543r1_fix",
        "cci": [
          "CCI-000172"
        ],
        "nist": [
          "AU-12 c",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "Review the system documentation to determine whether it is\nrequired to track categories of information, such as classification or\nsensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes,\nthis is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the triggers on all\ntables holding categorized information, to determine whether trace events are\ngenerated for all DELETE actions on these tables.  If not, this is a finding.\n\nCheck to see that all required event classes are being audited.  From the query\nprompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no\ntraces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\n\nIn the following, replace # with a trace ID being used for the auditing\nrequirements.\n\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is\na finding:\n\n82-91  -- User-defined Event (at least one of these, matching the triggers; 90\nis used in the supplied script)\n162 -- User error message\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the broad, server-level audit action group\nSCHEMA_OBJECT_ACCESS_GROUP for this purpose. SQL Server Audit's flexibility\nmakes other techniques possible.  If an alternative technique is in use and\ndemonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their\nnames.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions\non tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"SUCCESS\" or \"SUCCESS AND FAILURE\",\nthis is a finding.",
        "fix": "Where SQL Server Trace is in use, create triggers to raise a\ncustom event for DELETEs on each table holding categorized information.  The\nexamples provided in the supplemental file CustomTraceEvents.sql can serve as\nthe basis for these.\n\nAdd a block of code to the supplemental file Trace.sql for each custom event\nclass (integers in the range 82-91; the same event class may be used for all\nsuch triggers) used in these triggers.  Execute Trace.sql.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all\nauditable events and data items.  The script provided in the supplemental file\nAudit.sql can be used as the basis for this.  Supplement the standard audit\ndata as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO"
      },
      "code": "control 'V-67429' do\n  title \"Trace or Audit records must be generated when categorized information\n(e.g., classification levels/security levels) is deleted.\"\n  desc  \"Changes in categorized information must be tracked. Without an audit\ntrail, unauthorized access to protected data could go undetected.\n\n    For detailed information on categorizing information, refer to FIPS\nPublication 199, Standards for Security Categorization of Federal Information\nand Information Systems, and FIPS Publication 200, Minimum Security\nRequirements for Federal Information and Information Systems.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    Since Trace does not provide for tracking SELECT statements, it is\nnecessary to provide that part of the tracking at the application level.\nBecause of this, it may also be appropriate to audit DELETE actions at the\napplication level.  However, to capture all DELETEs, whether they come from the\napplication or bypass it, the Trace must be configured to cover them.\n  \"\n  if attribute('server_trace_or_audit_required')\n    impact 0.5\n  else\n    impact 0.0\n    desc 'Inspec attributes has specified that is not required to track categories\n    of information, such as classification or sensitivity level on the target'\n  end\n\n  tag \"gtitle\": 'SRG-APP-000502-DB-000348'\n  tag \"gid\": 'V-67429'\n  tag \"rid\": 'SV-81919r2_rule'\n  tag \"stig_id\": 'SQL4-00-037300'\n  tag \"fix_id\": 'F-73543r1_fix'\n  tag \"cci\": ['CCI-000172']\n  tag \"nist\": ['AU-12 c', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"Review the system documentation to determine whether it is\nrequired to track categories of information, such as classification or\nsensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes,\nthis is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the triggers on all\ntables holding categorized information, to determine whether trace events are\ngenerated for all DELETE actions on these tables.  If not, this is a finding.\n\nCheck to see that all required event classes are being audited.  From the query\nprompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no\ntraces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\n\nIn the following, replace # with a trace ID being used for the auditing\nrequirements.\n\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is\na finding:\n\n82-91  -- User-defined Event (at least one of these, matching the triggers; 90\nis used in the supplied script)\n162 -- User error message\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the broad, server-level audit action group\nSCHEMA_OBJECT_ACCESS_GROUP for this purpose. SQL Server Audit's flexibility\nmakes other techniques possible.  If an alternative technique is in use and\ndemonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\n\nAlternatively, review the contents of the system views with \\\"audit\\\" in their\nnames.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions\non tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \\\"SUCCESS\\\" or \\\"SUCCESS AND FAILURE\\\",\nthis is a finding.\"\n  tag \"fix\": \"Where SQL Server Trace is in use, create triggers to raise a\ncustom event for DELETEs on each table holding categorized information.  The\nexamples provided in the supplemental file CustomTraceEvents.sql can serve as\nthe basis for these.\n\nAdd a block of code to the supplemental file Trace.sql for each custom event\nclass (integers in the range 82-91; the same event class may be used for all\nsuch triggers) used in these triggers.  Execute Trace.sql.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all\nauditable events and data items.  The script provided in the supplemental file\nAudit.sql can be used as the basis for this.  Supplement the standard audit\ndata as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO\"\n\n  query_traces = %{\n    SELECT * FROM sys.traces\n  }\n  query_trace_eventinfo = %{\n    SELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(%<trace_id>s);\n  }\n\n  query_audits = %{\n    SELECT server_specification_id,\n           audit_action_name,\n           audited_result\n    FROM   sys.server_audit_specification_details\n    WHERE  audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n  }\n\n  server_trace_implemented = attribute('server_trace_implemented')\n  server_audit_implemented = attribute('server_audit_implemented')\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n\n  describe.one do\n    describe 'SQL Server Trace is in use for audit purposes' do\n      subject { server_trace_implemented }\n      it { should be true }\n    end\n\n    describe 'SQL Server Audit is in use for audit purposes' do\n      subject { server_audit_implemented }\n      it { should be true }\n    end\n  end\n\n  if server_trace_implemented\n    describe 'List defined traces for the SQL server instance' do\n      subject { sql_session.query(query_traces) }\n      it { should_not be_empty }\n    end\n\n    trace_ids = sql_session.query(query_traces).column('id')\n    describe.one do\n      trace_ids.each do |trace_id|\n        found_events = sql_session.query(format(query_trace_eventinfo, trace_id: trace_id)).column('eventid')\n        describe \"EventsIDs in Trace ID:#{trace_id}\" do\n          subject { found_events }\n          its('to_s') { should match /\"82\"|\"83\"|\"84\"|\"85\"|\"86\"|\"87\"|\"88\"|\"89\"|\"90\"|\"91\"/ }\n          it { should include '162' }\n        end\n      end\n    end\n  end\n\n  if server_audit_implemented\n    describe 'SQL Server Audit:' do\n      describe 'Defined Audits with Audit Action SCHEMA_OBJECT_ACCESS_GROUP' do\n        subject { sql_session.query(query_audits) }\n        it { should_not be_empty }\n      end\n      describe 'Audited Result for Defined Audit Actions' do\n        subject { sql_session.query(query_audits).column('audited_result').uniq.to_s }\n        it { should match /SUCCESS AND FAILURE|SUCCESS/ }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67429.rb",
        "line": 1
      },
      "id": "V-67429"
    },
    {
      "title": "Where SQL Server Audit is in use at the database level, SQL Server\nmust allow only the ISSM (or individuals or roles appointed by the ISSM) to\nselect which auditable events are to be audited at the database level.",
      "desc": "Without the capability to restrict which roles and individuals can\nselect which events are audited, unauthorized personnel may be able to prevent\nor interfere with the auditing of critical events.\n\n    Suppression of auditing could permit an adversary to evade detection.\n\n    Mis-configured audits can degrade the system's performance by overwhelming\nthe audit log. Mis-configured audits may also make it more difficult to\nestablish, correlate, and investigate the events relating to an incident or\nidentify those responsible for one.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    This version of the requirement deals with SQL Server Audit-based audit\ntrails.",
      "descriptions": {
        "default": "Without the capability to restrict which roles and individuals can\nselect which events are audited, unauthorized personnel may be able to prevent\nor interfere with the auditing of critical events.\n\n    Suppression of auditing could permit an adversary to evade detection.\n\n    Mis-configured audits can degrade the system's performance by overwhelming\nthe audit log. Mis-configured audits may also make it more difficult to\nestablish, correlate, and investigate the events relating to an incident or\nidentify those responsible for one.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    This version of the requirement deals with SQL Server Audit-based audit\ntrails."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000090-DB-000065",
        "gid": "V-67361",
        "rid": "SV-81851r2_rule",
        "stig_id": "SQL4-00-011320",
        "fix_id": "F-73473r1_fix",
        "cci": [
          "CCI-000171"
        ],
        "nist": [
          "AU-12 b",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "If SQL Server Audit is not in use at the database level, this\nis not applicable (NA).\n\nObtain the list of approved audit maintainers from the system documentation.\n\nReview the database roles and individual users that have the following\npermissions, both of which enable the ability to maintain audit definitions:\nALTER ANY DATABASE AUDIT\nCONTROL ON DATABASE\n\nThe functions and views provided in the supplemental file Permissions.sql can\nassist in this review.  In the following, \"STIG\" stands for the schema where\nyou have deployed these views and functions.  To see which logins and server\nroles have been granted these permissions:\n    SELECT\n        *\n    FROM\n        STIG.database_permissions P\n    WHERE\n        (P.[Permission] = 'ALTER ANY DATABASE AUDIT')\n        OR\n        (P.[Permission] = 'CONTROL' AND P.[Securable Type or Class] =\n'DATABASE')\n        ;\n\nTo see what users and database roles inherit these permissions from the\ndatabase roles reported by the previous query, repeat the following for each\none:\n    SELECT * FROM STIG.members_of_database_role(<database role name>);\n\nTo see all the permissions in effect for a database principal (server role or\nlogin):\n    SELECT * FROM STIG.server_effective_permissions(<principal name>);\n\nIf designated personnel are not able to configure auditable events, this is a\nfinding.\n\nIf unapproved personnel are able to configure auditable events, this is a\nfinding.",
        "fix": "Create a database role specifically for audit maintainers, and\ngive it permission to maintain audits, without granting it unnecessary\npermissions:\nUSE <database name>;\nGO\nCREATE ROLE DATABASE_AUDIT_MAINTAINERS;\nGO\nGRANT ALTER ANY DATABASE AUDIT TO DATABASE_AUDIT_MAINTAINERS;\nGO\n(The role name used here is an example; other names may be used.)\n\nUse REVOKE and/or DENY and/or ALTER ROLE ... DROP MEMBER ... statements to\nremove the ALTER ANY DATABASE AUDIT permission from all users.\n\nThen, for each authorized database user, run the statement:\nALTER ROLE DATABASE_AUDIT_MAINTAINERS ADD MEMBER <user name> ;\nGO\n\nUse REVOKE and/or DENY and/or ALTER SERVER ROLE ... DROP MEMBER ... statements\nto remove CONTROL DATABASE permission from logins that do not need it."
      },
      "code": "control 'V-67361' do\n  title \"Where SQL Server Audit is in use at the database level, SQL Server\nmust allow only the ISSM (or individuals or roles appointed by the ISSM) to\nselect which auditable events are to be audited at the database level.\"\n  desc  \"Without the capability to restrict which roles and individuals can\nselect which events are audited, unauthorized personnel may be able to prevent\nor interfere with the auditing of critical events.\n\n    Suppression of auditing could permit an adversary to evade detection.\n\n    Mis-configured audits can degrade the system's performance by overwhelming\nthe audit log. Mis-configured audits may also make it more difficult to\nestablish, correlate, and investigate the events relating to an incident or\nidentify those responsible for one.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n\n    This version of the requirement deals with SQL Server Audit-based audit\ntrails.\n  \"\n\n  if attribute('server_audit_at_database_level_required')\n    impact 0.5\n  else\n    impact 0.0\n    desc 'Inspec attributes has specified that SQL Server Audit is not in use at\n    the database level, this is not applicable (NA)'\n  end\n\n  tag \"gtitle\": 'SRG-APP-000090-DB-000065'\n  tag \"gid\": 'V-67361'\n  tag \"rid\": 'SV-81851r2_rule'\n  tag \"stig_id\": 'SQL4-00-011320'\n  tag \"fix_id\": 'F-73473r1_fix'\n  tag \"cci\": ['CCI-000171']\n  tag \"nist\": ['AU-12 b', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"If SQL Server Audit is not in use at the database level, this\nis not applicable (NA).\n\nObtain the list of approved audit maintainers from the system documentation.\n\nReview the database roles and individual users that have the following\npermissions, both of which enable the ability to maintain audit definitions:\nALTER ANY DATABASE AUDIT\nCONTROL ON DATABASE\n\nThe functions and views provided in the supplemental file Permissions.sql can\nassist in this review.  In the following, \\\"STIG\\\" stands for the schema where\nyou have deployed these views and functions.  To see which logins and server\nroles have been granted these permissions:\n    SELECT\n        *\n    FROM\n        STIG.database_permissions P\n    WHERE\n        (P.[Permission] = 'ALTER ANY DATABASE AUDIT')\n        OR\n        (P.[Permission] = 'CONTROL' AND P.[Securable Type or Class] =\n'DATABASE')\n        ;\n\nTo see what users and database roles inherit these permissions from the\ndatabase roles reported by the previous query, repeat the following for each\none:\n    SELECT * FROM STIG.members_of_database_role(<database role name>);\n\nTo see all the permissions in effect for a database principal (server role or\nlogin):\n    SELECT * FROM STIG.server_effective_permissions(<principal name>);\n\nIf designated personnel are not able to configure auditable events, this is a\nfinding.\n\nIf unapproved personnel are able to configure auditable events, this is a\nfinding.\"\n  tag \"fix\": \"Create a database role specifically for audit maintainers, and\ngive it permission to maintain audits, without granting it unnecessary\npermissions:\nUSE <database name>;\nGO\nCREATE ROLE DATABASE_AUDIT_MAINTAINERS;\nGO\nGRANT ALTER ANY DATABASE AUDIT TO DATABASE_AUDIT_MAINTAINERS;\nGO\n(The role name used here is an example; other names may be used.)\n\nUse REVOKE and/or DENY and/or ALTER ROLE ... DROP MEMBER ... statements to\nremove the ALTER ANY DATABASE AUDIT permission from all users.\n\nThen, for each authorized database user, run the statement:\nALTER ROLE DATABASE_AUDIT_MAINTAINERS ADD MEMBER <user name> ;\nGO\n\nUse REVOKE and/or DENY and/or ALTER SERVER ROLE ... DROP MEMBER ... statements\nto remove CONTROL DATABASE permission from logins that do not need it.\"\n\n  approved_audit_maintainers = attribute('approved_audit_maintainers')\n\n  # The query in check-text is assumes the presence of STIG schema as supplied with\n  # the STIG supplemental. The below query ( partially taken from 2016 MSSQL STIG)\n  # will work without STIG supplemental schema.\n\n  query = %{\n    SELECT DPE.PERMISSION_NAME AS 'PERMISSION',\n           DPM.NAME            AS 'ROLE MEMBER',\n           DPR.NAME            AS 'ROLE NAME'\n    FROM   SYS.DATABASE_ROLE_MEMBERS DRM\n           JOIN SYS.DATABASE_PERMISSIONS DPE\n             ON DRM.ROLE_PRINCIPAL_ID = DPE.GRANTEE_PRINCIPAL_ID\n           JOIN SYS.DATABASE_PRINCIPALS DPR\n             ON DRM.ROLE_PRINCIPAL_ID = DPR.PRINCIPAL_ID\n           JOIN SYS.DATABASE_PRINCIPALS DPM\n             ON DRM.MEMBER_PRINCIPAL_ID = DPM.PRINCIPAL_ID\n    WHERE  DPE.PERMISSION_NAME IN ( 'CONTROL', 'ALTER ANY DATABASE AUDIT' )\n    OR DPM.NAME IN ('db_owner')\n  }\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n\n  describe 'List of approved audit maintainers' do\n    subject { sql_session.query(query).column('role member').uniq }\n    it { should match_array approved_audit_maintainers }\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67361.rb",
        "line": 1
      },
      "id": "V-67361"
    },
    {
      "title": "SQL Server must be monitored to discover unauthorized changes to\nfunctions.",
      "desc": "When dealing with change control issues, it should be noted, any\nchanges to the hardware, software, and/or firmware components of SQL Server\nand/or application can potentially have significant effects on the overall\nsecurity of the system.\n\n    If SQL Server were to allow any user to make changes to software libraries,\nthen those changes might be implemented without undergoing the appropriate\ntesting and approvals that are part of a robust change management process.\n\n    This requirement is contingent upon the language in which the application\nis programmed, as many application architectures in use today incorporate their\nsoftware libraries into, and make them inseparable from, their compiled\ndistributions, rendering them static and version-dependent. However, this\nrequirement does apply to applications with software libraries accessible and\nconfigurable, as in the case of interpreted languages.\n\n    Accordingly, only qualified and authorized individuals shall be allowed to\nobtain access to SQL Server components for purposes of initiating changes,\nincluding upgrades and modifications.\n\n    Unmanaged changes that occur to the SQL Server software libraries or\nconfiguration, such as Functions, can lead to unauthorized or compromised\ninstallations.",
      "descriptions": {
        "default": "When dealing with change control issues, it should be noted, any\nchanges to the hardware, software, and/or firmware components of SQL Server\nand/or application can potentially have significant effects on the overall\nsecurity of the system.\n\n    If SQL Server were to allow any user to make changes to software libraries,\nthen those changes might be implemented without undergoing the appropriate\ntesting and approvals that are part of a robust change management process.\n\n    This requirement is contingent upon the language in which the application\nis programmed, as many application architectures in use today incorporate their\nsoftware libraries into, and make them inseparable from, their compiled\ndistributions, rendering them static and version-dependent. However, this\nrequirement does apply to applications with software libraries accessible and\nconfigurable, as in the case of interpreted languages.\n\n    Accordingly, only qualified and authorized individuals shall be allowed to\nobtain access to SQL Server components for purposes of initiating changes,\nincluding upgrades and modifications.\n\n    Unmanaged changes that occur to the SQL Server software libraries or\nconfiguration, such as Functions, can lead to unauthorized or compromised\ninstallations."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000133-DB-000179",
        "gid": "V-67365",
        "rid": "SV-81855r2_rule",
        "stig_id": "SQL4-00-014900",
        "fix_id": "F-73477r2_fix",
        "cci": [
          "CCI-001499"
        ],
        "nist": [
          "CM-5 (6)",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "Check the SQL Server configuration for a timed job that\nautomatically checks all system and user-defined Functions for being modified\nby running the following SQL Server query:\nEXEC msdb.dbo.sp_help_job @job_name = '<enter . . . job name>';\n\n(Alternatively, in SQL Server Management Studio, navigate to SQL Server Agent\nand examine the job from there.)\n\nIf a timed job or some other method is not implemented to check for Functions\nbeing modified, this is a finding.",
        "fix": "Configure a SQL Server timed job that automatically checks all\nsystem and user-defined Functions for being modified.\n\n(The supplemental file Track.sql, provided with this STIG, can be used to\nestablish a monitoring job.  This should be supplemented with a process for\ninforming the appropriate personnel.  Other techniques for achieving the same\nends, such as the use of DDL triggers, are acceptable.)"
      },
      "code": "control 'V-67365' do\n  title \"SQL Server must be monitored to discover unauthorized changes to\nfunctions.\"\n  desc  \"When dealing with change control issues, it should be noted, any\nchanges to the hardware, software, and/or firmware components of SQL Server\nand/or application can potentially have significant effects on the overall\nsecurity of the system.\n\n    If SQL Server were to allow any user to make changes to software libraries,\nthen those changes might be implemented without undergoing the appropriate\ntesting and approvals that are part of a robust change management process.\n\n    This requirement is contingent upon the language in which the application\nis programmed, as many application architectures in use today incorporate their\nsoftware libraries into, and make them inseparable from, their compiled\ndistributions, rendering them static and version-dependent. However, this\nrequirement does apply to applications with software libraries accessible and\nconfigurable, as in the case of interpreted languages.\n\n    Accordingly, only qualified and authorized individuals shall be allowed to\nobtain access to SQL Server components for purposes of initiating changes,\nincluding upgrades and modifications.\n\n    Unmanaged changes that occur to the SQL Server software libraries or\nconfiguration, such as Functions, can lead to unauthorized or compromised\ninstallations.\n  \"\n  impact 0.5\n  tag \"gtitle\": 'SRG-APP-000133-DB-000179'\n  tag \"gid\": 'V-67365'\n  tag \"rid\": 'SV-81855r2_rule'\n  tag \"stig_id\": 'SQL4-00-014900'\n  tag \"fix_id\": 'F-73477r2_fix'\n  tag \"cci\": ['CCI-001499']\n  tag \"nist\": ['CM-5 (6)', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"Check the SQL Server configuration for a timed job that\nautomatically checks all system and user-defined Functions for being modified\nby running the following SQL Server query:\nEXEC msdb.dbo.sp_help_job @job_name = '<enter . . . job name>';\n\n(Alternatively, in SQL Server Management Studio, navigate to SQL Server Agent\nand examine the job from there.)\n\nIf a timed job or some other method is not implemented to check for Functions\nbeing modified, this is a finding.\"\n  tag \"fix\": \"Configure a SQL Server timed job that automatically checks all\nsystem and user-defined Functions for being modified.\n\n(The supplemental file Track.sql, provided with this STIG, can be used to\nestablish a monitoring job.  This should be supplemented with a process for\ninforming the appropriate personnel.  Other techniques for achieving the same\nends, such as the use of DDL triggers, are acceptable.)\"\n\n  query = %{\n    SELECT enabled\n    FROM   msdb.dbo.sysjobs\n    WHERE  [name] = '%<job_name>s'\n  }\n\n  job_name = attribute('track_functions_changes_job_name')\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n\n  describe \"Scheduled job: #{job_name} enabled status\" do\n    subject { sql_session.query(format(query, job_name: job_name)).column('enabled') }\n    it { should cmp 1 }\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67365.rb",
        "line": 1
      },
      "id": "V-67365"
    },
    {
      "title": "The DBMS and associated applications must provide non-privileged users\nwith error messages that provide information necessary for corrective actions\nwithout revealing information that could be exploited by adversaries.",
      "desc": "Any DBMS or associated application providing too much information in\nerror messages on the screen or printout risks compromising the data and\nsecurity of the system. The structure and content of error messages need to be\ncarefully considered by the organization and development team.\n\n    Databases can inadvertently provide a wealth of information to an attacker\nthrough improperly handled error messages. In addition to sensitive business or\npersonal information, database errors can provide host names, IP addresses,\nuser names, and other system information not required for end-user\ntroubleshooting but very useful to someone targeting the system.\n\n    Carefully consider the structure/content of error messages. The extent to\nwhich information systems are able to identify and handle error conditions is\nguided by organizational policy and operational requirements. Information that\ncould be exploited by adversaries includes, for example, logon attempts with\npasswords entered by mistake as the username, mission/business information that\ncan be derived from (if not stated explicitly by) information recorded, and\npersonal information, such as account numbers, social security numbers, and\ncredit card numbers.\n\n    It is important that detailed error messages be visible only to those who\nare authorized to view them; that general users receive only generalized\nacknowledgment that errors have occurred; and that these generalized messages\nappear only when relevant to the user's task. For example, a message along the\nlines of, \"An error has occurred. Unable to save your changes. If this problem\npersists, please contact your help desk\" would be relevant. A message such as\n\"Warning: your transaction generated a large number of page splits\" would\nlikely not be relevant. \"ABGQ is not a valid widget code\" would be\nappropriate; but \"The INSERT statement conflicted with the FOREIGN KEY\nconstraint \"WidgetTransactionFK\". The conflict occurred in database \"DB7\",\ntable \"dbo.WidgetMaster\", column 'WidgetCode'\" would not, as it reveals too\nmuch about the database structure.\n\n    This calls for inspection of application source code, which will require\ncollaboration with the application developers. It is recognized that in many\ncases, the database administrator (DBA) is organizationally separate from the\napplication developers and may have limited, if any, access to source code.\nNevertheless, protections of this type are so important to the secure operation\nof databases that they must not be ignored. At a minimum, the DBA must attempt\nto obtain assurances from the development organization that this issue has been\naddressed and must document what has been discovered.",
      "descriptions": {
        "default": "Any DBMS or associated application providing too much information in\nerror messages on the screen or printout risks compromising the data and\nsecurity of the system. The structure and content of error messages need to be\ncarefully considered by the organization and development team.\n\n    Databases can inadvertently provide a wealth of information to an attacker\nthrough improperly handled error messages. In addition to sensitive business or\npersonal information, database errors can provide host names, IP addresses,\nuser names, and other system information not required for end-user\ntroubleshooting but very useful to someone targeting the system.\n\n    Carefully consider the structure/content of error messages. The extent to\nwhich information systems are able to identify and handle error conditions is\nguided by organizational policy and operational requirements. Information that\ncould be exploited by adversaries includes, for example, logon attempts with\npasswords entered by mistake as the username, mission/business information that\ncan be derived from (if not stated explicitly by) information recorded, and\npersonal information, such as account numbers, social security numbers, and\ncredit card numbers.\n\n    It is important that detailed error messages be visible only to those who\nare authorized to view them; that general users receive only generalized\nacknowledgment that errors have occurred; and that these generalized messages\nappear only when relevant to the user's task. For example, a message along the\nlines of, \"An error has occurred. Unable to save your changes. If this problem\npersists, please contact your help desk\" would be relevant. A message such as\n\"Warning: your transaction generated a large number of page splits\" would\nlikely not be relevant. \"ABGQ is not a valid widget code\" would be\nappropriate; but \"The INSERT statement conflicted with the FOREIGN KEY\nconstraint \"WidgetTransactionFK\". The conflict occurred in database \"DB7\",\ntable \"dbo.WidgetMaster\", column 'WidgetCode'\" would not, as it reveals too\nmuch about the database structure.\n\n    This calls for inspection of application source code, which will require\ncollaboration with the application developers. It is recognized that in many\ncases, the database administrator (DBA) is organizationally separate from the\napplication developers and may have limited, if any, access to source code.\nNevertheless, protections of this type are so important to the secure operation\nof databases that they must not be ignored. At a minimum, the DBA must attempt\nto obtain assurances from the development organization that this issue has been\naddressed and must document what has been discovered."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000266-DB-000162",
        "gid": "V-67397",
        "rid": "SV-81887r2_rule",
        "stig_id": "SQL4-00-022800",
        "fix_id": "F-73509r1_fix",
        "cci": [
          "CCI-001312"
        ],
        "nist": [
          "SI-11 a",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "Review application behavior and custom database code (stored\nprocedures; triggers),  to determine whether  error messages contain\ninformation beyond what is needed for explaining the issue to general users.\n\nIf database error messages contain PII data, sensitive business data, or\ninformation useful for identifying the host system or database structure, this\nis a finding.",
        "fix": "Configure DBMS settings, custom database code, and associated\napplication code not to divulge sensitive information or information useful for\nsystem identification in error messages that are displayed to general users.\n\nConsider enabling trace flag 3625 to mask certain system-level error information\nreturned to non-administrative users.\n\nLaunch SQL Server Configuration Manager >> Click SQL Services >> Open the\ninstance properties >> Click the Service Parameters tab >> Enter '-T3625' >>\nClick Add >> Click OK >> Restart SQL instance."
      },
      "code": "control 'V-67397' do\n  title \"The DBMS and associated applications must provide non-privileged users\nwith error messages that provide information necessary for corrective actions\nwithout revealing information that could be exploited by adversaries.\"\n  desc  \"Any DBMS or associated application providing too much information in\nerror messages on the screen or printout risks compromising the data and\nsecurity of the system. The structure and content of error messages need to be\ncarefully considered by the organization and development team.\n\n    Databases can inadvertently provide a wealth of information to an attacker\nthrough improperly handled error messages. In addition to sensitive business or\npersonal information, database errors can provide host names, IP addresses,\nuser names, and other system information not required for end-user\ntroubleshooting but very useful to someone targeting the system.\n\n    Carefully consider the structure/content of error messages. The extent to\nwhich information systems are able to identify and handle error conditions is\nguided by organizational policy and operational requirements. Information that\ncould be exploited by adversaries includes, for example, logon attempts with\npasswords entered by mistake as the username, mission/business information that\ncan be derived from (if not stated explicitly by) information recorded, and\npersonal information, such as account numbers, social security numbers, and\ncredit card numbers.\n\n    It is important that detailed error messages be visible only to those who\nare authorized to view them; that general users receive only generalized\nacknowledgment that errors have occurred; and that these generalized messages\nappear only when relevant to the user's task. For example, a message along the\nlines of, \\\"An error has occurred. Unable to save your changes. If this problem\npersists, please contact your help desk\\\" would be relevant. A message such as\n\\\"Warning: your transaction generated a large number of page splits\\\" would\nlikely not be relevant. \\\"ABGQ is not a valid widget code\\\" would be\nappropriate; but \\\"The INSERT statement conflicted with the FOREIGN KEY\nconstraint \\\"WidgetTransactionFK\\\". The conflict occurred in database \\\"DB7\\\",\ntable \\\"dbo.WidgetMaster\\\", column 'WidgetCode'\\\" would not, as it reveals too\nmuch about the database structure.\n\n    This calls for inspection of application source code, which will require\ncollaboration with the application developers. It is recognized that in many\ncases, the database administrator (DBA) is organizationally separate from the\napplication developers and may have limited, if any, access to source code.\nNevertheless, protections of this type are so important to the secure operation\nof databases that they must not be ignored. At a minimum, the DBA must attempt\nto obtain assurances from the development organization that this issue has been\naddressed and must document what has been discovered.\n  \"\n  impact 0.5\n  tag \"gtitle\": 'SRG-APP-000266-DB-000162'\n  tag \"gid\": 'V-67397'\n  tag \"rid\": 'SV-81887r2_rule'\n  tag \"stig_id\": 'SQL4-00-022800'\n  tag \"fix_id\": 'F-73509r1_fix'\n  tag \"cci\": ['CCI-001312']\n  tag \"nist\": ['SI-11 a', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"Review application behavior and custom database code (stored\nprocedures; triggers),  to determine whether  error messages contain\ninformation beyond what is needed for explaining the issue to general users.\n\nIf database error messages contain PII data, sensitive business data, or\ninformation useful for identifying the host system or database structure, this\nis a finding.\"\n  tag \"fix\": \"Configure DBMS settings, custom database code, and associated\napplication code not to divulge sensitive information or information useful for\nsystem identification in error messages that are displayed to general users.\n\nConsider enabling trace flag 3625 to mask certain system-level error information\nreturned to non-administrative users.\n\nLaunch SQL Server Configuration Manager >> Click SQL Services >> Open the\ninstance properties >> Click the Service Parameters tab >> Enter '-T3625' >>\nClick Add >> Click OK >> Restart SQL instance.\"\n\n  # The below query was taken from 2016 MSSQL STIG\n\n  query = %{\n    DBCC\n      TRACESTATUS (3625, -1)\n    GO\n    }\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n\n  describe 'TRACEFLAG 3625' do\n    subject { sql_session.query(query).rows[0] }\n    its('status') { should cmp 1 }\n    its('global') { should cmp 1 }\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67397.rb",
        "line": 1
      },
      "id": "V-67397"
    },
    {
      "title": "Trace or Audit records must be generated  when unsuccessful attempts\nto access categorized information (e.g., classification levels/security levels)\noccur.",
      "desc": "Changes in categorized information must be tracked. Without an audit\ntrail, unauthorized access to protected data could go undetected.\n\n    To aid in diagnosis, it is necessary to keep track of failed attempts in\naddition to the successful ones.\n\n    For detailed information on categorizing information, refer to FIPS\nPublication 199, Standards for Security Categorization of Federal Information\nand Information Systems, and FIPS Publication 200, Minimum Security\nRequirements for Federal Information and Information Systems.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\nNote also that Trace does not support auditing of SELECT statements, whereas\nAudit does.\n\n    Since Trace does not provide for tracking SELECT statements, it is\nnecessary to provide this tracking at the application level, if Trace is used\nfor audit purposes.\n\n    Use of SQL Server Audit's SCHEMA_OBJECT_ACCESS_GROUP causes capture of all\naccesses, successful and otherwise, to all schema-scoped objects.  The\n[Succeeded] column in the audit output indicates the success or failure of the\nattempted action.  Be aware, however, that it may report True in some cases\nwhere one would intuitively expect False.  For example, SELECT 1/0 FROM\nSYS.ALL_OBJECTS will appear in the audit trail as successful, if the user has\npermission to perform that action, even though it contains an invalid\nexpression.  Some other actions that one would consider failures (such as\nselecting from a table that does not exist) may not appear at all.",
      "descriptions": {
        "default": "Changes in categorized information must be tracked. Without an audit\ntrail, unauthorized access to protected data could go undetected.\n\n    To aid in diagnosis, it is necessary to keep track of failed attempts in\naddition to the successful ones.\n\n    For detailed information on categorizing information, refer to FIPS\nPublication 199, Standards for Security Categorization of Federal Information\nand Information Systems, and FIPS Publication 200, Minimum Security\nRequirements for Federal Information and Information Systems.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\nNote also that Trace does not support auditing of SELECT statements, whereas\nAudit does.\n\n    Since Trace does not provide for tracking SELECT statements, it is\nnecessary to provide this tracking at the application level, if Trace is used\nfor audit purposes.\n\n    Use of SQL Server Audit's SCHEMA_OBJECT_ACCESS_GROUP causes capture of all\naccesses, successful and otherwise, to all schema-scoped objects.  The\n[Succeeded] column in the audit output indicates the success or failure of the\nattempted action.  Be aware, however, that it may report True in some cases\nwhere one would intuitively expect False.  For example, SELECT 1/0 FROM\nSYS.ALL_OBJECTS will appear in the audit trail as successful, if the user has\npermission to perform that action, even though it contains an invalid\nexpression.  Some other actions that one would consider failures (such as\nselecting from a table that does not exist) may not appear at all."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000494-DB-000345",
        "gid": "V-67415",
        "rid": "SV-81905r2_rule",
        "stig_id": "SQL4-00-035900",
        "fix_id": "F-73529r1_fix",
        "cci": [
          "CCI-000172"
        ],
        "nist": [
          "AU-12 c",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "Review the system documentation to determine whether it is\nrequired to track categories of information, such as classification or\nsensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes,\nthis is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the application(s)\nusing the database to verify that all SELECT actions on categorized data,\nincluding unsuccessful attempts, are being audited;  and that the tracking\nrecords are written to the SQL Server Trace used for audit purposes.  If not,\nthis is a finding.\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the broad, server-level audit action group\nSCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility\nmakes other techniques possible.\n\nIf an alternative technique is in use and demonstrated effective, this is not a\nfinding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\n\nAlternatively, review the contents of the system views with \"audit\" in their\nnames.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions\non tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"FAILURE\" or \"SUCCESS AND FAILURE\",\nthis is a finding.",
        "fix": "Where SQL Server Trace is in use, implement tracking of SELECTs\non categorized data at the application level, using the system stored procedure\nsp_trace_generateevent to write the tracking records to the Trace used for\naudit purposes. Include failed attempts in the tracking.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all\nauditable events and data items.  The script provided in the supplemental file\nAudit.sql can be used as the basis for this.  Supplement the standard audit\ndata as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO"
      },
      "code": "control 'V-67415' do\n  title \"Trace or Audit records must be generated  when unsuccessful attempts\nto access categorized information (e.g., classification levels/security levels)\noccur.\"\n  desc  \"Changes in categorized information must be tracked. Without an audit\ntrail, unauthorized access to protected data could go undetected.\n\n    To aid in diagnosis, it is necessary to keep track of failed attempts in\naddition to the successful ones.\n\n    For detailed information on categorizing information, refer to FIPS\nPublication 199, Standards for Security Categorization of Federal Information\nand Information Systems, and FIPS Publication 200, Minimum Security\nRequirements for Federal Information and Information Systems.\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\nNote also that Trace does not support auditing of SELECT statements, whereas\nAudit does.\n\n    Since Trace does not provide for tracking SELECT statements, it is\nnecessary to provide this tracking at the application level, if Trace is used\nfor audit purposes.\n\n    Use of SQL Server Audit's SCHEMA_OBJECT_ACCESS_GROUP causes capture of all\naccesses, successful and otherwise, to all schema-scoped objects.  The\n[Succeeded] column in the audit output indicates the success or failure of the\nattempted action.  Be aware, however, that it may report True in some cases\nwhere one would intuitively expect False.  For example, SELECT 1/0 FROM\nSYS.ALL_OBJECTS will appear in the audit trail as successful, if the user has\npermission to perform that action, even though it contains an invalid\nexpression.  Some other actions that one would consider failures (such as\nselecting from a table that does not exist) may not appear at all.\n  \"\n  if attribute('server_trace_or_audit_required')\n    impact 0.5\n  else\n    impact 0.0\n    desc 'Inspec attributes has specified that is not required to track categories\n    of information, such as classification or sensitivity level on the target'\n  end\n\n  tag \"gtitle\": 'SRG-APP-000494-DB-000345'\n  tag \"gid\": 'V-67415'\n  tag \"rid\": 'SV-81905r2_rule'\n  tag \"stig_id\": 'SQL4-00-035900'\n  tag \"fix_id\": 'F-73529r1_fix'\n  tag \"cci\": ['CCI-000172']\n  tag \"nist\": ['AU-12 c', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"Review the system documentation to determine whether it is\nrequired to track categories of information, such as classification or\nsensitivity level.  If it is not, this is not applicable (NA).\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes,\nthis is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the application(s)\nusing the database to verify that all SELECT actions on categorized data,\nincluding unsuccessful attempts, are being audited;  and that the tracking\nrecords are written to the SQL Server Trace used for audit purposes.  If not,\nthis is a finding.\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the broad, server-level audit action group\nSCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility\nmakes other techniques possible.\n\nIf an alternative technique is in use and demonstrated effective, this is not a\nfinding.\n\nDetermine the name(s) of the server audit specification(s) in use.\n\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\n\nAlternatively, review the contents of the system views with \\\"audit\\\" in their\nnames.\n\nRun the following to verify that all SELECT, INSERT, UPDATE, and DELETE actions\non tables and views are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \\\"FAILURE\\\" or \\\"SUCCESS AND FAILURE\\\",\nthis is a finding.\"\n  tag \"fix\": \"Where SQL Server Trace is in use, implement tracking of SELECTs\non categorized data at the application level, using the system stored procedure\nsp_trace_generateevent to write the tracking records to the Trace used for\naudit purposes. Include failed attempts in the tracking.\n\nIf SQL Server Audit is in use, design and deploy an Audit that captures all\nauditable events and data items.  The script provided in the supplemental file\nAudit.sql can be used as the basis for this.  Supplement the standard audit\ndata as necessary, using Extended Events and/or triggers.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO\"\n  query_traces = %{\n    SELECT * FROM sys.traces\n  }\n  query_trace_eventinfo = %{\n    SELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(%<trace_id>s);\n  }\n\n  query_audits = %{\n    SELECT server_specification_id,\n           audit_action_name,\n           audited_result\n    FROM   sys.server_audit_specification_details\n    WHERE  audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n  }\n  server_trace_implemented = attribute('server_trace_implemented')\n  server_audit_implemented = attribute('server_audit_implemented')\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n\n  describe.one do\n    describe 'SQL Server Trace is in use for audit purposes' do\n      subject { server_trace_implemented }\n      it { should be true }\n    end\n\n    describe 'SQL Server Audit is in use for audit purposes' do\n      subject { server_audit_implemented }\n      it { should be true }\n    end\n  end\n\n  if server_trace_implemented\n    describe 'List defined traces for the SQL server instance' do\n      subject { sql_session.query(query_traces) }\n      it { should_not be_empty }\n    end\n\n    trace_ids = sql_session.query(query_traces).column('id')\n    describe.one do\n      trace_ids.each do |trace_id|\n        found_events = sql_session.query(format(query_trace_eventinfo, trace_id: trace_id)).column('eventid')\n        describe \"EventsIDs in Trace ID:#{trace_id}\" do\n          subject { found_events }\n          it { should include '28' }\n          it { should include '114' }\n        end\n      end\n    end\n  end\n\n  if server_audit_implemented\n    describe 'SQL Server Audit:' do\n      describe 'Defined Audits with Audit Action SCHEMA_OBJECT_ACCESS_GROUP' do\n        subject { sql_session.query(query_audits) }\n        it { should_not be_empty }\n      end\n      describe 'Audited Result for Defined Audit Actions' do\n        subject { sql_session.query(query_audits).column('audited_result').uniq.to_s }\n        it { should match /SUCCESS AND FAILURE|FAILURE/ }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67415.rb",
        "line": 1
      },
      "id": "V-67415"
    },
    {
      "title": "SQL Server must generate Trace or Audit records when\nprivileges/permissions are modified via locally-defined security objects.",
      "desc": "Changes in the permissions, privileges, and roles granted to users and\nroles must be tracked. Without an audit trail, unauthorized elevation or\nrestriction of privileges could go undetected. Elevated privileges give users\naccess to information and functionality that they should not have; restricted\nprivileges wrongly deny access to authorized users.\n\n    In SQL Server, there is no distinction between modification of permissions\nand granting or dropping them.  However, native SQL Server security\nfunctionality may be supplemented with application-specific tables and logic,\nin which case the following actions on these tables and\nprocedures/triggers/functions are also relevant:\n    UPDATE\n    EXECUTE\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.",
      "descriptions": {
        "default": "Changes in the permissions, privileges, and roles granted to users and\nroles must be tracked. Without an audit trail, unauthorized elevation or\nrestriction of privileges could go undetected. Elevated privileges give users\naccess to information and functionality that they should not have; restricted\nprivileges wrongly deny access to authorized users.\n\n    In SQL Server, there is no distinction between modification of permissions\nand granting or dropping them.  However, native SQL Server security\nfunctionality may be supplemented with application-specific tables and logic,\nin which case the following actions on these tables and\nprocedures/triggers/functions are also relevant:\n    UPDATE\n    EXECUTE\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016."
      },
      "impact": 0.5,
      "refs": [],
      "tags": {
        "gtitle": "SRG-APP-000495-DB-000328",
        "gid": "V-67417",
        "rid": "SV-81907r2_rule",
        "stig_id": "SQL4-00-036200",
        "fix_id": "F-73531r1_fix",
        "cci": [
          "CCI-000172"
        ],
        "nist": [
          "AU-12 c",
          "Rev_4"
        ],
        "false_negatives": null,
        "false_positives": null,
        "documentable": false,
        "mitigations": null,
        "severity_override_guidance": false,
        "potential_impacts": null,
        "third_party_tools": null,
        "mitigation_controls": null,
        "responsibility": null,
        "ia_controls": null,
        "check": "Obtain the list of locally-defined security tables, procedures\nand functions that require tracking.\n\nIf there are none, this is not a finding.\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes,\nthis is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the locally-defined\nsecurity tables for the existence of triggers to raise a custom event on each\nUpdate operation.  If such triggers are not present, this is a finding.\n\nVerify  that all required events are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no\ntraces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing\nrequirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is\na finding:\n\n42  -- SP:Starting\n43  -- SP:Completed\n82-91  -- User-defined EventsIDs\n162  -- User error message\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nVerify that all EXECUTE actions on locally-defined permissions-related\nprocedures are being audited.  If not, this is a finding.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the broad, server-level audit action group\nSCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility\nmakes other techniques possible.  If an alternative technique is in use and\ndemonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\nAlternatively, review the contents of the system views with \"audit\" in their\nnames.\n\nRun the following to verify that all UPDATE and EXECUTE actions on any\nlocally-defined permissions tables, procedures and functions are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \"SUCCESS\" or \"SUCCESS AND FAILURE\",\nthis is a finding.",
        "fix": "Where SQL Server Trace is in use, define  and enable a trace that\ncaptures all auditable events.  The script provided in the supplemental file\nTrace.sql can be used to do this.\n\nAdd blocks of code to Trace.sql for each custom event class (integers in the\nrange 82-91; the same event class may be used for all such triggers) used in\nthese triggers.\n\nCreate triggers to raise a custom event on each locally-defined security table\nthat requires tracking of Insert-Update-Delete operations.  The examples\nprovided in the supplemental file CustomTraceEvents.sql can serve as the basis\nfor these.\n\nExecute Trace.sql.\n\nWhere SQL Server Audit is in use, design and deploy a SQL Server Audit that\ncaptures all auditable events.  The script provided in the supplemental file\nAudit.sql can be used for this.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO"
      },
      "code": "control 'V-67417' do\n  title \"SQL Server must generate Trace or Audit records when\nprivileges/permissions are modified via locally-defined security objects.\"\n  desc  \"Changes in the permissions, privileges, and roles granted to users and\nroles must be tracked. Without an audit trail, unauthorized elevation or\nrestriction of privileges could go undetected. Elevated privileges give users\naccess to information and functionality that they should not have; restricted\nprivileges wrongly deny access to authorized users.\n\n    In SQL Server, there is no distinction between modification of permissions\nand granting or dropping them.  However, native SQL Server security\nfunctionality may be supplemented with application-specific tables and logic,\nin which case the following actions on these tables and\nprocedures/triggers/functions are also relevant:\n    UPDATE\n    EXECUTE\n\n    Use of SQL Server Audit is recommended.  All features of SQL Server Audit\nare available in the Enterprise and Developer editions of SQL Server 2014.  It\nis not available at the database level in other editions.  For this or legacy\nreasons, the instance may be using SQL Server Trace for auditing, which remains\nan acceptable solution for the time being.  Note, however, that Microsoft\nintends to remove most aspects of Trace at some point after SQL Server 2016.\n  \"\n  impact 0.5\n  tag \"gtitle\": 'SRG-APP-000495-DB-000328'\n  tag \"gid\": 'V-67417'\n  tag \"rid\": 'SV-81907r2_rule'\n  tag \"stig_id\": 'SQL4-00-036200'\n  tag \"fix_id\": 'F-73531r1_fix'\n  tag \"cci\": ['CCI-000172']\n  tag \"nist\": ['AU-12 c', 'Rev_4']\n  tag \"false_negatives\": nil\n  tag \"false_positives\": nil\n  tag \"documentable\": false\n  tag \"mitigations\": nil\n  tag \"severity_override_guidance\": false\n  tag \"potential_impacts\": nil\n  tag \"third_party_tools\": nil\n  tag \"mitigation_controls\": nil\n  tag \"responsibility\": nil\n  tag \"ia_controls\": nil\n  tag \"check\": \"Obtain the list of locally-defined security tables, procedures\nand functions that require tracking.\n\nIf there are none, this is not a finding.\n\nIf neither SQL Server Audit nor SQL Server Trace is in use for audit purposes,\nthis is a finding.\n\nIf SQL Server Trace is in use for audit purposes, review the locally-defined\nsecurity tables for the existence of triggers to raise a custom event on each\nUpdate operation.  If such triggers are not present, this is a finding.\n\nVerify  that all required events are being audited.  From the query prompt:\nSELECT * FROM sys.traces;\n\nAll currently defined traces for the SQL server instance will be listed. If no\ntraces are returned, this is a finding.\n\nDetermine the trace(s) being used for the auditing requirement.\nIn the following, replace # with a trace ID being used for the auditing\nrequirements.\nFrom the query prompt:\nSELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(#);\n\nThe following required event IDs should be among those listed; if not, this is\na finding:\n\n42  -- SP:Starting\n43  -- SP:Completed\n82-91  -- User-defined EventsIDs\n162  -- User error message\n\n\nIf SQL Server Audit is in use, proceed as follows.\n\nVerify that all EXECUTE actions on locally-defined permissions-related\nprocedures are being audited.  If not, this is a finding.\n\nThe basic SQL Server Audit configuration provided in the supplemental file\nAudit.sql uses the broad, server-level audit action group\nSCHEMA_OBJECT_ACCESS_GROUP for this purpose.  SQL Server Audit's flexibility\nmakes other techniques possible.  If an alternative technique is in use and\ndemonstrated effective, this is not a finding.\n\nDetermine the name(s) of the server audit specification(s) in use.\nTo look at audits and audit specifications, in Management Studio's object\nexplorer, expand\n<server name> >> Security >> Audits\nand\n<server name> >> Security >> Server Audit Specifications.\nAlso,\n<server name> >> Databases >> <database name> >> Security >> Database Audit\nSpecifications.\nAlternatively, review the contents of the system views with \\\"audit\\\" in their\nnames.\n\nRun the following to verify that all UPDATE and EXECUTE actions on any\nlocally-defined permissions tables, procedures and functions are being audited:\nUSE [master];\nGO\nSELECT * FROM sys.server_audit_specification_details WHERE\nserver_specification_id =\n(SELECT server_specification_id FROM sys.server_audit_implemented_specifications WHERE\n[name] = '<server_audit_implemented_specification_name>')\nAND audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n\nIf no row is returned, this is a finding.\n\nIf the audited_result column is not \\\"SUCCESS\\\" or \\\"SUCCESS AND FAILURE\\\",\nthis is a finding.\"\n  tag \"fix\": \"Where SQL Server Trace is in use, define  and enable a trace that\ncaptures all auditable events.  The script provided in the supplemental file\nTrace.sql can be used to do this.\n\nAdd blocks of code to Trace.sql for each custom event class (integers in the\nrange 82-91; the same event class may be used for all such triggers) used in\nthese triggers.\n\nCreate triggers to raise a custom event on each locally-defined security table\nthat requires tracking of Insert-Update-Delete operations.  The examples\nprovided in the supplemental file CustomTraceEvents.sql can serve as the basis\nfor these.\n\nExecute Trace.sql.\n\nWhere SQL Server Audit is in use, design and deploy a SQL Server Audit that\ncaptures all auditable events.  The script provided in the supplemental file\nAudit.sql can be used for this.\n\nAlternatively, to add the necessary data capture to an existing server audit\nspecification, run the script:\nUSE [master];\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= OFF);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> ADD\n(SCHEMA_OBJECT_ACCESS_GROUP);\nGO\nALTER SERVER AUDIT SPECIFICATION <server_audit_implemented_specification_name> WITH (STATE\n= ON);\nGO\"\n\n  query_traces = %{\n    SELECT * FROM sys.traces\n  }\n  query_trace_eventinfo = %{\n    SELECT DISTINCT(eventid) FROM sys.fn_trace_geteventinfo(%<trace_id>s);\n  }\n\n  query_audits = %{\n    SELECT server_specification_id,\n           audit_action_name,\n           audited_result\n    FROM   sys.server_audit_specification_details\n    WHERE  audit_action_name = 'SCHEMA_OBJECT_ACCESS_GROUP';\n  }\n\n  server_trace_implemented = attribute('server_trace_implemented')\n  server_audit_implemented = attribute('server_audit_implemented')\n\n  sql_session = mssql_session(user: attribute('user'),\n                              password: attribute('password'),\n                              host: attribute('host'),\n                              instance: attribute('instance'),\n                              port: attribute('port'),\n                              db_name: attribute('db_name'))\n\n  describe.one do\n    describe 'SQL Server Trace is in use for audit purposes' do\n      subject { server_trace_implemented }\n      it { should be true }\n    end\n\n    describe 'SQL Server Audit is in use for audit purposes' do\n      subject { server_audit_implemented }\n      it { should be true }\n    end\n  end\n\n  if server_trace_implemented\n    describe 'List defined traces for the SQL server instance' do\n      subject { sql_session.query(query_traces) }\n      it { should_not be_empty }\n    end\n\n    trace_ids = sql_session.query(query_traces).column('id')\n    describe.one do\n      trace_ids.each do |trace_id|\n        found_events = sql_session.query(format(query_trace_eventinfo, trace_id: trace_id)).column('eventid')\n        describe \"EventsIDs in Trace ID:#{trace_id}\" do\n          subject { found_events }\n          it { should include '42' }\n          it { should include '43' }\n          its('to_s') { should match /\"82\"|\"83\"|\"84\"|\"85\"|\"86\"|\"87\"|\"88\"|\"89\"|\"90\"|\"91\"/ }\n          it { should include '162' }\n        end\n      end\n    end\n  end\n\n  if server_audit_implemented\n    describe 'SQL Server Audit:' do\n      describe 'Defined Audits with Audit Action SCHEMA_OBJECT_ACCESS_GROUP' do\n        subject { sql_session.query(query_audits) }\n        it { should_not be_empty }\n      end\n      describe 'Audited Result for Defined Audit Actions' do\n        subject { sql_session.query(query_audits).column('audited_result').uniq.to_s }\n        it { should match /SUCCESS AND FAILURE|SUCCESS/ }\n      end\n    end\n  end\nend\n",
      "source_location": {
        "ref": "./MSQL 2014 Database STIG/controls/V-67417.rb",
        "line": 1
      },
      "id": "V-67417"
    }
  ],
  "groups": [
    {
      "title": null,
      "controls": [
        "V-67421"
      ],
      "id": "controls/V-67421.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67359"
      ],
      "id": "controls/V-67359.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67399"
      ],
      "id": "controls/V-67399.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67423"
      ],
      "id": "controls/V-67423.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67393"
      ],
      "id": "controls/V-67393.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67375"
      ],
      "id": "controls/V-67375.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67371"
      ],
      "id": "controls/V-67371.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67435"
      ],
      "id": "controls/V-67435.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67877"
      ],
      "id": "controls/V-67877.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67441"
      ],
      "id": "controls/V-67441.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67383"
      ],
      "id": "controls/V-67383.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67373"
      ],
      "id": "controls/V-67373.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67391"
      ],
      "id": "controls/V-67391.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67425"
      ],
      "id": "controls/V-67425.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67437"
      ],
      "id": "controls/V-67437.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67433"
      ],
      "id": "controls/V-67433.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67403"
      ],
      "id": "controls/V-67403.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67439"
      ],
      "id": "controls/V-67439.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67405"
      ],
      "id": "controls/V-67405.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67357"
      ],
      "id": "controls/V-67357.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67367"
      ],
      "id": "controls/V-67367.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67389"
      ],
      "id": "controls/V-67389.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67385"
      ],
      "id": "controls/V-67385.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67443"
      ],
      "id": "controls/V-67443.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67401"
      ],
      "id": "controls/V-67401.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67431"
      ],
      "id": "controls/V-67431.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67413"
      ],
      "id": "controls/V-67413.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67395"
      ],
      "id": "controls/V-67395.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67409"
      ],
      "id": "controls/V-67409.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67381"
      ],
      "id": "controls/V-67381.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67419"
      ],
      "id": "controls/V-67419.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67369"
      ],
      "id": "controls/V-67369.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67427"
      ],
      "id": "controls/V-67427.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67411"
      ],
      "id": "controls/V-67411.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67407"
      ],
      "id": "controls/V-67407.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67377"
      ],
      "id": "controls/V-67377.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67429"
      ],
      "id": "controls/V-67429.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67361"
      ],
      "id": "controls/V-67361.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67365"
      ],
      "id": "controls/V-67365.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67397"
      ],
      "id": "controls/V-67397.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67415"
      ],
      "id": "controls/V-67415.rb"
    },
    {
      "title": null,
      "controls": [
        "V-67417"
      ],
      "id": "controls/V-67417.rb"
    }
  ],
  "sha256": "1eeb69411c4d0157392a1b3ff7cdc0aa807998fae612a69ac8b90f5b62ec1ea8",
  "status_message": "",
  "status": "loaded",
  "generator": {
    "name": "inspec",
    "version": "4.33.1"
  }
}