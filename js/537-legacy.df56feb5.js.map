{"version":3,"file":"js/537-legacy.df56feb5.js","mappings":"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","sources":["webpack://@mitre/heimdall-lite/../../node_modules/@smithy/core/dist-es/submodules/event-streams/EventStreamSerde.js"],"sourcesContent":["import { fromUtf8, toUtf8 } from \"@smithy/util-utf8\";\nexport class EventStreamSerde {\n    marshaller;\n    serializer;\n    deserializer;\n    serdeContext;\n    defaultContentType;\n    constructor({ marshaller, serializer, deserializer, serdeContext, defaultContentType, }) {\n        this.marshaller = marshaller;\n        this.serializer = serializer;\n        this.deserializer = deserializer;\n        this.serdeContext = serdeContext;\n        this.defaultContentType = defaultContentType;\n    }\n    async serializeEventStream({ eventStream, requestSchema, initialRequest, }) {\n        const marshaller = this.marshaller;\n        const eventStreamMember = requestSchema.getEventStreamMember();\n        const unionSchema = requestSchema.getMemberSchema(eventStreamMember);\n        const serializer = this.serializer;\n        const defaultContentType = this.defaultContentType;\n        const initialRequestMarker = Symbol(\"initialRequestMarker\");\n        const eventStreamIterable = {\n            async *[Symbol.asyncIterator]() {\n                if (initialRequest) {\n                    const headers = {\n                        \":event-type\": { type: \"string\", value: \"initial-request\" },\n                        \":message-type\": { type: \"string\", value: \"event\" },\n                        \":content-type\": { type: \"string\", value: defaultContentType },\n                    };\n                    serializer.write(requestSchema, initialRequest);\n                    const body = serializer.flush();\n                    yield {\n                        [initialRequestMarker]: true,\n                        headers,\n                        body,\n                    };\n                }\n                for await (const page of eventStream) {\n                    yield page;\n                }\n            },\n        };\n        return marshaller.serialize(eventStreamIterable, (event) => {\n            if (event[initialRequestMarker]) {\n                return {\n                    headers: event.headers,\n                    body: event.body,\n                };\n            }\n            const unionMember = Object.keys(event).find((key) => {\n                return key !== \"__type\";\n            }) ?? \"\";\n            const { additionalHeaders, body, eventType, explicitPayloadContentType } = this.writeEventBody(unionMember, unionSchema, event);\n            const headers = {\n                \":event-type\": { type: \"string\", value: eventType },\n                \":message-type\": { type: \"string\", value: \"event\" },\n                \":content-type\": { type: \"string\", value: explicitPayloadContentType ?? defaultContentType },\n                ...additionalHeaders,\n            };\n            return {\n                headers,\n                body,\n            };\n        });\n    }\n    async deserializeEventStream({ response, responseSchema, initialResponseContainer, }) {\n        const marshaller = this.marshaller;\n        const eventStreamMember = responseSchema.getEventStreamMember();\n        const unionSchema = responseSchema.getMemberSchema(eventStreamMember);\n        const memberSchemas = unionSchema.getMemberSchemas();\n        const initialResponseMarker = Symbol(\"initialResponseMarker\");\n        const asyncIterable = marshaller.deserialize(response.body, async (event) => {\n            const unionMember = Object.keys(event).find((key) => {\n                return key !== \"__type\";\n            }) ?? \"\";\n            const body = event[unionMember].body;\n            if (unionMember === \"initial-response\") {\n                const dataObject = await this.deserializer.read(responseSchema, body);\n                delete dataObject[eventStreamMember];\n                return {\n                    [initialResponseMarker]: true,\n                    ...dataObject,\n                };\n            }\n            else if (unionMember in memberSchemas) {\n                const eventStreamSchema = memberSchemas[unionMember];\n                if (eventStreamSchema.isStructSchema()) {\n                    const out = {};\n                    let hasBindings = false;\n                    for (const [name, member] of eventStreamSchema.structIterator()) {\n                        const { eventHeader, eventPayload } = member.getMergedTraits();\n                        hasBindings = hasBindings || Boolean(eventHeader || eventPayload);\n                        if (eventPayload) {\n                            if (member.isBlobSchema()) {\n                                out[name] = body;\n                            }\n                            else if (member.isStringSchema()) {\n                                out[name] = (this.serdeContext?.utf8Encoder ?? toUtf8)(body);\n                            }\n                            else if (member.isStructSchema()) {\n                                out[name] = await this.deserializer.read(member, body);\n                            }\n                        }\n                        else if (eventHeader) {\n                            const value = event[unionMember].headers[name]?.value;\n                            if (value != null) {\n                                if (member.isNumericSchema()) {\n                                    if (value && typeof value === \"object\" && \"bytes\" in value) {\n                                        out[name] = BigInt(value.toString());\n                                    }\n                                    else {\n                                        out[name] = Number(value);\n                                    }\n                                }\n                                else {\n                                    out[name] = value;\n                                }\n                            }\n                        }\n                    }\n                    if (hasBindings) {\n                        return {\n                            [unionMember]: out,\n                        };\n                    }\n                }\n                return {\n                    [unionMember]: await this.deserializer.read(eventStreamSchema, body),\n                };\n            }\n            else {\n                return {\n                    $unknown: event,\n                };\n            }\n        });\n        const asyncIterator = asyncIterable[Symbol.asyncIterator]();\n        const firstEvent = await asyncIterator.next();\n        if (firstEvent.done) {\n            return asyncIterable;\n        }\n        if (firstEvent.value?.[initialResponseMarker]) {\n            if (!responseSchema) {\n                throw new Error(\"@smithy::core/protocols - initial-response event encountered in event stream but no response schema given.\");\n            }\n            for (const [key, value] of Object.entries(firstEvent.value)) {\n                initialResponseContainer[key] = value;\n            }\n        }\n        return {\n            async *[Symbol.asyncIterator]() {\n                if (!firstEvent?.value?.[initialResponseMarker]) {\n                    yield firstEvent.value;\n                }\n                while (true) {\n                    const { done, value } = await asyncIterator.next();\n                    if (done) {\n                        break;\n                    }\n                    yield value;\n                }\n            },\n        };\n    }\n    writeEventBody(unionMember, unionSchema, event) {\n        const serializer = this.serializer;\n        let eventType = unionMember;\n        let explicitPayloadMember = null;\n        let explicitPayloadContentType;\n        const isKnownSchema = (() => {\n            const struct = unionSchema.getSchema();\n            return struct[4].includes(unionMember);\n        })();\n        const additionalHeaders = {};\n        if (!isKnownSchema) {\n            const [type, value] = event[unionMember];\n            eventType = type;\n            serializer.write(15, value);\n        }\n        else {\n            const eventSchema = unionSchema.getMemberSchema(unionMember);\n            if (eventSchema.isStructSchema()) {\n                for (const [memberName, memberSchema] of eventSchema.structIterator()) {\n                    const { eventHeader, eventPayload } = memberSchema.getMergedTraits();\n                    if (eventPayload) {\n                        explicitPayloadMember = memberName;\n                    }\n                    else if (eventHeader) {\n                        const value = event[unionMember][memberName];\n                        let type = \"binary\";\n                        if (memberSchema.isNumericSchema()) {\n                            if ((-2) ** 31 <= value && value <= 2 ** 31 - 1) {\n                                type = \"integer\";\n                            }\n                            else {\n                                type = \"long\";\n                            }\n                        }\n                        else if (memberSchema.isTimestampSchema()) {\n                            type = \"timestamp\";\n                        }\n                        else if (memberSchema.isStringSchema()) {\n                            type = \"string\";\n                        }\n                        else if (memberSchema.isBooleanSchema()) {\n                            type = \"boolean\";\n                        }\n                        if (value != null) {\n                            additionalHeaders[memberName] = {\n                                type,\n                                value,\n                            };\n                            delete event[unionMember][memberName];\n                        }\n                    }\n                }\n                if (explicitPayloadMember !== null) {\n                    const payloadSchema = eventSchema.getMemberSchema(explicitPayloadMember);\n                    if (payloadSchema.isBlobSchema()) {\n                        explicitPayloadContentType = \"application/octet-stream\";\n                    }\n                    else if (payloadSchema.isStringSchema()) {\n                        explicitPayloadContentType = \"text/plain\";\n                    }\n                    serializer.write(payloadSchema, event[unionMember][explicitPayloadMember]);\n                }\n                else {\n                    serializer.write(eventSchema, event[unionMember]);\n                }\n            }\n            else {\n                throw new Error(\"@smithy/core/event-streams - non-struct member not supported in event stream union.\");\n            }\n        }\n        const messageSerialization = serializer.flush();\n        const body = typeof messageSerialization === \"string\"\n            ? (this.serdeContext?.utf8Decoder ?? fromUtf8)(messageSerialization)\n            : messageSerialization;\n        return {\n            body,\n            eventType,\n            explicitPayloadContentType,\n            additionalHeaders,\n        };\n    }\n}\n"],"names":["EventStreamSerde","marshaller","serializer","deserializer","serdeContext","defaultContentType","constructor","this","serializeEventStream","eventStream","requestSchema","initialRequest","eventStreamMember","getEventStreamMember","unionSchema","getMemberSchema","initialRequestMarker","Symbol","eventStreamIterable","asyncIterator","headers","type","value","write","body","flush","page","serialize","event","unionMember","Object","keys","find","key","additionalHeaders","eventType","explicitPayloadContentType","writeEventBody","deserializeEventStream","response","responseSchema","initialResponseContainer","memberSchemas","getMemberSchemas","initialResponseMarker","asyncIterable","deserialize","async","dataObject","read","eventStreamSchema","isStructSchema","out","hasBindings","name","member","structIterator","eventHeader","eventPayload","getMergedTraits","Boolean","isBlobSchema","isStringSchema","utf8Encoder","isNumericSchema","BigInt","toString","Number","$unknown","firstEvent","next","done","Error","entries","explicitPayloadMember","isKnownSchema","struct","getSchema","includes","eventSchema","memberName","memberSchema","isTimestampSchema","isBooleanSchema","payloadSchema","messageSerialization","utf8Decoder"],"ignoreList":[],"sourceRoot":""}